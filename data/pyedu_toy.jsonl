{"problem_description": "Given a string of characters, what are all the unique permutations of the characters in the string, sorted in lexicographical order?", "io_requirements": "Input:\n  `input_string` (str): A string of characters for which all unique permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string, sorted in lexicographical order.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    chars = list(input_string)\n    \n    # Generate all unique permutations of the characters\n    permutations = set([''.join(p) for p in itertools.permutations(chars)])\n    \n    # Sort the permutations in lexicographical order\n    sorted_permutations = sorted(permutations)\n    \n    # Return the sorted list of permutations\n    return sorted_permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "yms"}, "output": ["msy", "mys", "smy", "sym", "yms", "ysm"]}, {"input": {"input_string": "cko"}, "output": ["cko", "cok", "kco", "koc", "ock", "okc"]}, {"input": {"input_string": "gor"}, "output": ["gor", "gro", "ogr", "org", "rgo", "rog"]}, {"input": {"input_string": "evw"}, "output": ["evw", "ewv", "vew", "vwe", "wev", "wve"]}, {"input": {"input_string": "pvk"}, "output": ["kpv", "kvp", "pkv", "pvk", "vkp", "vpk"]}, {"input": {"input_string": "zqc"}, "output": ["cqz", "czq", "qcz", "qzc", "zcq", "zqc"]}, {"input": {"input_string": "hpi"}, "output": ["hip", "hpi", "ihp", "iph", "phi", "pih"]}, {"input": {"input_string": "mxh"}, "output": ["hmx", "hxm", "mhx", "mxh", "xhm", "xmh"]}, {"input": {"input_string": "yxz"}, "output": ["xyz", "xzy", "yxz", "yzx", "zxy", "zyx"]}, {"input": {"input_string": "fyq"}, "output": ["fqy", "fyq", "qfy", "qyf", "yfq", "yqf"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yuanyuanzijin/Offer-in-Python", "path": "/Chapter4_\u89e3\u51b3\u9762\u8bd5\u9898\u7684\u601d\u8def/38_\u5b57\u7b26\u4e32\u7684\u6392\u5217.py", "msgidx": 849}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass ParenthesisGenerator:\n    def __init__(self, n: int):\n        self.res = []\n        self.n = n\n\n    def helper(self, curr: str, start: int, end: int):\n        if len(curr) == 2 * self.n:\n            self.res.append(curr)\n            return\n        \n        if start < self.n:\n            self.helper(curr + \"(\", start + 1, end)\n            \n        if end < start:\n            self.helper(curr + \")\", start, end + 1)\n\n# main function\ndef main_solution(n: int) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    generator = ParenthesisGenerator(n)\n    generator.helper(\"\", 0, 0)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return generator.res", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rohitpatwa/leetcode", "path": "/22. Generate Parentheses.py", "msgidx": 194}}
{"problem_description": "Given the concept of the \"look and say\" sequence, where each term describes the digits of the previous term, what is the Nth term in this sequence?", "io_requirements": "Input:\n  `N` (int): An integer representing the position in the \"look and say\" sequence for which the term is to be generated.\n\nOutput:\n  `return` (str): A string representing the Nth term of the \"look and say\" sequence. Each digit in the sequence is concatenated without any separators.", "refcode": "# import necessary packages\nfrom functools import lru_cache\nfrom typing import List\n\n# all class and function definitions in the code file, if any\n@lru_cache(maxsize=32)\ndef look_and_say(n: int) -> List[int]:\n    if n == 1:\n        return [1]\n\n    prev = look_and_say(n - 1)\n    index = 0\n    size = len(prev)\n    res = []\n\n    while index < size:\n        val = prev[index]\n        count = 0\n\n        while index < size and val == prev[index]:\n            count += 1\n            index += 1\n\n        res.append(count)\n        res.append(val)\n\n    return res\n\n# main function\ndef main_solution(N: int) -> str:\n    # Convert the output of look_and_say to a JSON serializable string\n    result = look_and_say(N)\n    return ''.join(map(str, result))", "funcname": "main_solution", "ios": [{"input": {"N": 4}, "output": "1211"}, {"input": {"N": 9}, "output": "31131211131221"}, {"input": {"N": 6}, "output": "312211"}, {"input": {"N": 3}, "output": "21"}, {"input": {"N": 1}, "output": "1"}, {"input": {"N": 8}, "output": "1113213211"}, {"input": {"N": 2}, "output": "11"}, {"input": {"N": 7}, "output": "13112221"}, {"input": {"N": 5}, "output": "111221"}, {"input": {"N": 10}, "output": "13211311123113112211"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rrwt/daily-coding-challenge", "path": "/daily_problems/problem_201_to_300/275.py", "msgidx": 413}}
{"problem_description": "Given the concept of strobogrammatic numbers, which are numbers that appear the same after being rotated 180 degrees, what are all the strobogrammatic numbers that can be formed with `n` digits?", "io_requirements": "Input:\n  `n` (int): The number of digits in the strobogrammatic numbers to be found. Must be a non-negative integer.\n\nOutput:\n  `return` (List[str]): A list of strings representing all strobogrammatic numbers with `n` digits. Each string in the list is a strobogrammatic number.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef helper(n: int, base: int) -> List[str]:\n    if n == 0:\n        return [\"\"]\n\n    if n == 1:\n        return [\"1\", \"0\", \"8\"]\n\n    middles = helper(n - 2, base)\n\n    result = []\n\n    for middle in middles:\n        if n != base:\n            result.append(\"0\" + middle + \"0\")\n\n        result.append(\"1\" + middle + \"1\")\n        result.append(\"6\" + middle + \"9\")\n        result.append(\"8\" + middle + \"8\")\n        result.append(\"9\" + middle + \"6\")\n\n    return result\n\n# main function\ndef main_solution(n: int) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if n == 0:\n        return []\n\n    # Convert the output to JSON serializable format\n    return helper(n, n)", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["11", "69", "88", "96"]}, {"input": {"n": 1}, "output": ["1", "0", "8"]}, {"input": {"n": 0}, "output": []}, {"input": {"n": 3}, "output": ["111", "619", "818", "916", "101", "609", "808", "906", "181", "689", "888", "986"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "OneWinged-Eagle/MyDailyCodingProblem", "path": "/Easy/#362/main.py", "msgidx": 164}}
{"problem_description": "In a historical game of survival, a group of people stand in a circle. Starting from the first person, each person eliminates the person to their left. This process continues until only one person remains. Given the number of people in the circle, what is the position of the last person standing?", "io_requirements": "Input:\n  `n` (int): The number of people in the circle. Must be a non-negative integer.\n\nOutput:\n  `return` (int or str): The position (index starting from 0) of the last person standing. If `n` is 0, returns the string \"False\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephus(n):\n    if n == 0:\n        return False\n    def jos(k, P):\n        if len(P) == 1:\n            return P[0]\n        P.remove(P[(k + 1) % len(P)])\n        return jos((k + 1) % (len(P) + 1), P)\n    return jos(0, [i for i in range(n)])\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    # Call the josephus function\n    result = josephus(n)\n    # Convert the result to a JSON serializable type if necessary\n    if result is False:\n        result = \"False\"\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 13}, "output": 10}, {"input": {"n": 60}, "output": 56}, {"input": {"n": 73}, "output": 18}, {"input": {"n": 49}, "output": 34}, {"input": {"n": 68}, "output": 8}, {"input": {"n": 78}, "output": 28}, {"input": {"n": 55}, "output": 46}, {"input": {"n": 77}, "output": 26}, {"input": {"n": 42}, "output": 20}, {"input": {"n": 87}, "output": 46}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/YwXwxa6xmoonFRKQJ_19.py", "msgidx": 393}}
{"problem_description": "In a school, there are `n` lockers, all initially open. Each locker is numbered from 1 to `n`. There are also `n` students. The first student closes every locker. The second student changes the state (open/close) of every second locker, the third student changes the state of every third locker, and so on. After all students have gone through, which lockers remain closed? Specifically, is it true that only the lockers with numbers that are perfect squares remain closed?", "io_requirements": "Input:\n  `n` (int): The number of lockers. It should be a positive integer.\n\nOutput:\n  `return` (bool): A boolean value indicating whether only the lockers with square numbers are closed (`True`) or not (`False`).", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef initializeList(n):\n    return [0 for _ in range(n)]\n\ndef changeState(aList, idx):\n    aList[idx] = 1 - aList[idx]\n\ndef runList(aList):\n    for x in range(len(aList)):\n        for k in range(1, len(aList) // (x + 1) + 1):\n            idx = k * (x + 1) - 1\n            if idx < len(aList):\n                changeState(aList, idx)\n\ndef checkForSquares(aList):\n    for i in range(len(aList)):\n        if (math.isqrt(i + 1) ** 2 == i + 1) != (aList[i] == 1):\n            return False\n    return True\n\n# main function\ndef main_solution(n):\n    # Initialize the list of lockers\n    lockers = initializeList(n)\n    \n    # Run the simulation of students changing the state of lockers\n    runList(lockers)\n    \n    # Check if only the lockers with square numbers are closed\n    result = checkForSquares(lockers)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 37}, "output": true}, {"input": {"n": 64}, "output": true}, {"input": {"n": 56}, "output": true}, {"input": {"n": 59}, "output": true}, {"input": {"n": 58}, "output": true}, {"input": {"n": 85}, "output": true}, {"input": {"n": 19}, "output": true}, {"input": {"n": 96}, "output": true}, {"input": {"n": 39}, "output": true}, {"input": {"n": 71}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JimVargas5/locker-demo", "path": "/lockers_demo.py", "msgidx": 574}}
{"problem_description": "In a building, you have a certain number of balls and a limited number of trials to determine the highest floor from which a ball can be dropped without breaking. Given the number of trials (`drops`) and the number of balls (`balls`), what is the maximum number of floors you can evaluate to find the critical floor?", "io_requirements": "Input:\n  `drops` (int): The number of trials we are allowed to perform.\n  `balls` (int): The number of balls we have.\n\nOutput:\n  `return` (int): The maximum number of floors between which we can distinguish.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef floors(drops: int, balls: int) -> int:\n    \"\"\"\n    Calculates the highest building we can evaluate with the given parameters.\n\n    Args:\n        drops: The number of trials we are allowed to perform.\n        balls: The number of balls we have.\n\n    Returns:\n        The maximum number of floors between which we can distinguish.\n    \"\"\"\n    if drops == 0 or balls == 0:\n        return 0\n\n    return floors(drops - 1, balls - 1) + floors(drops - 1, balls) + 1\n\n# main function\ndef main_solution(drops: int, balls: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = floors(drops, balls)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"drops": 3, "balls": 1}, "output": 3}, {"input": {"drops": 6, "balls": 3}, "output": 41}, {"input": {"drops": 6, "balls": 1}, "output": 6}, {"input": {"drops": 1, "balls": 2}, "output": 1}, {"input": {"drops": 7, "balls": 3}, "output": 63}, {"input": {"drops": 7, "balls": 5}, "output": 119}, {"input": {"drops": 9, "balls": 2}, "output": 45}, {"input": {"drops": 10, "balls": 4}, "output": 385}, {"input": {"drops": 5, "balls": 3}, "output": 25}, {"input": {"drops": 1, "balls": 1}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Samyak-code/Instructorfiles", "path": "/lectures/code/riddles/r7_10.py", "msgidx": 635}}
{"problem_description": "Given a spiral where numbers are arranged starting from 1 in the center and moving outward in a clockwise direction, what is the sum of all numbers on the diagonals for a spiral with a side length of `long_side`?", "io_requirements": "Input:\n  `long_side` (int): The length of the side of the spiral. It must be an odd number greater than or equal to 3.\n\nOutput:\n  `return` (int): The sum of all numbers on the diagonals of the spiral with the given `long_side`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef corners_of_square(side):\n    corners = [side**2 - (side-1)*n for n in range(0,4,1)]\n    return corners[::-1]\n\n# main function\ndef main_solution(long_side):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  summ_of_corners = 1\n  full_list_corners = []\n  for side in range(3, long_side + 1, 2):\n      corners = corners_of_square(side)\n      for i in corners:\n          full_list_corners.append(i)\n          summ_of_corners += i \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return summ_of_corners", "funcname": "main_solution", "ios": [{"input": {"long_side": 403}, "output": 43715625}, {"input": {"long_side": 597}, "output": 142029781}, {"input": {"long_side": 411}, "output": 46369361}, {"input": {"long_side": 129}, "output": 1439617}, {"input": {"long_side": 591}, "output": 137792141}, {"input": {"long_side": 425}, "output": 51267961}, {"input": {"long_side": 969}, "output": 607039577}, {"input": {"long_side": 481}, "output": 74306081}, {"input": {"long_side": 699}, "output": 227933297}, {"input": {"long_side": 327}, "output": 23364421}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "HYuHY/Programming_school_HH", "path": "/1st_level_selection - Task_5.py", "msgidx": 82}}
{"problem_description": "Given a spiral pattern formed by numbers starting from 1 and moving to the right in a clockwise direction, what is the sum of the numbers on the diagonals in a spiral of size `spiral_size` by `spiral_size`?", "io_requirements": "Input:\n  `spiral_size` (int): The size of the spiral (e.g., 5 for a 5x5 spiral, 1001 for a 1001x1001 spiral). Must be an odd number greater than 1.\n\nOutput:\n  `return` (int): The sum of the numbers on the diagonals of the spiral.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n\n# main function\ndef main_solution(spiral_size):\n    # Convert the spiral_size to the appropriate format\n    spiral_sizes = [2 * x for x in range(1, (spiral_size // 2) + 1)]\n    \n    # Initialize variables\n    diagonal_number_sum = 1\n    current_diagonal_number = 1\n    \n    # Calculate the sum of the numbers on the diagonals\n    for x in spiral_sizes:\n        for y in range(4):\n            current_diagonal_number += x\n            diagonal_number_sum += current_diagonal_number\n    \n    # Return the sum of the numbers on the diagonals\n    return diagonal_number_sum", "funcname": "main_solution", "ios": [{"input": {"spiral_size": 801}, "output": 342936801}, {"input": {"spiral_size": 139}, "output": 1800257}, {"input": {"spiral_size": 211}, "output": 6285161}, {"input": {"spiral_size": 315}, "output": 20887281}, {"input": {"spiral_size": 643}, "output": 177439385}, {"input": {"spiral_size": 437}, "output": 55731701}, {"input": {"spiral_size": 359}, "output": 30910437}, {"input": {"spiral_size": 599}, "output": 143461397}, {"input": {"spiral_size": 589}, "output": 136398557}, {"input": {"spiral_size": 381}, "output": 36943981}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "brittneyexline/euler", "path": "/problem28.py", "msgidx": 166}}
{"problem_description": "Given a number, determine its position in the ECG Sequence, where the sequence starts with 1 and 2, and each subsequent number is the smallest number not already in the sequence that shares a factor (other than 1) with the preceding number. What is the index of the given number in the ECG Sequence?", "io_requirements": "Input:\n  `n` (int): The integer for which the ECG Sequence Index needs to be found.\n\nOutput:\n  `return` (int): The index of the integer `n` in the ECG Sequence.", "refcode": "# import necessary packages\nimport math\n\n# Function to find the greatest common divisor (GCD) of two numbers\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to find the ECG Sequence Index of a given number n\ndef ecg_seq_index(n):\n    sequence = [1, 2]\n    while True:\n        next_num = 3\n        while True:\n            if next_num not in sequence and gcd(sequence[-1], next_num) > 1:\n                sequence.append(next_num)\n                break\n            next_num += 1\n        if sequence[-1] == n:\n            return len(sequence) - 1\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer if it's not already\n    n = int(n)\n    # Call the ecg_seq_index function to get the result\n    result = ecg_seq_index(n)\n    # Return the result as an integer\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": 4}, {"input": {"n": 51}, "output": 33}, {"input": {"n": 18}, "output": 11}, {"input": {"n": 99}, "output": 95}, {"input": {"n": 98}, "output": 91}, {"input": {"n": 5}, "output": 9}, {"input": {"n": 38}, "output": 35}, {"input": {"n": 78}, "output": 69}, {"input": {"n": 71}, "output": 133}, {"input": {"n": 45}, "output": 38}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "serapred/academy", "path": "/0712/egc.py", "msgidx": 255}}
{"problem_description": "Given a system with multiple memory banks, each containing a certain number of blocks, the system periodically redistributes the blocks among the banks. The redistribution process continues until a previously seen configuration of blocks is encountered again. How many cycles are required to detect a duplicate configuration, and what is the final configuration of the memory banks at that point?", "io_requirements": "Input:\n  `banks` (list of int): A list of integers representing the number of blocks in each memory bank.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `cycle` (int): The number of cycles required to detect a duplicate configuration.\n    - `banks` (list of int): The final configuration of the memory banks after the duplicate configuration is detected.", "refcode": "# import necessary packages\nfrom numpy import argmax\n\n# main function\ndef main_solution(banks):\n    # Convert the input list to a JSON serializable format\n    banks = list(banks)\n    \n    num_banks = len(banks)\n\n    def rebalance(banks):\n        seen = set()\n        seen.add(tuple(banks))\n        cycle = 0\n\n        while True:\n            cycle += 1\n            bank = argmax(banks)\n            blocks = banks[bank]\n            banks[bank] = 0\n\n            while blocks > 0:\n                bank += 1\n                banks[bank % num_banks] += 1\n                blocks -= 1\n\n            t = tuple(banks)\n            if t in seen:\n                break\n            else:\n                seen.add(t)\n\n        return cycle, banks\n\n    cycle, banks = rebalance(banks)\n    \n    # Convert the output to a JSON serializable format\n    return {\"cycle\": cycle, \"banks\": banks}", "funcname": "main_solution", "ios": [{"input": {"banks": [8, 9, 7]}, "output": {"cycle": 6, "banks": [8, 12, 4]}}, {"input": {"banks": [8, 7, 7, 4, 2, 10, 7]}, "output": {"cycle": 40, "banks": [6, 4, 3, 13, 10, 8, 1]}}, {"input": {"banks": [2, 0, 0, 6, 1, 7, 7, 8]}, "output": {"cycle": 21, "banks": [0, 6, 5, 2, 7, 4, 3, 4]}}, {"input": {"banks": [8, 1, 9, 8, 8, 3, 7, 4, 7]}, "output": {"cycle": 120, "banks": [4, 3, 2, 1, 13, 11, 9, 7, 5]}}, {"input": {"banks": [7, 10, 7, 6]}, "output": {"cycle": 11, "banks": [3, 9, 6, 12]}}, {"input": {"banks": [10, 4, 9, 9]}, "output": {"cycle": 11, "banks": [10, 13, 6, 3]}}, {"input": {"banks": [3, 3, 6]}, "output": {"cycle": 7, "banks": [6, 4, 2]}}, {"input": {"banks": [1, 5, 3, 4, 0, 3, 6]}, "output": {"cycle": 7, "banks": [1, 5, 3, 4, 0, 3, 6]}}, {"input": {"banks": [2, 7, 8, 0, 10, 6, 10, 1, 2, 6]}, "output": {"cycle": 16, "banks": [9, 3, 4, 6, 6, 2, 5, 8, 8, 1]}}, {"input": {"banks": [0, 9, 1, 9, 5, 9, 4]}, "output": {"cycle": 72, "banks": [5, 3, 2, 1, 11, 8, 7]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "iverberk/advent-of-code-2017", "path": "/day-06/part1-2.py", "msgidx": 696}}
{"problem_description": "Given a positive integer, determine whether it is a \"happy number\". A \"happy number\" is defined as a number that, when repeatedly replaced by the sum of the squares of its digits, eventually reaches 1. If it enters a cycle that does not include 1, it is not a happy number. What is the result of checking if the given number is a happy number?", "io_requirements": "Input:\n  `n` (int): A positive integer to be checked if it is a \"happy number\".\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input number `n` is a \"happy number\" (True) or not (False).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        u = set([4, 16, 37, 58, 89, 145, 42, 20])\n\n        r = 0\n        while 1:\n            while (n > 0):\n                n, y = divmod(n, 10)\n                r = r + y ** 2\n\n            if (r == 1):\n                return True\n\n            if (r in u):\n                return False\n\n            n, r = r, 0\n\n# main function\ndef main_solution(n):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.isHappy(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 13}, "output": true}, {"input": {"n": 354}, "output": false}, {"input": {"n": 474}, "output": false}, {"input": {"n": 571}, "output": false}, {"input": {"n": 95}, "output": false}, {"input": {"n": 904}, "output": true}, {"input": {"n": 123}, "output": false}, {"input": {"n": 64}, "output": false}, {"input": {"n": 637}, "output": true}, {"input": {"n": 890}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cylinder-lee-cn/LeetCode", "path": "/LeetCode/202.py", "msgidx": 77}}
{"problem_description": "Given a stretch of beach represented by a string where '0' indicates a free spot and '1' indicates an occupied spot, how many new people can settle in on the beach while ensuring that there is at least one free spot between any two people?", "io_requirements": "Input:\n  `beach` (str): A string representing the beach, where '0' indicates a free spot and '1' indicates an occupied spot. The string should only contain '0' and '1' characters.\n\nOutput:\n  `return` (int): The maximum number of new people that can settle in on the beach, ensuring that there is at least one free spot between any two people.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(beach):\n    # Convert the beach string to a list for easier manipulation\n    beach_list = [x for x in beach]\n    \n    chairs = 0\n    i = 0\n    while i < len(beach_list):\n        if beach_list[i] == '0':\n            if i == 0:\n                try:\n                    if beach_list[i+1] == '0':\n                        chairs += 1\n                        beach_list[i] = '1'\n                        i += 1\n                    else:\n                        i += 1\n                except: \n                    chairs += 1\n                    i += 1\n                \n            elif i == len(beach_list) - 1:\n                if beach_list[i - 1] == '0':\n                    chairs += 1\n                    i += 1\n                else:\n                    i += 1\n            else:\n                if beach_list[i-1] == '0' and beach_list[i+1] == '0':\n                    chairs += 1\n                    beach_list[i] = '1'\n                    i += 1\n                else:\n                    i += 1\n        else: \n            i += 1\n    \n    # Return the number of new people that can settle in\n    return chairs", "funcname": "main_solution", "ios": [{"input": {"beach": "01111"}, "output": 0}, {"input": {"beach": "0101101101011000110"}, "output": 1}, {"input": {"beach": "10110100101100100101"}, "output": 0}, {"input": {"beach": "0"}, "output": 1}, {"input": {"beach": "01101001101110011001"}, "output": 0}, {"input": {"beach": "0111000011011110"}, "output": 1}, {"input": {"beach": "110101000001"}, "output": 2}, {"input": {"beach": "000100"}, "output": 2}, {"input": {"beach": "110011000111"}, "output": 1}, {"input": {"beach": "100101111101000"}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/HaMCeHeJkaWvMg7LS_4.py", "msgidx": 391}}
{"problem_description": "Given a network of caves connected by tunnels, where each cave is represented by a node and each tunnel by an edge, how many distinct paths can be taken from the 'start' cave to the 'end' cave, considering that small caves (represented by lowercase letters) can only be visited once, except for one small cave that can be visited twice? The network is described by a list of edges connecting the caves.", "io_requirements": "Input:\n  `edges` (list of tuples): A list of tuples representing the edges of the graph. Each tuple contains two strings representing the nodes connected by the edge.\n\nOutput:\n  `return` (int): The number of distinct paths from the 'start' node to the 'end' node in the graph, considering that small caves (lowercase nodes) can only be visited once, except for one small cave that can be visited twice.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(edges):\n  # Convert the list of edges into a graph representation\n  graph = defaultdict(list)\n  for left, right in edges:\n    graph[left].append(right)\n    graph[right].append(left)\n  \n  # Initialize the paths and finished count\n  paths = [('start', set(), False)]\n  finished = 0\n\n  # Process each path\n  while paths:\n    path = paths.pop()\n    tip, visited, doubled = path\n    for n in graph[tip]:\n      if n == 'start':\n        continue\n      elif n == 'end':\n        finished += 1\n      elif n.isupper():\n        paths.append((n, visited, doubled))\n      elif n not in visited:\n        paths.append((n, visited | {n}, doubled))\n      elif not doubled:\n        paths.append((n, visited, True))\n  \n  # Return the number of finished paths\n  return finished", "funcname": "main_solution", "ios": [{"input": {"edges": [["s", "z"], ["c", "start"], ["e", "p"], ["end", "r"]]}, "output": 0}, {"input": {"edges": [["z", "end"], ["start", "d"], ["k", "f"], ["c", "v"]]}, "output": 0}, {"input": {"edges": [["y", "a"], ["f", "z"], ["i", "f"], ["y", "a"], ["z", "p"]]}, "output": 0}, {"input": {"edges": [["a", "j"], ["start", "p"], ["a", "t"], ["e", "i"]]}, "output": 0}, {"input": {"edges": [["h", "f"], ["c", "g"], ["a", "x"]]}, "output": 0}, {"input": {"edges": [["start", "j"], ["o", "l"], ["m", "i"], ["x", "g"]]}, "output": 0}, {"input": {"edges": [["l", "i"], ["end", "p"], ["y", "end"], ["l", "u"]]}, "output": 0}, {"input": {"edges": [["g", "i"], ["w", "a"], ["start", "n"], ["end", "l"]]}, "output": 0}, {"input": {"edges": [["w", "l"], ["r", "o"], ["i", "x"], ["i", "h"]]}, "output": 0}, {"input": {"edges": [["s", "l"], ["m", "b"], ["i", "h"], ["h", "y"]]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "balshetzer/AdventOfCode", "path": "/2021/12b.py", "msgidx": 780}}
{"problem_description": "Given a natural number \\( n \\), which represents the sum of a Pythagorean triplet (a set of three natural numbers \\( a < b < c \\) such that \\( a^2 + b^2 = c^2 \\)), what are the values of \\( a \\), \\( b \\), and \\( c \\), and what is the product of these three numbers?", "io_requirements": "Input:\n  `n` (int): The sum of the Pythagorean triplet (a + b + c).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `a` (int): The first number in the Pythagorean triplet.\n    - `b` (int): The second number in the Pythagorean triplet.\n    - `c` (int): The third number in the Pythagorean triplet.\n    - `product_abc` (int): The product of the three numbers (a * b * c). If no such triplet exists, the values for `a`, `b`, `c`, and `product_abc` will be `None`.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # n (int): The sum of the Pythagorean triplet (a + b + c)\n    for a in range(1, n - 1):\n        for b in range(1, n - a - 1):\n            c = n - a - b\n            if a**2 + b**2 == c**2:\n                return {\"a\": a, \"b\": b, \"c\": c, \"product_abc\": a * b * c}\n    return {\"a\": None, \"b\": None, \"c\": None, \"product_abc\": None}", "funcname": "main_solution", "ios": [{"input": {"n": 576}, "output": {"a": 64, "b": 252, "c": 260, "product_abc": 4193280}}, {"input": {"n": 355}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}, {"input": {"n": 254}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}, {"input": {"n": 193}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}, {"input": {"n": 946}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}, {"input": {"n": 493}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}, {"input": {"n": 291}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}, {"input": {"n": 656}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}, {"input": {"n": 988}, "output": {"a": 266, "b": 312, "c": 410, "product_abc": 34026720}}, {"input": {"n": 589}, "output": {"a": null, "b": null, "c": null, "product_abc": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ncalkins89/Project-Euler", "path": "/project euler problem 9.py", "msgidx": 294}}
{"problem_description": "Imagine you are at a fast-food restaurant that sells chicken McNuggets in packs of 6, 9, and 20. Given a certain number of McNuggets `n`, can you determine if it is possible to buy exactly `n` McNuggets using these pack sizes?", "io_requirements": "Input:\n  `n` (int): An integer representing the number of McNuggets to check if it can be formed by combinations of 6, 9, and 20.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the number of McNuggets `n` can be formed by combinations of 6, 9, and 20.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef McNuggets(n):\n    \"\"\"\n    n is an int\n\n    Returns True if some integer combination of 6, 9 and 20 equals n\n    Otherwise returns False.\n    \"\"\"\n    for a in range(0, n//6 + 1):\n        for b in range(0, n//9 + 1):\n            for c in range(0, n//20 + 1):\n                if 6*a + 9*b + 20*c == n:\n                    return True\n    return False\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = McNuggets(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 88}, "output": true}, {"input": {"n": 14}, "output": false}, {"input": {"n": 29}, "output": true}, {"input": {"n": 1}, "output": false}, {"input": {"n": 93}, "output": true}, {"input": {"n": 11}, "output": false}, {"input": {"n": 40}, "output": true}, {"input": {"n": 31}, "output": false}, {"input": {"n": 50}, "output": true}, {"input": {"n": 98}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ppeiris/codes", "path": "/mooc/mit-6.00x/midexam1/midexam1-ps7.py", "msgidx": 119}}
{"problem_description": "Given a range of two-digit numbers, identify all fractions where the numerator and denominator share a common digit (excluding zero) and the fraction remains the same when this common digit is removed. What is the product of all such fractions in its simplest form?", "io_requirements": "Input:\n  `start_range` (int): The starting range for the numerator and denominator (inclusive).\n  `end_range` (int): The ending range for the numerator and denominator (inclusive).\n\nOutput:\n  `return` (dict): A dictionary containing the final fraction's numerator and denominator.\n    - `numerator` (int): The numerator of the final fraction.\n    - `denominator` (int): The denominator of the final fraction.", "refcode": "# import necessary packages\nfrom fractions import Fraction\n\n# main function\ndef main_solution(start_range, end_range):\n    product_n = 1\n    product_d = 1\n\n    for n in range(start_range, end_range + 1):\n        for d in range(start_range, end_range + 1):\n            reduced = n / d\n            if reduced >= 1.0:\n                continue\n            reduced = Fraction(n, d)\n\n            nstr = str(n)\n            dstr = str(d)\n\n            for l in nstr:\n                if l == '0':\n                    continue\n                if l in dstr:\n                    rnstr = nstr.replace(l, '')\n                    rdstr = dstr.replace(l, '')\n                    if len(rnstr) == 0 or len(rdstr) == 0 or int(rdstr) == 0:\n                        continue\n\n                    test = Fraction(int(rnstr), int(rdstr))\n                    if test == reduced:\n                        product_n *= int(rnstr)\n                        product_d *= int(rdstr)\n\n    final_fraction = Fraction(product_n, product_d)\n    return {\"numerator\": final_fraction.numerator, \"denominator\": final_fraction.denominator}", "funcname": "main_solution", "ios": [{"input": {"start_range": 22, "end_range": 68}, "output": {"numerator": 2, "denominator": 5}}, {"input": {"start_range": 10, "end_range": 20}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 49, "end_range": 80}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 24, "end_range": 58}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 28, "end_range": 37}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 32, "end_range": 95}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 33, "end_range": 79}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 29, "end_range": 57}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 34, "end_range": 83}, "output": {"numerator": 1, "denominator": 1}}, {"input": {"start_range": 25, "end_range": 82}, "output": {"numerator": 2, "denominator": 5}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "arm-out/ProjectEuler", "path": "/Problem_033.py", "msgidx": 44}}
{"problem_description": "You have a set of containers with varying capacities, and you need to store a specific amount of eggnog. How many different ways can you arrange the containers to exactly fit the total amount of eggnog? Additionally, if you are asked to use the minimum number of containers, how many different ways can you achieve this?", "io_requirements": "Input:\n  `containers` (list of strings): A list of container sizes, where each size is represented as a string.\n  `total_liters` (int): The total amount of liters that need to be stored in the containers.\n  `find_min_containers` (bool): A flag indicating whether to find the minimum number of containers that can hold the total liters. Default is `False`.\n\nOutput:\n  `return` (int): The number of different combinations of containers that can exactly fit the total liters of eggnog. If `find_min_containers` is `True`, it returns the number of combinations using the minimum number of containers.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(containers, total_liters, find_min_containers=False):\n    # Convert the list of container sizes to integers\n    containers = [int(x) for x in containers]\n    \n    # Initialize the number of combinations\n    num_combinations = 0\n    \n    # Iterate over the possible number of containers to use\n    for n in range(len(containers) + 1):\n        # Find all combinations of n containers that sum to total_liters\n        valid_combinations = [x for x in itertools.combinations(containers, n) if sum(x) == total_liters]\n        \n        # Add the number of valid combinations to the total\n        num_combinations += len(valid_combinations)\n        \n        # If we are looking for the minimum number of containers and we have found at least one combination, break\n        if find_min_containers and num_combinations:\n            break\n    \n    # Return the number of combinations\n    return num_combinations", "funcname": "main_solution", "ios": [{"input": {"containers": ["17", "25", "8", "26", "50", "25", "9"], "total_liters": 171, "find_min_containers": false}, "output": 0}, {"input": {"containers": ["43", "2", "14", "10", "1", "37"], "total_liters": 190, "find_min_containers": false}, "output": 0}, {"input": {"containers": ["17", "17", "19", "27", "14", "18", "43"], "total_liters": 156, "find_min_containers": false}, "output": 0}, {"input": {"containers": ["30", "45", "12", "34", "15", "9"], "total_liters": 126, "find_min_containers": false}, "output": 0}, {"input": {"containers": ["46", "24", "50", "19", "24", "35", "37", "8"], "total_liters": 196, "find_min_containers": false}, "output": 0}, {"input": {"containers": ["44", "30", "17", "4", "20"], "total_liters": 161, "find_min_containers": true}, "output": 0}, {"input": {"containers": ["15", "4", "40", "10", "43", "45", "8"], "total_liters": 178, "find_min_containers": true}, "output": 0}, {"input": {"containers": ["26", "33", "48", "14", "35", "7", "6"], "total_liters": 67, "find_min_containers": false}, "output": 1}, {"input": {"containers": ["36", "22", "29", "41", "4", "15", "24"], "total_liters": 116, "find_min_containers": true}, "output": 2}, {"input": {"containers": ["37", "19", "10", "8", "14", "3", "33", "41"], "total_liters": 196, "find_min_containers": false}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Hwesta/advent-of-code", "path": "/aoc2015/day17.py", "msgidx": 270}}
{"problem_description": "In a poker game, what is the estimated probability of drawing a full house (a hand with exactly three cards of one rank and two cards of another rank) from a standard deck of 52 cards, given a certain number of simulations?", "io_requirements": "Input:\n  `n_sims` (int): The number of simulations to run to estimate the probability of a full house. This should be a positive integer.\n\nOutput:\n  `return` (float): The estimated probability of getting a full house in a poker hand of 5 cards, based on the number of simulations specified. The value is a float between 0 and 1.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(n_sims):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  \n  # Deck of cards\n  deck = []\n  cards, n_cards = ['Heart', 'Club', 'Spade', 'Diamond'], 13\n\n  for card in cards:\n      deck += list(zip([card]*n_cards, list(range(n_cards))))\n\n  # Shuffle deck & count card occurrences in the hand\n  full_house, deck_of_cards = 0, deck.copy() \n  for i in range(n_sims):\n      np.random.shuffle(deck_of_cards)\n      hand, cards_in_hand = deck_of_cards[0:5], {}\n\n      for card in hand:\n          # Use .get() method to count occurrences of each card\n          cards_in_hand[card[1]] = cards_in_hand.get(card[1], 0) + 1\n          \n      # Condition for getting full house\n      condition = (max(cards_in_hand.values()) == 3) & (min(cards_in_hand.values()) == 2)\n\n      if  condition == True: \n          full_house += 1\n\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return full_house / n_sims", "funcname": "main_solution", "ios": [{"input": {"n_sims": 65719}, "output": 0.0013998995724219783}, {"input": {"n_sims": 87053}, "output": 0.0015622666651350326}, {"input": {"n_sims": 13920}, "output": 0.0015086206896551724}, {"input": {"n_sims": 14606}, "output": 0.0015062303163083663}, {"input": {"n_sims": 25523}, "output": 0.0011362300669983936}, {"input": {"n_sims": 58794}, "output": 0.0014967513691873321}, {"input": {"n_sims": 79180}, "output": 0.0017428643596867897}, {"input": {"n_sims": 85357}, "output": 0.0013472825895942922}, {"input": {"n_sims": 34685}, "output": 0.0014703762433328528}, {"input": {"n_sims": 25802}, "output": 0.0016277807921866521}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sashakrasnov/datacamp", "path": "/29-statistical-simulation-in-python/2-probability-and-data-generation-process/06-full-house.py", "msgidx": 124}}
{"problem_description": "Given a number, how many circular primes are there below that number? A circular prime is a prime number where all rotations of its digits are also prime numbers. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers.", "io_requirements": "Input:\n  `limit` (int): The upper limit for checking circular primes. It should be a positive integer greater than 1.\n\nOutput:\n  `return` (int): The number of circular primes below the given `limit`.", "refcode": "# import necessary packages\nimport math\nimport time\n\n# all class and function definitions in the code file, if any\ndef isPrime(n):\n    if n == 1:\n        return False\n    elif n < 4:\n        return True\n    elif n % 2 == 0:\n        return False\n    elif n < 9:\n        return True\n    elif n % 3 == 0:\n        return False\n    else:\n        r = int(math.sqrt(n) + 1)\n        f = 5\n        while f <= r:\n            if n % f == 0:\n                return False\n            if n % (f + 2) == 0:\n                return False\n            f = f + 6\n        return True\n\ndef all_perms(st):\n    if len(st) <= 1:\n        yield st\n    else:\n        for perm in all_perms(st[1:]):\n            for i in range(len(perm) + 1):\n                yield perm[:i] + st[0:1] + perm[i:]\n\ndef ListToInt(lst):\n    strang = ''\n    for i in range(len(lst)):\n        strang += str(lst[i])\n    return int(strang)\n\ndef isCircPrime(n):\n    if n < 10:\n        return isPrime(n)\n    else:\n        ns = str(n)\n        nl = [int(i) for i in ns]\n\n        for p in all_perms(nl):\n            q = ListToInt(p)\n            if not isPrime(q):\n                return False\n        return True\n\n# main function\ndef main_solution(limit):\n    count = 0\n    for u in range(2, limit):\n        if isCircPrime(u):\n            count += 1\n    return count", "funcname": "main_solution", "ios": [{"input": {"limit": 3385}, "output": 22}, {"input": {"limit": 4108}, "output": 22}, {"input": {"limit": 6913}, "output": 22}, {"input": {"limit": 3169}, "output": 22}, {"input": {"limit": 5954}, "output": 22}, {"input": {"limit": 8419}, "output": 22}, {"input": {"limit": 5069}, "output": 22}, {"input": {"limit": 1604}, "output": 22}, {"input": {"limit": 7526}, "output": 22}, {"input": {"limit": 9600}, "output": 22}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rylans/Project-euler", "path": "/35-circ prime under 1mil.py", "msgidx": 459}}
{"problem_description": "A person is selling ducks in villages. Each time he passes through a village, he sells half of his ducks plus one more. After passing through seven villages, he has two ducks left. How many ducks did he start with, and how many ducks did he sell in each village starting from a specific village?", "io_requirements": "Input:\n  `n` (int): The starting village number (0 \u2264 n \u2264 6). Represents the village from which the person starts selling ducks.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `total_ducks` (int): The total number of ducks the person initially had.\n    - `ducks_sold_per_village` (list of int): A list of integers representing the number of ducks sold in each village from the starting village to the last village (village 7).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    def rest(n):\n        if n == 7:\n            return 2\n        else:\n            rn1 = rest(n+1)\n            r = (rn1 + 1) * 2\n            return r\n    \n    total_ducks = rest(n)\n    ducks_sold_per_village = []\n    \n    for i in range(n, 7):\n        if i == n:\n            ducks_sold_per_village.append(total_ducks - rest(i+1))\n        else:\n            ducks_sold_per_village.append(rest(i) - rest(i+1))\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"total_ducks\": total_ducks,\n        \"ducks_sold_per_village\": ducks_sold_per_village\n    }", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": {"total_ducks": 62, "ducks_sold_per_village": [32, 16, 8, 4]}}, {"input": {"n": 2}, "output": {"total_ducks": 126, "ducks_sold_per_village": [64, 32, 16, 8, 4]}}, {"input": {"n": 6}, "output": {"total_ducks": 6, "ducks_sold_per_village": [4]}}, {"input": {"n": 0}, "output": {"total_ducks": 510, "ducks_sold_per_village": [256, 128, 64, 32, 16, 8, 4]}}, {"input": {"n": 1}, "output": {"total_ducks": 254, "ducks_sold_per_village": [128, 64, 32, 16, 8, 4]}}, {"input": {"n": 5}, "output": {"total_ducks": 14, "ducks_sold_per_village": [8, 4]}}, {"input": {"n": 4}, "output": {"total_ducks": 30, "ducks_sold_per_village": [16, 8, 4]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "heting-intesim/python-base", "path": "/\u57fa\u7840\u8bed\u6cd5/\u5356\u9e2d\u5b50\u95ee\u9898.py", "msgidx": 403}}
{"problem_description": "In a memory system, data is stored in a spiral grid pattern. Each position in the grid can be accessed by moving up, down, left, or right from any other position. Given a specific position in this grid, how many steps are required to move the data from that position to the origin (square 1), considering the shortest path?", "io_requirements": "Input:\n  `p` (int): The position in the spiral memory grid for which the Manhattan distance to the origin (square 1) is to be calculated.\n\nOutput:\n  `return` (int): The Manhattan distance from the given position `p` to the origin (square 1).", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef steps_from_origin(p, s=1):\n    \"\"\"tells us which increasing square of grid a point lies in\"\"\"\n    if p == 1:\n        return 1\n    elif p > (2*s+1)**2:\n        s += 1\n        return steps_from_origin(p, s)\n    else:\n        return s\n\ndef distance_midpoint(p, n):\n    \"\"\"each side is 2n-1 \"\"\"\n    # special case of center of grid\n    if n == 1:\n        return n\n    side = (2*n+1)\n    start = side**2\n    values = []\n    for i in range(1,4,1):\n        top = start-side*(i-1)\n        bottom = top - side\n        values = list(range(top, bottom, -1))\n        if p in values:\n            mid = values[round(len(values)/2)]\n            return mid-p+n\n\ndef manhattan_distance(start, end):\n    sx, sy = start\n    ex, ey = end\n    return abs(ex - sx) + abs(ey - sy)\n\n# main function\ndef main_solution(p):\n    # Convert the input to the required format\n    p = int(p)\n    \n    # Calculate the steps from origin\n    n = steps_from_origin(p)\n    \n    # Calculate the distance from the midpoint\n    distance = distance_midpoint(p, n)\n    \n    # Return the result\n    return distance", "funcname": "main_solution", "ios": [{"input": {"p": 726591}, "output": 165}, {"input": {"p": 655888}, "output": 210}, {"input": {"p": 70496}, "output": 258}, {"input": {"p": 183551}, "output": 61}, {"input": {"p": 132245}, "output": 250}, {"input": {"p": 413373}, "output": 75}, {"input": {"p": 784289}, "output": 705}, {"input": {"p": 969952}, "output": 273}, {"input": {"p": 574685}, "output": 636}, {"input": {"p": 270375}, "output": 24}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "smehan/AOC", "path": "/aoc_2017/d3.py", "msgidx": 231}}
{"problem_description": "Given a fractal pattern known as the Sierpi\u0144ski triangle, which is generated by recursively subdividing a triangle into smaller triangles, what will be the final shape of the triangle after a certain number of iterations starting from a given initial height?", "io_requirements": "Input:\n  `height` (int): The initial height of the Sierpi\u0144ski triangle.\n  `iterations` (int): The number of iterations to generate the Sierpi\u0144ski triangle.\n\nOutput:\n  `return` (list of str): A list of strings representing the final state of the Sierpi\u0144ski triangle after the specified number of iterations. Each string in the list represents a row of the triangle.", "refcode": "# import necessary packages\nfrom itertools import chain, islice\n\n# all class and function definitions in the code file, if any\ndef next_Sierpi\u0144ski(triangle): \n    base = (len(triangle[0]) << 1) | 1 \n    return chain((row.center(base) for row in triangle), \n                 map(' '.join, zip(triangle, triangle))) \n\ndef Sierpi\u0144ski(height): \n    triangle = generate_triangle(height) \n    while True: \n        yield triangle \n        triangle = list(next_Sierpi\u0144ski(triangle)) \n\ndef generate_triangle(height): \n    base = height << 1 \n    return [('*' * i).center(base - 1) for i in range(1, base + 1, 2)] \n\n# main function\ndef main_solution(height, iterations):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  triangles = list(islice(Sierpi\u0144ski(height), iterations))\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return [''.join(row) for row in triangles[-1]]", "funcname": "main_solution", "ios": [{"input": {"height": 3, "iterations": 1}, "output": ["  *  ", " *** ", "*****"]}, {"input": {"height": 3, "iterations": 2}, "output": ["     *     ", "    ***    ", "   *****   ", "  *     *  ", " ***   *** ", "***** *****"]}, {"input": {"height": 2, "iterations": 1}, "output": [" * ", "***"]}, {"input": {"height": 4, "iterations": 1}, "output": ["   *   ", "  ***  ", " ***** ", "*******"]}, {"input": {"height": 5, "iterations": 2}, "output": ["         *         ", "        ***        ", "       *****       ", "      *******      ", "     *********     ", "    *         *    ", "   ***       ***   ", "  *****     *****  ", " *******   ******* ", "********* *********"]}, {"input": {"height": 2, "iterations": 3}, "output": ["       *       ", "      ***      ", "     *   *     ", "    *** ***    ", "   *       *   ", "  ***     ***  ", " *   *   *   * ", "*** *** *** ***"]}, {"input": {"height": 4, "iterations": 2}, "output": ["       *       ", "      ***      ", "     *****     ", "    *******    ", "   *       *   ", "  ***     ***  ", " *****   ***** ", "******* *******"]}, {"input": {"height": 2, "iterations": 2}, "output": ["   *   ", "  ***  ", " *   * ", "*** ***"]}, {"input": {"height": 5, "iterations": 1}, "output": ["    *    ", "   ***   ", "  *****  ", " ******* ", "*********"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GeraldineE/SC20162", "path": "/trian.py", "msgidx": 263}}
{"problem_description": "Given a list of integers, how can we generate all possible partitions and their combinations in a flattened format?", "io_requirements": "Input:\n  `nums` (list of integers): A list of integers for which we need to generate all possible partitions and their combinations.\n\nOutput:\n  `return` (list of lists of integers): A list where each element is a list of integers representing a flattened partition of the input list.", "refcode": "# import necessary packages\nfrom copy import deepcopy\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef parts(nums):\n    # Returns all partitions of a list\n    if len(nums) == 1:\n        return [[nums]]\n    elif len(nums) >= 2:\n        new_parts = []\n        for part in parts(nums[:-1]):\n            new_parts += [part + [[nums[-1]]]]\n            temp_part = deepcopy(part)\n            temp_part[-1] += [nums[-1]]\n            new_parts += [temp_part]\n        return new_parts\n    \ndef cleaned_parts(nums):\n    l = parts(nums)\n    l.remove([nums])\n    return l   \n\ndef nicer_prod(*args):\n    return list(list(t) for t in product(*args))\n\ndef flatten(l):\n    return [subitem for item in l for subitem in item]\n\ndef K_list_of_lists(nums):\n    if len(nums) == 1:\n        return [[[nums[0]]]]\n    elif len(nums) == 2:\n        return [[[nums[0]],[nums[1]]]]\n    elif len(nums) >= 3:\n        bs_list = []\n        for outer_bs in cleaned_parts(nums):\n            sub_bs_list = nicer_prod(*[K_list_of_lists(part) for part in outer_bs])\n            sub_bs_list = [flatten(item) for item in sub_bs_list]\n            bs_list += [sub_bs + [outer_b for outer_b in outer_bs if (outer_b not in sub_bs)] for sub_bs in sub_bs_list]\n        return bs_list\n\n# main function\ndef main_solution(nums):\n    # Convert input to list if it's not already\n    if not isinstance(nums, list):\n        nums = list(nums)\n    \n    # Get the K_list_of_lists result\n    result = K_list_of_lists(nums)\n    \n    # Flatten the result to a JSON serializable format\n    flattened_result = [flatten(item) for item in result]\n    \n    return flattened_result", "funcname": "main_solution", "ios": [{"input": {"nums": [8, 6, 3]}, "output": [[8, 6, 3], [8, 6, 3, 6, 3], [8, 6, 3, 8, 6]]}, {"input": {"nums": [3, 5, 8]}, "output": [[3, 5, 8], [3, 5, 8, 5, 8], [3, 5, 8, 3, 5]]}, {"input": {"nums": [4, 5, 6]}, "output": [[4, 5, 6], [4, 5, 6, 5, 6], [4, 5, 6, 4, 5]]}, {"input": {"nums": [10, 10, 2]}, "output": [[10, 10, 2], [10, 10, 2, 10, 2], [10, 10, 2, 10, 10]]}, {"input": {"nums": [6, 7, 1]}, "output": [[6, 7, 1], [6, 7, 1, 7, 1], [6, 7, 1, 6, 7]]}, {"input": {"nums": [3, 10, 2]}, "output": [[3, 10, 2], [3, 10, 2, 10, 2], [3, 10, 2, 3, 10]]}, {"input": {"nums": [1, 3, 6]}, "output": [[1, 3, 6], [1, 3, 6, 3, 6], [1, 3, 6, 1, 3]]}, {"input": {"nums": [3, 3, 9]}, "output": [[3, 3, 9], [3, 3, 9, 3, 9], [3, 3, 9, 3, 3]]}, {"input": {"nums": [10, 10, 9]}, "output": [[10, 10, 9], [10, 10, 9, 10, 9], [10, 10, 9, 10, 10]]}, {"input": {"nums": [6, 10, 4]}, "output": [[6, 10, 4], [6, 10, 4, 10, 4], [6, 10, 4, 6, 10]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "natebottman/complex-2associahedra", "path": "/Kr.py", "msgidx": 241}}
{"problem_description": "Given a string that may represent a numeric value, determine whether the string conforms to the rules of valid numeric representation. The string may include digits, a single decimal point, a single 'e' or 'E' for scientific notation, and a single '+' or '-' sign. What is the result of checking if the string represents a valid numeric value?", "io_requirements": "Input:\n  `s` (str): A string that represents a potential numeric value. The string may contain digits, a single decimal point, a single 'e' or 'E' for scientific notation, and a single '+' or '-' sign. The string should not contain any other characters.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string `s` represents a valid numeric value. Returns `True` if the string is a valid numeric representation, otherwise `False`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isNumeric(self, s):\n        if not s or len(s) == 0:\n            return False\n        hasE = False\n        hasDecimal = False\n        hasSign = False\n\n        for i in range(len(s)):\n            if s[i] == '.':\n                if hasE or hasDecimal:\n                    return False\n                hasDecimal = True\n            elif s[i] == 'e' or s[i] == 'E':\n                if hasE or i == len(s)-1:\n                    return False\n                hasE = True\n            elif s[i] == '+' or s[i] == '-':\n                if hasSign and s[i-1] != 'e' and s[i-1] != 'E':\n                    return False\n                if not hasSign and i>0 and s[i-1] != 'e' and s[i-1] != 'E':\n                    return False\n                hasSign = True\n            elif s[i] < '0' or s[i] > '9':\n                return False\n        return True\n\n# main function\ndef main_solution(s):\n    # Convert the input string to a JSON serializable type\n    solution = Solution()\n    result = solution.isNumeric(s)\n    # Convert the result to a JSON serializable type\n    return result", "funcname": "main_solution", "ios": [{"input": {"s": "38"}, "output": true}, {"input": {"s": "257"}, "output": true}, {"input": {"s": "463"}, "output": true}, {"input": {"s": "-7.23"}, "output": true}, {"input": {"s": "6824"}, "output": true}, {"input": {"s": "+2810e-"}, "output": true}, {"input": {"s": "330060666-"}, "output": false}, {"input": {"s": "3662e8e"}, "output": false}, {"input": {"s": "77-548"}, "output": false}, {"input": {"s": "E57206"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dashayudabao/practise_jianzhioffer", "path": "/jianzhi_offer/day52\u8868\u793a\u6570\u503c\u7684\u5b57\u7b26\u4e32.py", "msgidx": 439}}
{"problem_description": "In a game, players take turns flipping two consecutive '++' to '--' in a string of characters. The player who cannot make a move loses the game. Given a string representing the current state of the game, can the player force a win?", "io_requirements": "Input:\n  `game_state` (str): A string representing the current state of the game. The string consists of characters '+' and '-'. The player can flip two consecutive '++' to '--' to make a move.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"can_win\"`, which is a boolean value indicating whether the player can force a win from the given `game_state`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    state_result = dict() # False: lose state True: victory state\n        \n    def loseState(self, s):\n        for i in range(len(s)-1):\n            if s[i:i+2] == \"++\":\n                return False\n        return True\n    \n    def canWin(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if s in Solution.state_result:\n            return Solution.state_result[s]\n        \n        if self.loseState(s):\n            Solution.state_result[s] = False\n            return False\n        \n        for i in range(len(s)-1):\n            if s[i:i+2] == \"++\" and not self.canWin(s[:i] + \"--\" + s[i+2:]):\n                Solution.state_result[s] = True\n                return True\n        Solution.state_result[s] = False\n        return False\n\n# main function\ndef main_solution(game_state):\n    # Convert the JSON serializable input to the original input variable\n    s = game_state\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the canWin method to determine if the player can win\n    result = solution.canWin(s)\n    \n    # Convert the result to a JSON serializable output\n    return {\"can_win\": result}", "funcname": "main_solution", "ios": [{"input": {"game_state": "++---+++-"}, "output": {"can_win": false}}, {"input": {"game_state": "-++--+++"}, "output": {"can_win": false}}, {"input": {"game_state": "-+--+--++"}, "output": {"can_win": true}}, {"input": {"game_state": "-++++---"}, "output": {"can_win": true}}, {"input": {"game_state": "---+--+--"}, "output": {"can_win": false}}, {"input": {"game_state": "+---+--++-"}, "output": {"can_win": true}}, {"input": {"game_state": "-++---"}, "output": {"can_win": true}}, {"input": {"game_state": "+---"}, "output": {"can_win": false}}, {"input": {"game_state": "---"}, "output": {"can_win": false}}, {"input": {"game_state": "--+--+----"}, "output": {"can_win": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "normanyahq/LeetCodeSolution", "path": "/Flip Game II/solution.py", "msgidx": 883}}
{"problem_description": "Given a set of lists represented in JSON format, how can we determine the decoder key by sorting the lists and identifying the positions of two specific divider packets? The decoder key is calculated as the product of the indices of these two divider packets after sorting.", "io_requirements": "Input:\n  `inputdata` (list of strings): A list of JSON-formatted strings representing lists. Each string should be a valid JSON representation of a list.\n\nOutput:\n  `return` (int): The decoder key, which is the product of the indices of the two divider packets after sorting the input lists.", "refcode": "# import necessary packages\nimport json\nfrom functools import cmp_to_key\n\n# all class and function definitions in the code file, if any\ndef are_lists_ordered(left, right):\n    for i, a in enumerate(left):\n        try:\n            b = right[i]\n        except IndexError:\n            return False\n        if type(a) == int and type(b) == int:\n            if a < b:\n                return True\n            if a > b:\n                return False\n        else:\n            if type(a) == int:\n                a = [a]\n            if type(b) == int:\n                b = [b]\n            inner_ordered = are_lists_ordered(a, b)\n            if inner_ordered != None:\n                return inner_ordered\n    if len(right) > len(left):\n        return True\n    return None\n\ndef sort_cmp(a, b):\n    cmp_dict = {False: -1, None: 0, True: 1}\n    return cmp_dict[are_lists_ordered(a, b)]\n\ndef import_json(inputdata: list):\n    return list(map(json.loads, inputdata))\n\n# main function\ndef main_solution(inputdata: list):\n    # Convert inputdata to a list of lists\n    pairs = import_json(inputdata)\n    \n    # Add divider packets\n    divider_packets = [[[2]], [[6]]]\n    pairs += divider_packets\n    \n    # Sort pairs\n    sorted_pairs = sorted(pairs, key=cmp_to_key(sort_cmp), reverse=True)\n    \n    # Find indices of divider packets\n    divider_indices = tuple(sorted_pairs.index(divider) + 1 for divider in divider_packets)\n    \n    # Calculate decoder key\n    decoder_key = divider_indices[0] * divider_indices[1]\n    \n    # Return the decoder key\n    return decoder_key", "funcname": "main_solution", "ios": [{"input": {"inputdata": ["[1, 8, 3, 3]", "[8, 2, 5, 3]", "[2, 1]", "[6]", "[8, 10, 10, 1]", "[6, 6, 9, 7, 7]", "[5, 10]"]}, "output": 12}, {"input": {"inputdata": ["[2, 1, 1, 7, 10]", "[4, 1]", "[1, 6, 3, 2]", "[5]"]}, "output": 12}, {"input": {"inputdata": ["[6, 9, 6, 3, 5]", "[7]", "[8, 5, 6, 4, 6]", "[6]", "[5, 4, 6, 4, 3]"]}, "output": 4}, {"input": {"inputdata": ["[3, 5]", "[8, 10, 2]", "[4, 9, 4, 4]", "[4, 2, 7, 4]", "[2, 4, 6, 8]", "[5]", "[2, 2, 6]"]}, "output": 8}, {"input": {"inputdata": ["[7, 7, 5]", "[7]"]}, "output": 2}, {"input": {"inputdata": ["[9, 6, 10, 6]", "[5]"]}, "output": 3}, {"input": {"inputdata": ["[3, 9, 3]", "[4, 7, 2, 3]", "[5, 9, 7, 1, 7]", "[3, 3]"]}, "output": 6}, {"input": {"inputdata": ["[8, 9]", "[5]", "[1, 2, 4, 9, 8]", "[6, 8, 2]", "[7, 7, 2, 5]", "[8]", "[10, 8]", "[2, 8, 3]", "[3, 2, 5, 5]"]}, "output": 12}, {"input": {"inputdata": ["[3, 9, 10, 2, 8]", "[8, 1, 3]", "[10, 4, 1]", "[1, 1, 7, 2, 1]", "[1, 5, 2, 5]", "[7, 7, 2, 7]", "[3, 9, 8]", "[5, 6, 9]", "[4, 3, 5]"]}, "output": 24}, {"input": {"inputdata": ["[5, 9, 10]", "[4]", "[2, 6, 8]", "[7, 4, 2, 2]", "[6]", "[1]", "[10, 1]", "[3, 1, 4, 4]"]}, "output": 16}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dgeoffri/adventofcode", "path": "/2022/day13b.py", "msgidx": 213}}
{"problem_description": "Given a set of disks arranged in ascending order from bottom to top on a starting position, how can you move all the disks to a target position using a temporary position, following the rules that only one disk can be moved at a time and a smaller disk can only be placed on top of a larger disk?", "io_requirements": "Input:\n  `n` (int): The number of disks to be moved.\n  `beginPlace` (str): The starting position of the disks, represented by a single character (e.g., 'A').\n  `endPlace` (str): The target position of the disks, represented by a single character (e.g., 'C').\n  `tempPlace` (str): The temporary position used for moving the disks, represented by a single character (e.g., 'B').\n\nOutput:\n  `return` (str): A JSON-formatted string containing a list of strings, each describing a move in the format \"\u4ece{beginPlace}\u79fb\u52a8\u5230{endPlace}\".", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef move(n, bp, ep, tp, result):\n    if n == 1:\n        result.append(f'\u4ece{bp}\u79fb\u52a8\u5230{ep}')\n    else:\n        move(n-1, bp, tp, ep, result)\n        result.append(f'\u4ece{bp}\u79fb\u52a8\u5230{ep}')\n        move(n-1, tp, ep, bp, result)\n\n# main function\ndef main_solution(n, beginPlace, endPlace, tempPlace):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = []\n    move(n, beginPlace, endPlace, tempPlace, result)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"n": 1, "beginPlace": "C", "endPlace": "B", "tempPlace": "A"}, "output": "[\"\\u4eceC\\u79fb\\u52a8\\u5230B\"]"}, {"input": {"n": 1, "beginPlace": "B", "endPlace": "A", "tempPlace": "C"}, "output": "[\"\\u4eceB\\u79fb\\u52a8\\u5230A\"]"}, {"input": {"n": 2, "beginPlace": "C", "endPlace": "A", "tempPlace": "B"}, "output": "[\"\\u4eceC\\u79fb\\u52a8\\u5230B\", \"\\u4eceC\\u79fb\\u52a8\\u5230A\", \"\\u4eceB\\u79fb\\u52a8\\u5230A\"]"}, {"input": {"n": 1, "beginPlace": "C", "endPlace": "A", "tempPlace": "B"}, "output": "[\"\\u4eceC\\u79fb\\u52a8\\u5230A\"]"}, {"input": {"n": 2, "beginPlace": "A", "endPlace": "B", "tempPlace": "C"}, "output": "[\"\\u4eceA\\u79fb\\u52a8\\u5230C\", \"\\u4eceA\\u79fb\\u52a8\\u5230B\", \"\\u4eceC\\u79fb\\u52a8\\u5230B\"]"}, {"input": {"n": 1, "beginPlace": "A", "endPlace": "C", "tempPlace": "B"}, "output": "[\"\\u4eceA\\u79fb\\u52a8\\u5230C\"]"}, {"input": {"n": 2, "beginPlace": "C", "endPlace": "B", "tempPlace": "A"}, "output": "[\"\\u4eceC\\u79fb\\u52a8\\u5230A\", \"\\u4eceC\\u79fb\\u52a8\\u5230B\", \"\\u4eceA\\u79fb\\u52a8\\u5230B\"]"}, {"input": {"n": 1, "beginPlace": "B", "endPlace": "C", "tempPlace": "A"}, "output": "[\"\\u4eceB\\u79fb\\u52a8\\u5230C\"]"}, {"input": {"n": 1, "beginPlace": "A", "endPlace": "B", "tempPlace": "C"}, "output": "[\"\\u4eceA\\u79fb\\u52a8\\u5230B\"]"}, {"input": {"n": 2, "beginPlace": "B", "endPlace": "A", "tempPlace": "C"}, "output": "[\"\\u4eceB\\u79fb\\u52a8\\u5230C\", \"\\u4eceB\\u79fb\\u52a8\\u5230A\", \"\\u4eceC\\u79fb\\u52a8\\u5230A\"]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "demonlittledog/pythonproject", "path": "/newpython/\u6c49\u8bfa\u5854.py", "msgidx": 848}}
{"problem_description": "Given a string consisting of lowercase letters, what are all the possible permutations of the string sorted in alphabetical order?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (str): A string containing all permutations of the input string, sorted alphabetically, with each permutation on a new line.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Generate all permutations of the input string\n    permutations = [''.join(p) for p in itertools.permutations(input_string)]\n    \n    # Sort the permutations alphabetically\n    permutations.sort()\n    \n    # Join the sorted permutations into a single string with each permutation on a new line\n    sorted_permutations = '\\n'.join(permutations)\n    \n    return sorted_permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "wxb"}, "output": "bwx\nbxw\nwbx\nwxb\nxbw\nxwb"}, {"input": {"input_string": "iob"}, "output": "bio\nboi\nibo\niob\nobi\noib"}, {"input": {"input_string": "emn"}, "output": "emn\nenm\nmen\nmne\nnem\nnme"}, {"input": {"input_string": "rdv"}, "output": "drv\ndvr\nrdv\nrvd\nvdr\nvrd"}, {"input": {"input_string": "fet"}, "output": "eft\netf\nfet\nfte\ntef\ntfe"}, {"input": {"input_string": "hrr"}, "output": "hrr\nhrr\nrhr\nrhr\nrrh\nrrh"}, {"input": {"input_string": "zvr"}, "output": "rvz\nrzv\nvrz\nvzr\nzrv\nzvr"}, {"input": {"input_string": "qvu"}, "output": "quv\nqvu\nuqv\nuvq\nvqu\nvuq"}, {"input": {"input_string": "zhw"}, "output": "hwz\nhzw\nwhz\nwzh\nzhw\nzwh"}, {"input": {"input_string": "ggs"}, "output": "ggs\nggs\ngsg\ngsg\nsgg\nsgg"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "smadha/MissionNLP", "path": "/src/nlp/as1/anagram.py", "msgidx": 747}}
{"problem_description": "Given a binary tree, determine if it is symmetric. A binary tree is symmetric if it looks the same when reflected across its center. What is the result of checking if the given binary tree is symmetric?", "io_requirements": "Input:\n  `tree_structure` (list of integers or None): A list representing the binary tree in level order traversal. Each element in the list represents the value of a node. If the value is `None`, it indicates that the node does not exist.\n\nOutput:\n  `return` (bool): `True` if the binary tree is symmetric, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef isSymmetric(root):\n    \"\"\"\n    :param root: TreeNode\n    :return: bool\n    \"\"\"\n    q = [root, ]\n    while q:\n        temp = []\n        val = []\n        while q:\n            p = q.pop()\n            if p != None:\n                temp.append(p.left)\n                temp.append(p.right)\n                if p.left:\n                    val.append(p.left.val)\n                else:\n                    val.append(None)\n                if p.right:\n                    val.append(p.right.val)\n                else:\n                    val.append(None)\n        if val[::] != val[::-1]:\n            return False\n        q = temp\n    return True\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    # Call the original function with the converted input\n    result = isSymmetric(root)\n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": []}, "output": true}, {"input": {"tree_structure": [29, null, null, null, 78, 30, 69, 5, 64]}, "output": true}, {"input": {"tree_structure": [47, null, null, 56]}, "output": true}, {"input": {"tree_structure": [64, 22, 28, 38, null, 22, 32]}, "output": false}, {"input": {"tree_structure": [17]}, "output": true}, {"input": {"tree_structure": [96, 38, 27, null]}, "output": false}, {"input": {"tree_structure": [25]}, "output": true}, {"input": {"tree_structure": [92, 66, 13, 65, 24, null, 74, 85, 98, 95]}, "output": false}, {"input": {"tree_structure": [53, null, 86, null, 59, 85, 17, 36]}, "output": false}, {"input": {"tree_structure": [93, 51, null, 14, 74, 21, 46]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Madanfeng/JianZhiOffer", "path": "/python_offer/28_\u5bf9\u79f0\u7684\u4e8c\u53c9\u6811.py", "msgidx": 789}}
{"problem_description": "A frog can jump up to `n` steps in a single leap. It can jump 1 step, 2 steps, up to `n` steps at a time. How many different ways can the frog jump exactly `n` steps?", "io_requirements": "Input:\n  `n` (int): A positive integer representing the number of steps the frog needs to jump.\n\nOutput:\n  `return` (int): The number of ways the frog can jump the `n` steps.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer if it's not already\n    n = int(n)\n    \n    # Calculate the number of ways the frog can jump using the provided logic\n    if n < 0:\n        return 0\n    else:\n        return 1 << (n - 1)  # Equivalent to 2^(n-1)", "funcname": "main_solution", "ios": [{"input": {"n": 6}, "output": 32}, {"input": {"n": 17}, "output": 65536}, {"input": {"n": 2}, "output": 2}, {"input": {"n": 9}, "output": 256}, {"input": {"n": 5}, "output": 16}, {"input": {"n": 10}, "output": 512}, {"input": {"n": 7}, "output": 64}, {"input": {"n": 18}, "output": 131072}, {"input": {"n": 14}, "output": 8192}, {"input": {"n": 12}, "output": 2048}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "xiaotao321/python_code", "path": "/code/fibonacci_frog_jump_v2.py", "msgidx": 566}}
{"problem_description": "Given a list of integers, a Binary Search Tree (BST) is constructed by inserting each integer into the tree. After constructing the BST, a specific integer value is searched within the tree. What is the result of this search operation?", "io_requirements": "Input:\n  `number_list` (list of integers): A list of integers representing the nodes to be inserted into the Binary Search Tree.\n  `search_value` (integer): The integer value to be searched in the Binary Search Tree.\n\nOutput:\n  `return` (dictionary): A dictionary with a single key \"found\" whose value is a boolean indicating whether the `search_value` was found in the Binary Search Tree.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self, number_list):\n        self.root = None\n        for node in number_list:\n            self.insert(node)\n\n    def insert(self, data):\n        n = self.root\n        if n is None:\n            self.root = Node(data)\n            return\n        else:\n            while True:\n                entry = n.data\n                if data < entry:\n                    if n.left is None:\n                        n.left = Node(data)\n                        return\n                    n = n.left\n                elif data > entry:\n                    if n.right is None:\n                        n.right = Node(data)\n                        return\n                    n = n.right\n                else:\n                    n.data = data\n                    return\n\n    def _search_bool(self, search):\n        n = self.root\n        if n is None:\n            return None\n        else:\n            lst = []\n            lst.append(n)\n            while len(lst) > 0:\n                node = lst.pop()\n                if node.data == search:\n                    return True\n                if node.left is not None:\n                    lst.append(node.left)\n                if node.right is not None:\n                    lst.append(node.right)\n            return False\n\n# main function\ndef main_solution(number_list, search_value):\n    # Convert JSON serializable inputs to original input variables\n    number_list = list(number_list)\n    search_value = int(search_value)\n\n    # Create the BST and search for the value\n    bst = BST(number_list)\n    result = bst._search_bool(search_value)\n\n    # Convert the result to JSON serializable output\n    return {\"found\": result}", "funcname": "main_solution", "ios": [{"input": {"number_list": [51, 14, 27, 94, 69, 39, 30, 56, 77, 50], "search_value": 44}, "output": {"found": false}}, {"input": {"number_list": [48, 63, 49, 10, 97, 2, 2, 79, 73, 29], "search_value": 17}, "output": {"found": false}}, {"input": {"number_list": [71, 70, 83, 57, 42, 56, 24, 47, 54, 62], "search_value": 15}, "output": {"found": false}}, {"input": {"number_list": [61, 87, 26, 9, 59, 60, 82, 67, 64, 40], "search_value": 83}, "output": {"found": false}}, {"input": {"number_list": [39, 95, 4, 53, 84, 8, 92, 39, 29, 2], "search_value": 73}, "output": {"found": false}}, {"input": {"number_list": [10, 0, 0, 8, 31, 24, 96, 7, 75, 77], "search_value": 59}, "output": {"found": false}}, {"input": {"number_list": [99, 52, 66, 86, 40, 2, 29, 90, 38, 5], "search_value": 47}, "output": {"found": false}}, {"input": {"number_list": [21, 62, 33, 17, 14, 78, 70, 71, 13, 66], "search_value": 26}, "output": {"found": false}}, {"input": {"number_list": [32, 46, 5, 15, 92, 59, 15, 83, 36, 41], "search_value": 84}, "output": {"found": false}}, {"input": {"number_list": [60, 55, 34, 30, 81, 43, 32, 3, 73, 80], "search_value": 25}, "output": {"found": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ryosuke071111/algorithms", "path": "/algorighms_&_datastructure/\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0/binary_search_tree.py", "msgidx": 108}}
{"problem_description": "Given a word, how can we determine all possible unique permutations of its letters?", "io_requirements": "Input:\n  `word` (str): A string representing the word for which permutations need to be generated. The string should not contain any spaces or special characters.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input word.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(word):\n    # Convert the input word to a list of characters\n    word_list = list(word)\n    \n    # Generate all permutations of the word\n    permutations = [''.join(p) for p in itertools.permutations(word_list)]\n    \n    # Remove duplicates by converting the list to a set and back to a list\n    unique_permutations = list(set(permutations))\n    \n    # Return the list of unique permutations\n    return unique_permutations", "funcname": "main_solution", "ios": [{"input": {"word": "wdx"}, "output": ["dxw", "xdw", "wxd", "wdx", "xwd", "dwx"]}, {"input": {"word": "nqo"}, "output": ["nqo", "oqn", "onq", "qno", "qon", "noq"]}, {"input": {"word": "qcn"}, "output": ["ncq", "qnc", "nqc", "cnq", "cqn", "qcn"]}, {"input": {"word": "hkt"}, "output": ["thk", "hkt", "kht", "kth", "htk", "tkh"]}, {"input": {"word": "kkn"}, "output": ["nkk", "kkn", "knk"]}, {"input": {"word": "lwp"}, "output": ["pwl", "wpl", "plw", "lwp", "wlp", "lpw"]}, {"input": {"word": "kfk"}, "output": ["fkk", "kfk", "kkf"]}, {"input": {"word": "hse"}, "output": ["hse", "hes", "esh", "she", "seh", "ehs"]}, {"input": {"word": "daf"}, "output": ["fad", "fda", "adf", "dfa", "daf", "afd"]}, {"input": {"word": "nmf"}, "output": ["fnm", "nfm", "fmn", "nmf", "mnf", "mfn"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sernol9/Python4Beginners", "path": "/Intro to Python/ch05/Exercise 5.10.py", "msgidx": 535}}
{"problem_description": "Santa is planning his annual journey to deliver presents to various locations. The elves have provided him with the distances between each pair of locations. Santa wants to know the shortest and longest possible routes he can take to visit each location exactly once and return to the starting point. Given the distances between the locations, what are the shortest and longest possible routes Santa can take?", "io_requirements": "Input:\n  `dist_pairs` (list of strings): A list of strings where each string represents a distance between two locations in the format \"LocationA to LocationB = Distance\".\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `min_distance` (int): The shortest distance Santa can travel to visit each location exactly once.\n    - `max_distance` (int): The longest distance Santa can travel to visit each location exactly once.", "refcode": "# import necessary packages\nfrom collections import defaultdict\nfrom itertools import permutations\n\n# main function\ndef main_solution(dist_pairs):\n    # Convert the list of distance pairs into a dictionary of distances\n    dist_dict = create_distance_dictionary(dist_pairs)\n    towns = list(dist_dict.keys())\n\n    # Initialize min and max total distances\n    min_total = float('inf')\n    max_total = 0\n\n    # Calculate the total distance for each possible route\n    for route in permutations(towns):\n        total = calculate_total_distance(route, dist_dict)\n        min_total = min(min_total, total)\n        max_total = max(max_total, total)\n\n    # Return the shortest and longest distances as a tuple\n    return {\"min_distance\": min_total, \"max_distance\": max_total}\n\n# Helper function to create a distance dictionary from distance pairs\ndef create_distance_dictionary(dist_pairs):\n    dist_dict = defaultdict(lambda: defaultdict(int))\n    for pair in dist_pairs:\n        start, _, end, _, dist = pair.split(\" \")\n        dist_dict[start][end] = int(dist)\n        dist_dict[end][start] = int(dist)\n    return dist_dict\n\n# Helper function to calculate the total distance of a route\ndef calculate_total_distance(route, dist_dict):\n    total = 0\n    for i in range(len(route) - 1):\n        total += dist_dict[route[i]][route[i + 1]]\n    return total", "funcname": "main_solution", "ios": [{"input": {"dist_pairs": ["Location0 to Location1 = 979", "Location0 to Location2 = 696", "Location0 to Location3 = 338", "Location1 to Location2 = 765", "Location1 to Location3 = 830", "Location2 to Location3 = 299"]}, "output": {"min_distance": 1402, "max_distance": 2505}}, {"input": {"dist_pairs": ["Location0 to Location1 = 431", "Location0 to Location2 = 170", "Location0 to Location3 = 596", "Location1 to Location2 = 945", "Location1 to Location3 = 780", "Location2 to Location3 = 954"]}, "output": {"min_distance": 1381, "max_distance": 2495}}, {"input": {"dist_pairs": ["Location0 to Location1 = 137", "Location0 to Location2 = 692", "Location0 to Location3 = 995", "Location1 to Location2 = 859", "Location1 to Location3 = 284", "Location2 to Location3 = 961"]}, "output": {"min_distance": 1113, "max_distance": 2815}}, {"input": {"dist_pairs": ["Location0 to Location1 = 104", "Location0 to Location2 = 830", "Location0 to Location3 = 213", "Location1 to Location2 = 423", "Location1 to Location3 = 451", "Location2 to Location3 = 704"]}, "output": {"min_distance": 740, "max_distance": 1985}}, {"input": {"dist_pairs": ["Location0 to Location1 = 714", "Location0 to Location2 = 420", "Location0 to Location3 = 591", "Location1 to Location2 = 238", "Location1 to Location3 = 479", "Location2 to Location3 = 648"]}, "output": {"min_distance": 1137, "max_distance": 1953}}, {"input": {"dist_pairs": ["Location0 to Location1 = 447", "Location0 to Location2 = 387", "Location1 to Location2 = 839"]}, "output": {"min_distance": 834, "max_distance": 1286}}, {"input": {"dist_pairs": ["Location0 to Location1 = 210", "Location0 to Location2 = 540", "Location0 to Location3 = 136", "Location1 to Location2 = 945", "Location1 to Location3 = 502", "Location2 to Location3 = 371"]}, "output": {"min_distance": 717, "max_distance": 1987}}, {"input": {"dist_pairs": ["Location0 to Location1 = 383", "Location0 to Location2 = 256", "Location0 to Location3 = 169", "Location1 to Location2 = 310", "Location1 to Location3 = 976", "Location2 to Location3 = 540"]}, "output": {"min_distance": 735, "max_distance": 1899}}, {"input": {"dist_pairs": ["Location0 to Location1 = 498", "Location0 to Location2 = 908", "Location1 to Location2 = 491"]}, "output": {"min_distance": 989, "max_distance": 1406}}, {"input": {"dist_pairs": ["Location0 to Location1 = 153", "Location0 to Location2 = 398", "Location0 to Location3 = 788", "Location1 to Location2 = 712", "Location1 to Location3 = 800", "Location2 to Location3 = 514"]}, "output": {"min_distance": 1065, "max_distance": 2300}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JohannSaratka/AdventOfCode", "path": "/AoC_2015/Day09/solution.py", "msgidx": 471}}
{"problem_description": "In a game where you flip two coins, A and B, 100 times, and you can choose which coin to flip each time, what is the probability of finishing with a positive total score if you optimize your strategy? Coin A has a probability `p1` of coming up heads, and coin B is fair with a probability of 0.5.", "io_requirements": "Input:\n  `p1` (float): The probability of coin A coming up heads. It should be a value between 0 and 1.\n  `p2` (float): The probability of coin B coming up heads. It should be a value between 0 and 1.\n  `flips` (int): The total number of flips to be made. It should be a positive integer.\nOutput:\n  `return` (float): The probability of winning the game with the optimal strategy, given the probabilities of the coins and the number of flips. It is a value between 0 and 1.", "refcode": "# import necessary packages\nimport sys\nfrom functools import lru_cache\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n@lru_cache(maxsize=40000)\ndef opt_strat(current_score, coins_remaining, p1=0.5, p2=0.5):\n    if -1 * current_score >= 2 * coins_remaining:\n        return 0\n    if current_score > coins_remaining:\n        return 1\n    return max([p1 * opt_strat(current_score + 1, coins_remaining - 1, p1, p2) +\n                (1 - p1) * opt_strat(current_score - 1, coins_remaining - 1, p1, p2),\n                p2 * opt_strat(current_score + 2, coins_remaining - 1, p1, p2) +\n                (1 - p2) * opt_strat(current_score - 2, coins_remaining - 1, p1, p2)])\n\n# main function\ndef main_solution(p1, p2, flips):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = opt_strat(0, flips, p1, p2)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"p1": 0.45, "p2": 0.5, "flips": 121}, "output": 0.5589099023195271}, {"input": {"p1": 0.21, "p2": 0.5, "flips": 65}, "output": 0.5172171000127564}, {"input": {"p1": 0.14, "p2": 0.5, "flips": 93}, "output": 0.5139257603069409}, {"input": {"p1": 0.33, "p2": 0.5, "flips": 76}, "output": 0.5234832535359224}, {"input": {"p1": 0.16, "p2": 0.5, "flips": 74}, "output": 0.5116498368967826}, {"input": {"p1": 0.54, "p2": 0.5, "flips": 55}, "output": 0.7761107896844532}, {"input": {"p1": 0.27, "p2": 0.5, "flips": 76}, "output": 0.5169161135533767}, {"input": {"p1": 0.59, "p2": 0.5, "flips": 146}, "output": 0.9869734190559041}, {"input": {"p1": 0.17, "p2": 0.5, "flips": 145}, "output": 0.5114483855122625}, {"input": {"p1": 0.4, "p2": 0.5, "flips": 111}, "output": 0.534864515351103}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bphillab/Five_Thirty_Eight_Riddler", "path": "/Riddler_20_02_21/Riddler_Classic_20_02_21.py", "msgidx": 619}}
{"problem_description": "Given a string consisting of alphanumeric characters, what are all the possible unique arrangements of the characters in the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should contain only alphanumeric characters and should not be empty.\n\nOutput:\n  `return` (list of str): A list of all possible permutations of the input string. Each permutation is a string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Generate all permutations of the input string\n    permutations = [''.join(p) for p in itertools.permutations(input_string)]\n    \n    # Return the list of permutations\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "jJk"}, "output": ["jJk", "jkJ", "Jjk", "Jkj", "kjJ", "kJj"]}, {"input": {"input_string": "MYw"}, "output": ["MYw", "MwY", "YMw", "YwM", "wMY", "wYM"]}, {"input": {"input_string": "Wv3"}, "output": ["Wv3", "W3v", "vW3", "v3W", "3Wv", "3vW"]}, {"input": {"input_string": "Ley"}, "output": ["Ley", "Lye", "eLy", "eyL", "yLe", "yeL"]}, {"input": {"input_string": "vbF"}, "output": ["vbF", "vFb", "bvF", "bFv", "Fvb", "Fbv"]}, {"input": {"input_string": "ydN"}, "output": ["ydN", "yNd", "dyN", "dNy", "Nyd", "Ndy"]}, {"input": {"input_string": "vhV"}, "output": ["vhV", "vVh", "hvV", "hVv", "Vvh", "Vhv"]}, {"input": {"input_string": "VsQ"}, "output": ["VsQ", "VQs", "sVQ", "sQV", "QVs", "QsV"]}, {"input": {"input_string": "rLh"}, "output": ["rLh", "rhL", "Lrh", "Lhr", "hrL", "hLr"]}, {"input": {"input_string": "1xR"}, "output": ["1xR", "1Rx", "x1R", "xR1", "R1x", "Rx1"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vegito11/Data_Structure", "path": "/Data-Structure-Algorithm-Python3/07-Recurrsion/05-string-all-permuation.py", "msgidx": 296}}
{"problem_description": "In a repeated game of Prisoner's Dilemma, two players take turns choosing between cooperation and defection. Each player has a strategy that involves cooperating for the first 5 rounds, defecting for the next 5 rounds, and then deciding based on the average scores of these two phases whether to continue cooperating or defecting. Given the order of a player and the history of actions taken by both players in the first 10 rounds, what action will the player take in the 11th round?", "io_requirements": "Input:\n  `order` (int): The order of the player (0 or 1).\n  `history` (list of lists): A 2x10 list representing the history of actions taken by both players in the first 10 rounds. Each sublist contains 10 integers (0 or 1) representing the actions (0 for defect, 1 for cooperate).\n\nOutput:\n  `return` (int): The action to be taken by the player in the 11th round (0 for defect, 1 for cooperate).", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass CheckAndChoose:\n    \"\"\" CheckAndChoose will cooperate 5 times, defect 5 times, then choose which had the best average score. \"\"\"\n\n    def step(self, history, round):\n        if round < 5:\n            action = 1  # Cooperate\n        elif round < 10:\n            action = 0  # Defect\n        elif round == 10:\n            outcome = [[[1, 1], [5, 0]], [[0, 5], [3, 3]]]\n            c_score = 0\n            d_score = 0\n            for i in range(0, 10):\n                if i < 5:\n                    score = outcome[history[0][i]][history[1][i]]\n                    c_score += score[self.order]\n\n                else:\n                    score = outcome[history[0][i]][history[1][i]]\n                    d_score += score[self.order]\n            if c_score > d_score:\n                action = 1\n            else:\n                action = 0\n\n        else:\n            action = history[self.order][round - 1]\n\n        return action\n\n# main function\ndef main_solution(order, history):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert JSON serializable inputs to the original input variables\n    order = int(order)\n    history = np.array(history)\n\n    # Initialize the CheckAndChoose class\n    check_and_choose = CheckAndChoose()\n    check_and_choose.order = order\n\n    # Determine the action for the 11th round\n    action = check_and_choose.step(history, 10)\n\n    # Convert the output to JSON serializable format\n    action = int(action)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return action", "funcname": "main_solution", "ios": [{"input": {"order": 0, "history": [[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 0]]}, "output": 0}, {"input": {"order": 1, "history": [[1, 1, 1, 1, 1, 1, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 0]]}, "output": 1}, {"input": {"order": 0, "history": [[1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0]]}, "output": 0}, {"input": {"order": 0, "history": [[0, 1, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 1, 1]]}, "output": 0}, {"input": {"order": 1, "history": [[1, 0, 1, 0, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]]}, "output": 0}, {"input": {"order": 1, "history": [[1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 0, 0]]}, "output": 1}, {"input": {"order": 1, "history": [[0, 0, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 1, 1]]}, "output": 0}, {"input": {"order": 1, "history": [[1, 1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]]}, "output": 0}, {"input": {"order": 0, "history": [[0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0]]}, "output": 1}, {"input": {"order": 0, "history": [[1, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0, 1]]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bgoonz/UsefulResourceRepo2.0", "path": "/_RESOURCES/awesome-git-user/ThinkComplexity2/code/IPD_Tournament/CheckAndChoose.py", "msgidx": 851}}
{"problem_description": "Given a list of IP addresses, each containing sequences both inside and outside square brackets, determine how many of these IP addresses support SSL (Super-Secret Listening). An IP supports SSL if it has an ABA (Area-Broadcast Accessor) sequence outside any square bracketed sections and a corresponding BAB (Byte Allocation Block) sequence inside the square bracketed sections. An ABA is any three-character sequence where the first and third characters are the same, and the second character is different. A corresponding BAB is the same characters but in reversed positions. How many IPs in the provided list support SSL?", "io_requirements": "Input:\n  `ip_addresses` (list of strings): A list of IP addresses, where each IP address is a string. Each string may contain square brackets `[]` to denote hypernet sequences.\n\nOutput:\n  `return` (int): The number of IP addresses that support SSL (Super-Secret Listening).", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef get_abas(string):\n    abas = []\n    for i in range(len(string) - 2):\n        if string[i] != string[i + 1] and string[i] == string[i + 2]:\n            abas.append(string[i] + string[i + 1] + string[i + 2])\n    return abas\n\ndef reverse_aba(string):\n    return string[1] + string[0] + string[1]\n\n# main function\ndef main_solution(ip_addresses):\n    count = 0\n    for line in ip_addresses:\n        groups = re.split(\"[\\[\\]]\", line)\n\n        supernet_sequences = []\n        hypernet_sequences = []\n        aba_list = []\n        bab_list = []\n\n        is_supernet = True\n        for group in groups:\n            abas = get_abas(group)\n            if is_supernet:\n                supernet_sequences.append(group)\n                aba_list.extend(abas)\n            else:\n                hypernet_sequences.append(group)\n                bab_list.extend(abas)\n            is_supernet = not is_supernet\n\n        aba_to_bab_list = list(map(reverse_aba, aba_list))\n\n        aba_bab_intersect = [val for val in aba_to_bab_list if val in bab_list]\n\n        if len(aba_bab_intersect) > 0:\n            count += 1\n\n    return count", "funcname": "main_solution", "ios": [{"input": {"ip_addresses": ["xso[epvggg]mfo[kpm]", "zbahkxhm", "xslwgi[eakc]", "uxrxledgjquuhrb", "xegy[oyzcjs]", "ajzojilp[ecees]rkslzdtgffk[nay]", "saniidxhwdf[cxzav]", "btsnld[kaes]xwkm[hjx]"]}, "output": 0}, {"input": {"ip_addresses": ["ahuyfdmbz", "twh[fxtibn]vszyjdnmidccakqknf", "xbayyldkyehoakcvu", "mgohponkcf[hivcs]nxehb[rvloui]", "tiqzwl[rluzr]", "ntaebfdgsi[waivx]idgbcuzpivrw[dqtnp]"]}, "output": 0}, {"input": {"ip_addresses": ["crngp[jqt]rtip[ggs]ggvqmsnk", "uaduehxgsabodri", "jhheuljtmuhifsoaz[xbcwur]udr", "sbqjvhufr[tkbk]", "temdv[arcnhx]rriuycopnhwzyjssla[vkxwst]", "xbaxcgrw[stcyt]", "hhzzlbjskgz[qprl]uik"]}, "output": 0}, {"input": {"ip_addresses": ["dmtm[dadc]hmzp[axyui]", "rkehu[oncxpa]pdcqdr[udb]", "hrjjjc", "zomh", "iktabt[mwofyk]ojrssg[jnfovk]zhftkdpgkwblt[pth]", "tvfggstedpzksh", "qrvj", "qqdka[wqkrd]gdm[mujyq]"]}, "output": 0}, {"input": {"ip_addresses": ["jqts[jbfumq]", "ovhvnoc[ftqjwo]mykunrvygh[nzeqt]dgkfne", "kbtl[rbzeib]", "ptlgmpymvvdrhd[zzap]gid", "hmbhdxkaxvjeg[uswh]mwnvlcbxa", "jen"]}, "output": 0}, {"input": {"ip_addresses": ["ugp[qkbwhz]bgqkvscwver", "oygce[nfzzqr]axqwy", "ytchzfrlq[xtzuj]", "okelt[tsobbe]", "ieuju[hwtgx]moovpgsol[uup]wzxdfnzxr", "ahpokzoosf"]}, "output": 0}, {"input": {"ip_addresses": ["cor[kxbgf]ydqbsckdunpiok[kxhy]", "pqqodvesmi[uan]phgyfjetqqtwn[dtapmf]", "kwdmemobyxfujy[vucrcy]tffp[tpemtq]", "lgte", "xglkizdzuju[tpsavm]nuwuktidly"]}, "output": 0}, {"input": {"ip_addresses": ["myatgsxpbge[kxvjej]pjsmvc[djtzoy]ayark[opag]", "themdl[ikrthg]jyhouthasve", "bhqen", "bvqqjsgfpo[pjx]xfukd[xxrp]bft[tck]", "rdtfytqasumcvrmbw[cafm]avzlu", "mijoo[klibwl]"]}, "output": 0}, {"input": {"ip_addresses": ["miet[nkk]bltdqg", "ssqs[nvoc]dtkwmdamodt", "sqmme[yeml]vimpl[tafz]sqji[fidnq]frmccv", "rxej[unm]weedyghnwsjupqjd[jnjt]lhtwha[ueumt]", "bhdswb[rbef]ljufqrn", "xarmqd", "hunbuzmxmc[dupjtb]esofzcspasnodncsn[qgmkch]"]}, "output": 0}, {"input": {"ip_addresses": ["ckpvevzn[ttkh]fyvd[ioghi]zvycvbs", "vjjitq[edk]epytnmimkum[eit]mxmm[tcp]", "yvhioh[pldi]kgkzo[klq]bvu[ncsph]", "phevqeziiiqx[jfgh]", "wdmurrlyv[zed]mikqwllv", "wtz"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mangei/adventofcode2016", "path": "/07_2.py", "msgidx": 651}}
{"problem_description": "Given a predefined tree structure, what is the lowest common ancestor of two randomly selected nodes `node1` and `node2`?", "io_requirements": "Input:\n  `node1` (int): The first node for which to find the lowest common ancestor.\n  `node2` (int): The second node for which to find the lowest common ancestor.\n\nOutput:\n  `return` (int): The lowest common ancestor of `node1` and `node2` in the predefined tree structure.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef find_all_descendants(tree, r, x):\n    \"\"\"\n    r is a single edglist.  the key is the node parent\n    \"\"\"\n    if r == x:\n        return [r]\n\n    if r not in tree:\n        return None\n    else:\n        all_desc1 = find_all_descendants(tree, tree[r][0], x)\n\n        if all_desc1 is not None:\n            return [r] + all_desc1\n\n        all_desc2 = find_all_descendants(tree, tree[r][1], x)\n        if all_desc2 is not None:\n            return [r] + all_desc2\n\ndef lowest_ancestor(tree, a, b):\n    a_d = find_all_descendants(tree, 30, a)[0:-1]\n    b_d = find_all_descendants(tree, 30, b)[0:-1]\n\n    score = defaultdict(int)\n    for pos, a in enumerate(a_d):\n        score[a] += pos\n    for pos, a in enumerate(b_d):\n        score[a] += pos\n\n    common = set(a_d) & set(b_d)\n\n    final_item = None\n    max_score = 0\n    for item, score in score.items():\n        if item in common and score >= max_score:\n            max_score = score\n            final_item = item\n\n    return final_item\n\ndef buildtree():\n    \"\"\"\n    Create edge lists.  First entry is root.\n    :return:\n    \"\"\"\n    tree = {30: (8, 52),\n            8: (3, 20),\n            20: (10, 29)}\n\n    return tree\n\n# main function\ndef main_solution(node1, node2):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    tree = buildtree()\n    result = lowest_ancestor(tree, node1, node2)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"node1": 52, "node2": 20}, "output": 30}, {"input": {"node1": 10, "node2": 8}, "output": 30}, {"input": {"node1": 29, "node2": 52}, "output": 30}, {"input": {"node1": 20, "node2": 29}, "output": 8}, {"input": {"node1": 29, "node2": 29}, "output": 20}, {"input": {"node1": 3, "node2": 10}, "output": 8}, {"input": {"node1": 29, "node2": 3}, "output": 8}, {"input": {"node1": 52, "node2": 29}, "output": 30}, {"input": {"node1": 20, "node2": 20}, "output": 8}, {"input": {"node1": 8, "node2": 3}, "output": 30}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jsrawan-mobo/samples", "path": "/python/ce/ancestor.py", "msgidx": 737}}
{"problem_description": "Given a string that contains characters and numbers, where numbers indicate how many times the preceding character or group of characters should be repeated, and nested parentheses to indicate nested repetitions, what is the decoded string after expanding all the repetitions?", "io_requirements": "Input:\n  `encoded_string` (str): A string that may contain characters and numbers, where numbers indicate how many times the preceding character or group of characters should be repeated. The string may also contain nested parentheses to indicate nested repetitions.\n\nOutput:\n  `return` (str): The decoded string where all the repetitions specified by the numbers in the input string have been expanded.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef unpack(str):\n    result = \"\"\n    num = \"\"\n    i = 0\n\n    while i < len(str):\n        if str[i] == \"(\":\n            if num != \"\":\n                result = result[:-1] + result[-1:] * int(num)\n                num = \"\"\n\n            str = result + unpack(str[i+1:])\n            i -= 1\n        elif str[i] == \")\":\n            if num != \"\":\n                result = result[:-1] + result[-1:] * int(num)\n                num = \"\"\n\n            for char in str[i+1:]:\n                if char in \"0123456789\":\n                    num += char\n                else:\n                    break\n\n            if num != \"\":\n                return result * int(num) + str[i+len(num)+1:]\n            else:\n                return result + str[i+1:]\n\n        elif str[i] in \"0123456789\":\n            num += str[i]\n        else:\n            if num != \"\":\n                result = result[:-1] + result[-1:] * int(num)\n                num = \"\"\n\n            result += str[i]\n\n        i += 1\n\n    if num != \"\":\n        return result[:-1] + result[-1:] * int(num)\n    else:\n        return result\n\n# main function\ndef main_solution(encoded_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    decoded_string = unpack(encoded_string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return decoded_string", "funcname": "main_solution", "ios": [{"input": {"encoded_string": "G(Y4)c(V5)R5w(g1)k1"}, "output": "GYYYYcVVVVVRRRRRwRRwgk"}, {"input": {"encoded_string": "h(p1)"}, "output": "hp"}, {"input": {"encoded_string": "n(e5)G5L(W4)l5x(i5)"}, "output": "neeeeeGGGGGLGGLWWWWlllllxlllllxiiiii"}, {"input": {"encoded_string": "w(c5)R(b2)V(j5)S3"}, "output": "wcccccRbbVjjjjjSSS"}, {"input": {"encoded_string": "c3M3v2b3"}, "output": "cccMMMvvbbb"}, {"input": {"encoded_string": "a4z(t1)V2t(k4)"}, "output": "aaaazaztVVtVtkkkk"}, {"input": {"encoded_string": "x(m1)l1t(U4)c(Y1)"}, "output": "xmltUUUc"}, {"input": {"encoded_string": "S(A2)P(H5)f(f5)V(H1)"}, "output": "SAAPHHHHHffffffVH"}, {"input": {"encoded_string": "X(Y1)H5a(j5)f2"}, "output": "XYHHHHHaHHajjjjjff"}, {"input": {"encoded_string": "N(m3)n2p(d5)"}, "output": "Nmmmnnpddddd"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "andres-halls/IAPB13_suvendatud", "path": "/Kodutoo_3/Kodutoo_3_Andres.py", "msgidx": 144}}
{"problem_description": "In a 2D grid, certain cells are marked as \"0\" and others as \"1\". A group of connected \"0\" cells forms an island. Given a grid and a threshold number, what are the islands that have fewer cells than the threshold number?", "io_requirements": "Input:\n  `board` (list of lists of integers): A 2D grid representing the board where each element is either 0 or 1.\n  `number` (integer): The threshold number for the size of islands. Islands smaller than this number will be returned.\n\nOutput:\n  `return` (list of lists of integers or boolean): A list of islands (each represented as a list of coordinates [row, col]) that are smaller than the given `number`. If no such islands exist, returns `False`.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(board, number):\n    # Convert the board to a numpy array if it's not already\n    if not isinstance(board, np.ndarray):\n        board = np.array(board)\n    \n    zero = np.argwhere(board == 0)\n    zero_list = zero.tolist()\n    zero_list_sorted = sorted(zero_list, key=lambda x: x[0])\n    (X, Y) = np.shape(board)\n    neighbors = lambda x, y: [[x2, y2] for x2 in range(x - 1, x + 2)\n                              for y2 in range(y - 1, y + 2)\n                              if (-1 < x <= X and\n                                  -1 < y <= Y and\n                                  (x != x2 or y != y2) and\n                                  (0 <= x2 <= X) and\n                                  (0 <= y2 <= Y))]\n    island = []\n    un_assigned = zero_list_sorted.copy()\n    while len(un_assigned) != 0:\n        element = un_assigned[0]\n        new_island = [element]\n        indicator = 1\n        element_list = [element]\n        un_assigned.remove(element)\n        while indicator != 0:\n            previous_indicator = indicator\n            indicator = 0\n            new_list = []\n            for k in range(previous_indicator):\n                element = element_list[-k]\n                element_neighbor = neighbors(element[0], element[1])\n                for i in range(len(un_assigned)):\n                    if un_assigned[i] in element_neighbor:\n                        new_island.append(un_assigned[i])\n                        indicator += 1\n                    new_list = new_island[-indicator:]\n                for i in new_list:\n                    if i in un_assigned:\n                        un_assigned.remove(i)\n            element_list = new_list\n        island.append(new_island)\n    island_size = []\n    for i in island:\n        island_size.append(len(i))\n    output = []\n    for i in range(len(island_size)):\n        if island_size[i] < number:\n            output.append(island[i])\n    if len(output) != 0:\n        return output\n    else:\n        return False", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 1]], "number": 4}, "output": false}, {"input": {"board": [[0, 1, 0, 1], [0, 1, 1, 0], [1, 0, 1, 0], [0, 0, 0, 1]], "number": 1}, "output": false}, {"input": {"board": [[1, 1, 1], [0, 0, 0], [1, 0, 0]], "number": 2}, "output": false}, {"input": {"board": [[0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [0, 1, 1, 0]], "number": 2}, "output": false}, {"input": {"board": [[1, 0, 0, 0], [0, 0, 1, 1], [1, 0, 1, 0], [1, 1, 0, 0]], "number": 1}, "output": false}, {"input": {"board": [[0, 0, 1], [0, 1, 1], [1, 0, 1]], "number": 3}, "output": false}, {"input": {"board": [[0, 0, 0], [1, 0, 1], [0, 1, 0]], "number": 5}, "output": false}, {"input": {"board": [[0, 0, 0], [0, 0, 0], [0, 1, 0]], "number": 3}, "output": false}, {"input": {"board": [[0, 1, 1, 0], [1, 0, 0, 1], [1, 1, 1, 1], [1, 1, 1, 0]], "number": 5}, "output": [[[0, 0], [1, 1], [1, 2], [0, 3]], [[3, 3]]]}, {"input": {"board": [[0, 0, 1], [0, 0, 1], [0, 0, 1]], "number": 2}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "HiNoHoshi/mp2", "path": "/mp2-code/island_check.py", "msgidx": 825}}
{"problem_description": "Given a set of 0 to 9 pandigital numbers, which are numbers that contain each digit from 0 to 9 exactly once, what is the sum of all such numbers that satisfy the following divisibility property: each number formed by the 2nd, 3rd, and 4th digits is divisible by 2, each number formed by the 3rd, 4th, and 5th digits is divisible by 3, and so on, up to the number formed by the 8th, 9th, and 10th digits being divisible by 17?", "io_requirements": "Input:\n  No input arguments are required.\n\nOutput:\n  `return` (int): The sum of all 0 to 9 pandigital numbers that satisfy the divisibility property.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution():\n    # Generate all 0 to 9 pandigital numbers\n    perms = itertools.permutations(\"0123456789\")\n    perms = [''.join(perm) for perm in perms]\n    perms = list(map(int, perms))\n    \n    # Check divisibility property and sum the valid numbers\n    def has_divisibility_property(n):\n        str_n = str(n)\n        sub_ints = [int(str_n[i:i+3]) for i in range(1, 8)]\n        div_vals = [2, 3, 5, 7, 11, 13, 17]\n        return all([(not sub_int % val) for sub_int, val in zip(sub_ints, div_vals)])\n    \n    total = sum([n for n in perms if has_divisibility_property(n)])\n    \n    # Return the sum of all valid pandigital numbers\n    return total", "funcname": "main_solution", "ios": [{"input": {}, "output": 16695334890}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "apethani21/project-euler", "path": "/solutions/p43.py", "msgidx": 218}}
{"problem_description": "In the context of Conway's Game of Life, given an initial state of a game board, what will be the state of the board after one iteration of the game rules? The rules are as follows:\n1. Any live cell with fewer than two live neighbors dies (underpopulation).\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies (overpopulation).\n4. Any dead cell with exactly three live neighbors becomes a live cell (reproduction).\n\nThe initial state of the board is represented by a 2D list where each element is either 0 (dead cell) or 1 (live cell). What will be the state of the board after applying these rules?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the initial state of the game board. Each element in the list is either 0 (dead cell) or 1 (live cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the next state of the game board after applying the rules of Conway's Game of Life. Each element in the list is either 0 (dead cell) or 1 (live cell).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def n_neighbors(self, board, m, n):\n        count = 0\n        rows = len(board)\n        cols = len(board[0])\n        new_row = 0\n        new_col = 0\n        direction_array = [(1,-1), (1,0), (-1,-1), (-1,0),(-1,1),(0,-1),(0,1),(1,1)]\n\n        for dirs in direction_array:\n            new_row = (m + dirs[0])\n            new_col = (n + dirs[1])\n            if (new_row >= 0 and new_row < rows and  new_col >= 0 and new_col < cols ) and (board[new_row][new_col] == 1 or board[new_row][new_col] == 2):\n                count += 1\n        return count\n \n    def gameOfLife(self, board: List[List[int]]) -> List[List[int]]:\n        if not board or len(board) == 0:\n            return board\n\n        rows = len(board)\n        cols = len(board[0])\n        \n        for i in range(rows):\n            for j in range(cols):\n                lives = self.n_neighbors(board, i, j)\n                \n                # Rule 1 and Rule 3\n                if board[i][j] == 1 and (lives < 2 or lives > 3):\n                    board[i][j] = 2  # -1 signifies the cell is now dead but originally was live.\n                if board[i][j] == 0 and lives == 3:\n                    board[i][j] = 3  # signifies the cell is now live but was originally dead.\n\n        for i in range(rows):\n            for j in range(cols):\n                board[i][j] = board[i][j] % 2\n        return board\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # Convert input to the required format\n    solution = Solution()\n    # Call the gameOfLife method and return the result\n    result = solution.gameOfLife(board)\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0]]}, "output": [[0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0]]}, {"input": {"board": [[0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 0]]}, "output": [[0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 0]]}, {"input": {"board": [[0, 1, 1, 1], [0, 0, 0, 0], [0, 0, 1, 1], [0, 0, 1, 0], [0, 0, 0, 0]]}, "output": [[0, 1, 1, 1], [0, 0, 0, 0], [0, 0, 1, 1], [0, 0, 1, 0], [0, 0, 0, 0]]}, {"input": {"board": [[0, 1, 0, 0], [1, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 0], [0, 1, 1, 1]]}, "output": [[0, 1, 0, 0], [1, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 0], [0, 1, 1, 1]]}, {"input": {"board": [[0, 1, 0], [1, 1, 1], [0, 0, 0], [0, 1, 1]]}, "output": [[0, 1, 0], [1, 1, 1], [0, 0, 0], [0, 1, 1]]}, {"input": {"board": [[0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]}, "output": [[0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0]]}, {"input": {"board": [[1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 0]]}, "output": [[1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 0]]}, {"input": {"board": [[0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, "output": [[0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": {"board": [[0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0]]}, "output": [[0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0]]}, {"input": {"board": [[1, 0, 0, 1], [0, 0, 0, 1], [1, 0, 0, 1], [0, 0, 0, 0]]}, "output": [[1, 0, 0, 1], [0, 0, 0, 1], [1, 0, 0, 1], [0, 0, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Karan1914/Array-2", "path": "/Problem3.py", "msgidx": 131}}
{"problem_description": "Given a binary tree, determine if it is symmetrical. A tree is symmetrical if it is a mirror of itself (i.e., symmetric around its center). What is the result of checking whether the given binary tree is symmetrical?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the binary tree structure. Each key-value pair represents a node in the tree. The keys are:\n    - `val` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another tree structure dictionary. If there is no left child, this should be `None`.\n    - `right` (dict or None): The right child of the node, represented as another tree structure dictionary. If there is no right child, this should be `None`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        if pRoot is None:\n            return True\n        root = TreeNode(pRoot.val)\n        self.mirror(pRoot, root)\n        return self.same_tree(pRoot, root)\n        \n    def mirror(self, pRoot, root):\n        if pRoot is None:\n            return\n        if pRoot.left is not None:\n            root.right = TreeNode(pRoot.left.val)\n        if pRoot.right is not None:\n            root.left = TreeNode(pRoot.right.val)\n        \n        self.mirror(pRoot.left, root.right)\n        self.mirror(pRoot.right, root.left)\n    \n    def same_tree(self, pRoot, pRootm):\n        if pRoot is None and pRootm is None:\n            return True\n        elif pRoot is None or pRootm is None:\n            return False\n        if pRoot.val != pRootm.val:\n            return False\n        \n        left = self.same_tree(pRoot.left, pRootm.left)\n        right = self.same_tree(pRoot.right, pRootm.right)\n        \n        return left and right\n\n# main function\ndef main_solution(tree_structure):\n    # Convert JSON serializable input to TreeNode structure\n    def build_tree(node_dict):\n        if not node_dict:\n            return None\n        root = TreeNode(node_dict['val'])\n        root.left = build_tree(node_dict['left'])\n        root.right = build_tree(node_dict['right'])\n        return root\n    \n    pRoot = build_tree(tree_structure)\n    \n    # Invoke the solution function\n    solution = Solution()\n    result = solution.isSymmetrical(pRoot)\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 62, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 52, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 35, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 21, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 96, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 75, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 93, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 72, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 86, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 44, "left": null, "right": null}}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RellRex/Sword-for-offer-with-python-2.7", "path": "/test58_\u5bf9\u79f0\u4e8c\u53c9\u6811.py", "msgidx": 172}}
{"problem_description": "Given a set of integers, how many valid partitions can be formed such that each partition contains all the elements of the original set?", "io_requirements": "Input:\n  `input_set` (list of integers): A list of integers representing the set for which we want to calculate the Bell number.\n\nOutput:\n  `return` (integer): The number of valid partitions of the input set.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef bell_number(setn, lst, prev):\n    if len(setn) <= 2:\n        return\n\n    tmp = list(setn)\n    for i in range(len(tmp)):\n        t = tmp[i]\n        l1 = [t]\n        l2 = tmp[0:i] + tmp[i+1:len(tmp)]\n\n        tup = None\n        if prev:\n            tup = (prev, l1, l2)\n        else:\n            tup = (l1, l2)\n\n        lst.append(tup)\n        bell_number(set(l2), lst, l1)\n\n# main function\ndef main_solution(input_set):\n    # Convert input_set to a set\n    s = set(input_set)\n    \n    # Initialize the list to store the partitions\n    lst = []\n    lst.append(set(s))\n    \n    # Call the bell_number function to generate partitions\n    bell_number(s, lst, None)\n    \n    # Count the number of valid partitions\n    c = 0\n    for t in lst:\n        tmp = []\n        for x in t:\n            if isinstance(x, list):\n                for y in x:\n                    tmp.append(y)\n            else:\n                tmp.append(x)\n\n        b = False\n        for i in s:\n            if i not in tmp:\n                b = True\n\n        if not b:\n            c += 1\n    \n    # Return the count of valid partitions\n    return c", "funcname": "main_solution", "ios": [{"input": {"input_set": [5, 8, 2, 4]}, "output": 17}, {"input": {"input_set": [7, 9, 8, 5]}, "output": 17}, {"input": {"input_set": [3, 8, 6]}, "output": 4}, {"input": {"input_set": [3, 9, 4, 2, 8]}, "output": 26}, {"input": {"input_set": [7, 5, 2, 3]}, "output": 17}, {"input": {"input_set": [2, 7, 6, 9]}, "output": 17}, {"input": {"input_set": [5, 6, 4, 8]}, "output": 17}, {"input": {"input_set": [1, 8, 6]}, "output": 4}, {"input": {"input_set": [4, 8, 6]}, "output": 4}, {"input": {"input_set": [6, 4, 3]}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bits2018wilp/python-lab", "path": "/src/main/prep/bell_number.py", "msgidx": 325}}
{"problem_description": "Given a classic puzzle known as the Tower of Hanoi, where you have three rods (A, B, and C) and a number of disks of different sizes that can slide onto any rod, the objective is to move the entire stack of disks from rod A to rod C, following these rules:\n1. Only one disk can be moved at a time.\n2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.\n3. No disk may be placed on top of a smaller disk.\n\nWhat is the sequence of moves required to solve the Tower of Hanoi puzzle for a given number of disks (n) using rods A, B, and C?", "io_requirements": "Input:\n  `n` (int): The number of disks to be moved.\n  `a` (str): The name of the source rod.\n  `b` (str): The name of the auxiliary rod.\n  `c` (str): The name of the target rod.\n\nOutput:\n  `return` (str): A JSON-serialized list of strings, where each string represents a move in the format \"source --> target\".", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef move(n, a, b, c, result):\n    if n == 1:\n        result.append(f\"{a} --> {c}\")\n    else:\n        move(n-1, a, c, b, result)  # \u5b50\u76ee\u68071\n        move(1, a, b, c, result)    # \u5b50\u76ee\u68072\n        move(n-1, b, a, c, result)  # \u5b50\u76ee\u68073\n\n# main function\ndef main_solution(n, a, b, c):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = []\n    move(n, a, b, c, result)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"n": 2, "a": "A", "b": "B", "c": "C"}, "output": "[\"A --> B\", \"A --> C\", \"B --> C\"]"}, {"input": {"n": 1, "a": "A", "b": "B", "c": "C"}, "output": "[\"A --> C\"]"}, {"input": {"n": 3, "a": "A", "b": "B", "c": "C"}, "output": "[\"A --> C\", \"A --> B\", \"C --> B\", \"A --> C\", \"B --> A\", \"B --> C\", \"A --> C\"]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "WillLan/gitdemo", "path": "/hannuo.py", "msgidx": 473}}
{"problem_description": "Given a sorted list of integers representing the nodes of a Binary Search Tree (BST), determine if the tree formed from this list is symmetric. Additionally, count the number of nodes in the tree that fall within a specified range [low, high]. What is the result of these two operations?", "io_requirements": "Input:\n  `tree_list` (list of int): A sorted list of integers representing the nodes of a Binary Search Tree.\n  `low` (int): The lower bound of the range for counting nodes.\n  `high` (int): The upper bound of the range for counting nodes.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `is_symmetric` (bool): Indicates whether the tree is symmetric.\n    - `count_in_range` (int): The number of nodes in the tree that fall within the specified range [low, high].", "refcode": "# import necessary packages\nimport json\nfrom collections import deque\n\n# Define TreeNode class\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Function to convert a list to a Binary Search Tree (BST)\ndef sortedArrayToBST(nums):\n    def inner(left, right):\n        if left > right:\n            return None\n        mid = (left + right) // 2\n        root = TreeNode(nums[mid])\n        root.left = inner(left, mid - 1)\n        root.right = inner(mid + 1, right)\n        return root\n    return inner(0, len(nums) - 1)\n\n# Function to check if a tree is symmetric\ndef isSymmetric(root):\n    def mirro(left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        return left.val == right.val and mirro(left.left, right.right) and mirro(left.right, right.left)\n    return mirro(root, root)\n\n# Function to get the count of nodes in a given range\ndef getCount(root, low, high):\n    if not root:\n        return 0\n    if root.val == high and root.val == low:\n        return 1\n    if root.val <= high and root.val >= low:\n        return (1 + getCount(root.left, low, high) + getCount(root.right, low, high))\n    elif root.val < low:\n        return getCount(root.right, low, high)\n    else:\n        return getCount(root.left, low, high)\n\n# main function\ndef main_solution(tree_list, low, high):\n    # Convert the list to a BST\n    root = sortedArrayToBST(tree_list)\n    \n    # Check if the tree is symmetric\n    symmetric = isSymmetric(root)\n    \n    # Get the count of nodes in the given range\n    count_in_range = getCount(root, low, high)\n    \n    # Return the results as a dictionary\n    return {\n        \"is_symmetric\": symmetric,\n        \"count_in_range\": count_in_range\n    }", "funcname": "main_solution", "ios": [{"input": {"tree_list": [11, 14, 16, 36, 76, 90, 99], "low": 19, "high": 91}, "output": {"is_symmetric": false, "count_in_range": 3}}, {"input": {"tree_list": [6, 18, 60, 70, 93, 95], "low": 39, "high": 65}, "output": {"is_symmetric": false, "count_in_range": 1}}, {"input": {"tree_list": [9, 16, 54, 56, 75, 76, 89], "low": 77, "high": 85}, "output": {"is_symmetric": false, "count_in_range": 0}}, {"input": {"tree_list": [10, 15, 77, 78, 98], "low": 81, "high": 89}, "output": {"is_symmetric": false, "count_in_range": 0}}, {"input": {"tree_list": [36, 42, 43, 46, 51, 53, 70, 85, 89, 97], "low": 72, "high": 97}, "output": {"is_symmetric": false, "count_in_range": 3}}, {"input": {"tree_list": [3, 5, 12, 34, 45, 50, 64, 65, 77, 97], "low": 75, "high": 97}, "output": {"is_symmetric": false, "count_in_range": 2}}, {"input": {"tree_list": [9, 31, 32, 39, 52], "low": 15, "high": 25}, "output": {"is_symmetric": false, "count_in_range": 0}}, {"input": {"tree_list": [6, 13, 14, 41, 44, 79, 81, 90, 98], "low": 8, "high": 41}, "output": {"is_symmetric": false, "count_in_range": 3}}, {"input": {"tree_list": [2, 8, 18, 43, 58, 61, 65, 71, 81, 93], "low": 39, "high": 49}, "output": {"is_symmetric": false, "count_in_range": 1}}, {"input": {"tree_list": [46, 50, 58, 88, 94, 96], "low": 93, "high": 96}, "output": {"is_symmetric": false, "count_in_range": 2}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Omar-zoubi/Data-Structure", "path": "/Data_structure.py", "msgidx": 591}}
{"problem_description": "In the context of Conway's Game of Life, given a grid of cells where each cell can be either alive or dead, what will be the state of the grid after one iteration of the game's rules? The rules dictate that a live cell with fewer than two live neighbors dies, a live cell with two or three live neighbors lives, a live cell with more than three live neighbors dies, and a dead cell with exactly three live neighbors becomes alive.", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the state of the game board. Each element in the list is either `0` (dead cell) or `1` (live cell). The size of the board is `m x n`, where `m` is the number of rows and `n` is the number of columns.\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the next state of the game board after applying the rules of Conway's Game of Life. Each element in the list is either `0` (dead cell) or `1` (live cell). The size of the board remains `m x n`.", "refcode": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def gameOfLife(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        LineNumber = len(board)  # \u9762\u677f\u884c\u6570\n        RowNumber = len(board[0])  # \u9762\u677f\u5217\u6570\n        Newboard = copy.deepcopy(board)\n        for i in range(0, LineNumber):\n            for j in range(0, RowNumber):\n                self.AllCells(board, i, j, Newboard)  # \u904d\u5386\u5468\u56f4\u7ec6\u80de\n        return Newboard\n\n    def AllCells(self, board, i, j, Newboard):  # \u904d\u5386\u5468\u56f4\u7ec6\u80de,\u83b7\u53d6\u81ea\u8eab\u4e0b\u6b21\u72b6\u6001\n        Cells = []\n        LivingCells = 0\n        DeadCells = 0\n        LineNumber = len(board)  # \u9762\u677f\u884c\u6570\n        RowNumber = len(board[0])  # \u9762\u677f\u5217\u6570\n        for m in range(i - 1, i + 2):\n            for n in range(j - 1, j + 2):\n                if (m < 0) or (n < 0) or (m > LineNumber - 1) or (n > RowNumber - 1):\n                    continue\n                if board[m][n] == 0:\n                    DeadCells = DeadCells + 1\n                else:\n                    LivingCells = LivingCells + 1\n\n        if board[i][j] == 0:  # \u672c\u6b21\u4e3a\u6b7b\u7ec6\u80de\n            DeadCells = DeadCells - 1\n            if LivingCells == 3:\n                Newboard[i][j] = 1\n        else:\n            LivingCells = LivingCells - 1\n            if LivingCells < 2 or LivingCells > 3:\n                Newboard[i][j] = 0\n\n        return Newboard\n\n# main function\ndef main_solution(board):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.gameOfLife(board)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 1, 1], [0, 0, 1], [0, 1, 0]]}, "output": [[0, 1, 1], [1, 0, 1], [0, 0, 0]]}, {"input": {"board": [[1, 0, 1], [0, 1, 0], [0, 1, 1], [1, 1, 0]]}, "output": [[0, 1, 0], [1, 0, 0], [0, 0, 1], [1, 1, 1]]}, {"input": {"board": [[1, 1, 0, 1], [1, 1, 0, 0], [1, 1, 1, 0]]}, "output": [[1, 1, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0]]}, {"input": {"board": [[1, 0, 1, 0], [1, 1, 1, 1], [1, 0, 1, 1], [1, 0, 1, 0]]}, "output": [[1, 0, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [0, 0, 1, 1]]}, {"input": {"board": [[0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [1, 0, 1, 0, 1], [0, 0, 1, 1, 1]]}, "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 1], [0, 1, 1, 0, 1]]}, {"input": {"board": [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [1, 0, 1, 0, 1]]}, "output": [[0, 0, 0, 0, 0], [1, 1, 0, 0, 0], [0, 1, 0, 0, 0]]}, {"input": {"board": [[1, 0, 1, 1], [0, 1, 0, 1], [1, 0, 1, 1]]}, "output": [[0, 1, 1, 1], [1, 0, 0, 0], [0, 1, 1, 1]]}, {"input": {"board": [[1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 1]]}, "output": [[0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0]]}, {"input": {"board": [[1, 0, 1, 1], [1, 0, 0, 1], [0, 0, 1, 0], [1, 0, 1, 0], [1, 1, 0, 0]]}, "output": [[0, 1, 1, 1], [0, 0, 0, 1], [0, 0, 1, 1], [1, 0, 1, 0], [1, 1, 0, 0]]}, {"input": {"board": [[1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0]]}, "output": [[0, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bulaimei1991/MyLeetcode", "path": "/Game Of Life.py", "msgidx": 81}}
{"problem_description": "Given a string of digits, where each digit can represent a set of letters (e.g., 2 represents \"abc\", 3 represents \"def\", etc.), what are all the possible letter combinations that can be formed by pressing these digits on a traditional phone keypad?", "io_requirements": "Input:\n  `digits` (str): A string of digits where each digit corresponds to a set of letters as per the `letters` dictionary. The length of the string should be between 1 and 4 characters.\n\nOutput:\n  `return` (list of str): A list of all possible letter combinations that the number could represent. Each combination is a string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nletters = {\n    2: \"abc\",\n    3: \"def\",\n    4: \"ghi\",\n    5: \"jkl\",\n    6: \"mno\",\n    7: \"pqrs\",\n    8: \"tuv\",\n    9: \"wxyz\"\n}\n\ndef backtrack(index, l, digits, ans):\n    if len(l) == len(digits):\n        ans.append(l)\n        return\n    possible = list(letters[int(digits[index])])\n    for char in possible:\n        l += char\n        backtrack(index + 1, l, digits, ans)\n        l = l[:-1]\n\ndef noCombi(digits):\n    ans = []\n    backtrack(0, \"\", digits, ans)\n    return ans\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = noCombi(digits)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"digits": "9"}, "output": ["w", "x", "y", "z"]}, {"input": {"digits": "6"}, "output": ["m", "n", "o"]}, {"input": {"digits": "57"}, "output": ["jp", "jq", "jr", "js", "kp", "kq", "kr", "ks", "lp", "lq", "lr", "ls"]}, {"input": {"digits": "3"}, "output": ["d", "e", "f"]}, {"input": {"digits": "4"}, "output": ["g", "h", "i"]}, {"input": {"digits": "5"}, "output": ["j", "k", "l"]}, {"input": {"digits": "55"}, "output": ["jj", "jk", "jl", "kj", "kk", "kl", "lj", "lk", "ll"]}, {"input": {"digits": "63"}, "output": ["md", "me", "mf", "nd", "ne", "nf", "od", "oe", "of"]}, {"input": {"digits": "65"}, "output": ["mj", "mk", "ml", "nj", "nk", "nl", "oj", "ok", "ol"]}, {"input": {"digits": "52"}, "output": ["ja", "jb", "jc", "ka", "kb", "kc", "la", "lb", "lc"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "inkyguy/coding", "path": "/PhoneNoCombi.py", "msgidx": 178}}
{"problem_description": "Given a number `N`, how many circular primes are there below `N`? A circular prime is a prime number with the property that all rotations of its digits are also prime numbers. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers.", "io_requirements": "Input:\n  `N` (int): An integer representing the upper limit up to which we need to find circular primes.\n\nOutput:\n  `return` (int): An integer representing the number of circular primes below the given limit `N`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPrime(n):\n    prime_list = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\n                  43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n    if n < 2:\n        return False\n    if n in prime_list:\n        return True\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef Sieve_of_Eratosthenes(n):\n    if type(n) != int:\n        raise TypeError(\"must be integer\")\n    if n < 2:\n        raise ValueError(\"must be greater than one\")\n    m = (n-1) // 2\n    sieve = [True] * m\n    i = 0\n    p = 3\n    prime_list = [2]\n    while p*p < n:\n        if sieve[i]:\n            prime_list += [p]\n            j = 2*i*i + 6*i + 3\n            while j < m:\n                sieve[j] = False\n                j += 2*i + 3\n        i += 1\n        p += 2\n    while i < m:\n        if sieve[i]:\n            prime_list += [p]\n        i += 1\n        p += 2\n    return prime_list\n\ndef numDigits(n):\n    return len(str(n))\n\ndef rotate(n):\n    one = n%10\n    d = numDigits(n)\n    n = n // 10\n    n += one*(10**(d-1))\n    return n\n\ndef isCircular(n):\n    d = numDigits(n)\n    for i in range(0, d):\n        if not isPrime(n):\n            return False\n        n = rotate(n)\n    return True\n\ndef get_circular_primes(N):\n    prime_list = Sieve_of_Eratosthenes(N)\n    prime_to_index = {p: i for i, p in enumerate(prime_list)}\n    primes_checked = [False] * len(prime_list)\n    prime_list = set(prime_list)\n\n    circular_primes = []\n    for p in prime_list:\n        if primes_checked[prime_to_index[p]]:\n            continue\n        \n        primes = []\n        for _ in range(numDigits(p)):\n            if p in prime_list:\n                j = prime_to_index[p]\n                primes.append(p)\n                primes_checked[j] = True\n            else:\n                break\n            p = rotate(p)\n        else:\n            circular_primes.extend(primes)\n\n    return list(sorted(set(circular_primes)))\n\n# main function\ndef main_solution(N):\n    # Convert input to integer if necessary\n    N = int(N)\n    \n    # Get the list of circular primes below N\n    circular_primes = get_circular_primes(N)\n    \n    # Return the number of circular primes as a JSON serializable output\n    return len(circular_primes)", "funcname": "main_solution", "ios": [{"input": {"N": 851219}, "output": 43}, {"input": {"N": 106230}, "output": 43}, {"input": {"N": 389277}, "output": 43}, {"input": {"N": 407159}, "output": 43}, {"input": {"N": 450161}, "output": 43}, {"input": {"N": 550988}, "output": 43}, {"input": {"N": 703099}, "output": 43}, {"input": {"N": 617935}, "output": 43}, {"input": {"N": 588881}, "output": 43}, {"input": {"N": 917661}, "output": 43}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ekeilty17/Project_Euler", "path": "/P035.py", "msgidx": 723}}
{"problem_description": "Given two strings of the same length, how can we determine if one string is a scrambled version of the other? Specifically, if we have two strings `s1` and `s2`, what is the result of checking whether `s2` is a scrambled version of `s1`?", "io_requirements": "Input:\n  `s1` (str): The first string to be checked for scrambling.\n  `s2` (str): The second string to be checked if it is a scrambled version of `s1`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether `s2` is a scrambled version of `s1`.", "refcode": "# import necessary packages\nimport collections\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        return self.recursiveScramble(s1, s2, {})\n\n    def recursiveScramble(self, s, t, memo):\n        if len(s) != len(t):\n            return False\n        if len(s) <= 1:\n            return s == t\n        if (s, t) in memo:\n            return memo[s, t]\n        for i in range(1, len(s)):\n            # \u9012\u5f52\u5224\u65ads1\u548cs2\u5de6\u53f3\u4e24\u4fa7\u662f\u5426\u4e3ascramble\n            if (self.recursiveScramble(s[:i], t[-i:], memo) and self.recursiveScramble(s[i:], t[:-i], memo)) or\\\n               (self.recursiveScramble(s[:i], t[:i], memo) and self.recursiveScramble(s[i:], t[i:], memo)):\n                   memo[s,t] = True\n                   return True\n        memo[s, t] = False\n        return False\n\n# main function\ndef main_solution(s1, s2):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.isScramble(s1, s2)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"s1": "kotFOdk", "s2": "ZncKZSd"}, "output": false}, {"input": {"s1": "H", "s2": "z"}, "output": false}, {"input": {"s1": "SlDZ", "s2": "ZGXI"}, "output": false}, {"input": {"s1": "PvCeCUhZ", "s2": "obEzAVgw"}, "output": false}, {"input": {"s1": "UMvJMu", "s2": "YZoEZX"}, "output": false}, {"input": {"s1": "qQer", "s2": "xIbx"}, "output": false}, {"input": {"s1": "WqMY", "s2": "Whyc"}, "output": false}, {"input": {"s1": "JRyx", "s2": "JUtL"}, "output": false}, {"input": {"s1": "VCvINbGFc", "s2": "wmuysAgFo"}, "output": false}, {"input": {"s1": "OYzUrW", "s2": "NbZYQp"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wanglinjie/coding", "path": "/leetcode/scramblestring.py", "msgidx": 622}}
{"problem_description": "Given a phone number, what are all the possible mnemonics that can be generated based on the traditional phone keypad mapping?", "io_requirements": "Input:\n  `phone_number` (str): A string representing a phone number where each character is a digit from '0' to '9'.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a possible mnemonic for the given phone number based on the mapping provided.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nmapping = ('0', '1', 'ABC', 'DEF', 'GHI', 'JKL', 'MNO', 'PQRS', 'TUV', 'WXYZ')\n\ndef phone_mnemonic(phone_number):\n    def mnemonic_recursor(digit):\n        if digit == len(phone_number):\n            mnemonics.append(''.join(partial_mnemonic))\n        else:\n            for c in mapping[int(phone_number[digit])]:\n                partial_mnemonic[digit] = c\n                mnemonic_recursor(digit + 1)\n    \n    mnemonics, partial_mnemonic = [], [0] * len(phone_number)\n    mnemonic_recursor(0)\n    return mnemonics\n\n# main function\ndef main_solution(phone_number):\n    # Convert the phone number to a string if it's not already\n    phone_number = str(phone_number)\n    \n    # Call the phone_mnemonic function to get the mnemonics\n    result = phone_mnemonic(phone_number)\n    \n    # Return the result as a list of strings\n    return result", "funcname": "main_solution", "ios": [{"input": {"phone_number": "1014030"}, "output": ["101G0D0", "101G0E0", "101G0F0", "101H0D0", "101H0E0", "101H0F0", "101I0D0", "101I0E0", "101I0F0"]}, {"input": {"phone_number": "0010089001"}, "output": ["00100TW001", "00100TX001", "00100TY001", "00100TZ001", "00100UW001", "00100UX001", "00100UY001", "00100UZ001", "00100VW001", "00100VX001", "00100VY001", "00100VZ001"]}, {"input": {"phone_number": "0040811"}, "output": ["00G0T11", "00G0U11", "00G0V11", "00H0T11", "00H0U11", "00H0V11", "00I0T11", "00I0U11", "00I0V11"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "eunnovax/python_algorithms", "path": "/strings/phone_mnemonic.py", "msgidx": 693}}
{"problem_description": "You have a circular lock with three wheels, each displaying numbers from 0 to 9. The lock can rotate each wheel in both clockwise and counterclockwise directions. However, the lock has several dead ends, meaning certain combinations will cause the lock to become stuck. Given the initial state of the lock set to `000`, a target combination, and a list of dead ends, what is the minimum number of moves required to reach the target state, or is it impossible to reach the target state without hitting a dead end?", "io_requirements": "Input:\n  `initial_state` (list of int): A list of three integers representing the initial state of the lock, where each integer is between 0 and 9.\n  `target_state` (list of int): A list of three integers representing the target state of the lock, where each integer is between 0 and 9.\n  `dead_ends` (list of list of int): A list of lists, where each inner list contains three integers representing a dead end state of the lock, where each integer is between 0 and 9.\n\nOutput:\n  `return` (int or None): The minimum number of moves required to reach the target state from the initial state, or `None` if it is impossible to reach the target state without hitting a dead end.", "refcode": "# import necessary packages\nimport heapq\n\n# all class and function definitions in the code file, if any\ndef is_valid_state(state, dead_ends):\n    \"\"\"Check if the state is not a dead end.\"\"\"\n    return state not in dead_ends\n\ndef get_neighbors(state):\n    \"\"\"Generate all possible next states from the current state.\"\"\"\n    neighbors = []\n    for i in range(3):\n        for d in [-1, 1]:\n            new_state = list(state)\n            new_state[i] = (new_state[i] + d) % 10\n            neighbors.append(tuple(new_state))\n    return neighbors\n\ndef heuristic(state, target):\n    \"\"\"Calculate the heuristic value as the sum of absolute differences for each wheel.\"\"\"\n    return sum(abs(state[i] - target[i]) for i in range(3))\n\n# main function\ndef main_solution(initial_state, target_state, dead_ends):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    initial_state = tuple(initial_state)\n    target_state = tuple(target_state)\n    dead_ends = set(tuple(dead_end) for dead_end in dead_ends)\n    \n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    if initial_state in dead_ends or target_state in dead_ends:\n        return None\n    \n    # A* algorithm to find the shortest path\n    open_set = []\n    heapq.heappush(open_set, (heuristic(initial_state, target_state), 0, initial_state))\n    came_from = {}\n    g_score = {initial_state: 0}\n    \n    while open_set:\n        _, current_g, current_state = heapq.heappop(open_set)\n        \n        if current_state == target_state:\n            return current_g\n        \n        for neighbor in get_neighbors(current_state):\n            if not is_valid_state(neighbor, dead_ends):\n                continue\n            \n            tentative_g_score = current_g + 1\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current_state\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, target_state)\n                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))\n    \n    return None", "funcname": "main_solution", "ios": [{"input": {"initial_state": [0, 0, 0], "target_state": [9, 4, 1], "dead_ends": [[3, 9, 1]]}, "output": 6}, {"input": {"initial_state": [0, 0, 0], "target_state": [3, 4, 3], "dead_ends": [[2, 6, 2]]}, "output": 10}, {"input": {"initial_state": [0, 0, 0], "target_state": [8, 9, 9], "dead_ends": [[9, 4, 0]]}, "output": 4}, {"input": {"initial_state": [0, 0, 0], "target_state": [9, 3, 8], "dead_ends": [[1, 6, 4]]}, "output": 6}, {"input": {"initial_state": [0, 0, 0], "target_state": [8, 7, 3], "dead_ends": [[0, 8, 8]]}, "output": 8}, {"input": {"initial_state": [0, 0, 0], "target_state": [0, 8, 0], "dead_ends": [[3, 9, 5], [3, 0, 3]]}, "output": 2}, {"input": {"initial_state": [0, 0, 0], "target_state": [9, 3, 8], "dead_ends": [[5, 6, 7], [7, 6, 9]]}, "output": 6}, {"input": {"initial_state": [0, 0, 0], "target_state": [7, 4, 7], "dead_ends": [[1, 7, 4]]}, "output": 10}, {"input": {"initial_state": [0, 0, 0], "target_state": [4, 7, 4], "dead_ends": [[1, 0, 7], [0, 7, 5]]}, "output": 11}, {"input": {"initial_state": [0, 0, 0], "target_state": [1, 5, 2], "dead_ends": [[5, 0, 5]]}, "output": 8}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "carlhinderer/python-exercises", "path": "/daily-coding-problems/problem313.py", "msgidx": 821}}
{"problem_description": "Given a partially filled board for a game where each row and column must contain an equal number of 0s and 1s, and no three consecutive 0s or 1s are allowed in any row or column, how can you complete the board such that all rules are satisfied? What will be the final configuration of the board after filling in all the empty positions?", "io_requirements": "Input:\n  `board` (list of lists of integers): A 2D list representing the initial state of the board. Each element in the list can be either 0, 1, or 9. 0 and 1 represent filled positions, and 9 represents an empty position. The board must be square (i.e., the number of rows equals the number of columns).\n\nOutput:\n  `return` (list of lists of integers): A 2D list representing the solved state of the board. Each element in the list will be either 0 or 1, indicating the filled positions.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass alolboard():\n    def __init__(self, board):\n        self.board = board.copy()\n        self.edge = len(board)\n    \n    def compare(self, a, b):\n        if (a == 9).any() or (b == 9).any():\n            return False\n        else:\n            return (a == b).all()\n    \n    def valid(self, pos, num):\n        row, col = pos\n        cnt_lmt = self.edge / 2\n        \n        temp = np.copy(self.board)   \n        temp[row, col] = num\n        \n        for cl in range(max(0, col - 2), min(self.edge - 3, col) + 1):\n            if temp[row, cl] == temp[row, cl + 1] == temp[row, cl + 2]:\n                return False\n\n        for rw in range(max(0, row - 2), min(self.edge - 3, row) + 1):\n            if temp[rw, col] == temp[rw + 1, col] == temp[rw + 2, col]:\n                return False        \n            \n        elem_cnt_col = (temp[:, col] == num).sum()\n        if elem_cnt_col > cnt_lmt:\n            return False\n\n        elem_cnt_row = (temp[row, :] == num).sum()\n        if elem_cnt_row > cnt_lmt:\n            return False\n            \n        crow = self.board[row, :]\n        ccol = self.board[:, col]\n        for r in range(self.edge):\n            if r != row:\n                if self.compare(crow, self.board[r, :]) == True:\n                    return False\n        \n        for c in range(self.edge):\n            if c != col:\n                if self.compare(ccol, self.board[:, c]) == True:\n                    return False\n                \n        return True\n                  \n    def next_open(self):\n        for row in range(self.edge):\n            for col in range(self.edge):\n                if self.board[row, col] not in [0, 1]:\n                    return (row, col)\n        return True\n    \n    def solve(self):\n        if self.next_open() == True:\n            return True\n        else:\n            row, col = self.next_open()\n        \n        for num in range(2):\n            self.board[row, col] = num\n            \n            if self.valid((row, col), num) == True:\n                if self.solve() == True:\n                    return True\n        self.board[row, col] = 9\n        \n        return False\n\n# main function\ndef main_solution(board):\n    # Convert the input list to a numpy array\n    board_np = np.array(board)\n    \n    # Create an instance of the alolboard class\n    b = alolboard(board_np)\n    \n    # Solve the board\n    b.solve()\n    \n    # Convert the solved board back to a list\n    solved_board = b.board.tolist()\n    \n    # Return the solved board\n    return solved_board", "funcname": "main_solution", "ios": [{"input": {"board": [[0, 9, 0, 1], [1, 1, 9, 0], [1, 9, 0, 1], [9, 0, 9, 0]]}, "output": [[0, 9, 0, 1], [1, 1, 9, 0], [1, 9, 0, 1], [9, 0, 9, 0]]}, {"input": {"board": [[0, 0, 1, 1], [0, 1, 1, 1], [0, 0, 9, 9], [1, 0, 0, 0]]}, "output": [[0, 0, 1, 1], [0, 1, 1, 1], [0, 0, 9, 9], [1, 0, 0, 0]]}, {"input": {"board": [[1, 1, 9, 9], [1, 1, 0, 9], [1, 9, 1, 0], [0, 9, 0, 9]]}, "output": [[1, 1, 9, 9], [1, 1, 0, 9], [1, 9, 1, 0], [0, 9, 0, 9]]}, {"input": {"board": [[1, 9, 1, 0], [1, 9, 0, 1], [0, 0, 9, 0], [0, 9, 0, 0]]}, "output": [[1, 9, 1, 0], [1, 9, 0, 1], [0, 0, 9, 0], [0, 9, 0, 0]]}, {"input": {"board": [[0, 1, 1, 9], [1, 1, 1, 9], [0, 1, 9, 1], [0, 1, 1, 9]]}, "output": [[0, 1, 1, 9], [1, 1, 1, 9], [0, 1, 9, 1], [0, 1, 1, 9]]}, {"input": {"board": [[0, 1, 0, 1], [0, 1, 1, 0], [9, 9, 0, 1], [0, 1, 9, 9]]}, "output": [[0, 1, 0, 1], [0, 1, 1, 0], [9, 9, 0, 1], [0, 1, 9, 9]]}, {"input": {"board": [[9, 9, 1, 9], [1, 1, 1, 9], [1, 0, 0, 1], [0, 0, 9, 0]]}, "output": [[9, 9, 1, 9], [1, 1, 1, 9], [1, 0, 0, 1], [0, 0, 9, 0]]}, {"input": {"board": [[0, 9, 1, 1], [9, 1, 9, 0], [1, 1, 1, 1], [0, 9, 0, 9]]}, "output": [[0, 9, 1, 1], [9, 1, 9, 0], [1, 1, 1, 1], [0, 9, 0, 9]]}, {"input": {"board": [[9, 1, 9, 9], [0, 1, 1, 0], [9, 0, 1, 0], [9, 1, 1, 0]]}, "output": [[9, 1, 9, 9], [0, 1, 1, 0], [9, 0, 1, 0], [9, 1, 1, 0]]}, {"input": {"board": [[9, 0, 0, 0], [0, 1, 1, 0], [9, 1, 9, 9], [9, 1, 0, 0]]}, "output": [[9, 0, 0, 0], [0, 1, 1, 0], [9, 1, 9, 9], [9, 1, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "taowangwork/board_puzzle_solver", "path": "/solver.py", "msgidx": 556}}
{"problem_description": "Given a set of nine unique digits from 1 to 9, how can you arrange these digits to form three distinct three-digit numbers such that the first number is a multiple of 3, the second number is a multiple of 4, and the third number is a multiple of 5?", "io_requirements": "Input:\n  `digits` (list of int): A list of 9 unique digits from 1 to 9.\n\nOutput:\n  `return` (dict): A dictionary containing three keys:\n    - `\"a\"` (int): A three-digit number formed from the first three digits of the permutation, which is a multiple of 3.\n    - `\"b\"` (int): A three-digit number formed from the next three digits of the permutation, which is a multiple of 4.\n    - `\"c\"` (int): A three-digit number formed from the last three digits of the permutation, which is a multiple of 5.\n    If no valid permutation is found, the values for `\"a\"`, `\"b\"`, and `\"c\"` will be `None`.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(digits):\n    # digits (list of int): A list of 9 unique digits from 1 to 9.\n    nums = digits\n    for perms in permutations(nums, 9):\n        a = int(\"\".join(map(str, perms[0:3])))\n        b = int(\"\".join(map(str, perms[3:6])))\n        c = int(\"\".join(map(str, perms[6:])))\n        if a % 3 == 0 and b % 4 == 0 and c % 5 == 0:\n            return {\"a\": a, \"b\": b, \"c\": c}\n    return {\"a\": None, \"b\": None, \"c\": None}", "funcname": "main_solution", "ios": [{"input": {"digits": [4, 3, 8, 6, 5, 7, 1, 2, 9]}, "output": {"a": 438, "b": 672, "c": 195}}, {"input": {"digits": [3, 9, 5, 7, 8, 1, 4, 2, 6]}, "output": {"a": 396, "b": 784, "c": 125}}, {"input": {"digits": [9, 5, 8, 3, 7, 1, 2, 6, 4]}, "output": {"a": 987, "b": 312, "c": 645}}, {"input": {"digits": [3, 7, 1, 2, 6, 9, 4, 5, 8]}, "output": {"a": 372, "b": 164, "c": 985}}, {"input": {"digits": [6, 5, 3, 2, 9, 8, 4, 7, 1]}, "output": {"a": 639, "b": 284, "c": 715}}, {"input": {"digits": [9, 1, 8, 7, 6, 4, 2, 3, 5]}, "output": {"a": 918, "b": 764, "c": 235}}, {"input": {"digits": [1, 8, 5, 6, 9, 7, 3, 4, 2]}, "output": {"a": 186, "b": 972, "c": 345}}, {"input": {"digits": [6, 4, 1, 2, 7, 5, 8, 9, 3]}, "output": {"a": 648, "b": 172, "c": 935}}, {"input": {"digits": [1, 2, 6, 4, 3, 9, 8, 5, 7]}, "output": {"a": 126, "b": 348, "c": 975}}, {"input": {"digits": [6, 4, 8, 9, 1, 2, 3, 7, 5]}, "output": {"a": 648, "b": 912, "c": 375}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "drewtuley/LogicPuzzles", "path": "/Day25.py", "msgidx": 1084}}
{"problem_description": "In the study of fractal geometry, the dragon curve is a well-known fractal pattern. Each generation of the dragon curve has a specific length and pattern. Given a specific generation `n` of the dragon curve, we are interested in extracting a sequence of length `l` starting from position `p`. What is the resulting sequence from the dragon curve at generation `n` starting at position `p` with length `l`?", "io_requirements": "Input:\n  `n` (int): The generation number of the dragon curve.\n  `p` (int): The starting position in the dragon curve sequence.\n  `l` (int): The length of the sequence to be extracted from the starting position.\n\nOutput:\n  `return` (str): A string representing the extracted sequence from the dragon curve starting at position `p` with length `l`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nSIGN = ['+', '-']\n\ndef sign(n):\n    # return nth sign\n    def log2(num):\n        # return [log2(num)]\n        assert num >= 1\n\n        result = 0\n        while True:\n            if num == 1:\n                break\n            result += 1\n            num = num // 2\n\n        return result\n\n    assert n >= 1\n\n    # if n is power of 2, then sign is +\n    k = pow(2, log2(n))\n    if n == k:\n        return 0\n\n    return 1 - sign(2*k - n)\n\n# main function\ndef main_solution(n, p, l):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = []\n  for idx in range(p-1, p-1+l):\n      curr = None\n      if idx % 6 in [0, 4]:\n          curr = 'F'\n      elif idx % 6 == 1:\n          curr = 'X'\n      elif idx % 6 in [2, 5]:\n          curr = SIGN[sign((idx//3) + 1)]\n      elif idx % 6 == 3:\n          curr = 'Y'\n\n      result.append(curr)\n\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return ''.join(result)", "funcname": "main_solution", "ios": [{"input": {"n": 10, "p": 32, "l": 10}, "output": "X-YF-FX+YF"}, {"input": {"n": 3, "p": 69, "l": 9}, "output": "-YF-FX+YF"}, {"input": {"n": 6, "p": 75, "l": 7}, "output": "+YF+FX-"}, {"input": {"n": 5, "p": 2, "l": 5}, "output": "X+YF+"}, {"input": {"n": 4, "p": 44, "l": 3}, "output": "X-Y"}, {"input": {"n": 7, "p": 24, "l": 1}, "output": "+"}, {"input": {"n": 6, "p": 36, "l": 6}, "output": "-FX+YF"}, {"input": {"n": 6, "p": 82, "l": 7}, "output": "YF-FX+Y"}, {"input": {"n": 10, "p": 60, "l": 4}, "output": "+FX+"}, {"input": {"n": 8, "p": 53, "l": 3}, "output": "F+F"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vip7265/ProgrammingStudy", "path": "/Chapter09_DPTechnique/Dragon/sjw_dragon.py", "msgidx": 355}}
{"problem_description": "Given four cards, each containing a number from 1 to 9, can you determine if these numbers can be combined using the operations multiplication, division, addition, subtraction, and parentheses to yield the value of 24? Note that division represents real division, not integer division, and each operation is performed between two numbers. Additionally, unary operations and concatenation of numbers are not allowed. What is the result of this operation for the given set of numbers?", "io_requirements": "Input:\n  `nums` (List[int]): A list of 4 integers, each ranging from 1 to 9.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the numbers in `nums` can be combined using the operations *, /, +, -, (, ) to equal 24.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def judgePoint24(self, nums: List[int]) -> bool:\n        return self.dfs(nums, {})\n\n    def dfs(self, A, cache):\n        if tuple(A) not in cache:\n            n = len(A)\n            if n == 1:\n                return abs(A[0] - 24) < 0.001\n\n            for i in range(n):\n                for j in range(i):\n                    a = A[i]\n                    b = A[j]\n                    for c in (a+b, a-b, b-a, a*b, b and a/b, a and b/a):\n                        A_new = A[:j] + A[j+1:i] + A[i+1:] + [c]\n                        A_new.sort()\n                        if self.dfs(A_new, cache):\n                            cache[tuple(A)] = True\n                            return cache[tuple(A)]\n\n            cache[tuple(A)] = False\n\n        return cache[tuple(A)]\n\n# main function\ndef main_solution(nums: List[int]) -> bool:\n    # Convert input to the required format\n    solution = Solution()\n    result = solution.judgePoint24(nums)\n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"nums": [5, 1, 6, 3]}, "output": true}, {"input": {"nums": [1, 1, 1, 5]}, "output": false}, {"input": {"nums": [6, 3, 4, 6]}, "output": true}, {"input": {"nums": [6, 7, 6, 8]}, "output": false}, {"input": {"nums": [2, 8, 6, 5]}, "output": true}, {"input": {"nums": [5, 7, 3, 2]}, "output": true}, {"input": {"nums": [6, 8, 1, 3]}, "output": true}, {"input": {"nums": [3, 4, 8, 6]}, "output": true}, {"input": {"nums": [3, 9, 1, 1]}, "output": true}, {"input": {"nums": [5, 7, 5, 6]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "syurskyi/Python_Topics", "path": "/125_algorithms/_exercises/templates/_algorithms_challenges/leetcode/LeetCode_with_solution/679 24 Game.py", "msgidx": 748}}
{"problem_description": "Given a list of items, how can we determine all unique subsequences of a specified length from the list? For example, if we have a list of letters and want to find all unique pairs of letters, what would be the result?", "io_requirements": "Input:\n- `items` (list of str): A list of items from which combinations are to be generated. Each item in the list should be a string.\n- `n` (int): The length of each combination. This should be a non-negative integer.\n\nOutput:\n- `return` (list of list of str): A list of all unique subsequences of length `n` from the `items`. Each subsequence is represented as a list of strings.", "refcode": "# import necessary packages\nfrom itertools import combinations\n\n# main function\ndef main_solution(items, n):\n    \"\"\"\n    Generates all unique subsequences of length n from the given list of items.\n    \n    Parameters:\n    items (list of str): A list of items from which combinations are to be generated.\n    n (int): The length of each combination.\n    \n    Returns:\n    list of list of str: A list of all unique subsequences of length n from the items.\n    \"\"\"\n    # Generate all unique combinations of length n from the items\n    result = list(combinations(items, n))\n    \n    # Convert each combination tuple to a list for JSON serializability\n    result = [list(comb) for comb in result]\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"items": ["r", "u", "P", "E"], "n": 4}, "output": [["r", "u", "P", "E"]]}, {"input": {"items": ["I", "v", "D"], "n": 1}, "output": [["I"], ["v"], ["D"]]}, {"input": {"items": ["m", "Y", "W", "I"], "n": 3}, "output": [["m", "Y", "W"], ["m", "Y", "I"], ["m", "W", "I"], ["Y", "W", "I"]]}, {"input": {"items": ["x", "L", "s", "K", "G"], "n": 1}, "output": [["x"], ["L"], ["s"], ["K"], ["G"]]}, {"input": {"items": ["f", "b", "Y", "W"], "n": 1}, "output": [["f"], ["b"], ["Y"], ["W"]]}, {"input": {"items": ["b", "Q", "E"], "n": 3}, "output": [["b", "Q", "E"]]}, {"input": {"items": ["C", "D", "v"], "n": 2}, "output": [["C", "D"], ["C", "v"], ["D", "v"]]}, {"input": {"items": ["r", "H", "W", "r"], "n": 4}, "output": [["r", "H", "W", "r"]]}, {"input": {"items": ["X", "v", "m"], "n": 3}, "output": [["X", "v", "m"]]}, {"input": {"items": ["I", "p", "G"], "n": 2}, "output": [["I", "p"], ["I", "G"], ["p", "G"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "strigazi/athena", "path": "/PhysicsAnalysis/PyAnalysis/PyAnalysisUtils/python/combo.py", "msgidx": 658}}
{"problem_description": "Given a set of staircases with varying numbers of steps, and a set of modulo bases, how many different ways can each staircase be climbed, considering that you can only take 1 or 2 steps at a time, and the result for each staircase should be modulo the given base?", "io_requirements": "Input:\n  `A` (list of integers): A list of integers representing the number of steps in each staircase.\n  `B` (list of integers): A list of integers representing the modulo base for each staircase.\n\nOutput:\n  `return` (list of integers): A list of integers representing the number of ways to climb each staircase, calculated using the modulo base.", "refcode": "# import necessary packages\nimport numpy as np\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef subir(N):\n    if(N==0):\n        return 1\n    elif N==1:\n        return 1\n    else:\n        return subir(N-1)+subir(N-2)\n\ndef arreglo_escaleras(a, b):\n    final = []\n    for i in range(len(a)):       \n        n = a[i] % (2*b[i])\n        temp = subir(n)\n        final.append(temp)\n    return final\n\n# main function\ndef main_solution(A, B):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # convert JSON serializable inputs to original input variables\n  A = np.array(A)\n  B = np.array(B)\n  \n  # call the original function\n  result = arreglo_escaleras(A, B)\n  \n  # convert the result to JSON serializable output\n  result = list(result)\n  \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"A": [8, 10, 4, 3, 5], "B": [2, 3, 3, 3, 3]}, "output": [1, 5, 5, 3, 8]}, {"input": {"A": [3, 8, 2, 6, 3], "B": [1, 1, 4, 5, 2]}, "output": [1, 1, 2, 13, 3]}, {"input": {"A": [9, 5, 1, 2, 8], "B": [2, 1, 3, 3, 1]}, "output": [1, 1, 1, 2, 1]}, {"input": {"A": [6, 7, 5, 9, 7], "B": [5, 1, 4, 5, 3]}, "output": [13, 1, 8, 55, 1]}, {"input": {"A": [8, 4, 3, 1, 2], "B": [2, 4, 4, 5, 5]}, "output": [1, 5, 3, 1, 2]}, {"input": {"A": [1, 1, 3, 2, 7], "B": [5, 1, 5, 4, 2]}, "output": [1, 1, 3, 2, 3]}, {"input": {"A": [9, 7, 2, 4, 5], "B": [5, 5, 1, 5, 4]}, "output": [55, 21, 1, 5, 8]}, {"input": {"A": [6, 7, 4, 10, 8], "B": [2, 1, 4, 4, 3]}, "output": [2, 1, 5, 2, 2]}, {"input": {"A": [9, 4, 4, 8, 1], "B": [2, 1, 3, 2, 3]}, "output": [1, 1, 5, 1, 1]}, {"input": {"A": [8, 10, 10, 3, 7], "B": [5, 3, 5, 4, 3]}, "output": [34, 5, 1, 3, 1]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "alvise30/CM20151_HW3_ElkinAlvis", "path": "/P2/subiendo_escaleras.py", "msgidx": 1026}}
{"problem_description": "Given a number `n`, which represents the number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate. It should be a positive integer.\n\nOutput:\n  `return` (List[str]): A list of strings, where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        if n == 0:\n            return []\n        # \u8bb0\u5f55\u6240\u6709\u5408\u6cd5\u7684\u62ec\u53f7\u7ec4\u5408\n        res = []\n        # \u56de\u6eaf\u8fc7\u7a0b\u4e2d\u7684\u8def\u5f84\n        track = ''\n        self.backtrack(n, n, track, res)\n        return res\n\n    def backtrack(self, left: int, right: int, track: str, res: List[int]):\n        # \u82e5\u5de6\u62ec\u53f7\u5269\u4e0b\u7684\u591a\uff0c\u8bf4\u660e\u4e0d\u5408\u6cd5\n        if right < left:\n            return\n        # \u6570\u91cf\u5c0f\u4e8e 0 \u80af\u5b9a\u662f\u4e0d\u5408\u6cd5\u7684\n        if right < 0 or left < 0:\n            return\n        # \u5f53\u6240\u6709\u62ec\u53f7\u90fd\u6070\u597d\u7528\u5b8c\u65f6\uff0c\u5f97\u5230\u4e00\u4e2a\u5408\u6cd5\u7684\u62ec\u53f7\u7ec4\u5408\n        if left == 0 and right == 0:\n            res.append(track)\n            return\n\n        # \u5c1d\u8bd5\u653e\u4e00\u4e2a\u5de6\u62ec\u53f7\n        track = track + '('     # \u9009\u62e9\n        self.backtrack(left - 1, right, track, res)\n        track = track[:len(track) - 1:]     # \u64a4\u9500\u9009\u62e9\n\n        # \u5c1d\u8bd5\u653e\u4e00\u4e2a\u53f3\u62ec\u53f7\n        track = track + ')'     # \u9009\u62e9\n        self.backtrack(left, right - 1, track, res)\n        track = track[:len(track) - 1:]     # \u64a4\u9500\u9009\u62e9\n\n# main function\ndef main_solution(n: int) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Step657/leetcode", "path": "/2_back_track_method/22_generateParenthesis.py", "msgidx": 298}}
{"problem_description": "In a voting simulation game, voters can choose to vote randomly or truthfully on whether a message is spam or ham. Given the number of voters, the threshold for a super majority, and the rewards for correct and incorrect votes, how often does random voting or truthful voting dominate in terms of expected rewards when the correct answer is known?", "io_requirements": "Input:\n  `num_voters` (int): The number of voters in the game.\n  `super_majority_threshold` (float): The threshold for a super majority, expressed as a fraction of the total number of voters.\n  `reward_correct` (int): The reward given when a voter votes correctly.\n  `reward_wrong` (int): The reward given when a voter votes incorrectly.\n  `correct_answer` (str): The correct answer, either \"S\" for spam or \"H\" for ham.\n\nOutput:\n  `return` (dict): A dictionary containing the dominance of random voting and truthful voting.\n    - `random_dominance` (int): The number of scenarios where random voting is dominant.\n    - `truthful_dominance` (int): The number of scenarios where truthful voting is dominant.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Game(object):\n    def __init__(self, n, k, rr, rw):\n        self.numPlayer = n\n        self.k = float(k)\n        self.rewardRight = rr\n        self.rewardWrong = rw\n        self.strategy = [[\"R\", \"S\"], [\"R\", \"H\"], [\"T\", \"S\"], [\"T\", \"H\"]]\n        self.voteCost = 1\n\n    def getReward(self, strategy, correct):\n        r = 0\n        if strategy[1] == correct:\n            r += self.rewardRight\n        else:\n            r += self.rewardWrong\n        if strategy[0] == \"T\":\n            r -= self.voteCost\n        return r\n\n    def generateOutcomes(self, correct):\n        outcomes = [[]]\n        for n in range(self.numPlayer):\n            newoutcome = []\n            for s in self.strategy:\n                if s[0] == \"T\" and s[1] != correct:\n                    continue\n                for oc in outcomes:\n                    newoutcome.append([s] + oc)\n            outcomes = newoutcome\n\n        for outcome in outcomes:\n            topvote = \"S\"\n            result = {\"S\": 0, \"H\": 0}\n            for vote in outcome:\n                result[vote[1]] += 1\n            if result[\"H\"] >= round(self.numPlayer * self.k):\n                topvote = \"H\"\n            for i in range(len(outcome)):\n                reward = self.getReward(outcome[i], topvote)\n                outcome[i] = outcome[i] + [reward]\n        return outcomes\n\n    def play(self, correct):\n        outcomes = self.generateOutcomes(correct)\n        for p in range(1):\n            strategy = dict()\n            totalreward = {\"R\": 0, \"T\": 0}\n            totalcount = {\"R\": 0, \"T\": 0}\n            for outcome in outcomes:\n                playervote = outcome[p]\n                totalreward[playervote[0]] += playervote[2]\n                totalcount[playervote[0]] += 1\n                other = outcome[:]\n                del other[p]\n                other = \"\".join([o[0] for o in other])\n                if other not in strategy:\n                    strategy[other] = []\n                strategy[other].append(playervote)\n\n            for k in strategy:\n                news = [[\"R\", 0, 0], [\"T\", 0, 0]]\n                for s in strategy[k]:\n                    if s[0] == \"R\":\n                        news[0][1] += s[2]\n                        news[0][2] += 1.0\n                    else:\n                        news[1][1] += s[2]\n                        news[1][2] += 1.0\n                news[0][1] /= news[0][2]\n                news[1][1] /= news[1][2]\n                strategy[k] = news\n\n            truthful = 0\n            random = 0\n            for k in sorted(strategy):\n                if strategy[k][0][1] < strategy[k][1][1]:\n                    truthful += 1\n                else:\n                    random += 1\n        return {\"random_dominance\": random, \"truthful_dominance\": truthful}\n\n# main function\ndef main_solution(num_voters, super_majority_threshold, reward_correct, reward_wrong, correct_answer):\n    game = Game(num_voters, super_majority_threshold, reward_correct, reward_wrong)\n    result = game.play(correct_answer)\n    return result", "funcname": "main_solution", "ios": [{"input": {"num_voters": 8, "super_majority_threshold": 0.62, "reward_correct": 57, "reward_wrong": -38, "correct_answer": "S"}, "output": {"random_dominance": 0, "truthful_dominance": 128}}, {"input": {"num_voters": 7, "super_majority_threshold": 0.6, "reward_correct": 97, "reward_wrong": -27, "correct_answer": "S"}, "output": {"random_dominance": 1, "truthful_dominance": 63}}, {"input": {"num_voters": 5, "super_majority_threshold": 0.8, "reward_correct": 112, "reward_wrong": -39, "correct_answer": "H"}, "output": {"random_dominance": 11, "truthful_dominance": 5}}, {"input": {"num_voters": 10, "super_majority_threshold": 0.54, "reward_correct": 72, "reward_wrong": -45, "correct_answer": "H"}, "output": {"random_dominance": 0, "truthful_dominance": 512}}, {"input": {"num_voters": 5, "super_majority_threshold": 0.62, "reward_correct": 107, "reward_wrong": -42, "correct_answer": "S"}, "output": {"random_dominance": 1, "truthful_dominance": 15}}, {"input": {"num_voters": 9, "super_majority_threshold": 0.58, "reward_correct": 143, "reward_wrong": -28, "correct_answer": "H"}, "output": {"random_dominance": 1, "truthful_dominance": 255}}, {"input": {"num_voters": 10, "super_majority_threshold": 0.64, "reward_correct": 121, "reward_wrong": -21, "correct_answer": "H"}, "output": {"random_dominance": 10, "truthful_dominance": 502}}, {"input": {"num_voters": 5, "super_majority_threshold": 0.52, "reward_correct": 88, "reward_wrong": -21, "correct_answer": "H"}, "output": {"random_dominance": 1, "truthful_dominance": 15}}, {"input": {"num_voters": 9, "super_majority_threshold": 0.72, "reward_correct": 144, "reward_wrong": -21, "correct_answer": "S"}, "output": {"random_dominance": 0, "truthful_dominance": 256}}, {"input": {"num_voters": 6, "super_majority_threshold": 0.67, "reward_correct": 137, "reward_wrong": -19, "correct_answer": "S"}, "output": {"random_dominance": 0, "truthful_dominance": 32}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rpi-scales/account-recovery", "path": "/tools/game_theory_voting.py", "msgidx": 820}}
{"problem_description": "Given the structure of a B+ Tree, which is a type of balanced tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time, how many maximum and minimum keys can be stored in a B+ Tree with a specific order and height?", "io_requirements": "Input:\n  `order` (int): The maximum number of keys in a record, which defines the order of the B+ Tree.\n  `height` (int): The height of the B+ Tree.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `max_keys` (int): The maximum number of keys in the B+ Tree.\n    - `min_keys` (int): The minimum number of keys in the B+ Tree.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self):\n        raise NotImplementedError\n\nclass InnerNode(Node):\n    def __int__(self):\n        raise NotImplementedError\n\nclass LeafNode(Node):\n    def __int__(self):\n        self.level = None\n        self.slots = None\n        self.prev = None\n        self.next = None\n        self.sorted_keys = []\n        self.vals = []\n\nclass Cursor:\n    def __int__(self):\n        raise NotImplementedError\n\nclass Btree:\n    def __init__(self, max_deg):\n        self.root = None\n        self.max_deg = max_deg\n\n    def insert(self, key, val):\n        pass\n\n    def delete(self, key):\n        pass\n\n# main function\ndef main_solution(order, height):\n    # Calculate the maximum and minimum number of keys in a B+ tree with the given order and height\n    max_keys = order ** height\n    min_keys = 2 * (order // 2) ** (height - 1)\n    \n    # Return the results as a dictionary\n    return {\n        \"max_keys\": max_keys,\n        \"min_keys\": min_keys\n    }", "funcname": "main_solution", "ios": [{"input": {"order": 7, "height": 3}, "output": {"max_keys": 343, "min_keys": 18}}, {"input": {"order": 6, "height": 4}, "output": {"max_keys": 1296, "min_keys": 54}}, {"input": {"order": 10, "height": 5}, "output": {"max_keys": 100000, "min_keys": 1250}}, {"input": {"order": 9, "height": 5}, "output": {"max_keys": 59049, "min_keys": 512}}, {"input": {"order": 6, "height": 2}, "output": {"max_keys": 36, "min_keys": 6}}, {"input": {"order": 6, "height": 3}, "output": {"max_keys": 216, "min_keys": 18}}, {"input": {"order": 5, "height": 2}, "output": {"max_keys": 25, "min_keys": 4}}, {"input": {"order": 8, "height": 5}, "output": {"max_keys": 32768, "min_keys": 512}}, {"input": {"order": 5, "height": 5}, "output": {"max_keys": 3125, "min_keys": 32}}, {"input": {"order": 8, "height": 3}, "output": {"max_keys": 512, "min_keys": 32}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mikeliao97/learn_db", "path": "/btree.py", "msgidx": 809}}
{"problem_description": "Given a set of points in a 2D plane, what are the points that form the convex hull of the set? The convex hull is the smallest convex polygon that can enclose all the given points.", "io_requirements": "Input:\n  `points` (list of tuples): A list of tuples where each tuple represents a point in 2D space. Each tuple contains two float values representing the x and y coordinates of the point.\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the points that form the convex hull of the input points. Each tuple contains two float values representing the x and y coordinates of the point on the convex hull.", "refcode": "# import necessary packages\nimport math\nfrom enum import Enum\n\n# all class and function definitions in the code file, if any\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Line:\n    class Location(Enum):\n        LEFT = 1\n        ON = 2\n        RIGHT = 3\n\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n    def discriminate(self, point):\n        mark = (point.x - self.p1.x) * (self.p2.y - self.p1.y) - (point.y - self.p1.y) * (self.p2.x - self.p1.x)\n        if mark < 0:\n            return Line.Location.LEFT\n        elif mark > 0:\n            return Line.Location.RIGHT\n        else:\n            return Line.Location.ON\n\nclass Operations:\n    @staticmethod\n    def length(p1, p2):\n        return math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)\n\n    @staticmethod\n    def square(p1, p2, p3):\n        a = Operations.length(p1, p2)\n        b = Operations.length(p2, p3)\n        c = Operations.length(p1, p3)\n        p = (a + b + c) / 2\n        return math.sqrt(p * (p - a) * (p - b) * (p - c))\n\n    @staticmethod\n    def polar_angle(origin, point):\n        x = point.x - origin.x\n        y = point.y - origin.y\n        if x != 0:\n            return math.atan2(y, x)\n        else:\n            if y > 0:\n                return math.pi / 2\n            elif y < 0:\n                return 3 * math.pi / 2\n            else:\n                return None\n\n    @staticmethod\n    def sort_by_polar_angle(points):\n        x_average = sum(p.x for p in points) / len(points)\n        y_average = sum(p.y for p in points) / len(points)\n        centroid = Point(x_average, y_average)\n        points.sort(key=lambda p: Operations.polar_angle(centroid, p))\n\nclass QuickHull:\n    epsilon = 1\n\n    @staticmethod\n    def execute(points):\n        if len(points) == 0:\n            return None\n\n        first_point = min(points, key=lambda p: p.x)\n        second_point = Point(first_point.x, first_point.y - QuickHull.epsilon)\n        points.append(second_point)\n\n        result = QuickHull.__quickhull(points, Line(first_point, second_point))\n        points.remove(second_point)\n        result.remove(second_point)\n\n        return result\n\n    @staticmethod\n    def __quickhull(points, line):\n        if len(points) == 2:\n            Operations.sort_by_polar_angle(points)\n            return points\n\n        farthest_point = max(points, key=lambda p: Operations.square(p, line.p1, line.p2))\n        left_line = Line(line.p1, farthest_point)\n        right_line = Line(farthest_point, line.p2)\n        left_points = []\n        right_points = []\n\n        for point in points:\n            pos_left = left_line.discriminate(point)\n            pos_right = right_line.discriminate(point)\n            if pos_left == Line.Location.LEFT or pos_left == Line.Location.ON:\n                left_points.append(point)\n            if pos_right == Line.Location.LEFT or pos_right == Line.Location.ON:\n                right_points.append(point)\n\n        result_left = QuickHull.__quickhull(left_points, left_line)\n        result_right = QuickHull.__quickhull(right_points, right_line)\n        result_right.remove(farthest_point)\n\n        return result_left + result_right\n\n# main function\ndef main_solution(points):\n    # Convert input list of tuples to list of Point objects\n    point_objects = [Point(x, y) for x, y in points]\n    \n    # Execute QuickHull algorithm\n    hull_points = QuickHull.execute(point_objects)\n    \n    # Convert result back to list of tuples\n    result = [(point.x, point.y) for point in hull_points]\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"points": [[78.53232863502019, 95.0564842838348], [61.191896874119486, 32.09275034497191], [95.12596619578491, 84.11587924727972], [81.55362212183636, 39.324725195877896]]}, "output": [[61.191896874119486, 32.09275034497191], [78.53232863502019, 95.0564842838348], [95.12596619578491, 84.11587924727972], [81.55362212183636, 39.324725195877896]]}, {"input": {"points": [[65.90267995025839, 61.71344664709544], [98.28311017816779, 57.46224766280985], [86.92925796471151, 41.47285932393683], [9.394862060550102, 50.550829951535704]]}, "output": [[9.394862060550102, 50.550829951535704], [65.90267995025839, 61.71344664709544], [98.28311017816779, 57.46224766280985], [86.92925796471151, 41.47285932393683]]}, {"input": {"points": [[76.15947131823421, 10.685304553318986], [86.25973459413923, 32.00895731031651], [1.1035842469606094, 63.24073194560238], [26.827699881518598, 86.77423422564497], [6.207192486827562, 74.9995063198904], [55.985133641675745, 74.9634440772669]]}, "output": [[1.1035842469606094, 63.24073194560238], [6.207192486827562, 74.9995063198904], [26.827699881518598, 86.77423422564497], [55.985133641675745, 74.9634440772669], [86.25973459413923, 32.00895731031651], [76.15947131823421, 10.685304553318986]]}, {"input": {"points": [[77.66438317746889, 2.5594551534136922], [38.174366378572756, 0.38047156444875885], [77.57262903853118, 37.15692505286617], [52.34085906837189, 11.465186084416834], [33.29720882927069, 87.25531399516304], [77.96150350651544, 51.67054792803037]]}, "output": [[77.96150350651544, 51.67054792803037], [33.29720882927069, 87.25531399516304], [77.66438317746889, 2.5594551534136922], [38.174366378572756, 0.38047156444875885]]}, {"input": {"points": [[35.63127567569807, 98.93311180151342], [76.13139293764839, 79.1523487279596], [38.557493643371934, 43.370187284735614]]}, "output": [[76.13139293764839, 79.1523487279596], [35.63127567569807, 98.93311180151342], [38.557493643371934, 43.370187284735614]]}, {"input": {"points": [[83.64591685635432, 33.62444585359105], [85.19749532378366, 44.445803981342635], [26.055031581306164, 95.67918057932704], [74.44076241158062, 5.8594074375042045], [40.28156885299098, 39.191944342765396], [65.81379550646548, 14.413455501362016]]}, "output": [[85.19749532378366, 44.445803981342635], [26.055031581306164, 95.67918057932704], [83.64591685635432, 33.62444585359105], [74.44076241158062, 5.8594074375042045], [40.28156885299098, 39.191944342765396]]}, {"input": {"points": [[98.30388483683188, 2.6690011402527913], [59.87581325591215, 24.6891284047707], [84.02416920291856, 70.9708801141962]]}, "output": [[59.87581325591215, 24.6891284047707], [84.02416920291856, 70.9708801141962], [98.30388483683188, 2.6690011402527913]]}, {"input": {"points": [[78.27647092496568, 83.04703665013972], [5.227191893629146, 98.89243068206471], [26.561488370702, 31.05068971826508], [70.51770827808328, 20.534572444949728], [85.33744684448702, 33.31872983497228], [36.24391529330988, 10.163285791955456]]}, "output": [[78.27647092496568, 83.04703665013972], [5.227191893629146, 98.89243068206471], [85.33744684448702, 33.31872983497228], [70.51770827808328, 20.534572444949728], [36.24391529330988, 10.163285791955456], [26.561488370702, 31.05068971826508]]}, {"input": {"points": [[8.684504100523437, 5.168416070106718], [46.078878032709426, 89.85682117389189], [97.22070298450265, 8.367813402700108], [4.52145759807514, 28.724927225748807]]}, "output": [[4.52145759807514, 28.724927225748807], [46.078878032709426, 89.85682117389189], [97.22070298450265, 8.367813402700108], [8.684504100523437, 5.168416070106718]]}, {"input": {"points": [[73.84362879198105, 21.56594365933725], [25.593245052611902, 82.92882610732703], [23.16284368809557, 47.85124835996779], [40.65505968031844, 65.46618319660425], [38.06380818238293, 66.01588649301979], [62.70150289940592, 52.60353991140623]]}, "output": [[23.16284368809557, 47.85124835996779], [25.593245052611902, 82.92882610732703], [62.70150289940592, 52.60353991140623], [73.84362879198105, 21.56594365933725]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sozzo/Computer_Graphics", "path": "/Lab5/main.py", "msgidx": 699}}
{"problem_description": "Given a number, how many steps does it take to reach the center of a spiral grid, and what is the first value written in the spiral grid that is larger than the given number?", "io_requirements": "Input:\n  `the_input` (int): An integer representing the input number for which we need to calculate the steps to the center and the first larger value in a spiral grid.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `total_steps_part1` (int): The number of steps required to reach the center from the given input in a spiral grid.\n    - `larger_value_part2` (int): The first value written in the spiral grid that is larger than the given input.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(the_input):\n    # Convert the input to an integer if it's not already\n    the_input = int(the_input)\n\n    # Part 1: Calculate the number of steps to reach the center from the given input\n    total_steps_part1 = part1(the_input)\n\n    # Part 2: Calculate the first value written that is larger than the input\n    larger_value_part2 = part2(the_input)\n\n    # Return the results as a dictionary\n    return {\n        \"total_steps_part1\": total_steps_part1,\n        \"larger_value_part2\": larger_value_part2\n    }\n\n# Helper functions from the original code file\ndef part1(the_input):\n    left = (-1, 0)\n    right = (1, 0)\n    down = (0, -1)\n    up = (0, 1)\n\n    num = the_input\n\n    odd_num = get_odd_num(num)\n\n    top_right, top_left, bottom_left, bottom_right = get_corners(odd_num)\n\n    steps_to_square = []\n\n    steps_to_square += [right] * max((bottom_right - max(num, bottom_left)), 0)\n    steps_to_square += [down] * max((bottom_left - max(num, top_left)), 0)\n    steps_to_square += [left] * max((top_left - max(num, top_right)), 0)\n    steps_to_square += [up] * max((top_right - num), 0)\n\n    steps_from_square = steps_from_odd_square(odd_num)\n\n    steps_to_one = steps_to_square + steps_from_square\n\n    total_steps_to_one = [0, 0]\n    for x, y in steps_to_one:\n        total_steps_to_one[0] += x\n        total_steps_to_one[1] += y\n\n    total_steps = sum(abs(steps) for steps in total_steps_to_one)\n\n    return total_steps\n\ndef part2(the_input):\n    LEFT = (0, -1)\n    RIGHT = (0, 1)\n    DOWN = (1, 0)\n    UP = (-1, 0)\n\n    the_grid = [[0 for x in range(11)] for y in range(11)]\n\n    the_grid[5][5] = 1\n\n    def next_index(x, y):\n        offset = -5\n\n        x = x + offset\n        y = y + offset\n\n        N = max(abs(coord) for coord in (x, y))\n\n        on_bottom = x == N\n        on_right = y == N\n        on_top = x == -N\n        on_left = y == -N\n\n        if on_bottom:\n            direction = RIGHT\n        elif on_left:\n            direction = DOWN\n        elif on_top:\n            direction = LEFT\n        elif on_right:\n            direction = UP\n\n        the_next = (x + direction[0], y + direction[1])\n\n        the_next = (the_next[0] - offset, the_next[1] - offset)\n\n        return the_next\n\n    def surrounding_indices(x, y):\n        return [\n            (x - 1, y - 1),\n            (x - 1, y),\n            (x - 1, y + 1),\n            (x, y + 1),\n            (x + 1, y + 1),\n            (x + 1, y),\n            (x + 1, y - 1),\n            (x, y - 1)\n        ]\n\n    def surrounding_sum(x, y):\n        return sum(the_grid[x][y] for x, y in surrounding_indices(x, y))\n\n    current_index = (5, 5)\n    new_value = 0\n    while new_value <= the_input:\n        current_index = next_index(*current_index)\n        new_value = surrounding_sum(*current_index)\n        x, y = current_index\n        the_grid[x][y] = new_value\n\n    return new_value\n\ndef steps_from_odd_square(odd_num):\n    left = (-1, 0)\n    up = (0, 1)\n\n    if odd_num == 1:\n        return []\n    else:\n        return [left, up] + steps_from_odd_square(odd_num - 2)\n\ndef get_odd_num(num):\n    the_num = math.ceil(math.sqrt(num))\n    is_even = the_num % 2 == 0\n\n    if is_even:\n        the_num += 1\n\n    return the_num\n\ndef get_corners(num):\n    top_right = (num ** 2) - (3*num) + 3\n    top_left = (num ** 2) - (2*num) + 2\n    bottom_left = (num ** 2) - num + 1\n    bottom_right = num ** 2\n\n    return [top_right, top_left, bottom_left, bottom_right]", "funcname": "main_solution", "ios": [{"input": {"the_input": 542}, "output": {"total_steps_part1": 13, "larger_value_part2": 747}}, {"input": {"the_input": 369}, "output": {"total_steps_part1": 12, "larger_value_part2": 747}}, {"input": {"the_input": 949}, "output": {"total_steps_part1": 18, "larger_value_part2": 957}}, {"input": {"the_input": 532}, "output": {"total_steps_part1": 21, "larger_value_part2": 747}}, {"input": {"the_input": 371}, "output": {"total_steps_part1": 10, "larger_value_part2": 747}}, {"input": {"the_input": 144}, "output": {"total_steps_part1": 11, "larger_value_part2": 147}}, {"input": {"the_input": 439}, "output": {"total_steps_part1": 18, "larger_value_part2": 747}}, {"input": {"the_input": 569}, "output": {"total_steps_part1": 16, "larger_value_part2": 747}}, {"input": {"the_input": 402}, "output": {"total_steps_part1": 19, "larger_value_part2": 747}}, {"input": {"the_input": 566}, "output": {"total_steps_part1": 13, "larger_value_part2": 747}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "michaeljb/advent-of-code-2017", "path": "/day3.py", "msgidx": 302}}
{"problem_description": "Given a sequence of integers, determine if it represents the post-order traversal of a Binary Search Tree (BST). What is the result indicating whether the sequence is a valid post-order traversal of a BST?", "io_requirements": "Input:\n  `sequence` (list of integers): A list of integers representing the sequence to be checked.\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a Binary Search Tree. The possible values are \"Yes\" or \"No\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        \"\"\"\n        :param sequence: \u8f93\u5165\u5e8f\u5217\n        :return: \u5224\u65ad\u662f\u5426\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\n        \"\"\"\n        if not sequence:\n            return False\n        # \u6839\u8282\u70b9\n        root = sequence[-1]\n        # \u786e\u5b9a\u5de6\u5b50\u6811\u5e8f\u5217\n        index = 0\n        while index < len(sequence) - 1:\n            if sequence[index] > root:\n                break\n            index += 1\n        # check \u540e\u9762\u7684\u6570\u5b57\u5747\u662f\u5927\u4e8eroot\u7684\n        for i in range(index, len(sequence) - 1):\n            if sequence[i] < root:\n                return False\n        left = True\n        if sequence[:index]:\n            left = self.VerifySquenceOfBST(sequence[:index])\n        right = True\n        if sequence[index:-1]:\n            right = self.VerifySquenceOfBST(sequence[index:-1])\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.VerifySquenceOfBST(sequence)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return \"Yes\" if result else \"No\"", "funcname": "main_solution", "ios": [{"input": {"sequence": [9, 12, 17]}, "output": "Yes"}, {"input": {"sequence": [16, 17, 11, 10, 12]}, "output": "No"}, {"input": {"sequence": [16, 2, 3]}, "output": "No"}, {"input": {"sequence": [10, 14, 6, 8, 5, 2, 17, 18]}, "output": "No"}, {"input": {"sequence": [8, 1, 19, 16, 2, 4, 5, 15]}, "output": "No"}, {"input": {"sequence": [17, 8, 16, 18, 9]}, "output": "No"}, {"input": {"sequence": [16, 18, 8, 3, 14, 2, 1, 19]}, "output": "No"}, {"input": {"sequence": [8, 10, 19, 7, 9, 2, 18, 15, 3]}, "output": "No"}, {"input": {"sequence": [19, 11, 16, 14]}, "output": "No"}, {"input": {"sequence": [11, 6, 10, 1, 2, 3, 12, 14]}, "output": "No"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Rodin2333/Algorithm", "path": "/\u5251\u6307offer/23\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217.py", "msgidx": 1140}}
{"problem_description": "Given a positive integer `N`, what is the smallest integer sequence of length `N` that does not contain any repeated subsequences of length 2 or more?", "io_requirements": "Input:\n  `N` (int): The length of the sequence to be generated. It should be a positive integer.\n\nOutput:\n  `return` (int): The smallest integer sequence of length `N` that does not contain any repeated subsequences of length 2 or more. If no such sequence exists, the function will return `None`.", "refcode": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(N):\n    # Convert the input to the required format for the back_tracking function\n    N = int(N)\n    \n    # Define the back_tracking function to be used within main_solution\n    def back_tracking(answer, idx):\n        # Check for duplicate subsequences\n        for i in range(1, (idx//2)+1):\n            if answer[-i:] == answer[-2*i:-i]:\n                return\n        # If the answer length matches N, return the answer as an integer\n        if idx == N:\n            return int(answer)\n\n        # Recursively try adding '1', '2', or '3' to the answer\n        for i in ['1', '2', '3']:\n            result = back_tracking(answer + i, idx + 1)\n            if result is not None:\n                return result\n    \n    # Start the back_tracking process with initial answer '1' and index 1\n    return back_tracking('1', 1)", "funcname": "main_solution", "ios": [{"input": {"N": 9}, "output": 121312313}, {"input": {"N": 4}, "output": 1213}, {"input": {"N": 8}, "output": 12131231}, {"input": {"N": 3}, "output": 121}, {"input": {"N": 5}, "output": 12131}, {"input": {"N": 2}, "output": 12}, {"input": {"N": 7}, "output": 1213121}, {"input": {"N": 10}, "output": 1213123132}, {"input": {"N": 1}, "output": 1}, {"input": {"N": 6}, "output": 121312}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Yejin6911/Algorithm", "path": "/\ubc31\uc900/BJ_2661.py", "msgidx": 997}}
{"problem_description": "In a Tic-Tac-Toe game, what is the current status of the game given the current board configuration? Specifically, who is the winner, if any, or is the game still ongoing?", "io_requirements": "Input:\n  `board_state` (list of lists): A 3x3 list representing the current state of the Tic-Tac-Toe board.\n                                 0 represents an empty cell, 1 represents a circle (O), and -1 represents a cross (X).\n\nOutput:\n  `return` (str): The winner of the game. \"Circle\" if circle wins, \"Cross\" if cross wins, \"Draw\" if the game is a draw,\n                  or \"Ongoing\" if the game is still ongoing.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Tictac:\n    \"\"\"\n        Tictac module\n        circle is 1, cross is -1\n        reward for circle win is 1,\n        reward for cross win or draw is -1\n    \"\"\"\n\n    def __init__(self):\n        self.ended = False\n        self.board = np.zeros([3, 3], np.int8)\n        self.color = 1\n        self.winner = 0\n\n    def search_possible_steps(self):\n        \"\"\"search possible steps, return all steps available as an array\"\"\"\n        if self.ended:\n            return False\n        possible_steps_turple = (self.board == 0)\n        possible_steps = np.transpose(possible_steps_turple.nonzero())\n        return possible_steps\n\n    def get_next_states(self):\n        \"\"\"get possible steps\"\"\"\n        if self.ended:\n            return False\n        possible_steps = self.search_possible_steps()\n        n = possible_steps.shape[0]\n        next_states = np.zeros([n, 3, 3], dtype=np.int8)\n        for i in range(n):\n            x, y = possible_steps[i]\n            next_states[i][x][y] = self.color\n            next_states[i] = next_states[i] + self.board\n        return next_states\n\n    def get_reward(self, actions, next_states):\n        \"\"\"check one of the board, if game has ended\n            define circle as 1, cross as -1\n            if circle wins return reward 1\n            else return reward 0\n        \"\"\"\n        r = []\n        for state in next_states:\n            ended, winner = self.judge_terminal(state)\n            if ended:\n                r.append(winner)\n            else:\n                r.append(0)\n        return np.array(r)\n\n    def play(self, position):\n        \"\"\"play at certain position\"\"\"\n        (x, y) = position\n        if self.board[x][y] != 0:\n            return 'Error'\n        else:\n            self.board[x][y] = self.color\n            self.color = self.color * -1\n            (terminated, winner) = self.judge_terminal()\n            if terminated:\n                self.ended = True\n                self.winner = winner\n                return winner\n\n    def judge_terminal(self, state=False):\n        \"\"\"return terminal State and winner\"\"\"\n        if type(state) == np.ndarray:\n            board = state\n        else:\n            board = self.board\n        diagsum1 = board[0][0] + board[1][1] + board[2][2]\n        diagsum2 = board[0][2] + board[1][1] + board[2][0]\n        if np.any(np.sum(board, 0) == 3) or np.any(np.sum(board, 1) == 3) \\\n                or diagsum1 == 3 or diagsum2 == 3:\n            return (True, 1)\n        elif np.any(np.sum(board, 0) == -3) or np.any(np.sum(board, 1) == -3) \\\n                or diagsum1 == -3 or diagsum2 == -3:\n            return (True, -1)\n        elif np.all(board != 0):\n            return (True, 0)\n        else:\n            return (False, 0)\n\n    def reset(self):\n        \"\"\"reset\"\"\"\n        self = self.__init__()\n        return self\n\n# main function\ndef main_solution(board_state):\n    \"\"\"\n    Main function to determine the winner of a Tic-Tac-Toe game based on the current board state.\n    \n    Parameters:\n    board_state (list of lists): A 3x3 list representing the current state of the Tic-Tac-Toe board.\n                                 0 represents an empty cell, 1 represents a circle (O), and -1 represents a cross (X).\n    \n    Returns:\n    str: The winner of the game. \"Circle\" if circle wins, \"Cross\" if cross wins, \"Draw\" if the game is a draw,\n         or \"Ongoing\" if the game is still ongoing.\n    \"\"\"\n    game = Tictac()\n    game.board = np.array(board_state, dtype=np.int8)\n    terminated, winner = game.judge_terminal()\n    if terminated:\n        if winner == 1:\n            return \"Circle\"\n        elif winner == -1:\n            return \"Cross\"\n        else:\n            return \"Draw\"\n    else:\n        return \"Ongoing\"", "funcname": "main_solution", "ios": [{"input": {"board_state": [[-1, -1, 1], [-1, 0, -1], [-1, 0, 1]]}, "output": "Cross"}, {"input": {"board_state": [[-1, 1, 1], [0, 1, -1], [-1, -1, 1]]}, "output": "Ongoing"}, {"input": {"board_state": [[0, 0, 0], [1, -1, 0], [-1, -1, -1]]}, "output": "Cross"}, {"input": {"board_state": [[-1, 0, 0], [-1, 1, 1], [-1, 1, 0]]}, "output": "Cross"}, {"input": {"board_state": [[1, 1, -1], [-1, 1, 1], [-1, -1, 0]]}, "output": "Ongoing"}, {"input": {"board_state": [[0, 0, 0], [-1, -1, 0], [0, 0, -1]]}, "output": "Ongoing"}, {"input": {"board_state": [[1, 1, 0], [1, 1, -1], [-1, 0, 0]]}, "output": "Ongoing"}, {"input": {"board_state": [[1, 1, 0], [-1, 0, 0], [1, -1, -1]]}, "output": "Ongoing"}, {"input": {"board_state": [[-1, 1, 1], [-1, 1, -1], [-1, 1, -1]]}, "output": "Circle"}, {"input": {"board_state": [[0, 1, 0], [0, -1, -1], [-1, -1, 1]]}, "output": "Ongoing"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sepmein/tictac", "path": "/hulihutu/tictac.py", "msgidx": 143}}
{"problem_description": "In a social network, users have established friendships with each other. Given a user, what is the most recommended new friend based on mutual friends of friends, and how frequently does this recommended friend appear in the mutual friends list?", "io_requirements": "Input:\n  `user_id` (int): The ID of the user for whom the recommendation should be done. It should be an integer between 0 and 9.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `recommended_friend_id` (int or None): The ID of the recommended friend. If no recommendation is available, it will be `None`.\n    - `recommended_friend_name` (str or None): The name of the recommended friend. If no recommendation is available, it will be `None`.\n    - `frequency` (int): The frequency of the recommended friend in the friends of friends list. If no recommendation is available, it will be `0`.", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# users data structure - list of dictionaries\nusers = [\n    {\"id\": 0, \"name\": \"Hero\"},\n    {\"id\": 1, \"name\": \"Dunn\"},\n    {\"id\": 2, \"name\": \"Sue\"},\n    {\"id\": 3, \"name\": \"Chi\"},\n    {\"id\": 4, \"name\": \"Thor\"},\n    {\"id\": 5, \"name\": \"Clive\"},\n    {\"id\": 6, \"name\": \"Hicks\"},\n    {\"id\": 7, \"name\": \"Devin\"},\n    {\"id\": 8, \"name\": \"Kate\"},\n    {\"id\": 9, \"name\": \"Klein\"},\n]\n\n# friendship data structure\nfriendship = [(0,1),(0,2),(1,2),(1,3),(2,3),(3,4),(4,5),(5,6),(5,7),(6,8),(7,8),(8,9)]\n\n# Build list of friends for every user\nfor user in users:\n    user[\"friends\"] = []\n\nfor i, j in friendship:\n    users[i][\"friends\"].append(users[j])\n    users[j][\"friends\"].append(users[i])\n\ndef not_the_same(user, other_user):\n    return user[\"id\"] != other_user[\"id\"]\n\ndef not_friends(user, other_user):\n    return all(not_the_same(user, friend) for friend in other_user[\"friends\"])\n\ndef friends_of_friend_ids(user):\n    return Counter(foaf[\"id\"]\n                   for friend in user[\"friends\"]\n                   for foaf in friend[\"friends\"]\n                   if not_the_same(user, foaf)\n                   and not_friends(user, foaf))\n\n# main function\ndef main_solution(user_id):\n    # Convert user_id to the corresponding user dictionary\n    user = next(user for user in users if user[\"id\"] == user_id)\n    \n    # Get the friends of friends count\n    foaf_counter = friends_of_friend_ids(user)\n    \n    # Extract the most common friend of friends\n    if len(foaf_counter) > 0:\n        recommended_friend_id, frequency = foaf_counter.most_common(1)[0]\n        recommended_friend_name = next(user[\"name\"] for user in users if user[\"id\"] == recommended_friend_id)\n    else:\n        recommended_friend_id, recommended_friend_name, frequency = None, None, 0\n    \n    # Return the result as a dictionary\n    return {\n        \"recommended_friend_id\": recommended_friend_id,\n        \"recommended_friend_name\": recommended_friend_name,\n        \"frequency\": frequency\n    }", "funcname": "main_solution", "ios": [{"input": {"user_id": 2}, "output": {"recommended_friend_id": 4, "recommended_friend_name": "Thor", "frequency": 1}}, {"input": {"user_id": 4}, "output": {"recommended_friend_id": 1, "recommended_friend_name": "Dunn", "frequency": 1}}, {"input": {"user_id": 6}, "output": {"recommended_friend_id": 7, "recommended_friend_name": "Devin", "frequency": 2}}, {"input": {"user_id": 8}, "output": {"recommended_friend_id": 5, "recommended_friend_name": "Clive", "frequency": 2}}, {"input": {"user_id": 0}, "output": {"recommended_friend_id": 3, "recommended_friend_name": "Chi", "frequency": 2}}, {"input": {"user_id": 3}, "output": {"recommended_friend_id": 0, "recommended_friend_name": "Hero", "frequency": 2}}, {"input": {"user_id": 5}, "output": {"recommended_friend_id": 8, "recommended_friend_name": "Kate", "frequency": 2}}, {"input": {"user_id": 9}, "output": {"recommended_friend_id": 6, "recommended_friend_name": "Hicks", "frequency": 1}}, {"input": {"user_id": 7}, "output": {"recommended_friend_id": 6, "recommended_friend_name": "Hicks", "frequency": 2}}, {"input": {"user_id": 1}, "output": {"recommended_friend_id": 4, "recommended_friend_name": "Thor", "frequency": 1}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zizu1985/100daysOfDataScience", "path": "/day2/recommender_systems.py", "msgidx": 861}}
{"problem_description": "Given a binary tree represented as a list in level order traversal, determine whether the tree adheres to the properties of a Min-Max heap. A Min-Max heap is a type of binary heap where nodes at even levels (0, 2, 4, ...) are smaller than their descendants, and nodes at odd levels (1, 3, 5, ...) are larger than their descendants. What is the result indicating whether the given binary tree is a valid Min-Max heap?", "io_requirements": "Input:\n  `mm_heap` (list of integers): A list representing the binary tree in level order traversal. Each element in the list corresponds to a node in the binary tree.\n\nOutput:\n  `return` (boolean): A boolean value indicating whether the given binary tree is a valid Min-Max heap. Returns `True` if it is a valid Min-Max heap, otherwise `False`.", "refcode": "# import necessary packages\nimport sys\n\n# all class and function definitions in the code file, if any\nclass MinMaxHeap:\n    def isMinMax(self, mm_heap):\n        # determine number of levels\n        ch = True\n        i = 1\n        while ch:\n            leng = 0\n            for j in range(i+1):\n                leng += 2**j\n            if leng >= len(mm_heap):\n                rem = leng - len(mm_heap)\n                ch = False   \n            i += 1\n        levels = i\n        if levels % 2 == 0:\n            dummy = sys.maxsize\n        else: dummy = -sys.maxsize\n\n        # add missing leaves to heap array for next step\n        for i in range(rem):\n            mm_heap.append(dummy)        \n                \n        heap = [None]*(levels+1) \n        for i in range(1, levels+1):\n            heap[i] = [0]*(2**(i-1))\n            for j in range(len(heap[i])):\n                heap[i][j] = mm_heap[(2**(i-1))+j-1]\n\n        for i in range(1, len(heap)):\n            heap[i].insert(0, None)\n\n        result = True\n        for i in range(1, levels):\n            for j in range(1, len(heap[i])):\n                if i % 2 == 1:              #if level is odd\n                    if heap[i][j] > heap[i+1][(2*j)-1] or heap[i][j] > heap[i+1][2*j]:\n                        result = False\n                        break\n                else:                       # if level is even\n                    if heap[i][j] < heap[i+1][(2*j)-1] or heap[i][j] < heap[i+1][2*j]:\n                        result = False\n                        break\n        return result\n\n# main function\ndef main_solution(mm_heap):\n    # Convert input to list if it's not already\n    if not isinstance(mm_heap, list):\n        mm_heap = list(mm_heap)\n    \n    # Create an instance of MinMaxHeap and check if the heap is valid\n    heap_checker = MinMaxHeap()\n    result = heap_checker.isMinMax(mm_heap)\n    \n    # Return the result as a boolean\n    return result", "funcname": "main_solution", "ios": [{"input": {"mm_heap": [99, 13, 15, 8, 25, 79, -9223372036854775807]}, "output": false}, {"input": {"mm_heap": [85, 78, 8, 81, 51, 57, 33, 54, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807]}, "output": false}, {"input": {"mm_heap": [21, 97, 4, 83, 6, 56, -9223372036854775807]}, "output": false}, {"input": {"mm_heap": [56, 62, 74, 89, 63, 5, 21]}, "output": false}, {"input": {"mm_heap": [59, 84, 26, 69, 60, 7, 31, 50, 98, 46, 2, 67, 31, 9223372036854775807, 9223372036854775807]}, "output": false}, {"input": {"mm_heap": [60, 70, 78, 58, 52, 34, 5, 96, 64, 3, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807]}, "output": false}, {"input": {"mm_heap": [68, 89, 51, 30, 78, 26, -9223372036854775807]}, "output": false}, {"input": {"mm_heap": [86, 33, 92, 12, 47, 95, 56, 14, 76, 100, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807]}, "output": false}, {"input": {"mm_heap": [64, 61, 96, 17, 70, 32, 10, 14, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807]}, "output": false}, {"input": {"mm_heap": [88, 36, 51, 57, 17, 5, 99, 15, 19, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807, 9223372036854775807]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "brada1/Algo-1", "path": "/week3/2-Min-Max-Heap/min_max_heap.py", "msgidx": 688}}
{"problem_description": "Given a chessboard of size NxN, where N is a positive integer, determine if it is possible to place N queens on the board such that no two queens threaten each other. A queen can move horizontally, vertically, and diagonally. What is the result of whether a solution exists for a randomly generated board size N?", "io_requirements": "Input:\n  `N` (int): The size of the NxN chessboard and the number of queens to be placed.\n\nOutput:\n  `return` (dict): A dictionary with a single key `solution_exists` which is a boolean indicating whether a solution exists for the given N.", "refcode": "# import necessary packages\nimport numpy as np\n\n# the function that checks the validity of placing a Queen in a specific row and column\ndef is_valid(board, N, row, col):\n    # checking if the current row has any other queen\n    if max(board[row, :]) == 1:\n        return False\n\n    # checking upper left diagonal\n    k = row - 1\n    l = col - 1\n    while (k >= 0 and l >= 0):\n        if (board[k, l] == 1):\n            return False\n        k = k - 1\n        l = l - 1\n\n    # checking lower left diagonal\n    k = row + 1\n    l = col - 1\n    while (k < N and l >= 0):\n        if (board[k, l] == 1):\n            return False\n        k = k + 1\n        l = l - 1\n    return True\n\n# this function is called recursively to explore the solutions and stops when we reach one of the solutions\ndef placeQueen(board, N, col):\n    # if we placed all the queens correctly and we found a solution\n    if (col == N):\n        return True\n    # for each row in the board do the following\n    for row in range(0, N):\n        if (is_valid(board, N, row, col)):\n            board[row, col] = 1\n\n            if (placeQueen(board, N, col + 1) == True):\n                return True\n            board[row, col] = 0\n    return False  # this happens if no possible solution found (when 1 < N < 4)\n\n# main function\ndef main_solution(N):\n    # Convert input to integer\n    N = int(N)\n    \n    # Create the board\n    board = np.zeros((N, N), dtype=int)\n    \n    # Check if a solution exists\n    solution_exists = placeQueen(board, N, 0)\n    \n    # Return the result as a dictionary\n    return {\"solution_exists\": solution_exists}", "funcname": "main_solution", "ios": [{"input": {"N": 3}, "output": {"solution_exists": false}}, {"input": {"N": 1}, "output": {"solution_exists": true}}, {"input": {"N": 7}, "output": {"solution_exists": true}}, {"input": {"N": 6}, "output": {"solution_exists": true}}, {"input": {"N": 4}, "output": {"solution_exists": true}}, {"input": {"N": 8}, "output": {"solution_exists": true}}, {"input": {"N": 2}, "output": {"solution_exists": false}}, {"input": {"N": 9}, "output": {"solution_exists": true}}, {"input": {"N": 5}, "output": {"solution_exists": true}}, {"input": {"N": 10}, "output": {"solution_exists": true}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Khaled-Abdelhamid/N-queens-problem", "path": "/main.py", "msgidx": 960}}
{"problem_description": "Given a set of strings, each containing a sequence of characters, determine all possible ways to order the characters such that for any given string, the characters appear in the same relative order as in the string. What are the possible ordered sequences of characters that satisfy these constraints?", "io_requirements": "Input:\n  `input_lines` (list of strings): A list where each string represents a line of input. Each string contains characters that need to be ordered based on their precedence.\n\nOutput:\n  `return` (list of strings): A list of all possible ordered sequences of characters that satisfy the precedence constraints defined by the input lines.", "refcode": "# import necessary packages\nfrom itertools import *\n\n# all class and function definitions in the code file, if any\nclass Problem:\n    \"\"\"\n    Generic class to solve the problems\n    \"\"\"\n\n    __passChars = []\n    __charsMap = {}\n    __solutions = []\n\n    def __appenPredSuc(self, inChar, inCharToAdd):\n        try:\n            self.__charsMap[inChar].index(inCharToAdd)\n        except:\n            self.__charsMap[inChar].append(inCharToAdd)\n\n    def __removeChar(self, inChar, inCharsMap):\n        \"\"\" Remove a character from the list and the antecers \"\"\"\n        result = {}\n        for char, connections in inCharsMap.items():\n            if char != inChar:\n                result[char] = []\n\n                for prev in connections:\n                    if prev != inChar:\n                        result[char].append(prev)\n        return result\n\n    def __getFirstChars(self, inCharsMap):\n        \"\"\" Get the character without antecesors \"\"\"\n        charsMap = inCharsMap\n        possibleChars = []\n        for char, connections in inCharsMap.items():\n            if len(connections) == 0:\n                possibleChars.append(char)\n\n        return possibleChars\n\n    def __calcSolutions(self, inCharsMap, inCurrentSol = ''):\n        \"\"\" Recursive method, gets all the possible solutions and store it in self.__solutions \"\"\"\n        if len(inCharsMap) == 0:\n            self.__solutions.append(inCurrentSol)\n        else:\n            chars = self.__getFirstChars(inCharsMap)\n\n            for char in chars:\n                self.__calcSolutions(self.__removeChar(char, inCharsMap), inCurrentSol + char)\n\n    def solve(self):\n        \"\"\"\n        Method that reolves te problem and resturns the solutions in an array of strings\n        \"\"\"\n\n        ret = []\n\n        for passChars in self.__passChars:\n            for charPos in range(0, len(passChars)):\n                if self.__charsMap.get(passChars[charPos], False) == False:\n                    self.__charsMap[passChars[charPos]] = []\n\n                for charSubPos in range(0, len(passChars)):\n                    if charPos > charSubPos:\n                        self.__appenPredSuc(passChars[charPos], passChars[charSubPos])\n\n        self.__calcSolutions(self.__charsMap)\n\n        return sorted(self.__solutions)\n\n    def __init__(self, inInputLines):\n        \"\"\" Takes and parse the input lines into the internal structure \"\"\"\n        for line in inInputLines:\n            self.__passChars.append(line)\n\n# main function\ndef main_solution(input_lines):\n    # input_lines is a list of strings, each string representing a line of input\n    problem = Problem(input_lines)\n    solutions = problem.solve()\n    # Convert the list of solutions to a JSON serializable format\n    return solutions", "funcname": "main_solution", "ios": [{"input": {"input_lines": ["jvdjes", "dmyy"]}, "output": []}, {"input": {"input_lines": ["wamyf", "gpdhlx", "wpw"]}, "output": []}, {"input": {"input_lines": ["ekkspk", "kwa"]}, "output": []}, {"input": {"input_lines": ["bfc", "tejvke", "nelzvw"]}, "output": []}, {"input": {"input_lines": ["krxrv", "lef", "xwl"]}, "output": []}, {"input": {"input_lines": ["evib", "ctepg", "dgg", "mhy"]}, "output": []}, {"input": {"input_lines": ["rus", "syd", "stzjx"]}, "output": []}, {"input": {"input_lines": ["wstcod", "hzilj", "lauhv"]}, "output": []}, {"input": {"input_lines": ["obgsig", "yxj", "mop", "ytq"]}, "output": []}, {"input": {"input_lines": ["eihz", "qum", "flz", "ihnm"]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jsleetw/Tuenti-Programming-Challenge-2", "path": "/07_the_secure_password/secure.py", "msgidx": 118}}
{"problem_description": "Imagine you are navigating a hexagonal grid where each move can be one of six directions: north (n), northeast (ne), southeast (se), south (s), southwest (sw), or northwest (nw). Given a sequence of such moves, what are the final coordinates, the final distance from the starting point, and the maximum distance reached during the journey?", "io_requirements": "Input:\n  `directions` (str): A string of comma-separated directions representing movements on a hexagonal grid. Each direction can be one of 'n', 'ne', 'se', 's', 'sw', 'nw'.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `final_position` (dict): A dictionary representing the final coordinates after all movements. It contains keys `x`, `y`, and `z` with integer values.\n    - `final_distance` (int): An integer representing the number of steps away from the starting point after all movements.\n    - `max_distance` (int): An integer representing the maximum distance from the starting point at any point during the movements.", "refcode": "# import necessary packages\nfrom collections import namedtuple\n\n# all class and function definitions in the code file, if any\nCoord = namedtuple('Coord', ['x', 'y', 'z'])\n\ndirection_map = {\n    'n': Coord(x=0, y=1, z=-1),\n    'ne': Coord(x=1, y=0, z=-1),\n    'se': Coord(x=1, y=-1, z=0),\n    's': Coord(x=0, y=-1, z=1),\n    'sw': Coord(x=-1, y=0, z=1),\n    'nw': Coord(x=-1, y=1, z=0),\n}\n\ndef cube_distance(a, b):\n    return (abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z)) / 2\n\ndef move(start, direction):\n    return Coord(\n        x=start.x + direction_map[direction].x,\n        y=start.y + direction_map[direction].y,\n        z=start.z + direction_map[direction].z)\n\n# main function\ndef main_solution(directions):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    directions = directions.split(',')\n    current = Coord(x=0, y=0, z=0)\n    start = Coord(x=0, y=0, z=0)\n    distances = list()\n    for direction in directions:\n        current = move(current, direction)\n        distances.append(cube_distance(start, current))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"final_position\": {\"x\": current.x, \"y\": current.y, \"z\": current.z},\n        \"final_distance\": cube_distance(start, current),\n        \"max_distance\": max(distances)\n    }", "funcname": "main_solution", "ios": [{"input": {"directions": "sw,n,n,se,nw,se,sw,sw,ne,se"}, "output": {"final_position": {"x": 0, "y": 0, "z": 0}, "final_distance": 0.0, "max_distance": 2.0}}, {"input": {"directions": "se,ne,ne,ne,ne,s,ne,n,s,s,ne,ne,sw,sw,sw,ne,n"}, "output": {"final_position": {"x": 6, "y": -2, "z": -4}, "final_distance": 6.0, "max_distance": 8.0}}, {"input": {"directions": "n,sw,s,n,se,sw,s"}, "output": {"final_position": {"x": -1, "y": -1, "z": 2}, "final_distance": 2.0, "max_distance": 2.0}}, {"input": {"directions": "s,n,se,n,ne,ne"}, "output": {"final_position": {"x": 3, "y": 0, "z": -3}, "final_distance": 3.0, "max_distance": 3.0}}, {"input": {"directions": "se,se"}, "output": {"final_position": {"x": 2, "y": -2, "z": 0}, "final_distance": 2.0, "max_distance": 2.0}}, {"input": {"directions": "se,sw,n,se,sw,s,s,ne,ne,s,n,se,ne,sw"}, "output": {"final_position": {"x": 3, "y": -4, "z": 1}, "final_distance": 4.0, "max_distance": 4.0}}, {"input": {"directions": "ne,s,ne,n,n,nw,nw,nw,sw,sw,nw,s,se,sw,nw,se,sw"}, "output": {"final_position": {"x": -5, "y": 3, "z": 2}, "final_distance": 5.0, "max_distance": 5.0}}, {"input": {"directions": "ne,ne,n,se"}, "output": {"final_position": {"x": 3, "y": 0, "z": -3}, "final_distance": 3.0, "max_distance": 3.0}}, {"input": {"directions": "sw,ne,ne,s,ne,n"}, "output": {"final_position": {"x": 2, "y": 0, "z": -2}, "final_distance": 2.0, "max_distance": 2.0}}, {"input": {"directions": "ne,se,nw,sw,s,sw,nw,nw,nw,sw,s,nw,sw,s,nw,sw,n,n,sw,sw"}, "output": {"final_position": {"x": -11, "y": 4, "z": 7}, "final_distance": 11.0, "max_distance": 11.0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "srfraser/adventofcode", "path": "/2017/11/python/soln.py", "msgidx": 899}}
{"problem_description": "Given a cryptarithmetic puzzle represented by a string, where each letter stands for a unique digit, how can you determine the correct digit assignment that satisfies the equation? For example, in the puzzle 'ODD + ODD == EVEN', what digit assignments for O, D, and E would make the equation true?", "io_requirements": "Input:\n  `formula` (str): A string representing a cryptarithmetic puzzle. The formula should be in the format of a mathematical equation involving letters, e.g., 'ODD + ODD == EVEN'.\n\nOutput:\n  `return` (str or None): A string with the digits filled in to solve the cryptarithmetic puzzle, or None if the puzzle is not solvable.", "refcode": "# import necessary packages\nimport string, re, itertools\n\n# all class and function definitions in the code file, if any\ndef fill_in(formula):\n    \"Generate all possible fillings-in of letters in formula with digits.\"\n    letters = ''.join(set(re.findall('[A-Z]', formula)))\n    for digits in itertools.permutations('1234567890', len(letters)):\n        table = str.maketrans(letters, ''.join(digits))\n        yield formula.translate(table)\n\ndef valid(f):\n    \"\"\"Formula f is valid if and only if it has no \n    numbers with leading zero, and evals true.\"\"\"\n    try: \n        return not re.search(r'\\b0[0-9]', f) and eval(f) is True\n    except ArithmeticError:\n        return False\n\n# main function\ndef main_solution(formula):\n    \"\"\"Given a formula like 'ODD + ODD == EVEN', fill in digits to solve it.\n    Input formula is a string; output is a digit-filled-in string or None.\"\"\"\n    for f in fill_in(formula):\n        if valid(f):\n            return f\n    return None", "funcname": "main_solution", "ios": [{"input": {"formula": "PLUTO not in set([PLANETS])"}, "output": "24596 not in set([2487391])"}, {"input": {"formula": "ONE < TWO < THREE"}, "output": "562 < 715 < 74322"}, {"input": {"formula": "YOU == ME**2"}, "output": "576 == 24**2"}, {"input": {"formula": "TWO + TWO == FOUR"}, "output": "928 + 928 == 1856"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rifattigli23/Udacity", "path": "/cs212/Unit2/cryptarithmetic.py", "msgidx": 1012}}
{"problem_description": "Given a 2D grid of characters, where each character can be either a space, a '+', a '-', or a '|', how many rectangles can be formed by connecting four '+' characters in such a way that they form the corners of a rectangle? The grid is represented as a list of strings, where each string is a row in the grid.", "io_requirements": "Input:\n  `lines` (List[str]): A list of strings representing the 2D grid. Each string is a row in the grid. The grid contains characters like '+', '-', '|', and spaces.\n\nOutput:\n  `return` (int): The number of rectangles formed by '+' characters in the grid.", "refcode": "# import necessary packages\nfrom typing import List\nimport itertools\n\n# main function\ndef main_solution(lines: List[str]) -> int:\n    \"\"\"\n    Counts the number of rectangles formed by '+' characters in a 2D grid of characters.\n\n    Args:\n        lines (List[str]): A list of strings representing the 2D grid. Each string is a row in the grid.\n\n    Returns:\n        int: The number of rectangles found in the grid.\n    \"\"\"\n    rectangles = 0\n    if not lines or not isinstance(lines, list):\n        return rectangles\n    \n    lines_plus_coords = []  # tuples of (y, x) coordinates where '+' is found\n    for y in range(len(lines)):\n        for x in range(len(lines[0])):\n            if lines[y][x] == \"+\":\n                lines_plus_coords.append((y, x))\n    \n    save_combinations = [*itertools.combinations(lines_plus_coords, 4)]\n    for combination in save_combinations:\n        if check_if_rectangle(lines, list(combination)):\n            rectangles += 1\n    \n    return rectangles\n\ndef check_if_rectangle(lines: List[str], multiple_coords: List[tuple]) -> bool:\n    \"\"\"\n    Checks if four given coordinates form a rectangle in the grid.\n\n    Args:\n        lines (List[str]): A list of strings representing the 2D grid.\n        multiple_coords (List[tuple]): A list of four tuples representing the coordinates of '+' characters.\n\n    Returns:\n        bool: True if the coordinates form a rectangle, False otherwise.\n    \"\"\"\n    if (multiple_coords[0][1] != multiple_coords[2][1] or\n            multiple_coords[1][1] != multiple_coords[3][1] or\n            multiple_coords[0][0] != multiple_coords[1][0] or\n            multiple_coords[2][0] != multiple_coords[3][0]):\n        return False\n    \n    y = multiple_coords[0][0]\n    x = multiple_coords[0][1] + 1\n    while x != multiple_coords[1][1]:\n        if lines[y][x] == \"-\" or lines[y][x] == \"+\":\n            x += 1\n        else:\n            return False\n    \n    y = multiple_coords[2][0]\n    x = multiple_coords[2][1] + 1\n    while x != multiple_coords[3][1]:\n        if lines[y][x] == \"-\" or lines[y][x] == \"+\":\n            x += 1\n        else:\n            return False\n    \n    y = multiple_coords[0][0] + 1\n    x = multiple_coords[0][1]\n    while y != multiple_coords[2][0]:\n        if lines[y][x] == \"|\" or lines[y][x] == \"+\":\n            y += 1\n        else:\n            return False\n    \n    y = multiple_coords[1][0] + 1\n    x = multiple_coords[1][1]\n    while y != multiple_coords[3][0]:\n        if lines[y][x] == \"|\" or lines[y][x] == \"+\":\n            y += 1\n        else:\n            return False\n    \n    return True", "funcname": "main_solution", "ios": [{"input": {"lines": ["| +-||", "| |  |", "||  | ", "|+|++ ", "  | - ", " ++  -", "--  +-", "+ ---+"]}, "output": 0}, {"input": {"lines": ["+---  |", " -  +--", " -- |+|", "|-+|-  ", "|- -| |", "+|+ |+ ", "|-|+-||", " -+ | |", "+ +||+-"]}, "output": 0}, {"input": {"lines": ["+ -++", " ++- ", " |||-"]}, "output": 0}, {"input": {"lines": ["-||+| -| |", "-||-+--+|-", "+ -|| -|- ", "- +|||++-|", " -|-   -+ ", "-||||| |- ", "--- |----+", "||+-- + +|"]}, "output": 0}, {"input": {"lines": ["   ", "-  ", " |+", "|  ", "|  ", "||+", "+-+", "  +", "+-|"]}, "output": 0}, {"input": {"lines": ["-+ ||+-", "+  +-+|", " --++ |", "|+| | -", "- - +-+", "-| -+||", "+|  - +", "- - |- ", "   -|+-", "  | ---"]}, "output": 0}, {"input": {"lines": ["| +- +", "-+ +|-", " +|-|-", "+|| ++", "-+|-- ", "---++-", "--||-+", "|-+ |-", "- -++-", " |  | "]}, "output": 0}, {"input": {"lines": ["-+ -+|", "||-- |", " +-|+ ", "|+ |-|", "|||++-", "-|++ +", "-+|+| "]}, "output": 0}, {"input": {"lines": ["  +", "---", "  |", "|||", "| +"]}, "output": 0}, {"input": {"lines": ["-+| ", "+  |", "|-+-", "+-| ", "+  |", " -  ", "+  -", " + +"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "matthew-samyn/python-assignment-Matthew", "path": "/rectangles.py", "msgidx": 28}}
{"problem_description": "Given the British usage of writing numbers in words, how many letters are used when writing out all numbers from 1 to 1000 inclusive, excluding spaces and hyphens?", "io_requirements": "Input:\n  `start_number` (int): The starting number of the range (must be 1).\n  `end_number` (int): The ending number of the range (must be 1000).\n\nOutput:\n  `return` (int): The total number of letters used when writing out all numbers from `start_number` to `end_number` in words, excluding spaces and hyphens.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef assembleCount():\n    ones = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    tens = [\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    before = ones + [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tmp = []\n    res = []\n    \n    for i in range(len(tens)):\n        tmp.append(tens[i])\n        for j in range(len(ones)):\n            tmp.append(tens[i] + ones[j])\n            \n    first100 = before + tmp\n    \n    for i in range(len(ones)):\n        res.append(ones[i] + \"hundred\")\n        for j in range(len(first100)):\n            res.append(ones[i] + \"hundredand\" + first100[j])\n    \n    final = first100 + res + [\"onethousand\"]\n\n    sum = 0\n    for i in range(len(final)):\n        sum += len(final[i])\n    \n    return sum\n\n# main function\ndef main_solution(start_number, end_number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    if start_number != 1 or end_number != 1000:\n        raise ValueError(\"The function is designed to work only for numbers from 1 to 1000.\")\n    \n    result = assembleCount()\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"start_number": 1, "end_number": 1000}, "output": 21124}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KartikTalwar/Puzzles", "path": "/Project Euler/011-020/Problem17.py", "msgidx": 951}}
{"problem_description": "Given a number, what are the largest and smallest numbers that can be obtained by swapping exactly two of its digits, ensuring that leading zeros are not permitted?", "io_requirements": "Input:\n  `number` (str): A string representation of the number for which Maxie and Minnie need to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `maxie` (int): The largest number that can be obtained by swapping two digits of the input number.\n    - `minnie` (int): The smallest number that can be obtained by swapping two digits of the input number.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef maxmin(n):\n    swaps, n = [n], str(n)\n    for a in range(len(n)):\n        for b in range(len(n)):\n            if a != b:\n                swap = list(n)\n                swap[a], swap[b] = swap[b], swap[a]\n                if swap[0] != '0':\n                    swaps.append(int(''.join(swap)))\n    return (max(swaps), min(swaps))\n\n# main function\ndef main_solution(number):\n    # Convert the JSON serializable input to the original input variable\n    n = int(number)\n    \n    # Call the maxmin function to get Maxie and Minnie\n    maxie, minnie = maxmin(n)\n    \n    # Convert the output to JSON serializable format\n    return {\"maxie\": maxie, \"minnie\": minnie}", "funcname": "main_solution", "ios": [{"input": {"number": "87545"}, "output": {"maxie": 87554, "minnie": 47585}}, {"input": {"number": "54331"}, "output": {"maxie": 54331, "minnie": 14335}}, {"input": {"number": "68158"}, "output": {"maxie": 88156, "minnie": 18658}}, {"input": {"number": "52678"}, "output": {"maxie": 82675, "minnie": 25678}}, {"input": {"number": "77042"}, "output": {"maxie": 77402, "minnie": 27047}}, {"input": {"number": "79259"}, "output": {"maxie": 99257, "minnie": 29759}}, {"input": {"number": "44385"}, "output": {"maxie": 84345, "minnie": 34485}}, {"input": {"number": "34938"}, "output": {"maxie": 94338, "minnie": 33948}}, {"input": {"number": "81924"}, "output": {"maxie": 91824, "minnie": 18924}}, {"input": {"number": "95790"}, "output": {"maxie": 99750, "minnie": 59790}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/HqpZQPZiHbPK4HgEB_16.py", "msgidx": 1040}}
{"problem_description": "Given a set of digits from 1 to 9, what is the sum of all unique products whose multiplicand/multiplier/product identity can be written as a pandigital number using the specified lengths for the multiplicand and multiplier?", "io_requirements": "Input:\n- `digits` (list of int): List of digits to be used in the pandigital number. Example: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`.\n- `f1_length` (int): Length of the first factor. Example: `2`.\n- `f2_length` (int): Length of the second factor. Example: `3`.\n\nOutput:\n- `return` (int): Sum of all unique products that form a pandigital identity.", "refcode": "# import necessary packages\nfrom itertools import permutations as p\n\n# main function\ndef main_solution(digits, f1_length, f2_length):\n    \"\"\"\n    Find the sum of all products whose multiplicand/multiplier/product identity can be written as a pandigital number.\n    \n    Args:\n    digits (list of int): List of digits to be used in the pandigital number.\n    f1_length (int): Length of the first factor.\n    f2_length (int): Length of the second factor.\n    \n    Returns:\n    int: Sum of all unique products that form a pandigital identity.\n    \"\"\"\n    \n    def pdi(_digits, _f1length, _f2length):\n        products = {}\n        factors1 = p(_digits, _f1length)\n\n        for f in factors1:\n            rd = [d for d in _digits if d not in f]\n            factors2 = p(rd, _f2length)\n            for F in factors2:\n                rd2 = [d for d in rd if d not in f and d not in F]\n                possible_products = p(rd2, len(_digits) - _f1length - _f2length)\n                for P in possible_products:\n                    factor1 = int(\"\".join(map(str, f)))\n                    factor2 = int(\"\".join(map(str, F)))\n                    product = int(\"\".join(map(str, P)))\n\n                    if factor1 * factor2 == product:\n                        products[product] = (factor1, factor2)\n\n        return products\n\n    p23 = pdi(digits, f1_length, f2_length)\n    p14 = pdi(digits, f1_length, f2_length)\n\n    return sum(p23.keys()) + sum(p14.keys())", "funcname": "main_solution", "ios": [{"input": {"digits": [1, 2, 3, 4, 5, 6, 7, 8, 9], "f1_length": 2, "f2_length": 3}, "output": 60848}, {"input": {"digits": [1, 2, 3, 4, 5, 6, 7, 8, 9], "f1_length": 1, "f2_length": 4}, "output": 29608}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mwcz/euler", "path": "/py/q32.py", "msgidx": 935}}
{"problem_description": "Given a poem composed of three lines, each separated by a `/`, determine if the poem follows the traditional Haiku structure, which requires the first line to have 5 syllables, the second line to have 7 syllables, and the third line to have 5 syllables. Does the provided poem meet the Haiku syllable pattern?", "io_requirements": "Input:\n  `poem` (str): A string representing a poem, where each line is separated by a `/`. The poem should be in the format of a Haiku, with three lines.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the poem adheres to the Haiku structure (5, 7, 5 syllables per line).", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(poem):\n  # Convert the input poem string to a list of lines\n  lines = poem.split(\"/\")\n  \n  # Define the regex pattern to find syllables\n  regex = r\"([^aeiouy ,]*[AEIOUYaeiouy]+[^aeiouy ,]*)\"\n  \n  # Count syllables in each line, excluding \"e\", \"es\", and \"e's\" at the end of words\n  syllable_counts = [len([syl for syl in re.findall(regex, line) if syl != \"e\" and syl != \"es\" and syl != \"e's\"]) for line in lines]\n  \n  # Check if the syllable counts match the Haiku pattern [5, 7, 5]\n  is_haiku = syllable_counts == [5, 7, 5]\n  \n  # Return the result as a boolean\n  return is_haiku", "funcname": "main_solution", "ios": [{"input": {"poem": "cunkepdamina/fimasxfonembsipnhyo/zehxupugzutgu"}, "output": false}, {"input": {"poem": "kminenvabdazemg/qeniwyzpenhululqxej/spyqyyruwnzyb"}, "output": false}, {"input": {"poem": "iwoxidowpmu/haqtjodbomuzthukeqtfu/uusekzqharoz"}, "output": false}, {"input": {"poem": "huqmycevekip/mozmkefxlykizqimtoku/dekaurano"}, "output": false}, {"input": {"poem": "bizlnmiwdesohnyqv/lizicydvkagyrsfbino/filyuyo"}, "output": false}, {"input": {"poem": "vybbirnixaflu/yruxafleqmyfaza/variltvwiene"}, "output": false}, {"input": {"poem": "gixgogbuaa/jnocawoswefacgkunevm/dukfbascobybxhe"}, "output": false}, {"input": {"poem": "bixricavea/xcyodijdtogiazu/vunwhopynove"}, "output": false}, {"input": {"poem": "myvmidteqewbzed/jynilupikuvcibde/denkeqiwojxvi"}, "output": false}, {"input": {"poem": "emunwwygzyxaj/ttoonawkunypfau/hutyqyxefma"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/ZT2mRQeYigSW2mojW_8.py", "msgidx": 1064}}
{"problem_description": "Given a word without spaces, what are all the unique permutations of the word in alphabetical order, and what is the position of the original word in this sorted list of permutations?", "io_requirements": "Input:\n  `word` (str): A string representing the word for which permutations need to be generated. The word should not contain spaces.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `permutations` (list of str): A list of all unique permutations of the input word, sorted in alphabetical order.\n    - `position` (int): The position of the original word in the sorted list of permutations.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef permute(word):\n    '''The recursive permuting function\n    Takes a word and returns its permutations'''\n\n    allPermutes = []\n\n    for i in range(len(word)):\n        # subWord is the word without one character\n        subWord = \"\"\n        for j in range(len(word)):\n            if j != i:\n                subWord += word[j]\n\n        if len(subWord) > 0:\n            # Calling the recursion\n            subPermutes = permute(subWord)\n            for j in subPermutes:\n                allPermutes.append(word[i] + j)\n\n    if len(allPermutes) == 0:\n        allPermutes = list(word)\n    return allPermutes\n\n# main function\ndef main_solution(word):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Permutations returned contains repetitions if word has repetitions!!\n    fakePermutations = permute(word)\n    permutations = []\n    for i in fakePermutations:\n        if i not in permutations:\n            permutations.append(i)\n\n    permutations.sort()\n    \n    # Find the position of the original word in the sorted permutations\n    position = permutations.index(word) + 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"permutations\": permutations, \"position\": position}", "funcname": "main_solution", "ios": [{"input": {"word": "zql"}, "output": {"permutations": ["lqz", "lzq", "qlz", "qzl", "zlq", "zql"], "position": 6}}, {"input": {"word": "lcw"}, "output": {"permutations": ["clw", "cwl", "lcw", "lwc", "wcl", "wlc"], "position": 3}}, {"input": {"word": "nly"}, "output": {"permutations": ["lny", "lyn", "nly", "nyl", "yln", "ynl"], "position": 3}}, {"input": {"word": "fae"}, "output": {"permutations": ["aef", "afe", "eaf", "efa", "fae", "fea"], "position": 5}}, {"input": {"word": "qwr"}, "output": {"permutations": ["qrw", "qwr", "rqw", "rwq", "wqr", "wrq"], "position": 2}}, {"input": {"word": "qan"}, "output": {"permutations": ["anq", "aqn", "naq", "nqa", "qan", "qna"], "position": 5}}, {"input": {"word": "rrg"}, "output": {"permutations": ["grr", "rgr", "rrg"], "position": 3}}, {"input": {"word": "hsf"}, "output": {"permutations": ["fhs", "fsh", "hfs", "hsf", "sfh", "shf"], "position": 4}}, {"input": {"word": "szv"}, "output": {"permutations": ["svz", "szv", "vsz", "vzs", "zsv", "zvs"], "position": 2}}, {"input": {"word": "fli"}, "output": {"permutations": ["fil", "fli", "ifl", "ilf", "lfi", "lif"], "position": 2}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shubhamDev73/permutations", "path": "/permutations.py", "msgidx": 1213}}
{"problem_description": "Given a wall that needs to be built using bricks of height 3 or 7, determine if it is possible to build a wall of a certain height using these bricks. What is the result indicating whether the wall can be built or not?", "io_requirements": "Input:\n  `wall_height` (int): The height of the wall that needs to be checked if it can be built using bricks of height 3 or 7.\n\nOutput:\n  `return` (str): A string that indicates whether the wall can be built using bricks of height 3 or 7. The possible values are \"YES\" or \"NO\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    \"\"\"\n    @param x: the wall's height\n    @return: YES or NO\n    \"\"\"\n\n    def isBuild(self, x):\n        # Write your code here\n        if x < 0:\n            return \"NO\"\n        if x % 3 == 0 or x % 7 == 0:\n            return \"YES\"\n        else:\n            a = x - 3\n            b = x - 7\n            return self.isBuild(a) and self.isBuild(b)\n\n# main function\ndef main_solution(wall_height):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.isBuild(wall_height)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"wall_height": 51}, "output": "YES"}, {"input": {"wall_height": 41}, "output": "YES"}, {"input": {"wall_height": 42}, "output": "YES"}, {"input": {"wall_height": 79}, "output": "YES"}, {"input": {"wall_height": 68}, "output": "YES"}, {"input": {"wall_height": 20}, "output": "YES"}, {"input": {"wall_height": 90}, "output": "YES"}, {"input": {"wall_height": 22}, "output": "YES"}, {"input": {"wall_height": 57}, "output": "YES"}, {"input": {"wall_height": 92}, "output": "YES"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MartinYan623/Lint-Code", "path": "/Algorithm/Easy/501-1000/749John's backyard garden.py", "msgidx": 1297}}
{"problem_description": "Given a string that may contain various types of brackets such as (), {}, [], and/or <>, determine whether the string has balanced pairs of these brackets. Balanced pairs mean that every opening bracket has a corresponding closing bracket in the correct order. What is the result of checking if the string has balanced brackets?", "io_requirements": "Input:\n  `phrase` (str): A string that may contain various types of brackets: (), {}, [], and/or <>.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string has balanced pairs of brackets. Returns `True` if the brackets are balanced, otherwise `False`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef has_balanced_brackets(phrase):\n    \"\"\"Does a given string have balanced pairs of brackets?\n\n    Given a string as input, return True or False depending on whether the\n    string contains balanced (), {}, [], and/or <>.\n    \"\"\"\n\n    if not phrase:\n        return False\n\n    symbols = ['(', ')', '{', '}', '[', ']', '<', '>']\n    brackets = []\n\n    for char in phrase:\n        try:\n            symbol_index = symbols.index(char)\n        except ValueError:\n            if char not in symbols:\n                continue\n\n        if symbol_index % 2 == 0:\n            brackets.append(char)\n        else:\n            if len(brackets) == 0 or brackets[-1] != symbols[symbol_index - 1]:\n                return False\n            else:\n                brackets.pop()\n\n    return len(brackets) == 0\n\n# main function\ndef main_solution(phrase):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return has_balanced_brackets(phrase)", "funcname": "main_solution", "ios": [{"input": {"phrase": "8QBNon777x V6jyi6hABP]tYu1JZO3pNAGaCzQ5"}, "output": false}, {"input": {"phrase": "G773Vd}48BQR939Qpt}"}, "output": false}, {"input": {"phrase": "W[V  Job3lR81(19t)wIOdXAtgTUUS"}, "output": false}, {"input": {"phrase": "rtyKFcnB(n3>RBNfYgvYOHE8}6p9RcsTn7DP8hys"}, "output": false}, {"input": {"phrase": "jRW0Dyp5c4PPPamcSLoQ(MlraXD} 6}TFcl6"}, "output": false}, {"input": {"phrase": "<4yuc0cJf]0GW 5ShfV5f3jAgEQg UmTe0H1B3z"}, "output": false}, {"input": {"phrase": "hM]bhf"}, "output": false}, {"input": {"phrase": "(WCx{Ji1d3(<"}, "output": false}, {"input": {"phrase": "rkggrx"}, "output": true}, {"input": {"phrase": "cKa{K1by9ADfg<"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "beccarosenthal/whiteboard-practice-problems", "path": "/balanced_brackets.py", "msgidx": 1148}}
{"problem_description": "In a historical execution game, there are `n` people standing in a circle. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, `k` people are skipped and the next person is executed. What is the position of the person who will remain alive till the end?", "io_requirements": "Input:\n  `n` (int): The number of people standing in a circle.\n  `k` (int): The number of people to be skipped in each step.\n\nOutput:\n  `return` (int): The position of the person who will remain alive till the end.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephus(n, k):\n    if n == 1:\n        return 1\n    else:\n        return (josephus(n - 1, k) + k - 1) % n + 1\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = josephus(n, k)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 28, "k": 10}, "output": 8}, {"input": {"n": 52, "k": 47}, "output": 3}, {"input": {"n": 99, "k": 17}, "output": 36}, {"input": {"n": 14, "k": 9}, "output": 6}, {"input": {"n": 97, "k": 50}, "output": 44}, {"input": {"n": 94, "k": 11}, "output": 72}, {"input": {"n": 51, "k": 20}, "output": 3}, {"input": {"n": 6, "k": 1}, "output": 6}, {"input": {"n": 32, "k": 27}, "output": 11}, {"input": {"n": 36, "k": 3}, "output": 16}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "singh-shreya6/Codes", "path": "/Python/Josephus_Problem.py", "msgidx": 1235}}
{"problem_description": "Given a chessboard of size `n` by `n`, how many distinct ways can you place `n` queens on the board such that no two queens can attack each other?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of distinct solutions to the n-queens problem. It is a non-negative integer.", "refcode": "# import necessary packages\nimport functools\n\n# main function\ndef main_solution(n: int) -> int:\n    \"\"\"\n    Solves the n-queens problem and returns the number of distinct solutions.\n    \n    Args:\n        n (int): The size of the chessboard and the number of queens.\n    \n    Returns:\n        int: The number of distinct solutions to the n-queens problem.\n    \"\"\"\n    filled: tuple = ()\n\n    @functools.lru_cache(None)\n    def loop(filled, row) -> int:\n        \"\"\"\n        Recursively calculates the number of possible states for placing queens.\n        \n        Args:\n            filled (tuple): A tuple of tuples representing the positions of already placed queens.\n            row (int): The current row to place a queen.\n        \n        Returns:\n            int: The number of possible states.\n        \"\"\"\n        if row >= n:\n            return 1\n        res = 0\n        for col in range(n):\n            if can_add(filled, row, col):\n                res += loop(filled + ((row, col), ), row + 1)\n        return res\n\n    return loop(filled, 0)\n\ndef can_add(filled, row, col) -> bool:\n    \"\"\"\n    Checks if a queen can be placed at the specified position without attacking other queens.\n    \n    Args:\n        filled (tuple): A tuple of tuples representing the positions of already placed queens.\n        row (int): The row to place the new queen.\n        col (int): The column to place the new queen.\n    \n    Returns:\n        bool: True if the queen can be placed, False otherwise.\n    \"\"\"\n    for i, j in filled:\n        if col == j or abs(i - row) == abs(j - col):\n            return False\n    return True", "funcname": "main_solution", "ios": [{"input": {"n": 8}, "output": 92}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 10}, "output": 724}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 5}, "output": 10}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vchub/daily-python", "path": "/dp/test_8queen.py", "msgidx": 1147}}
{"problem_description": "Given a starting gene sequence, a target gene sequence, and a list of valid gene sequences (gene bank), how many minimum mutations are required to transform the starting gene sequence into the target gene sequence, where each mutation changes one character of the gene sequence to one of the valid characters (\"A\", \"C\", \"G\", \"T\") and the resulting sequence must be in the gene bank? If it is not possible to achieve the target sequence, what should be returned?", "io_requirements": "Input:\n  `start` (str): The starting gene sequence, a string of 8 characters where each character is one of \"A\", \"C\", \"G\", or \"T\".\n  `end` (str): The target gene sequence, a string of 8 characters where each character is one of \"A\", \"C\", \"G\", or \"T\".\n  `bank` (List[str]): A list of valid gene sequences, each being a string of 8 characters where each character is one of \"A\", \"C\", \"G\", or \"T\".\n\nOutput:\n  `return` (int): The minimum number of mutations required to change the `start` gene sequence to the `end` gene sequence. If it is not possible, returns -1.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: List[str]) -> int:\n        if end not in bank: return -1\n        front = {start}\n        back = {end}\n        dist = 0\n        wordList = set(bank)\n        word_len = len(start)\n        while front:\n            dist += 1\n            next_front = set()\n            for word in front:\n                for i in range(word_len):\n                    for c in ['A', 'C', 'G', 'T']:\n                        if c != word[i]:\n                            new_word = word[:i] + c + word[i+1:]\n                            if new_word in back:\n                                return dist\n                            if new_word in wordList:\n                                next_front.add(new_word)\n                                wordList.remove(new_word)\n            front = next_front\n            if len(back) < len(front):\n                front, back = back, front\n        return -1\n\n# main function\ndef main_solution(start: str, end: str, bank: List[str]) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.minMutation(start, end, bank)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"start": "GCTGCCCC", "end": "TGCCACTG", "bank": ["GAGTTGTC", "TTGTTAAG"]}, "output": -1}, {"input": {"start": "TTGCACCT", "end": "GTCTGTAC", "bank": ["CATAAACC", "ATGGATAT", "CACAAGTC", "GTCACCGG"]}, "output": -1}, {"input": {"start": "GCCGGCAC", "end": "GGGAAATA", "bank": ["CCGTAATC", "TAGATGAT", "TTAACGTA", "CCCTCTGT", "CAGATCAC", "CGGTCTAG"]}, "output": -1}, {"input": {"start": "AATATAAC", "end": "ATCCATGT", "bank": ["ACAAGATC", "TCAATCTA", "GTCACGGA", "CCACATGA", "AGATAAGC", "AGGACTAA"]}, "output": -1}, {"input": {"start": "GCCGTAGC", "end": "CCCATTTT", "bank": ["GTGGTACT", "GACGCCAG", "GTCATCAC", "GACGCAAG", "GCAGGAAG", "GCCTATTC"]}, "output": -1}, {"input": {"start": "GGAAGAGG", "end": "GGTTTGGT", "bank": ["GGCAAGCG"]}, "output": -1}, {"input": {"start": "GCTTGATG", "end": "ACACGTTT", "bank": ["TGGGGATT", "GGTTCTTA", "AACAGGAA", "TGTGACTC", "CAACTCCC"]}, "output": -1}, {"input": {"start": "GCAACCAG", "end": "AATCTCTC", "bank": ["TAAGCAGT", "TAAAGGGG", "GGGAACAT", "GTCGCCTG", "CCCACTCG", "CGTGACTA"]}, "output": -1}, {"input": {"start": "CAGTACCT", "end": "TCCGGGCT", "bank": ["CTGCCTTC"]}, "output": -1}, {"input": {"start": "CAAGGAAT", "end": "CCGCGAGA", "bank": ["GCTATGAC", "ATCGCTAC", "CCTCGCCT"]}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ZhiyuSun/leetcode-practice", "path": "/301-500/433_\u6700\u5c0f\u57fa\u56e0\u53d8\u5316.py", "msgidx": 1061}}
{"problem_description": "Given a sequence of brackets, where each bracket is either an opening '(' or '[' or a closing ')' or ']', determine the result of the bracket evaluation. The result is calculated based on the proper nesting and matching of the brackets. If the brackets are properly nested and matched, the result will be the sum of the values associated with the brackets. If the brackets are not properly nested or matched, the result will be 0. What is the result of the bracket evaluation for the given sequence of brackets?", "io_requirements": "Input:\n  `brackets` (str): A string representing a sequence of brackets. Each character in the string should be one of the following: '(', ')', '[', ']'.\n\nOutput:\n  `return` (int): An integer representing the result of the bracket evaluation. If the brackets are properly nested and matched, the result will be the sum of the values associated with the brackets. If the brackets are not properly nested or matched, the result will be 0.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef cal_stack(stack, bracket):\n    pre_value = 1\n    for i in stack[::-1]:\n        if type(i) == int:\n            if pre_value == 1:\n                pre_value = i\n                stack.pop()\n            else:\n                stack.pop()\n                pre_value += i\n        else:\n            if i == '(' and bracket == ')':\n                pre_value *= 2\n                stack.pop()\n                stack.append(pre_value)\n                break\n            elif i == '[' and bracket == ']':\n                pre_value *= 3\n                stack.pop()\n                stack.append(pre_value)\n                break\n    return stack\n\n# main function\ndef main_solution(brackets):\n    stack = []\n    closed = [')', ']']\n    opened = ['(', '[']\n    result = 0\n\n    for i in brackets:\n        if i in opened:\n            stack.append(i)\n        elif i in closed:\n            if len(stack) == 0:\n                result = 0\n                break\n            else:\n                b = stack[-1]\n                if b not in opened:\n                    stack = cal_stack(stack, i)\n                    if stack == -1:\n                        result = 0\n                        break\n                else:\n                    if i == ')' and b == '(':\n                        stack.pop()\n                        stack.append(2)\n                    elif i == ']' and b == '[':\n                        stack.pop()\n                        stack.append(3)\n                    else:\n                        result = 0\n                        break\n\n    for i in stack:\n        if type(i) is str:\n            result = 0\n            break\n        else:\n            result += i\n\n    return result", "funcname": "main_solution", "ios": [{"input": {"brackets": "((][)(]][[]]][)"}, "output": 0}, {"input": {"brackets": ")[])["}, "output": 0}, {"input": {"brackets": "("}, "output": 0}, {"input": {"brackets": "]))))][(["}, "output": 0}, {"input": {"brackets": ")[("}, "output": 0}, {"input": {"brackets": "))()()[((((](]("}, "output": 0}, {"input": {"brackets": "[)"}, "output": 0}, {"input": {"brackets": "(([[)([("}, "output": 0}, {"input": {"brackets": "][][][)]))("}, "output": 0}, {"input": {"brackets": "))([([[[(((([)[()]"}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "deadlylaid/pracpy", "path": "/algorithms/baekjoon/2504.py", "msgidx": 1183}}
{"problem_description": "Given a set of synonyms and two sentences, determine if the sentences are equivalent based on the provided synonyms. For example, if \"eat\" and \"consume\" are synonyms, then the sentences \"He wants to eat food.\" and \"He wants to consume food.\" are considered equivalent. What is the result of comparing the two sentences based on the given synonyms?", "io_requirements": "Input:\n  `sentence_1` (str): The first sentence to be compared.\n  `sentence_2` (str): The second sentence to be compared.\n  `synonyms` (list of tuples): A list of tuples where each tuple contains two words that are synonyms.\n\nOutput:\n  `return` (bool): True if the two sentences are equivalent based on the provided synonyms, False otherwise.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef split_sentence_into_words(sentence):\n    sentence = re.sub(r\"[^\\w\\s]\", \"\", sentence)  # remove punctuation from sentence\n    words = sentence.split(\" \")\n    return words, len(words)\n\ndef check_equivalent_words(word_1, word_2, equivalence_map):\n    if word_1 == word_2:  # the same word at same position in 2 sentence\n        return True\n    if word_1 not in equivalence_map.keys() or word_2 not in equivalence_map.keys():\n            return False\n    word_1_equals = equivalence_map[word_1]\n    word_2_equals = equivalence_map[word_2]\n    if word_1 not in word_2_equals or word_2 not in word_1_equals:\n        return False\n    return True\n\ndef build_equivalence_map(synonyms):\n    equivalence_map = initialize_equivalence_map(synonyms)\n    for pair in synonyms:\n        a, b = pair[0], pair[1]\n        equivalence_map[a].append(b)\n        equivalence_map[b].append(a)\n    return equivalence_map\n\ndef initialize_equivalence_map(synonyms):\n    equivalence_map = {}\n    for pair in synonyms:\n        a, b = pair[0], pair[1]\n        equivalence_map[a] = []\n        equivalence_map[b] = []\n    return equivalence_map\n\n# main function\ndef main_solution(sentence_1, sentence_2, synonyms):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    words_1, n1 = split_sentence_into_words(sentence_1)\n    words_2, n2 = split_sentence_into_words(sentence_2)\n    if n1 != n2: # there must be words without equivalence\n        return False\n    equivalence_map = build_equivalence_map(synonyms)\n    for i in range(n1):\n        if not check_equivalent_words(words_1[i], words_2[i], equivalence_map):\n            return False\n    return True", "funcname": "main_solution", "ios": [{"input": {"sentence_1": "He wants to eat meal", "sentence_2": "She needs to eat drink", "synonyms": [["eat", "consume"], ["consume", "drink"], ["eat", "eat"]]}, "output": false}, {"input": {"sentence_1": "They wants to drink meal", "sentence_2": "She wants to consume meal", "synonyms": [["eat", "drink"], ["eat", "drink"], ["drink", "eat"]]}, "output": false}, {"input": {"sentence_1": "She wants to drink meal", "sentence_2": "She wants to eat drink", "synonyms": [["drink", "consume"], ["eat", "eat"], ["eat", "drink"]]}, "output": false}, {"input": {"sentence_1": "He needs to drink meal", "sentence_2": "She wants to consume drink", "synonyms": [["consume", "consume"], ["consume", "drink"], ["eat", "eat"]]}, "output": false}, {"input": {"sentence_1": "She wants to consume meal", "sentence_2": "They wants to eat drink", "synonyms": [["eat", "eat"], ["consume", "eat"], ["consume", "consume"]]}, "output": false}, {"input": {"sentence_1": "She wants to drink food", "sentence_2": "They needs to eat meal", "synonyms": [["eat", "drink"], ["eat", "drink"], ["eat", "drink"]]}, "output": false}, {"input": {"sentence_1": "They likes to drink meal", "sentence_2": "He needs to consume food", "synonyms": [["drink", "drink"], ["consume", "consume"], ["eat", "consume"]]}, "output": false}, {"input": {"sentence_1": "She wants to eat meal", "sentence_2": "She likes to drink food", "synonyms": [["consume", "eat"], ["drink", "consume"], ["eat", "drink"]]}, "output": false}, {"input": {"sentence_1": "They needs to eat drink", "sentence_2": "They needs to consume meal", "synonyms": [["eat", "eat"], ["consume", "eat"], ["consume", "drink"]]}, "output": false}, {"input": {"sentence_1": "He wants to drink drink", "sentence_2": "She wants to consume food", "synonyms": [["eat", "consume"], ["drink", "eat"], ["eat", "drink"]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lakshyatyagi24/daily-coding-problems", "path": "/python/345.py", "msgidx": 902}}
{"problem_description": "In a Tic-Tac-Toe game, given the current state of the board, what is the optimal move for the 'X' player to make next? The board is represented as a list where each element can be an integer (empty cell) or a string ('X' or 'O' representing a player's move). The goal is to determine the index of the board where 'X' should be placed to maximize its chances of winning.", "io_requirements": "Input:\n  `board` (list of integers and strings): A list representing the current state of the Tic-Tac-Toe board. Each element can be an integer (representing an empty cell) or a string ('X' or 'O' representing a player's move). The list should have exactly 9 elements.\n\nOutput:\n  `return` (integer): An integer representing the best move for the 'X' player according to the Minimax algorithm. The integer corresponds to the index of the board list where 'X' should be placed.", "refcode": "# import necessary packages\nimport math\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\ndef is_terminal(state):\n    \"\"\"\n    returns True if the state is either a win or a tie (board full)\n    :param state: State of the checkerboard. Ex: [0; 1; 2; 3; X; 5; 6; 7; 8]\n    :return:\n    \"\"\"\n    StateIsTerminal = False\n\n    if state.count('X') + state.count('O') >= len(state):\n        return True\n    for x in range(0, len(state) - 1, 3):\n        horizontalX = state[x:(x + 3)].count('X') == 3\n        horizontalO = state[x:(x + 3)].count('O') == 3\n\n        verticalX = [state[math.floor(x / 3)], state[math.floor(x / 3) + 3], state[math.floor(x / 3) + 6]].count(\n            'X') == 3\n        verticalO = [state[math.floor(x / 3)], state[math.floor(x / 3) + 3], state[math.floor(x / 3) + 6]].count(\n            'O') == 3\n\n        if verticalX or horizontalX or verticalO or horizontalO:\n            return True\n\n    leftToRightX = [state[0], state[4], state[8]].count('X') == 3\n    leftToRightO = [state[0], state[4], state[8]].count('O') == 3\n    rightToLeftX = [state[2], state[4], state[6]].count('X') == 3\n    rightToLeftO = [state[2], state[4], state[6]].count('O') == 3\n\n    if leftToRightX or leftToRightO or rightToLeftX or rightToLeftO:\n        return True\n\n    return StateIsTerminal\n\n\ndef utility_of(state):\n    \"\"\"\n    returns +1 if winner is X (MAX player), -1 if winner is O (MIN player), or 0 otherwise\n    :param state: State of the checkerboard. Ex: [0; 1; 2; 3; X; 5; 6; 7; 8]\n    :return:\n    \"\"\"\n    utility = 0\n\n    for x in range(0, len(state) - 1, 3):\n        horizontalX = state[x:(x + 3)].count('X') == 3\n        horizontalO = state[x:(x + 3)].count('O') == 3\n\n        verticalX = [state[math.floor(x / 3)], state[math.floor(x / 3) + 3], state[math.floor(x / 3) + 6]] \\\n                        .count('X') == 3\n        verticalO = [state[math.floor(x / 3)], state[math.floor(x / 3) + 3], state[math.floor(x / 3) + 6]] \\\n                        .count('O') == 3\n\n        if verticalX or horizontalX:\n            utility = 1\n        elif verticalO or horizontalO:\n            utility = -1\n\n    leftToRightX = [state[0], state[4], state[8]].count('X') == 3\n    leftToRightO = [state[0], state[4], state[8]].count('O') == 3\n    rightToLeftX = [state[2], state[4], state[6]].count('X') == 3\n    rightToLeftO = [state[2], state[4], state[6]].count('O') == 3\n    if leftToRightX or rightToLeftX:\n        utility = 1\n    elif leftToRightO or rightToLeftO:\n        utility = -1\n\n    return utility\n\n\ndef successors_of(state):\n    \"\"\"\n    returns a list of tuples (move, state) as shown in the exercise slides\n    :param state: State of the checkerboard. Ex: [0; 1; 2; 3; X; 5; 6; 7; 8]\n    :return:\n    \"\"\"\n    count = Counter(state)\n    turn = 'O'\n    if count['X'] <= count['O']:\n        turn = 'X'\n    successors = []\n    counter = 0\n    for x in range(0, len(state)):\n        if state[x] != 'X' and state[x] != 'O':\n            duplicate = state.copy()\n            duplicate[x] = turn\n            successors.append((x, duplicate))\n            counter += 1\n    return successors\n\n\ndef argmax(iterable, func):\n    return max(iterable, key=func)\n\n\ndef minmax_decision(state):\n    def max_value(state):\n        if is_terminal(state):\n            return utility_of(state)\n        v = -infinity\n        for (a, s) in successors_of(state):\n            v = max(v, min_value(s))\n        return v\n\n    def min_value(state):\n        if is_terminal(state):\n            return utility_of(state)\n        v = infinity\n        for (a, s) in successors_of(state):\n            v = min(v, max_value(s))\n        return v\n\n    infinity = float('inf')\n    action, state = argmax(successors_of(state), lambda a: min_value(a[1]))\n    return action\n\n# main function\ndef main_solution(board):\n    \"\"\"\n    Determines the best move for the 'X' player in a Tic-Tac-Toe game using the Minimax algorithm.\n    :param board: A list representing the current state of the Tic-Tac-Toe board. Ex: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n    :return: An integer representing the best move for 'X' player.\n    \"\"\"\n    best_move = minmax_decision(board)\n    return best_move", "funcname": "main_solution", "ios": [{"input": {"board": ["X", "O", "O", "O", "X", "X", "O", 7, "X"]}, "output": 7}, {"input": {"board": [0, 1, 2, 3, 4, 5, 6, 7, 8]}, "output": 0}, {"input": {"board": [0, "X", 2, 3, 4, 5, "X", 7, 8]}, "output": 0}, {"input": {"board": [0, "X", "X", "X", "O", "O", 6, 7, "O"]}, "output": 0}, {"input": {"board": [0, 1, 2, 3, 4, "X", 6, 7, 8]}, "output": 0}, {"input": {"board": ["X", "X", 2, 3, 4, 5, 6, "O", "X"]}, "output": 3}, {"input": {"board": ["O", "X", "O", "X", 4, 5, "O", "O", "O"]}, "output": 4}, {"input": {"board": ["O", "X", "X", "X", "O", "X", "X", 7, "O"]}, "output": 7}, {"input": {"board": [0, "O", 2, "O", 4, 5, 6, 7, 8]}, "output": 0}, {"input": {"board": [0, 1, 2, 3, 4, 5, "O", 7, 8]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sieben8nein/AIExerciseCollection", "path": "/Week13/Ex05/tictactoe_template.py", "msgidx": 212}}
{"problem_description": "Given the definition of the set M, where the number 1 is in M, and if x is in M, then y = 2 * x + 1 and z = 3 * x + 1 are also in M, what are the first `n` numbers in M when listed in ascending order?", "io_requirements": "Input:\n  `n` (int): The number of Wirth numbers to generate. It should be a positive integer.\n\nOutput:\n  `return` (list): A list of the first `n` Wirth numbers in ascending order. Each element in the list is an integer.", "refcode": "# import necessary packages\nimport heapq\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Generate the first n Wirth numbers using a heap.\n\n    Args:\n    n (int): The number of Wirth numbers to generate.\n\n    Returns:\n    list: A list of the first n Wirth numbers in ascending order.\n    \"\"\"\n    ls = []\n    heap = []\n    heapq.heappush(heap, 1)\n    while len(ls) < n:\n        i = heapq.heappop(heap)\n        if i not in ls:\n            ls.append(i)\n            heapq.heappush(heap, 2 * i + 1)\n            heapq.heappush(heap, 3 * i + 1)\n    return ls", "funcname": "main_solution", "ios": [{"input": {"n": 11}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22]}, {"input": {"n": 12}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27]}, {"input": {"n": 15}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, 28, 31, 39]}, {"input": {"n": 9}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19]}, {"input": {"n": 17}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, 28, 31, 39, 40, 43]}, {"input": {"n": 13}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, 28]}, {"input": {"n": 19}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, 28, 31, 39, 40, 43, 45, 46]}, {"input": {"n": 14}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, 28, 31]}, {"input": {"n": 10}, "output": [1, 3, 4, 7, 9, 10, 13, 15, 19, 21]}, {"input": {"n": 1}, "output": [1]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jpverkamp/small-projects", "path": "/blog/numbers-of-wirth.py", "msgidx": 1045}}
{"problem_description": "Given a binary tree, determine whether it is symmetric around its center, meaning each side mirrors the other. What is the result of checking if the given binary tree is symmetric?", "io_requirements": "Input:\n  `tree_json` (str): A JSON string representing the binary tree. The tree is represented as a dictionary with keys \"value\" (int), \"left\" (dict or None), and \"right\" (dict or None). Each node in the tree has these keys, and the values for \"left\" and \"right\" are either None or another dictionary representing the left and right children.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetric around its center.", "refcode": "# import necessary packages\nimport json\n\n# Definition for binary tree:\nclass Tree(object):\n    def __init__(self, x):\n        self.value = x\n        self.left = None\n        self.right = None\n\n# Function to convert JSON serializable input to Tree object\ndef json_to_tree(json_tree):\n    if json_tree is None:\n        return None\n    root = Tree(json_tree['value'])\n    root.left = json_to_tree(json_tree['left'])\n    root.right = json_to_tree(json_tree['right'])\n    return root\n\n# Function to check if two trees are mirror images\ndef isMirror(root1, root2):\n    if root1 == None and root2 == None:\n        return True\n    \n    if root1 != None and root2 != None:\n        if root1.value != root2.value:\n            return False\n        ret1 = isMirror(root1.left, root2.right)\n        ret2 = isMirror(root1.right, root2.left)\n        return (ret1 and ret2)\n        \n    return False\n\n# Main function\ndef main_solution(tree_json):\n    # Convert JSON serializable input to Tree object\n    tree = json_to_tree(json.loads(tree_json))\n    \n    # Check if the tree is symmetric\n    result = isTreeSymmetric(tree)\n    \n    # Return the result as a JSON serializable output\n    return result\n\n# Function to check if the tree is symmetric\ndef isTreeSymmetric(t):\n    if t == None:\n        return True\n    \n    return isMirror(t.left, t.right)", "funcname": "main_solution", "ios": [{"input": {"tree_json": "{\"value\": 7, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 24, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 91, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 51, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 54, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 47, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 73, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 40, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 16, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_json": "{\"value\": 48, \"left\": null, \"right\": null}"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Reece323/coding-problems", "path": "/codesignal/isTreeSymmetric.py", "msgidx": 1188}}
{"problem_description": "Given a positive integer `n`, identify all the numbers within the range from 1 to `n` that, when each digit is rotated 180\u00b0, form a different number that is also within the same range. What are these numbers?", "io_requirements": "Input:\n  `n` (int): A positive integer representing the upper limit of the range to search for rotation numbers.\n\nOutput:\n  `return` (list of str): A list of strings representing all the numbers in the range 1 to `n` that satisfy the definition of a rotation number. Each string in the list is a number that can be rotated 180\u00b0 to form a different number within the same range.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def RotationNumber(self, n):\n        cannot_rotate = set([str(i) for i in range(0,10)]) - set([\"0\",\"6\",\"8\",\"9\"])\n        d = {\"0\": \"0\", \"6\": \"9\", \"8\": \"8\", \"9\": \"6\"}\n        def rotate(n, bound):\n            result = []\n            for char in str(n):\n                if char in cannot_rotate:\n                    return None\n                result.append(d[char])\n                \n            new = int(\"\".join(result)) \n            if  new != n and new <= bound:\n                return n\n            else:\n                return None\n        result = []    \n        for i in range(1, n+1):\n            r = rotate(i, n)\n            if r:\n                result.append(r)\n        return result\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the RotationNumber method\n    result = solution.RotationNumber(n)\n    \n    # Convert the result to a list of strings for JSON serialization\n    result = [str(num) for num in result]\n    \n    # Return the result as a list of strings\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 264}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 440}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 384}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 432}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 713}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 509}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 804}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 491}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 797}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}, {"input": {"n": 621}, "output": ["6", "9", "60", "66", "68", "69", "86", "89", "90", "96", "98", "99"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hrssurt/lintcode", "path": "/lintcode/1812  Rotation Number.py", "msgidx": 1355}}
{"problem_description": "In a container represented by a square matrix, different kinds of spare parts are marked by numbers from 1 to 5. An empty cell is marked by 0. The radiation emitted from the container is due to the largest group of identical spare parts that are adjacently joined. What is the size of the largest group of identical spare parts and the number of the spare part itself?", "io_requirements": "Input:\n  `matrix` (list of lists of integers): A square matrix representing the container. Each element in the matrix is an integer between 0 and 5, where 0 represents an empty cell and 1 through 5 represent different kinds of spare parts.\n\nOutput:\n  `return` (list of integers): A list containing two integers. The first integer represents the size of the largest group of identical, adjacently joined spare parts. The second integer represents the number of the spare part in that largest group.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef find_largest_group(matrix):\n    def dfs(x, y, part_number):\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            cx, cy = stack.pop()\n            if 0 <= cx < len(matrix) and 0 <= cy < len(matrix[0]) and matrix[cx][cy] == part_number:\n                count += 1\n                matrix[cx][cy] = -1  # Mark as visited\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    stack.append((cx + dx, cy + dy))\n        return count\n\n    max_group_size = 0\n    part_number = 0\n\n    for i, j in itertools.product(range(len(matrix)), range(len(matrix[0]))):\n        if matrix[i][j] > 0:\n            group_size = dfs(i, j, matrix[i][j])\n            if group_size > max_group_size:\n                max_group_size = group_size\n                part_number = matrix[i][j]\n\n    return [max_group_size, part_number]\n\n# main function\ndef main_solution(matrix):\n    # Convert the input matrix to a list of lists if it's not already\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists\")\n    \n    # Call the function to find the largest group\n    result = find_largest_group(matrix)\n    \n    # Return the result as a list of two integers\n    return result", "funcname": "main_solution", "ios": [{"input": {"matrix": [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]}, "output": [3, -1]}, {"input": {"matrix": [[0, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]}, "output": [3, -1]}, {"input": {"matrix": [[-1, 0, -1, -1], [-1, -1, -1, -1], [-1, -1, 0, -1], [-1, -1, -1, 0]]}, "output": [3, -1]}, {"input": {"matrix": [[-1, -1, -1, -1], [-1, -1, -1, 0], [-1, -1, -1, -1], [0, -1, -1, -1]]}, "output": [4, -1]}, {"input": {"matrix": [[-1, 0, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, 0, -1, -1]]}, "output": [3, -1]}, {"input": {"matrix": [[0, -1, -1], [-1, -1, -1], [-1, -1, -1]]}, "output": [2, -1]}, {"input": {"matrix": [[-1, 0, -1], [-1, -1, -1], [-1, 0, -1]]}, "output": [2, -1]}, {"input": {"matrix": [[0, -1, 0, -1], [-1, 0, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, 0]]}, "output": [2, -1]}, {"input": {"matrix": [[-1, 0, -1], [0, -1, -1], [-1, 0, -1]]}, "output": [1, -1]}, {"input": {"matrix": [[-1, -1, -1, 0], [-1, -1, 0, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]}, "output": [5, -1]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bespontoff/checkio", "path": "/solutions/Blizzard/radiation_search.py", "msgidx": 1239}}
{"problem_description": "Given a positive integer, determine whether all its permutations (rearrangements of its digits) are prime numbers. What is the result for a randomly generated number?", "io_requirements": "Input:\n  `number` (int): A positive integer to be checked if all its permutations are prime numbers.\n\nOutput:\n  `return` (bool): `True` if all permutations of the input number are prime, otherwise `False`.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef isPrime(n):\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n < 2:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False    \n    return True\n\ndef permutable(n):\n    perms = list(set((permutations(str(n)))))\n    nums = []\n    # parse\n    for perm in perms:\n        num = \"\"\n        for i in range(len(perm)):\n            num += perm[i]\n        nums.append(int(num))\n    for num in nums:\n        if not isPrime(num):\n            return False\n    return True\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = permutable(number)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"number": 168}, "output": false}, {"input": {"number": 667}, "output": false}, {"input": {"number": 643}, "output": false}, {"input": {"number": 959}, "output": false}, {"input": {"number": 551}, "output": false}, {"input": {"number": 580}, "output": false}, {"input": {"number": 301}, "output": false}, {"input": {"number": 533}, "output": false}, {"input": {"number": 309}, "output": false}, {"input": {"number": 525}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "petr7555/SoloLearn-coding-challenges", "path": "/74_Permutable_prime.py", "msgidx": 1470}}
{"problem_description": "Imagine you are feeding pigeons in a park. You start with a certain number of portions of bird feed. Each minute, more pigeons arrive, and you continue feeding them until you run out of food. The pigeons that arrive first get fed first. Given the number of portions of bird feed you have, how many pigeons will be fed with at least one portion of wheat?", "io_requirements": "Input:\n  `number` (int): The number of portions of bird feed available.\n\nOutput:\n  `return` (int): The number of pigeons that will be fed with at least one portion of wheat.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef pigAtMin(num):\n    return (num * (num + 1)) / 2\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    i = min = 1\n    while i == 1:\n        pig = pigAtMin(min)      \n        # not enough portions to feed all the pigeons of this minute        \n        if number - pig <= 0:\n            # Enough portions to feed new pigeons\n            if number > pigAtMin(min - 1):\n                i = 0\n                pig = number\n            # Not enough portions to feed new pigeons\n            else:\n                i = 0\n                pig = pigAtMin(min - 1)\n        # Enough portions to feed all the pigeons from this minute, lets feed more!\n        else:\n            number -= pig\n            min += 1\n        \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return int(pig)", "funcname": "main_solution", "ios": [{"input": {"number": 99}, "output": 28}, {"input": {"number": 14}, "output": 6}, {"input": {"number": 93}, "output": 28}, {"input": {"number": 63}, "output": 21}, {"input": {"number": 56}, "output": 21}, {"input": {"number": 73}, "output": 21}, {"input": {"number": 17}, "output": 7}, {"input": {"number": 62}, "output": 21}, {"input": {"number": 53}, "output": 18}, {"input": {"number": 52}, "output": 17}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "elcresan/PythonTasks", "path": "/home/feedPigeons.py", "msgidx": 1441}}
{"problem_description": "Given a binary tree, determine if it is symmetric around its center. A tree is symmetric if the left subtree is a mirror reflection of the right subtree. What is the result of checking the symmetry of the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented as a dictionary with keys `\"val\"` (int), `\"left\"` (dict or null), and `\"right\"` (dict or null).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetric.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isMirror(self, t1: TreeNode, t2: TreeNode):\n        if t1 is None and t2 is None:\n            return True\n        if t1 is None or t2 is None:\n            return False\n        return (t1.val == t2.val) and self.isMirror(t1.right, t2.left) and self.isMirror(t1.left, t2.right)\n\n    def isSymmetric(self, root: TreeNode):\n        return self.isMirror(root, root)\n\n# main function\ndef main_solution(tree_structure: str):\n    # Convert the JSON serializable input to the original input variables\n    tree_dict = json.loads(tree_structure)\n    \n    def build_tree(node_dict):\n        if not node_dict:\n            return None\n        root = TreeNode(node_dict['val'])\n        root.left = build_tree(node_dict['left'])\n        root.right = build_tree(node_dict['right'])\n        return root\n    \n    root = build_tree(tree_dict)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetric(root)\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": "{\"val\": 18, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 84, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 57, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 15, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 41, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 37, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 31, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 20, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 30, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 94, \"left\": null, \"right\": null}"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "earsonlau/westworld", "path": "/TREE/\u5bf9\u79f0\u4e8c\u53c9\u6811.py", "msgidx": 1146}}
{"problem_description": "Given a range of integers from N to M, what are all the palindromic prime numbers within this range?", "io_requirements": "Input:\n  `start_point` (str): A string representing the starting integer (N) for the range within which to find palindromic primes.\n  `end_point` (str): A string representing the ending integer (M) for the range within which to find palindromic primes.\n\nOutput:\n  `return` (list of int): A list of integers representing all palindromic primes between `start_point` and `end_point` (inclusive).", "refcode": "# import necessary packages\nimport sys\nsys.setrecursionlimit(30000)\n\n# all class and function definitions in the code file, if any\ndef palindrome(string_no):\n    if len(string_no) <= 1:\n        return True\n    else:\n        if string_no[0] == string_no[len(string_no)-1]: \n            return palindrome(string_no[1:len(string_no)-1])\n        else:\n            return False\n\ndef prime_numbers(x, y):\n    if y > x**(1/2):\n        return True\n    if x % y == 0: \n        return False\n    else:\n        return prime_numbers(x, y+1)\n\n# main function\ndef main_solution(start_point, end_point):\n    # Convert input arguments to the required types\n    start_point = int(start_point)\n    end_point = int(end_point)\n    \n    # Adjust start_point if it is 1\n    if start_point == 1:\n        start_point += 1\n    \n    # Function to find palindromic primes\n    def palindro_primes(x, y):\n        if x > y:\n            return []\n        else:\n            if palindrome(str(x)) and prime_numbers(x, 2):\n                return [x] + palindro_primes(x+1, y)\n            else:\n                return palindro_primes(x+1, y)\n    \n    # Get the list of palindromic primes\n    palindromic_primes = palindro_primes(start_point, end_point)\n    \n    # Convert the list to a JSON serializable format\n    return palindromic_primes", "funcname": "main_solution", "ios": [{"input": {"start_point": "288", "end_point": "901"}, "output": [313, 353, 373, 383, 727, 757, 787, 797]}, {"input": {"start_point": "972", "end_point": "1005"}, "output": []}, {"input": {"start_point": "589", "end_point": "1738"}, "output": [727, 757, 787, 797, 919, 929]}, {"input": {"start_point": "642", "end_point": "1188"}, "output": [727, 757, 787, 797, 919, 929]}, {"input": {"start_point": "663", "end_point": "1683"}, "output": [727, 757, 787, 797, 919, 929]}, {"input": {"start_point": "141", "end_point": "550"}, "output": [151, 181, 191, 313, 353, 373, 383]}, {"input": {"start_point": "321", "end_point": "1015"}, "output": [353, 373, 383, 727, 757, 787, 797, 919, 929]}, {"input": {"start_point": "228", "end_point": "1276"}, "output": [313, 353, 373, 383, 727, 757, 787, 797, 919, 929]}, {"input": {"start_point": "235", "end_point": "762"}, "output": [313, 353, 373, 383, 727, 757]}, {"input": {"start_point": "616", "end_point": "1820"}, "output": [727, 757, 787, 797, 919, 929]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MrHamdulay/csc3-capstone", "path": "/examples/data/Assignment_8/mnyret003/question4.py", "msgidx": 1338}}
{"problem_description": "In a digital communication system, certain strings are considered \"nice\" if they meet specific criteria for readability and redundancy. A string is considered \"nice\" if it contains a pair of any two letters that appears at least twice in the string without overlapping, and it contains at least one letter which repeats with exactly one letter between them. Given a list of strings, how many of them are \"nice\"?", "io_requirements": "Input:\n  `strings` (list of str): A list of strings where each string is to be checked for the \"nice\" property. Each string should be a sequence of characters without any specific format restrictions.\n\nOutput:\n  `return` (int): The number of \"nice\" strings in the input list. A \"nice\" string is defined as one that contains a pair of any two letters that appears at least twice in the string without overlapping, and at least one letter which repeats with exactly one letter between them.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef check_nice_string(strng):\n  one_repeat_between_flag = False\n  letter_tracker = defaultdict(list)\n  previous_letter = ''\n  previous_two_letters = ['', '']\n  \n  for index, letter in enumerate(strng):\n    # Check for pair of any two letters appearing twice in string without overlapping\n    if previous_letter:\n      # Track pairs of letters in hash: pairs are keys, indices of pairs are values\n      # Get all noted locations for the current two-letter string\n      previous_pairs = letter_tracker[previous_letter + letter]\n      # If the second index of a pair location is equal to the current letter index - 1,\n      # then those pairs are overlapping and we don't want to add it\n      if all(pair[1] != index - 1 for pair in previous_pairs):\n        letter_tracker[previous_letter + letter].append([index - 1, index])\n    \n    # Check for one letter that repeats with exactly one letter between its repeat\n    if previous_two_letters[0] == letter and previous_two_letters[1]:\n      one_repeat_between_flag = True\n    \n    # Update state-keeping variables  \n    previous_letter = letter\n    previous_two_letters.append(letter)\n    previous_two_letters = previous_two_letters[1:]\n  \n  return one_repeat_between_flag and any(len(value) >= 2 for key, value in letter_tracker.items())\n\n# main function\ndef main_solution(strings):\n  # strings: a list of strings to be checked\n  nice_count = 0\n  for string in strings:\n    if check_nice_string(string):\n      nice_count += 1\n  return nice_count", "funcname": "main_solution", "ios": [{"input": {"strings": ["MXdrCoKCvuubCnX", "VtVloAbbOIfpeUztx", "WXRODgZwSOlffavvlGP", "ZJKYHEmcPcnKCUUv", "jSxGXrwfXcoja"]}, "output": 0}, {"input": {"strings": ["stdmiFmRkAN", "sFOaNdjEIEeGGFeAoQ", "jiyAMpBxDx", "cYnIpQlyce", "HjsDXOwIoZtMazLtSbJA", "mTBKrBmuqoEjWwgI"]}, "output": 0}, {"input": {"strings": ["TbzhKmjrqXYiMKw", "fIiYtgmBoxUohr", "OnyyFPnPBCcMEXdEAF", "GTibwMfhmMQaQ", "zkBdSUGwytp", "QHqSoiXuWkMfMZixa", "YuMROSPPOXJ", "HeMotiUskZU", "jGwLuuDOJy"]}, "output": 0}, {"input": {"strings": ["KhCxMnQYhxcsrlEtxgCG", "TvPgOsmhCrUFWAvrQNK", "jFZrioQDqJDqvRX", "qdmDQRtOfueqvDS", "aeIsBYMWEXytRLbuip", "ZJkCtYfrbWmVfkNHEgF"]}, "output": 0}, {"input": {"strings": ["pyqFLDBctld", "aLgKsbmqWx", "sJKhtSPudRtbSKO", "iUijSKBYLHOGkTeVxmu", "JjggWAogoVrrL"]}, "output": 0}, {"input": {"strings": ["LQsoSGoLZGVMmvPkdGUJ", "gXhEZYdAfxMXYDB", "zQmJtERfOPM", "BibMsixEaVYEc", "KArUYMEeOKdHkpTesU", "PQpBAzYQinXVuXbQ"]}, "output": 0}, {"input": {"strings": ["IQlYxmRLoECDJcPFu", "DQrQKLcSzblRZwFco", "KztSKxKnqEHfaNrQDZ", "PhtCSFHxLFoCmjjpxsx", "kzHpKOFZxrAtDZJShMiU", "QttxwDwpdHbof", "dwdOVLsnyrv"]}, "output": 0}, {"input": {"strings": ["KWgXyRBQQfSTKFvJRH", "ZjZkOtsFxd", "TWYMcISBbvsQTZVxbIf", "PRMDrjjUCoNpCLFYl", "eBLngdoNCOylBinkP", "AWklOZcsKgRFZp"]}, "output": 0}, {"input": {"strings": ["VJgpLgKdUIPftcUVNppF", "rXthYJuKpk", "wEnNGBhAOAVStamW", "GLluZWGikPiLOd", "pFBORUGcvQohplqjtjmV", "sAqRjAdnhmUGcAdLP"]}, "output": 0}, {"input": {"strings": ["spArkkpDsCfW", "GDjWjtvKJLtNoLQyMha", "NyuIqXfPUhVohFCdy", "VzYSvQRPgRUjWiEe", "vyWYyelgZH", "huyvEXOQitcB", "CcENnhrwOp"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jennifersong/advent_of_code", "path": "/5/day5b.py", "msgidx": 1304}}
{"problem_description": "Given a range of 5-digit numbers, what are the sequences of six consecutive prime numbers within that range, where the differences between consecutive numbers in the sequence follow the pattern: b = a + 2, c = b + 4, d = c + 6, e = d + 8, and f = e + 10?", "io_requirements": "Input:\n  `start_range` (int): The starting number of the range of 5-digit numbers to check for prime sequences.\n  `end_range` (int): The ending number of the range of 5-digit numbers to check for prime sequences.\n\nOutput:\n  `return` (list of lists of int): A list containing lists of six consecutive prime numbers that satisfy the given conditions. Each inner list represents a sequence of numbers [a, b, c, d, e, f] where b = a + 2, c = b + 4, d = c + 6, e = d + 8, and f = e + 10.", "refcode": "# import necessary packages\nfrom math import sqrt\n\n# Function to check if a number is prime\ndef is_prime(num):\n    for i in range(2, round(sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(start_range, end_range):\n    # start_range and end_range should be integers representing the range of 5-digit numbers to check\n    results = []\n    for i in range(start_range, end_range, 2):\n        check = []\n        for x in range(i, i + 31):\n            check.append(is_prime(x))\n            if check.count(True) > 6:\n                break\n        if (check.count(True) == 6 and\n            is_prime(i) and is_prime(i + 2) and is_prime(i + 6) and\n            is_prime(i + 12) and is_prime(i + 20) and is_prime(i + 30)):\n            results.append([i, i + 2, i + 6, i + 12, i + 20, i + 30])\n    return results", "funcname": "main_solution", "ios": [{"input": {"start_range": 44001, "end_range": 46572}, "output": []}, {"input": {"start_range": 11977, "end_range": 45852}, "output": [[13901, 13903, 13907, 13913, 13921, 13931], [21557, 21559, 21563, 21569, 21577, 21587], [28277, 28279, 28283, 28289, 28297, 28307]]}, {"input": {"start_range": 95088, "end_range": 95123}, "output": []}, {"input": {"start_range": 44751, "end_range": 77998}, "output": [[55661, 55663, 55667, 55673, 55681, 55691], [68897, 68899, 68903, 68909, 68917, 68927]]}, {"input": {"start_range": 51088, "end_range": 96029}, "output": []}, {"input": {"start_range": 80765, "end_range": 83195}, "output": []}, {"input": {"start_range": 91978, "end_range": 92965}, "output": []}, {"input": {"start_range": 66724, "end_range": 81846}, "output": []}, {"input": {"start_range": 60541, "end_range": 85795}, "output": [[68897, 68899, 68903, 68909, 68917, 68927]]}, {"input": {"start_range": 31392, "end_range": 56561}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "puneeth-devadiga/COMP9021", "path": "/Lab_3_solutions/prime_practice_1.py", "msgidx": 1282}}
{"problem_description": "In a game of life simulation, a cell's state in the next generation depends on the number of its alive neighbours. Given a specific cell located at position (io, jo) in a grid of dimensions width x height, and whether the grid wraps around or not, how many alive neighbours does the cell have?", "io_requirements": "Input:\n  `io` (int): The row index of the cell in the grid.\n  `jo` (int): The column index of the cell in the grid.\n  `width` (int): The width of the grid.\n  `height` (int): The height of the grid.\n  `wrap` (bool): A boolean indicating whether the grid wraps around (True) or not (False).\n\nOutput:\n  `return` (int): The number of alive neighbours the cell at position (io, jo) has.", "refcode": "# import necessary packages\nfrom multiprocessing import Process\n\n# all class and function definitions in the code file, if any\nclass GameOfLife:\n    def hasCell(self, i, j):\n        # Placeholder method to check if a cell exists at position (i, j)\n        return True  # Assuming all cells exist for simplicity\n\nclass Cell(Process):\n    Alive = False\n\n    def __init__(self):\n        Process.__init__(self)\n        self.Alive = True\n\n    def run(self, GOL, io, jo, wr, countlist, width, height):\n        '''Counts how many neighbours the cell at io,jo has in the field Field and with or without wrap as set by wr'''\n        counter, itemp, jtemp = 0, 0, 0\n        for i in range(3):\n            itemp = io - 1 + i\n            if wr:\n                if itemp < 0:\n                    itemp = height - 1\n                elif itemp == height:\n                    itemp = 0\n            for j in range(3):\n                jtemp = jo - 1 + j\n                if itemp == io and jtemp == jo:\n                    continue\n                if wr:\n                    if jtemp < 0:\n                        jtemp = width - 1\n                    elif jtemp == width:\n                        jtemp = 0\n                    if GOL.hasCell(itemp, jtemp):\n                        counter += 1\n                else:\n                    if itemp >= 0 and jtemp >= 0 and itemp < height and jtemp < width and GOL.hasCell(itemp, jtemp):\n                        counter += 1\n        countlist[(io, jo)] = counter\n\n# main function\ndef main_solution(io, jo, width, height, wrap):\n    # Convert JSON serializable inputs to original input variables\n    GOL = GameOfLife()\n    countlist = {}\n    cell = Cell()\n    cell.run(GOL, io, jo, wrap, countlist, width, height)\n    \n    # Convert output to JSON serializable format\n    result = countlist[(io, jo)]\n    \n    # Return the final output\n    return result", "funcname": "main_solution", "ios": [{"input": {"io": 4, "jo": 1, "width": 13, "height": 17, "wrap": false}, "output": 8}, {"input": {"io": 4, "jo": 1, "width": 16, "height": 15, "wrap": true}, "output": 8}, {"input": {"io": 0, "jo": 5, "width": 17, "height": 11, "wrap": false}, "output": 5}, {"input": {"io": 3, "jo": 2, "width": 11, "height": 11, "wrap": false}, "output": 8}, {"input": {"io": 3, "jo": 9, "width": 15, "height": 14, "wrap": false}, "output": 8}, {"input": {"io": 3, "jo": 9, "width": 19, "height": 16, "wrap": false}, "output": 8}, {"input": {"io": 2, "jo": 1, "width": 12, "height": 18, "wrap": false}, "output": 8}, {"input": {"io": 3, "jo": 4, "width": 16, "height": 11, "wrap": false}, "output": 8}, {"input": {"io": 2, "jo": 7, "width": 20, "height": 12, "wrap": true}, "output": 8}, {"input": {"io": 3, "jo": 8, "width": 15, "height": 10, "wrap": false}, "output": 8}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Tritlo/GameOfLife", "path": "/Cell.py", "msgidx": 958}}
{"problem_description": "In a game of Tic-Tac-Toe, given the current state of the board and the player whose turn it is, what will be the state of the board after the AI makes its move?", "io_requirements": "Input:\n- `board_state` (list of lists of strings): A 3x3 grid representing the current state of the Tic-Tac-Toe board. Each cell can be either `'X'`, `'O'`, or `'_'` (empty).\n- `current_turn` (string): A single character representing the current player's turn. It can be either `'X'` or `'O'`.\n\nOutput:\n- `return` (list of lists of strings): A 3x3 grid representing the updated state of the Tic-Tac-Toe board after the AI has made its move.", "refcode": "# import necessary packages\nfrom copy import deepcopy\nimport math\n\n# Constants\nINITIAL_BOARD = [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]\nPLAYER_SIGN = 'X'\nCOMPUTER_SIGN = 'O'\nEMPTY_PLACE = '_'\n\n# Board class definition\nclass Board():\n    def __init__(self, board):\n        self.board = board\n\n    def __getitem__(self, index):\n        return self.board[index]\n\n    def __setitem__(self, index, value):\n        self.board[index] = value\n\n    def check_is_empty_place(self, move):\n        return self.board[move[0]][move[1]] == '_'\n\n    def make_move_on_board(self, move, sign):\n        self.board[move[0]][move[1]] = sign\n        return self.board\n\n    def is_board_full(self):\n        for elem in self.board:\n            for el in elem:\n                if el == '_':\n                    return False\n        return True\n\n    def utility(self):\n        brd = self.board\n        diagonals = [[brd[0][0], brd[1][1], brd[2][2]],\n                     [brd[2][0], brd[1][1], brd[0][2]]\n                     ]\n\n        rows_and_columns = [[brd[0][0], brd[0][1], brd[0][2]],\n                            [brd[1][0], brd[1][1], brd[1][2]],\n                            [brd[2][0], brd[2][1], brd[2][2]],\n                            [brd[0][0], brd[1][0], brd[2][0]],\n                            [brd[0][1], brd[1][1], brd[2][1]],\n                            [brd[0][2], brd[1][2], brd[2][2]],\n                            ]\n\n        if ['X', 'X', 'X'] in diagonals or ['X', 'X', 'X'] in rows_and_columns:\n            return -1\n        elif ['O', 'O', 'O'] in diagonals or ['O', 'O', 'O'] in rows_and_columns:\n            return 1\n        elif not self.is_board_full():\n            return -2\n        return 0\n\n# Minimax functions\ndef max_value(board, alpha, beta, initDepth, bestDepth):\n    best = -math.inf\n    next_move = (0, 0)\n    isTerminalState = board.utility()\n    if isTerminalState == -1:\n        return (-1, next_move, initDepth, bestDepth)\n    elif isTerminalState == 1:\n        return (1, next_move, initDepth, bestDepth)\n    elif isTerminalState == 0:\n        return (0, next_move, initDepth, bestDepth)\n\n    for i in reversed(range(0, 3)):\n        for j in reversed(range(0, 3)):\n            current_board = deepcopy(board)\n            if current_board[i][j] == EMPTY_PLACE:\n                depth = initDepth\n                current_board[i][j] = COMPUTER_SIGN\n                new_best = min_value(current_board, alpha, beta, depth + 1, bestDepth)\n                depth = new_best[2]\n                bestDepth = new_best[3]\n                if new_best[0] > best or (new_best[0] == best and depth < bestDepth):\n                    best = new_best[0]\n                    next_move = (i, j)\n                    bestDepth = depth\n                if best >= beta:\n                    return (best, next_move, depth, bestDepth)\n                alpha = max(best, alpha)\n    return (best, next_move, depth, bestDepth)\n\ndef min_value(board, alpha, beta, initDepth, bestDepth):\n    best = math.inf\n    next_move = (0, 0)\n    isTerminalState = board.utility()\n    if isTerminalState == -1:\n        return (-1, next_move, initDepth, bestDepth)\n    elif isTerminalState == 1:\n        return (1, next_move, initDepth, bestDepth)\n    elif isTerminalState == 0:\n        return (0, next_move, initDepth, bestDepth)\n\n    for i in range(0, 3):\n        for j in range(0, 3):\n            current_board = deepcopy(board)\n            if current_board[i][j] == EMPTY_PLACE:\n                depth = initDepth\n                current_board[i][j] = PLAYER_SIGN\n                new_best = max_value(current_board, alpha, beta, depth + 1, bestDepth)\n                depth = new_best[2]\n                bestDepth = new_best[3]\n                if new_best[0] < best or (new_best[0] == best and depth < bestDepth):\n                    best = new_best[0]\n                    next_move = (i, j)\n                    bestDepth = depth\n                if best <= alpha:\n                    return (best, next_move, depth, bestDepth)\n                beta = min(best, beta)\n    return (best, next_move, depth, bestDepth)\n\ndef ai_move(board):\n    depth = 0\n    bestDepth = 11\n    board_copy = deepcopy(board)\n    (m, move, d, bd) = max_value(board_copy, -math.inf, math.inf, depth, bestDepth)\n    board[move[0]][move[1]] = 'O'\n    return board\n\n# Main function\ndef main_solution(board_state, current_turn):\n    board = Board(board_state)\n    if current_turn == 'X':\n        board = deepcopy(ai_move(board))\n    else:\n        board = deepcopy(ai_move(board))\n    return board.board", "funcname": "main_solution", "ios": [{"input": {"board_state": [["X", "_", "_"], ["_", "O", "_"], ["_", "_", "_"]], "current_turn": "O"}, "output": [["X", "_", "_"], ["_", "O", "_"], ["_", "_", "_"]]}, {"input": {"board_state": [["_", "_", "O"], ["O", "_", "_"], ["X", "_", "O"]], "current_turn": "X"}, "output": [["_", "_", "O"], ["O", "_", "_"], ["X", "_", "O"]]}, {"input": {"board_state": [["_", "_", "_"], ["_", "O", "_"], ["_", "_", "O"]], "current_turn": "O"}, "output": [["_", "_", "_"], ["_", "O", "_"], ["_", "_", "O"]]}, {"input": {"board_state": [["_", "_", "_"], ["_", "O", "_"], ["X", "_", "_"]], "current_turn": "O"}, "output": [["_", "_", "_"], ["_", "O", "_"], ["X", "_", "_"]]}, {"input": {"board_state": [["X", "_", "_"], ["O", "_", "_"], ["X", "X", "O"]], "current_turn": "O"}, "output": [["X", "_", "_"], ["O", "_", "_"], ["X", "X", "O"]]}, {"input": {"board_state": [["_", "X", "_"], ["_", "_", "_"], ["_", "O", "_"]], "current_turn": "X"}, "output": [["_", "X", "_"], ["_", "_", "_"], ["_", "O", "_"]]}, {"input": {"board_state": [["_", "_", "_"], ["_", "_", "_"], ["O", "_", "O"]], "current_turn": "O"}, "output": [["_", "_", "_"], ["_", "_", "_"], ["O", "_", "O"]]}, {"input": {"board_state": [["_", "_", "_"], ["O", "O", "O"], ["_", "X", "_"]], "current_turn": "O"}, "output": [["_", "_", "_"], ["O", "O", "O"], ["_", "X", "_"]]}, {"input": {"board_state": [["X", "_", "_"], ["_", "_", "_"], ["_", "O", "X"]], "current_turn": "O"}, "output": [["X", "_", "_"], ["_", "_", "_"], ["_", "O", "X"]]}, {"input": {"board_state": [["_", "_", "_"], ["_", "_", "_"], ["_", "X", "O"]], "current_turn": "O"}, "output": [["_", "_", "_"], ["_", "_", "_"], ["_", "X", "O"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ralitsalyka/Artificial-Intelligence-Course", "path": "/Homework4-TicTacToe/tictactoe.py", "msgidx": 741}}
{"problem_description": "In a game of marbles, players take turns placing marbles in a circle. Each turn, a player places a marble and scores points if the marble's value is a multiple of 23. The game ends when all marbles are placed. Given the number of players and the value of the last marble, what is the highest score achieved by any player at the end of the game?", "io_requirements": "Input:\n  `num_players` (int): The number of players participating in the game.\n  `valuablest_marble` (int): The value of the last marble in the game.\n\nOutput:\n  `return` (int): The highest score achieved by any player at the end of the game.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(num_players, valuablest_marble):\n    # Initialize scores for each player\n    scores = {i: 0 for i in range(1, num_players + 1)}\n    # Initialize the circle with the first marble\n    circle = deque([0])\n\n    # Play the game\n    for marble in range(1, valuablest_marble + 1):\n        if marble % 23 == 0:\n            # Rotate the circle and update scores\n            circle.rotate(7)\n            scores[marble % num_players + 1] += marble + circle.pop()\n            circle.rotate(-1)\n        else:\n            # Rotate and add the marble to the circle\n            circle.rotate(-1)\n            circle.append(marble)\n\n    # Return the highest score\n    return max(scores.values()) if scores else 0", "funcname": "main_solution", "ios": [{"input": {"num_players": 27, "valuablest_marble": 137}, "output": 165}, {"input": {"num_players": 6, "valuablest_marble": 372}, "output": 960}, {"input": {"num_players": 30, "valuablest_marble": 795}, "output": 1225}, {"input": {"num_players": 68, "valuablest_marble": 900}, "output": 1282}, {"input": {"num_players": 52, "valuablest_marble": 195}, "output": 227}, {"input": {"num_players": 69, "valuablest_marble": 209}, "output": 520}, {"input": {"num_players": 94, "valuablest_marble": 893}, "output": 1251}, {"input": {"num_players": 48, "valuablest_marble": 205}, "output": 227}, {"input": {"num_players": 62, "valuablest_marble": 207}, "output": 244}, {"input": {"num_players": 3, "valuablest_marble": 674}, "output": 4947}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "meggangreen/advent-code-2018", "path": "/files/day-09.py", "msgidx": 1492}}
{"problem_description": "In a pancake flipping contest, contestants are given a stack of pancakes with some burnt sides up ('-') and some burnt sides down ('+'). They are also provided with a flipper of a certain size. The goal is to determine the minimum number of flips required to make all pancakes have the burnt side down ('+'). If it's impossible to achieve this, the contestant should indicate that it's \"IMPOSSIBLE\". Given the state of the pancakes and the size of the flipper, how many flips are needed to achieve the goal?", "io_requirements": "Input:\n  `pancakes` (str): A string representing the state of the pancakes, where '-' indicates a pancake with the burnt side up and '+' indicates a pancake with the burnt side down.\n  `flipper` (str): A string representing the size of the flipper, which is an integer.\n\nOutput:\n  `return` (str): A string representing the minimum number of flips required to make all pancakes have the burnt side down ('+'). If it's impossible to achieve this, the string \"IMPOSSIBLE\" is returned.", "refcode": "# import necessary packages\nimport sys\nsys.setrecursionlimit(1500)\n\n# all class and function definitions in the code file, if any\ndef pancake_reverse(pancakes):\n    result = \"\"\n    for pancake in pancakes:\n        if pancake == '-':\n            result += '+'\n        elif pancake == '+':\n            result += '-'\n        else:\n            raise Exception(\"Impossible!\")\n    return result\n\ndef solve(pancakes, flipper):\n    if len(pancakes) == flipper:\n        if pancakes == flipper * '+':\n            return 0\n        if pancakes == flipper * '-':\n            return 1\n        return \"IMPOSSIBLE\"\n    if pancakes[0] == '-':\n        rec = solve(pancake_reverse(pancakes[1:flipper]) + pancakes[flipper:], flipper)\n        if rec == \"IMPOSSIBLE\":\n            return \"IMPOSSIBLE\"\n        return 1 + rec\n    else:\n        rec = solve(pancakes[1:], flipper)\n        if rec == \"IMPOSSIBLE\":\n            return \"IMPOSSIBLE\"\n        return rec\n\n# main function\ndef main_solution(pancakes, flipper):\n    # Convert flipper to integer\n    flipper = int(flipper)\n    \n    # Call the solve function\n    result = solve(pancakes, flipper)\n    \n    # Convert the result to a string if it's not \"IMPOSSIBLE\"\n    if result != \"IMPOSSIBLE\":\n        result = str(result)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"pancakes": "--+-+-", "flipper": "3"}, "output": "IMPOSSIBLE"}, {"input": {"pancakes": "+-++-+-+", "flipper": "6"}, "output": "IMPOSSIBLE"}, {"input": {"pancakes": "+++-+--++", "flipper": "8"}, "output": "IMPOSSIBLE"}, {"input": {"pancakes": "+-+", "flipper": "3"}, "output": "IMPOSSIBLE"}, {"input": {"pancakes": "--+", "flipper": "1"}, "output": "2"}, {"input": {"pancakes": "+++++++++-", "flipper": "3"}, "output": "IMPOSSIBLE"}, {"input": {"pancakes": "-+", "flipper": "2"}, "output": "IMPOSSIBLE"}, {"input": {"pancakes": "-", "flipper": "1"}, "output": "1"}, {"input": {"pancakes": "+-", "flipper": "2"}, "output": "IMPOSSIBLE"}, {"input": {"pancakes": "------++--", "flipper": "7"}, "output": "IMPOSSIBLE"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dr-dos-ok/Code_Jam_Webscraper", "path": "/solutions_python/Problem_199/1127.py", "msgidx": 1283}}
{"problem_description": "Given a binary watch with 4 LEDs representing hours and 6 LEDs representing minutes, if a certain number of LEDs are turned on, what are all the possible times that the watch could display?", "io_requirements": "Input:\n  `num` (int): The number of LEDs that are currently on. It should be a non-negative integer less than 10.\n\nOutput:\n  `return` (List[str]): A list of strings representing all possible times in the format \"H:MM\". Each string represents a valid time that the binary watch could display with the given number of LEDs on.", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(num: int) -> List[str]:\n    \"\"\"\n    Given a non-negative integer `num` representing the number of LEDs that are currently on,\n    return all possible times the binary watch could represent.\n\n    Args:\n        num (int): The number of LEDs that are currently on.\n\n    Returns:\n        List[str]: A list of strings representing all possible times in the format \"H:MM\".\n    \"\"\"\n    def build_time_string(buf: List[bool]):\n        hour = 0\n        v = 1\n        for i in range(4):\n            if buf[i]:\n                hour += v\n            v <<= 1\n        minute = 0\n        v = 1\n        for i in range(4, 10):\n            if buf[i]:\n                minute += v\n            v <<= 1\n        return [hour < 12 and minute < 60, \"%d:%02d\" % (hour, minute)]\n\n    def next(num: int, start: int, buf: List[bool], result: List[str]):\n        if num > 0:\n            for i in range(start, 11-num):\n                buf[i] = True\n                next(num-1, i+1, buf, result)\n                buf[i] = False\n        else:\n            r = build_time_string(buf)\n            if r[0]:\n                result.append(r[1])\n\n    retval = []\n    if num < 10:\n        buf = [False for _ in range(10)]\n        next(num, 0, buf, retval)\n    return retval", "funcname": "main_solution", "ios": [{"input": {"num": 0}, "output": ["0:00"]}, {"input": {"num": 1}, "output": ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]}, {"input": {"num": 8}, "output": ["7:31", "7:47", "7:55", "7:59", "11:31", "11:47", "11:55", "11:59"]}, {"input": {"num": 9}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cyril-gao/wheel", "path": "/Algorithms/leetcode/Python/backtracking/binary_watch.py", "msgidx": 1474}}
{"problem_description": "Given an encoded message consisting of digits from '0' to '9', how many different ways can the message be decoded into a sequence of uppercase letters, where each letter corresponds to a number between '1' and '26'?", "io_requirements": "Input:\n  `S` (str): A string of digits from '0' to '9' representing an encoded message.\n\nOutput:\n  `return` (int): The number of ways to decode the encoded message `S`.", "refcode": "# import necessary packages\nimport string\n\n# main function\ndef main_solution(S: str) -> int:\n    # Convert the input string to a list of characters for easier manipulation\n    S = list(S)\n    \n    # Create a mapping from numbers to corresponding uppercase letters\n    charMap = {str(i + 1): string.ascii_uppercase[i] for i in range(26)}\n    \n    # Initialize a list to store the results\n    result = []\n    \n    # Helper function to recursively decode the string\n    def helper(s, acc):\n        if not s and acc:\n            result.append(acc)\n            return\n        curr = \"\"\n        for i, num in enumerate(s):\n            curr += num\n            if curr in charMap:\n                helper(s[i + 1:], acc + charMap[curr])\n    \n    # Start the recursive decoding process\n    helper(S, \"\")\n    \n    # Return the number of ways to decode the string\n    return len(result)", "funcname": "main_solution", "ios": [{"input": {"S": "11"}, "output": 2}, {"input": {"S": "851"}, "output": 1}, {"input": {"S": "682524"}, "output": 4}, {"input": {"S": "34"}, "output": 1}, {"input": {"S": "818417"}, "output": 4}, {"input": {"S": "1242"}, "output": 3}, {"input": {"S": "4639164362"}, "output": 2}, {"input": {"S": "933"}, "output": 1}, {"input": {"S": "1917776"}, "output": 4}, {"input": {"S": "786"}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "scottwedge/algorithm", "path": "/_pramp/200202/decode_variations_mine.py", "msgidx": 1800}}
{"problem_description": "A robotics company, Trax, has developed a self-driving robot designed to traverse desert environments. The robot moves in a circular pattern, taking steps forward and turning at a constant angle. Given the initial position and orientation of the robot, the turning angle, the step size, and the number of steps it should take, what will be the final position of the robot after completing these steps?", "io_requirements": "Input:\n  `initial_x` (float): The initial x-coordinate of the robot's position.\n  `initial_y` (float): The initial y-coordinate of the robot's position.\n  `initial_orientation` (float): The initial orientation of the robot in degrees.\n  `turning_angle` (float): The turning angle of the robot in degrees.\n  `step_size` (float): The distance the robot moves in each step.\n  `num_steps` (int): The number of steps the robot should take.\n\nOutput:\n  `return` (tuple of floats): The final (x, y) coordinates of the robot after the specified number of steps.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Robot:\n    def __init__(self, x, y, orientation, turning, distance):\n        self.x = x\n        self.y = y\n        self.orientation = orientation\n        self.turning = turning\n        self.distance = distance\n\n    def move(self):\n        self.orientation += self.turning\n        self.x += self.distance * np.cos(self.orientation)\n        self.y += self.distance * np.sin(self.orientation)\n        return (self.x, self.y)\n\n# main function\ndef main_solution(initial_x, initial_y, initial_orientation, turning_angle, step_size, num_steps):\n    # Convert JSON serializable inputs to the original input variables\n    initial_orientation = np.radians(initial_orientation)\n    turning_angle = np.radians(turning_angle)\n    \n    # Create the robot instance\n    robot = Robot(initial_x, initial_y, initial_orientation, turning_angle, step_size)\n    \n    # Move the robot for the specified number of steps\n    for _ in range(num_steps):\n        robot.move()\n    \n    # Convert the output to JSON serializable format\n    final_position = (round(robot.x, 2), round(robot.y, 2))\n    \n    return final_position", "funcname": "main_solution", "ios": [{"input": {"initial_x": 25.74, "initial_y": -13.45, "initial_orientation": 132.5, "turning_angle": -158.56, "step_size": 2.05, "num_steps": 15}, "output": [26.84, -15.08]}, {"input": {"initial_x": -14.92, "initial_y": 39.6, "initial_orientation": 200.17, "turning_angle": 96.61, "step_size": 3.49, "num_steps": 52}, "output": [-14.59, 40.18]}, {"input": {"initial_x": 90.04, "initial_y": 29.49, "initial_orientation": 281.74, "turning_angle": 116.27, "step_size": 7.53, "num_steps": 1}, "output": [95.97, 34.13]}, {"input": {"initial_x": -30.42, "initial_y": -22.06, "initial_orientation": 355.51, "turning_angle": 4.39, "step_size": 6.04, "num_steps": 36}, "output": [5.13, 128.62]}, {"input": {"initial_x": 28.82, "initial_y": -82.85, "initial_orientation": 114.07, "turning_angle": 5.98, "step_size": 0.79, "num_steps": 15}, "output": [18.67, -79.53]}, {"input": {"initial_x": 70.25, "initial_y": 70.08, "initial_orientation": 80.56, "turning_angle": 0.13, "step_size": 2.69, "num_steps": 94}, "output": [84.62, 322.05]}, {"input": {"initial_x": 41.0, "initial_y": -9.35, "initial_orientation": 200.29, "turning_angle": -171.71, "step_size": 2.02, "num_steps": 31}, "output": [42.12, -9.92]}, {"input": {"initial_x": 52.4, "initial_y": -46.05, "initial_orientation": 120.79, "turning_angle": -37.22, "step_size": 8.7, "num_steps": 23}, "output": [73.32, -31.86]}, {"input": {"initial_x": -69.47, "initial_y": 89.81, "initial_orientation": 303.45, "turning_angle": 149.03, "step_size": 9.69, "num_steps": 5}, "output": [-67.58, 90.92]}, {"input": {"initial_x": 51.84, "initial_y": -28.95, "initial_orientation": 270.34, "turning_angle": 102.51, "step_size": 1.84, "num_steps": 99}, "output": [53.16, -29.05]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "di-wendy/CS8803", "path": "/studentMain.py", "msgidx": 1573}}
{"problem_description": "Given a set of `n` disks stacked in increasing order of size on one of three pegs (A, B, C), what is the sequence of moves required to transfer all disks from peg A to peg C using peg B as an auxiliary peg, following the rules of the Tower of Hanoi puzzle?", "io_requirements": "Input:\n  `n` (int): The number of disks to be moved. It should be a positive integer.\n\nOutput:\n  `return` (str): A JSON-formatted string representing the sequence of moves required to solve the Tower of Hanoi problem. Each move is represented as a dictionary with keys `\"disk\"` (int), `\"from\"` (str), and `\"to\"` (str).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef TOH(n, A, C, B, moves):\n    if n > 0:\n        TOH(n-1, A, B, C, moves)  # A to B using C\n        moves.append({\"disk\": n, \"from\": A, \"to\": C})\n        TOH(n-1, B, C, A, moves)  # B to C using A\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    moves = []\n    TOH(n, 'A', 'C', 'B', moves)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return json.dumps(moves)", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": "[{\"disk\": 1, \"from\": \"A\", \"to\": \"C\"}]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hemangbehl/Data-Structures-Algorithms_practice", "path": "/leetcode_session2/stack_q17_Tower_of_Hanoi_recurssive.py", "msgidx": 1655}}
{"problem_description": "Given a set of 10 unique digits (0-9), how many 10-digit pandigital numbers can be formed that satisfy the following properties: the number formed by the 2nd, 3rd, and 4th digits is divisible by 2, the number formed by the 3rd, 4th, and 5th digits is divisible by 3, the number formed by the 4th, 5th, and 6th digits is divisible by 5, the number formed by the 5th, 6th, and 7th digits is divisible by 7, the number formed by the 6th, 7th, and 8th digits is divisible by 11, the number formed by the 7th, 8th, and 9th digits is divisible by 13, and the number formed by the 8th, 9th, and 10th digits is divisible by 17? What is the sum of all such 10-digit pandigital numbers?", "io_requirements": "Input:\n  `digits` (list of integers): A list of 10 unique digits (0-9) that will be used to generate permutations.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `count_of_pandigitals` (int): The count of 10-digit pandigital numbers with the specified sub-string divisibility properties.\n    - `sum_of_pandigitals` (int): The sum of all 10-digit pandigital numbers with the specified sub-string divisibility properties.", "refcode": "import itertools\n\ndef is10DigitPandigital(numstr):\n    resultSet = set()\n    noduplicates = True\n    for char in numstr:\n        digChar = int(char)\n        if digChar in resultSet:\n            noduplicates = False\n        else:\n            resultSet.add(digChar)\n    if noduplicates:\n        return True\n    return False\n\ndef main_solution(digits):\n    sum_of_pandigitals = 0\n    count_of_pandigitals = 0\n    digitsSet = set(digits)\n    \n    for i in itertools.permutations(digitsSet, 10):\n        d1, d2, d3, d4, d5, d6, d7, d8, d9, d10 = i\n\n        d2d3d4 = d2 * 100 + d3 * 10 + d4\n        d3d4d5 = d3 * 100 + d4 * 10 + d5\n        d4d5d6 = d4 * 100 + d5 * 10 + d6\n        d5d6d7 = d5 * 100 + d6 * 10 + d7\n        d6d7d8 = d6 * 100 + d7 * 10 + d8\n        d7d8d9 = d7 * 100 + d8 * 10 + d9\n        d8d9d10 = d8 * 100 + d9 * 10 + d10\n\n        if (d2d3d4 % 2 == 0 and\n            d3d4d5 % 3 == 0 and\n            d4d5d6 % 5 == 0 and\n            d5d6d7 % 7 == 0 and\n            d6d7d8 % 11 == 0 and\n            d7d8d9 % 13 == 0 and\n            d8d9d10 % 17 == 0):\n            strnum = ''.join(map(str, i))\n            val = int(strnum)\n            count_of_pandigitals += 1\n            sum_of_pandigitals += val\n\n    return {\"count_of_pandigitals\": count_of_pandigitals, \"sum_of_pandigitals\": sum_of_pandigitals}", "funcname": "main_solution", "ios": [{"input": {"digits": [3, 9, 7, 1, 0, 6, 4, 2, 5, 8]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [3, 1, 2, 8, 6, 7, 0, 5, 4, 9]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [2, 6, 3, 5, 8, 9, 0, 7, 1, 4]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [9, 0, 5, 6, 7, 3, 8, 1, 2, 4]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [1, 6, 8, 9, 4, 0, 3, 2, 5, 7]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [8, 9, 4, 0, 6, 1, 3, 2, 7, 5]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [2, 8, 0, 6, 9, 7, 1, 3, 5, 4]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [9, 6, 0, 3, 2, 8, 4, 7, 1, 5]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [0, 8, 1, 9, 5, 2, 3, 4, 6, 7]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}, {"input": {"digits": [1, 0, 3, 7, 8, 2, 4, 5, 9, 6]}, "output": {"count_of_pandigitals": 6, "sum_of_pandigitals": 16695334890}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jnash67/eulerpython", "path": "/euler43.py", "msgidx": 1065}}
{"problem_description": "Given a spiral matrix formed by starting with the number 1 and moving to the right in a clockwise direction, what is the sum of the numbers on the diagonals in an n by n spiral matrix?", "io_requirements": "Input:\n  `n` (int): The size of the spiral matrix (n x n). It must be an odd integer greater than or equal to 1.\n\nOutput:\n  `return` (int): The sum of the numbers on the diagonals of the n x n spiral matrix.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(n):\n    # Initialize the sum with the center value 1\n    ret = 1\n    cur = 1\n    size = 1\n    i = 1\n    \n    # Loop until the size of the spiral reaches n\n    while size < n:\n        # Calculate the values of the four corners of the current layer\n        bottomRight = cur + 2 * i\n        bottomLeft = cur + 4 * i\n        topLeft = cur + 6 * i\n        topRight = cur + 8 * i\n        \n        # Update the current value to the top right corner of the current layer\n        cur = topRight\n        \n        # Add the values of the four corners to the sum\n        ret += bottomRight + bottomLeft + topLeft + topRight\n        \n        # Increment the layer index and update the size of the spiral\n        i += 1\n        size += 2\n    \n    # Return the sum of the numbers on the diagonals\n    return ret", "funcname": "main_solution", "ios": [{"input": {"n": 287}, "output": 15801501}, {"input": {"n": 691}, "output": 220199241}, {"input": {"n": 569}, "output": 122975977}, {"input": {"n": 581}, "output": 130918181}, {"input": {"n": 169}, "output": 3232377}, {"input": {"n": 279}, "output": 14517717}, {"input": {"n": 655}, "output": 187556301}, {"input": {"n": 783}, "output": 320340045}, {"input": {"n": 477}, "output": 72468621}, {"input": {"n": 673}, "output": 203441505}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chrisbubernak/ProjectEulerChallenges", "path": "/28_NumberSpiralDiagonals.py", "msgidx": 1788}}
{"problem_description": "Given the schedules of two individuals, represented by their respective time intervals during which they are busy, what are the common free time intervals during which both individuals are available?", "io_requirements": "Input:\n  `A` (list of lists of integers): A list of time intervals where each interval is represented as a list of two integers [start, end].\n  `B` (list of lists of integers): A list of time intervals where each interval is represented as a list of two integers [start, end].\n\nOutput:\n  `return` (list of lists of integers): A list of time intervals where each interval is represented as a list of two integers [start, end], representing the common free time intervals between A and B.", "refcode": "# import necessary packages\nfrom queue import PriorityQueue\nfrom functools import cmp_to_key\n\n# all class and function definitions in the code file, if any\ndef comp(a, b):\n    if a[0] == b[0]:\n        return a[1] - b[1]\n    else:\n        return a[0] - b[0]\n\ndef commomTime(A, B):\n    l = []\n    for a in A:\n        l.append((a[0], 1))\n        l.append((a[1], -1))\n    for b in B:\n        l.append((b[0], 1))\n        l.append((b[1], -1))\n    l = sorted(l, key=cmp_to_key(comp))\n    count = 0\n    currStart = l[0][0]\n    res = []\n    for time in l:\n        if time[1] == 1:\n            currStart = time[0]\n        else:\n            if count == 2:\n                res.append([currStart, time[0]])\n            currStart = -1\n        count += time[1]\n    return res\n\n# main function\ndef main_solution(A, B):\n    # Convert input lists to JSON serializable format\n    A = [[int(a[0]), int(a[1])] for a in A]\n    B = [[int(b[0]), int(b[1])] for b in B]\n    \n    # Call the core function\n    result = commomTime(A, B)\n    \n    # Convert output to JSON serializable format\n    result = [[int(r[0]), int(r[1])] for r in result]\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"A": [[14, 23], [13, 14]], "B": [[19, 21]]}, "output": [[19, 21]]}, {"input": {"A": [[3, 15], [12, 16], [17, 19]], "B": [[0, 18]]}, "output": [[-1, 16], [17, 18]]}, {"input": {"A": [[0, 13]], "B": [[22, 24], [23, 24]]}, "output": [[23, 24]]}, {"input": {"A": [[23, 24], [14, 22], [8, 21]], "B": [[17, 20]]}, "output": [[-1, 21]]}, {"input": {"A": [[3, 24], [12, 14], [13, 16]], "B": [[10, 12]]}, "output": [[10, 12], [-1, 16]]}, {"input": {"A": [[19, 21], [6, 8]], "B": [[17, 20]]}, "output": [[19, 20]]}, {"input": {"A": [[12, 21], [1, 10]], "B": [[14, 17]]}, "output": [[14, 17]]}, {"input": {"A": [[0, 7]], "B": [[0, 3], [6, 21]]}, "output": [[0, 3], [6, 7]]}, {"input": {"A": [[6, 22], [23, 24]], "B": [[7, 24], [6, 21]]}, "output": [[-1, 22], [23, 24]]}, {"input": {"A": [[3, 23]], "B": [[12, 16], [22, 24], [0, 21]]}, "output": [[-1, 21], [22, 23]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "xufanxingxing/PythonPractice", "path": "/facebook/twoList.py", "msgidx": 1719}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of n pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n\n    def helper(self, res, path, left, right):\n        if left > right: return\n        if left == 0 and right == 0:\n            res.append(path[0:])\n        if left > 0:\n            self.helper(res, path + '(', left-1, right)\n        if right > 0:\n            self.helper(res, path + ')', left, right-1)\n\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        path = ''\n        self.helper(res, path, n, n)\n        return res\n\n# main function\ndef main_solution(n):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.generateParenthesis(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yehongyu/acode", "path": "/2019/binary_search/generate_parentheses_22.py", "msgidx": 1644}}
{"problem_description": "Given two binary inputs, what is the result of the XOR operation on these inputs?", "io_requirements": "Input:\n  `x1` (int): The first binary input (0 or 1).\n  `x2` (int): The second binary input (0 or 1).\n\nOutput:\n  `return` (int): The output of the XOR operation, which is either 0 or 1.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef NAND(x1, x2):\n    x = np.array([x1, x2])\n    w = np.array([-0.5, -0.5])\n    b = 0.7\n    tmp = np.sum(w * x) + b\n    if tmp <= 0:\n        return 0\n    else:\n        return 1\n\ndef OR(x1, x2):\n    x = np.array([x1, x2])\n    w = np.array([0.5, 0.5])\n    b = -0.2\n    tmp = np.sum(x * w) + b\n    if tmp <= 0:\n        return 0\n    else:\n        return 1\n\ndef AND(x1, x2):\n    w1, w2, theta = 0.5, 0.5, 0.7\n    tmp = x1 * w1 + x2 * w2\n    if tmp <= theta:\n        return 0\n    elif tmp > theta:\n        return 1\n\ndef XOR(x1, x2):\n    s1 = NAND(x1, x2)\n    s2 = OR(x1, x2)\n    y = AND(s1, s2)\n    return y\n\n# main function\ndef main_solution(x1, x2):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = XOR(x1, x2)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"x1": 1, "x2": 1}, "output": 0}, {"input": {"x1": 1, "x2": 0}, "output": 1}, {"input": {"x1": 0, "x2": 0}, "output": 0}, {"input": {"x1": 0, "x2": 1}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "peterlee0127/python-practice", "path": "/deep learning/gate.py", "msgidx": 1863}}
{"problem_description": "Given a binary tree represented by a list in level order traversal, where `None` indicates a null node, determine whether the tree is symmetric. A tree is symmetric if it looks the same when reflected across its center. What is the result of checking the symmetry of the given binary tree?", "io_requirements": "Input:\n  `tree_data` (list of integers or None): A list representing the binary tree in level order traversal. `None` represents a null node.\n\nOutput:\n  `return` (boolean): `True` if the binary tree is symmetric, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Function to convert JSON serializable input to TreeNode\ndef list_to_tree(data):\n    if not data:\n        return None\n    root = TreeNode(data[0])\n    queue = [root]\n    index = 1\n    while queue and index < len(data):\n        node = queue.pop(0)\n        if data[index] is not None:\n            node.left = TreeNode(data[index])\n            queue.append(node.left)\n        index += 1\n        if index < len(data) and data[index] is not None:\n            node.right = TreeNode(data[index])\n            queue.append(node.right)\n        index += 1\n    return root\n\n# Function to check if a binary tree is symmetric\nclass Solution(object):\n    def isSymmetric(self, root):\n        return self.symmetric(root, root)\n    \n    def symmetric(self, root1, root2):\n        if root1 == None and root2 == None:\n            return True\n        if root1 == None or root2 == None:\n            return False\n        return root1.val == root2.val and self.symmetric(root1.left, root2.right) and self.symmetric(root1.right, root2.left)\n\n# main function\ndef main_solution(tree_data):\n    # Convert JSON serializable input to TreeNode\n    root = list_to_tree(tree_data)\n    \n    # Check if the tree is symmetric\n    solution = Solution()\n    is_symmetric = solution.isSymmetric(root)\n    \n    # Return the result as a JSON serializable output\n    return is_symmetric", "funcname": "main_solution", "ios": [{"input": {"tree_data": [41, 50, 38, 58, 75, 73, 19, 32, 60, 60, 97, 88, null, 20, 46]}, "output": false}, {"input": {"tree_data": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]}, "output": true}, {"input": {"tree_data": [null]}, "output": true}, {"input": {"tree_data": [5, null, 15, null, null, 45, 38, null, null, null, null, null, 18, 65, 7]}, "output": false}, {"input": {"tree_data": [75]}, "output": true}, {"input": {"tree_data": [71, 5, null]}, "output": false}, {"input": {"tree_data": [9, 44, 92]}, "output": false}, {"input": {"tree_data": [37, 8, 94, 22, 76, 27, 37]}, "output": false}, {"input": {"tree_data": [1]}, "output": true}, {"input": {"tree_data": [79, null, 96]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "FishRedLeaf/my_code", "path": "/leetcode/dfs/101\u5bf9\u79f0\u4e8c\u53c9\u6811.py", "msgidx": 1710}}
{"problem_description": "Imagine you have a crystal ball and you want to determine its hardness coefficient by dropping it from different floors of a building. The building has `n` floors and you have `d` crystal balls. The hardness coefficient is the highest floor from which the ball can be dropped without breaking. Given the number of floors and the number of balls, what is the hardness coefficient of the crystal ball, and how many drops and balls were used or broken during the experiment?", "io_requirements": "Input:\n  `n` (int): The number of floors.\n  `d` (int): The number of balls.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `radix` (int): The radix chosen for the experiment.\n    - `removed_balls` (int): The number of unnecessary balls removed.\n    - `hardness_coefficient` (int): The hardness coefficient of the crystal.\n    - `total_drops` (int): The total number of drops performed.\n    - `balls_broken` (int): The number of balls broken during the experiment.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef convertToDecimal(r, d, rep):\n    number = 0\n    for i in range(d-1):\n        number = (number + rep[i]) * r\n    number += rep[d-1]\n    return number\n\n# main function\ndef main_solution(n, d):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # First determine the radix r\n    r = 1\n    while (r**d <= n):\n        r += 1\n    \n    d_init = d\n    # Exercise 1: remove unnecessary balls\n    while (r**(d-1) > n):\n        d -= 1\n    removed_balls = d_init - d\n    \n    interval = {'start': 0, 'end': n}\n    numDrops = 0\n    floorNoBreak = [0] * d\n    balls_broken = 0\n    for i in range(d):\n        # Begin phase i\n        for j in range(r-1):\n            # increment ith digit of representation\n            floorNoBreak[i] += 1\n            Floor = convertToDecimal(r, d, floorNoBreak)\n            # Make sure you aren't higher than the highest floor\n            if Floor > n:\n                floorNoBreak[i] -= 1\n                break\n\n            numDrops += 1\n            if Floor > interval['end']:\n                interval['end'] = convertToDecimal(r, d, floorNoBreak)-1\n                floorNoBreak[i] -= 1\n                balls_broken += 1\n                break\n            else:\n                interval['start'] = convertToDecimal(r, d, floorNoBreak)\n\n    hardness = convertToDecimal(r, d, floorNoBreak)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\n        \"radix\": r,\n        \"removed_balls\": removed_balls,\n        \"hardness_coefficient\": hardness,\n        \"total_drops\": numDrops,\n        \"balls_broken\": balls_broken\n    }", "funcname": "main_solution", "ios": [{"input": {"n": 70, "d": 7}, "output": {"radix": 2, "removed_balls": 0, "hardness_coefficient": 70, "total_drops": 3, "balls_broken": 0}}, {"input": {"n": 57, "d": 2}, "output": {"radix": 8, "removed_balls": 0, "hardness_coefficient": 57, "total_drops": 8, "balls_broken": 0}}, {"input": {"n": 95, "d": 10}, "output": {"radix": 2, "removed_balls": 3, "hardness_coefficient": 95, "total_drops": 6, "balls_broken": 0}}, {"input": {"n": 32, "d": 10}, "output": {"radix": 2, "removed_balls": 4, "hardness_coefficient": 32, "total_drops": 1, "balls_broken": 0}}, {"input": {"n": 92, "d": 9}, "output": {"radix": 2, "removed_balls": 2, "hardness_coefficient": 92, "total_drops": 4, "balls_broken": 0}}, {"input": {"n": 27, "d": 4}, "output": {"radix": 3, "removed_balls": 0, "hardness_coefficient": 27, "total_drops": 1, "balls_broken": 0}}, {"input": {"n": 14, "d": 5}, "output": {"radix": 2, "removed_balls": 1, "hardness_coefficient": 14, "total_drops": 3, "balls_broken": 0}}, {"input": {"n": 99, "d": 3}, "output": {"radix": 5, "removed_balls": 0, "hardness_coefficient": 99, "total_drops": 11, "balls_broken": 0}}, {"input": {"n": 51, "d": 6}, "output": {"radix": 2, "removed_balls": 0, "hardness_coefficient": 51, "total_drops": 4, "balls_broken": 0}}, {"input": {"n": 12, "d": 6}, "output": {"radix": 2, "removed_balls": 2, "hardness_coefficient": 12, "total_drops": 2, "balls_broken": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Susensio/aim.101p", "path": "/puzzle-4-please-do-break-the-crystal/balls.py", "msgidx": 1286}}
{"problem_description": "Given a set of points in a 2D plane, how many quadrangles can be formed that have points in all four quadrants and whose area is an integer?", "io_requirements": "Input:\n  `points` (list of tuples): A list of points where each point is represented as a tuple of two integers `(x, y)`. Each tuple represents the coordinates of a point in a 2D plane.\n\nOutput:\n  `return` (int): The number of nice quadrangles that can be formed from the given list of points. A nice quadrangle is defined as a quadrangle that has points in all 4 quadrants and its area is an integer.", "refcode": "# import necessary packages\nimport itertools\nimport math\n\n# all class and function definitions in the code file, if any\ndef get_quadrant(p):\n    \"\"\"\n    Gets the quadrant for a point. Point is represented as a tuple of 2, i.e., p = (x, y)\n    Returns 1 (where the signs of the two coordinates are (+,+)), 2 (\u2212,+), 3 (\u2212,\u2212), and 4 (+,\u2212).\n    Note 0 is considered to have a plus sign\n    \"\"\"\n    if p[0] >= 0 and p[1] >= 0:\n        return 1\n    elif p[0] < 0 and p[1] >= 0:\n        return 2\n    elif p[0] < 0 and p[1] < 0:\n        return 3\n    else:\n        return 4\n\ndef is_in_all_quadrants(q):\n    \"\"\"\n    Checks if the quadrange has a point in all 4 quadrants.\n    Quadrange is represented as a tuple of 4 points, i.e., q = ((x,y), (x,y), (x,y), (x,y))\n    \"\"\"\n    quadrants = [False, False, False, False]\n\n    for p in q:\n        quadrants[get_quadrant(p) - 1] = True\n\n    for b in quadrants:\n        if not b:\n            return False\n\n    return True\n\ndef area(q):\n    \"\"\"\n    Area implements Green's theorem, also known as the shoelace theorem\n    or the surveyors' theorem, which is the 2D case of the more general Stokes' theorem.\n    Call this function only if inAllQuadrants() returns true.\n    See http://code.activestate.com/recipes/578275-2d-polygon-area/\n    See http://www.mathpages.com/home/kmath201/kmath201.htm\n    See https://en.wikipedia.org/wiki/Shoelace_formula\n    \"\"\"\n    ordered_points = [None] * 4\n\n    for p in q:\n        ordered_points[get_quadrant(p) - 1] = p\n\n    # calculate the area using the Green's theorem\n    total = 0\n    for i, p in enumerate(ordered_points):\n        v1 = p\n        v2 = ordered_points[(i + 1) % 4]\n        total += v1[0] * v2[1] - v1[1] * v2[0]\n\n    return math.fabs(total / 2.0)\n\ndef is_nice(q):\n    \"\"\"\n    is_nice returns true if the quadrangle has points in all 4 quadrants and its area is an integer\n    \"\"\"\n    if not is_in_all_quadrants(q):\n        return False\n\n    a = area(q)\n\n    # check if area is a whole number within a small epsilon error\n    if a - math.trunc(a) < 0.00001:\n        return True\n\n    return False\n\ndef count_nice_quadrangles(points):\n    \"\"\"\n    count_nice_quadrangles counts the number of nice quadrangles in a given list of points\n    \"\"\"\n    if len(points) < 4:\n        return 0\n\n    count = 0\n    for q in itertools.combinations(points, 4):\n        if is_nice(q):\n            count += 1\n\n    return count\n\n# main function\ndef main_solution(points):\n    \"\"\"\n    Counts the number of nice quadrangles in a given list of points.\n    \"\"\"\n    # Convert input to the required format\n    points = [(int(p[0]), int(p[1])) for p in points]\n    \n    # Calculate the number of nice quadrangles\n    result = count_nice_quadrangles(points)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"points": [[8, -7], [9, -8], [0, -10], [3, -1], [5, -5]]}, "output": 0}, {"input": {"points": [[2, 6], [2, 7], [-4, -5], [5, 7], [-3, -5], [-7, -9]]}, "output": 0}, {"input": {"points": [[10, 1], [-3, -8], [5, 9], [9, 4], [10, -6], [3, 3]]}, "output": 0}, {"input": {"points": [[-10, 6], [-3, -7], [-3, -9], [10, -8], [-5, -9]]}, "output": 0}, {"input": {"points": [[-6, -9], [-1, 0], [7, 7], [-8, 1]]}, "output": 0}, {"input": {"points": [[-2, 10], [4, -2], [9, 8], [-10, 3], [1, 1], [-10, -10]]}, "output": 2}, {"input": {"points": [[-4, 3], [-6, 2], [-9, 4], [4, 10], [-4, 10], [5, 6]]}, "output": 0}, {"input": {"points": [[-6, 0], [-6, 2], [-3, 7], [-10, 1]]}, "output": 0}, {"input": {"points": [[-5, -1], [-3, 4], [10, -3], [7, -1], [2, -2], [9, -2]]}, "output": 0}, {"input": {"points": [[-4, -1], [2, 5], [-4, -5], [3, 9]]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "devng/code-puzzles", "path": "/src/devng/codechef/nicequad/nicequad.py", "msgidx": 1561}}
{"problem_description": "Given a set of polygonal numbers (triangle, square, pentagonal, hexagonal, heptagonal, and octagonal), find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type is represented by a different number in the set. The set is cyclic in that the last two digits of each number is the first two digits of the next number (including the last number with the first). What is the sum of this set of numbers?", "io_requirements": "Input:\n  `N` (int): The number of polygonal types to consider (e.g., 3 for triangle, square, and pentagonal; 6 for triangle, square, pentagonal, hexagonal, heptagonal, and octagonal).\n\nOutput:\n  `return` (int): The sum of the cyclic set of 4-digit numbers that represent the specified polygonal types.", "refcode": "# import necessary packages\nimport math\nfrom collections import deque\n\n# Function to calculate the polygonal number\ndef p(i, n):\n    if 3 <= i:\n        return int((((i - 2) * n - i + 4) * n / 2))\n    return 0\n\n# Function to check if two numbers are connected (cyclic)\ndef isConn(i, j):\n    return str(i)[2:] == str(j)[:2]\n\n# Main function\ndef main_solution(N):\n    # Initialize variables\n    d = {}\n    l = []\n    \n    # Generate polygonal numbers and store them in a dictionary\n    for i in range(3, 9):\n        lb = math.ceil((math.sqrt(i * (i + 7992) - 15984) + i - 4) / (2 * i - 4))\n        ub = math.floor((math.sqrt(i * (i + 79992) - 159984) + i - 4) / (2 * i - 4))\n        tl = []\n        for j in range(lb, ub + 1):\n            t = p(i, j)\n            if '0' != str(t)[2]:\n                l.append([i, t])\n                tl.append(t)\n        d[i] = tl + []\n\n    # Create a dictionary of connections between numbers\n    dic = {}\n    for i in l:\n        k = i[0]\n        v = i[1]\n        tl = []\n        for j in l:\n            if (k != j[0]) and isConn(v, j[1]):\n                tl.append(j[1])\n        dic[v] = tl + []\n\n    # Remove numbers with no connections\n    sod = len(dic)\n    nsod = 0\n    while nsod != sod:\n        sod = nsod\n        dl = list(dic.keys())\n        for i in dl:\n            if 0 == len(dic[i]):\n                dic.pop(i)\n                for j in dic:\n                    tvl = []\n                    for x in dic[j]:\n                        if i != x:\n                            tvl.append(x)\n                    dic[j] = list(set(tvl))\n        nsod = len(dic)\n\n    # Sort and initialize the deque\n    tpnl = list(dic.keys())\n    tpnl.sort()\n    pnl = deque(tpnl)\n\n    # Create a reverse dictionary to map numbers to their polygonal types\n    rd = {}\n    for i in pnl:\n        tl = []\n        for j in d:\n            if i in d[j]:\n                tl.append(j)\n        rd[i] = tl + []\n\n    # Find the cyclic set of numbers\n    resl = []\n    tstack = []\n    sstack = []\n    while (N > len(resl)) or (not isConn(resl[N - 1], resl[0])):\n        if N == len(resl):\n            resl.pop()\n            tstack = sstack.pop()\n            if 0 < len(tstack):\n                resl.append(tstack.pop())\n                sstack.append(tstack + [])\n                tstack = dic[resl[-1]] + []\n            else:\n                resl.pop()\n                tstack = sstack.pop()\n        elif 0 == len(resl):\n            resl.append(pnl.popleft())\n            sstack.append(tstack + [])\n            tstack = dic[resl[-1]] + []\n        if N > len(resl):\n            if 0 < len(tstack):\n                resl.append(tstack.pop())\n                sstack.append(tstack + [])\n                tstack = dic[resl[-1]] + []\n            else:\n                resl.pop()\n                tstack = sstack.pop()\n\n    # Return the sum of the cyclic set of numbers\n    return sum(resl)", "funcname": "main_solution", "ios": [{"input": {"N": 4}, "output": 11110}, {"input": {"N": 8}, "output": 27371}, {"input": {"N": 7}, "output": 24644}, {"input": {"N": 6}, "output": 23634}, {"input": {"N": 5}, "output": 11615}, {"input": {"N": 3}, "output": 12120}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gcd0318/pe", "path": "/l3/pe61.py", "msgidx": 1511}}
{"problem_description": "Given a set of prime numbers and their corresponding exponents, what are all the factors of the number formed by the product of these primes raised to their respective exponents?", "io_requirements": "Input:\n  `primes` (str): A JSON-formatted string representing a list of prime numbers.\n  `exponents` (str): A JSON-formatted string representing a list of exponents corresponding to the primes.\n\nOutput:\n  `return` (str): A JSON-formatted string representing a list of all factors of the number formed by the product of primes raised to their respective exponents.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef nextCounter(counter, exponents):\n    carry = 1\n    i = 0\n    while i < len(exponents) and counter[i] + carry >= exponents[i] + 1:\n        counter[i] += carry\n        carry = counter[i] // (exponents[i] + 1)\n        counter[i] %= (exponents[i] + 1)\n        i += 1\n\n    counter[i] += carry\n    return counter\n\ndef findFactors(primes, exponents):\n    counter = [0] * len(exponents)\n    factors = []\n    while counter[len(exponents) - 1] == 0:\n        number = 1\n        for j in range(len(exponents)):\n            number *= primes[j] ** counter[j]\n        factors.append(number)\n        counter = nextCounter(counter, exponents)\n    return factors\n\n# main function\ndef main_solution(primes, exponents):\n    # Convert input to JSON serializable format if necessary\n    primes = json.loads(primes)\n    exponents = json.loads(exponents)\n    \n    # Find all factors\n    factors = findFactors(primes, exponents)\n    \n    # Convert output to JSON serializable format\n    return json.dumps(factors)", "funcname": "main_solution", "ios": [{"input": {"primes": "[13, 29, 11]", "exponents": "[1, 2, 3]"}, "output": "[1, 13, 29, 377, 841, 10933]"}, {"input": {"primes": "[5, 7]", "exponents": "[2, 1]"}, "output": "[1, 5, 25]"}, {"input": {"primes": "[19, 2]", "exponents": "[3, 2]"}, "output": "[1, 19, 361, 6859]"}, {"input": {"primes": "[13, 29, 2]", "exponents": "[1, 2, 3]"}, "output": "[1, 13, 29, 377, 841, 10933]"}, {"input": {"primes": "[5, 11]", "exponents": "[2, 1]"}, "output": "[1, 5, 25]"}, {"input": {"primes": "[5, 13, 19]", "exponents": "[1, 3, 2]"}, "output": "[1, 5, 13, 65, 169, 845, 2197, 10985]"}, {"input": {"primes": "[11, 2]", "exponents": "[2, 1]"}, "output": "[1, 11, 121]"}, {"input": {"primes": "[17, 7]", "exponents": "[2, 2]"}, "output": "[1, 17, 289]"}, {"input": {"primes": "[7, 29, 5]", "exponents": "[1, 2, 3]"}, "output": "[1, 7, 29, 203, 841, 5887]"}, {"input": {"primes": "[13, 19, 17, 29]", "exponents": "[2, 1, 1, 3]"}, "output": "[1, 13, 169, 19, 247, 3211, 17, 221, 2873, 323, 4199, 54587]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "artemisge/cryptography", "path": "/thema23.py", "msgidx": 1777}}
{"problem_description": "Given an even number `n`, what are all the possible valid sequences of `n` parentheses that can be formed? A valid sequence is one where every opening parenthesis '(' has a corresponding closing parenthesis ')', and at no point in the sequence does the number of closing parentheses exceed the number of opening parentheses.", "io_requirements": "Input:\n  `n` (int): The length of the parentheses sequence to generate. It must be an even number.\n\nOutput:\n  `return` (list of str): A list of valid parentheses sequences of length `n`, sorted lexicographically. Each string in the list is a valid sequence of parentheses.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(n):\n    # Generate all possible patterns of parentheses\n    all_pattern = itertools.product([0, 1], repeat=n)\n    ans = []\n    \n    for pattern in all_pattern:\n        # Generate the parentheses string from the pattern\n        s = ''.join('(' if p == 1 else ')' for p in pattern)\n        \n        # Validate the parentheses string\n        pointer = 0\n        flag = True\n        for char in s:\n            if char == '(':\n                pointer += 1\n            else:\n                pointer -= 1\n            if pointer < 0:\n                flag = False\n                break\n        \n        if flag and pointer == 0:\n            ans.append(s)\n    \n    # Return the sorted list of valid parentheses strings\n    return sorted(ans)", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": ["(())", "()()"]}, {"input": {"n": 2}, "output": ["()"]}, {"input": {"n": 6}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shimmee/competitive-programming", "path": "/AtCoder/Practice/\u5178\u578b90\u554f/\u5178\u578b90\u554f002.py", "msgidx": 1872}}
{"problem_description": "Given a graph with `n` nodes and a set of `edges` connecting these nodes, determine whether the graph is a tree. A tree is defined as an acyclic connected graph. What is the result indicating whether the graph is a tree or not?", "io_requirements": "Input:\n  `n` (int): The number of nodes in the graph.\n  `edges` (list of tuples): A list of tuples where each tuple represents an edge between two nodes. Each tuple contains two integers representing the nodes connected by the edge.\n\nOutput:\n  `return` (str): A string that is either \"YES\" if the graph is a tree, or \"NO\" if the graph is not a tree.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self.graph = defaultdict(list)\n\n    def insert(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def iscyclic(self, v, visited, parent):\n        visited[v] = True\n        for i in self.graph[v]:\n            if not visited[i]:\n                if self.iscyclic(i, visited, v):\n                    return True\n            elif i != parent:\n                return True\n        return False\n\n    def istree(self):\n        visited = [False] * self.v\n        if self.iscyclic(0, visited, -1):\n            return False\n        for i in range(self.v):\n            if not visited[i]:\n                return False\n        return True\n\n# main function\ndef main_solution(n, edges):\n    # n: number of nodes in the graph\n    # edges: list of tuples representing the edges in the graph\n    \n    graph = Graph(n)\n    for u, v in edges:\n        graph.insert(u, v)\n    \n    # return, the returned value must be json serializable\n    return \"YES\" if graph.istree() else \"NO\"", "funcname": "main_solution", "ios": [{"input": {"n": 7, "edges": [[1, 6], [0, 1], [4, 5], [1, 3], [4, 0], [5, 3]]}, "output": "NO"}, {"input": {"n": 7, "edges": [[0, 1], [5, 3], [6, 4], [3, 4], [1, 0], [5, 4]]}, "output": "NO"}, {"input": {"n": 5, "edges": [[4, 3], [1, 4], [4, 0], [1, 0]]}, "output": "NO"}, {"input": {"n": 2, "edges": [[0, 1]]}, "output": "YES"}, {"input": {"n": 5, "edges": [[1, 4], [1, 3], [2, 4], [0, 2]]}, "output": "YES"}, {"input": {"n": 3, "edges": [[0, 1], [0, 1]]}, "output": "NO"}, {"input": {"n": 5, "edges": [[2, 1], [4, 0], [4, 2], [3, 0]]}, "output": "YES"}, {"input": {"n": 5, "edges": [[3, 0], [1, 0], [3, 4], [0, 2]]}, "output": "YES"}, {"input": {"n": 5, "edges": [[1, 3], [2, 4], [1, 0], [4, 0]]}, "output": "YES"}, {"input": {"n": 5, "edges": [[0, 2], [4, 0], [0, 4], [1, 2]]}, "output": "NO"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "heyyviv/Algorithms", "path": "/problems/istree.py", "msgidx": 1731}}
{"problem_description": "Given a chessboard where a knight starts at a specific position and needs to reach a destination position, what is the shortest path the knight can take, avoiding certain illegal positions? The knight moves in an L-shape (two squares in one direction and then one square perpendicular).", "io_requirements": "Input:\n  `start_x` (int): The x-coordinate of the starting position of the knight.\n  `start_y` (int): The y-coordinate of the starting position of the knight.\n  `end_x` (int): The x-coordinate of the destination position of the knight.\n  `end_y` (int): The y-coordinate of the destination position of the knight.\n  `illegal_positions` (list of dict): A list of dictionaries where each dictionary contains the x and y coordinates of illegal positions. Each dictionary has keys `x` (int) and `y` (int).\n\nOutput:\n  `return` (dict): A dictionary with a single key `path` which is a list of tuples. Each tuple represents a position (x, y) in the path from the start to the end. If no path exists, the list will be empty.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Node:  # \u039a\u03cc\u03bc\u03b2\u03bf\u03b9 \u03c4\u03bf\u03c5 \u03b3\u03c1\u03ac\u03c6\u03bf\u03c5\n    # (x, y) \u03b7 \u03b8\u03ad\u03c3\u03b7 \u03c4\u03bf\u03c5 \u03ba\u03cc\u03bc\u03b2\u03bf\u03c5 \u03bc\u03b5 \u03c3\u03c5\u03bd\u03c4\u03b5\u03c4\u03b1\u03b3\u03bc\u03ad\u03bd\u03b5\u03c2 \u03c3\u03ba\u03b1\u03ba\u03b9\u03ad\u03c1\u03b1\u03c2\n    def __init__(self, x, y, prev=''):\n        self.x = x\n        self.y = y\n        self.prev = prev\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n    def __eq__(self, other):\n        return (self.x, self.y) == (other.x, other.y)\n    \n    def __str__(self):\n        return \"{}->({},{})\".format(self.prev.__str__(),self.x,self.y)\n\n# \u0388\u03bb\u03b5\u03b3\u03c7\u03bf\u03c2 \u03b1\u03bd \u03b5\u03af\u03bd\u03b1\u03b9 \u03b5\u03bd\u03c4\u03cc\u03c2 \u03c3\u03ba\u03b1\u03ba\u03b9\u03ad\u03c1\u03b1\u03c2 \u03c4\u03bf \u03ac\u03bb\u03bf\u03b3\u03bf\ndef valid(x, y, n, m):\n    return not (x < 1 or y < 1 or x > n or y > m)\n\n# \u039a\u03c5\u03c1\u03af\u03c9\u03c2 \u03c0\u03c1\u03cc\u03b3\u03c1\u03b1\u03bc\u03bc\u03b1\ndef BFS(src, dest, illegal):\n    x_move = [2, 2, -2, -2, 1, 1, -1, -1]  # \u039f\u03b9 \u03ba\u03b9\u03bd\u03ae\u03c3\u03b5\u03b9\u03c2 \u03c4\u03bf\u03c5 \u03b1\u03bb\u03cc\u03b3\u03bf\u03c5\n    y_move = [-1, 1, 1, -1, 2, -2, 2, -2]  #\n    \n    visited = set()  # \u0398\u03b1 \u03b1\u03c0\u03bf\u03b8\u03b7\u03ba\u03b5\u03cd\u03bf\u03c5\u03bc\u03b5 \u03c4\u03bf\u03c5 \u03ba\u03cc\u03bc\u03b2\u03bf\u03c5\u03c2 \u03c0\u03bf\u03c5 \u03b5\u03bb\u03ad\u03b3\u03be\u03b1\u03bc\u03b5\n\n    q = deque()  # \u0398\u03b1 \u03c0\u03c1\u03bf\u03c3\u03b8\u03ad\u03c4\u03bf\u03c5\u03bc\u03b5 \u03c4\u03bf\u03c5 \u03ba\u03cc\u03bc\u03b2\u03bf\u03c5\u03c2 \u03c0\u03c1\u03bf\u03c2 \u03ad\u03bb\u03b5\u03b3\u03c7\u03bf\n    q.append(src)  # \u039e\u03b5\u03ba\u03b9\u03bd\u03ac\u03bc\u03b5 \u03bc\u03b5 \u03c4\u03bf\u03bd \u03b1\u03c1\u03c7\u03b9\u03ba\u03cc \u03ba\u03cc\u03bc\u03b2\u03bf\n\n    while q:  # \u038c\u03c3\u03bf \u03b4\u03b5\u03bd \u03b5\u03af\u03bd\u03b1\u03b9 \u03ba\u03b5\u03bd\u03ae \u03b7 \u03bf\u03c5\u03c1\u03ac\n\n        node = q.popleft()  # \u03a0\u03ac\u03c1\u03b5 \u03c4\u03bf \u03c0\u03c1\u03ce\u03c4\u03bf \u03c3\u03c4\u03bf\u03b9\u03c7\u03b5\u03af\u03bf & \u03b1\u03c6\u03b1\u03af\u03c1\u03b5\u03c3\u03ad \u03c4\u03bf \n\n        x = node.x  # x-\u03c3\u03c5\u03bd\u03b9\u03c3\u03c4\u03ce\u03c3\u03b1\n        y = node.y  # y-\u03c3\u03c5\u03bd\u03b9\u03c3\u03c4\u03ce\u03c3\u03b1\n\n        if x == dest.x and y == dest.y:  # \u0391\u03bd \u03ad\u03c6\u03c4\u03b1\u03c3\u03b5 \u03c3\u03c4\u03bf\u03bd \u03c4\u03b5\u03bb\u03b9\u03ba\u03cc \u03c0\u03c1\u03bf\u03bf\u03c1\u03b9\u03c3\u03bc\u03cc\n            return node  # \u0395\u03c0\u03b9\u03c3\u03c4\u03c1\u03ad\u03c6\u03b5\u03b9 \u03c4\u03bf\u03bd \u03ba\u03cc\u03bc\u03b2\u03bf\n\n        if node not in visited:  # \u0391\u03bd \u03b4\u03b5\u03bd \u03ad\u03c7\u03bf\u03c5\u03bc\u03b5 \u03b5\u03c0\u03b9\u03c3\u03ba\u03b5\u03c6\u03c4\u03b5\u03af \u03c4\u03bf\u03bd \u03ba\u03cc\u03bc\u03b2\u03bf\n            visited.add(node)  # \u03a4\u03bf\u03bd \u03c0\u03c1\u03bf\u03c3\u03b8\u03ad\u03c4\u03bf\u03c5\u03bc\u03b5 \u03c3\u03c4\u03b7\u03bd \u03bb\u03af\u03c3\u03c4\u03b1 visited\n\n            for i in range(8):  # \u039a\u03ac\u03bd\u03bf\u03c5\u03bc\u03b5 8 \u03ba\u03b9\u03bd\u03ae\u03c3\u03b5\u03b9\u03c2\n                x1 = x + x_move[i]\n                y1 = y + y_move[i]\n\n                if valid(x1, y1, dest.x, dest.y):  # \u0395\u03ac\u03bd \u03b4\u03b5\u03bd \u03b5\u03af\u03bc\u03b1\u03c3\u03c4\u03b5 \u03b5\u03ba\u03c4\u03cc\u03c2 \u03c3\u03ba\u03b1\u03ba\u03b9\u03ad\u03c1\u03b1\u03c2\n                    if (x1, y1) not in illegal:  # \u0395\u03ac\u03bd \u03b4\u03b5\u03bd \u03c0\u03ac\u03bc\u03b5 \u03c3\u03b5 \u03b1\u03c0\u03b1\u03b3\u03bf\u03c1\u03b5\u03c5\u03bc\u03ad\u03bd\u03bf \u03ba\u03cc\u03bc\u03b2\u03bf\n                        q.append(Node(x1, y1, node))  # \u03a0\u03c1\u03bf\u03c3\u03b8\u03ad\u03c4\u03bf\u03c5\u03bc\u03b5 \u03c3\u03c4\u03b7\u03bd \u03bf\u03c5\u03c1\u03ac \u03c0\u03c1\u03bf\u03c2 \u03ad\u03bb\u03b5\u03b3\u03c7\u03bf \u03c4\u03bf\u03bd \u03bd\u03ad\u03bf \u03ba\u03cc\u03bc\u03b2\u03bf\n\n    # \u0395\u03c0\u03b9\u03c3\u03c4\u03c1\u03ad\u03c6\u03bf\u03c5\u03bc\u03b5 false \u03b1\u03bd \u03b4\u03b5\u03bd \u03b3\u03af\u03bd\u03b5\u03c4\u03b1\u03b9 \u03b7 \u03bc\u03b5\u03c4\u03b1\u03ba\u03af\u03bd\u03b7\u03c3\u03b7\n    return False\n\n# main function\ndef main_solution(start_x, start_y, end_x, end_y, illegal_positions):\n    # Convert JSON serializable inputs to the original input variables\n    src = Node(start_x, start_y)\n    dest = Node(end_x, end_y)\n    illegal = [(pos['x'], pos['y']) for pos in illegal_positions]\n    \n    # Call the BFS function\n    result = BFS(src, dest, illegal)\n    \n    # Convert the result to a JSON serializable output\n    if result:\n        path = []\n        while result:\n            path.append((result.x, result.y))\n            result = result.prev\n        path.reverse()\n        return {\"path\": path}\n    else:\n        return {\"path\": []}", "funcname": "main_solution", "ios": [{"input": {"start_x": 5, "start_y": 8, "end_x": 7, "end_y": 5, "illegal_positions": [{"x": 8, "y": 4}]}, "output": {"path": []}}, {"input": {"start_x": 8, "start_y": 4, "end_x": 4, "end_y": 2, "illegal_positions": [{"x": 8, "y": 6}]}, "output": {"path": []}}, {"input": {"start_x": 6, "start_y": 6, "end_x": 2, "end_y": 2, "illegal_positions": [{"x": 4, "y": 1}]}, "output": {"path": []}}, {"input": {"start_x": 2, "start_y": 2, "end_x": 4, "end_y": 7, "illegal_positions": [{"x": 6, "y": 2}]}, "output": {"path": [[2, 2], [4, 3], [3, 5], [4, 7]]}}, {"input": {"start_x": 2, "start_y": 2, "end_x": 6, "end_y": 1, "illegal_positions": [{"x": 2, "y": 8}]}, "output": {"path": []}}, {"input": {"start_x": 1, "start_y": 3, "end_x": 3, "end_y": 7, "illegal_positions": [{"x": 1, "y": 8}]}, "output": {"path": [[1, 3], [2, 5], [3, 7]]}}, {"input": {"start_x": 1, "start_y": 5, "end_x": 4, "end_y": 1, "illegal_positions": [{"x": 5, "y": 4}]}, "output": {"path": []}}, {"input": {"start_x": 4, "start_y": 2, "end_x": 7, "end_y": 3, "illegal_positions": [{"x": 7, "y": 3}]}, "output": {"path": []}}, {"input": {"start_x": 6, "start_y": 8, "end_x": 8, "end_y": 4, "illegal_positions": [{"x": 8, "y": 1}]}, "output": {"path": []}}, {"input": {"start_x": 7, "start_y": 8, "end_x": 2, "end_y": 6, "illegal_positions": [{"x": 6, "y": 7}]}, "output": {"path": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "J0K3RAS/KnightTour", "path": "/exc3c.py", "msgidx": 1330}}
{"problem_description": "Given a Sudoku grid and the dimensions of its sub-grids, determine whether the grid is a valid Sudoku solution. A valid Sudoku solution must satisfy the following conditions:\n1. Each row must contain all integers from 1 to the size of the grid exactly once.\n2. Each column must contain all integers from 1 to the size of the grid exactly once.\n3. Each sub-grid (defined by the given number of rows and columns) must contain all integers from 1 to the size of the grid exactly once.\n\nWhat is the validity of the provided Sudoku grid based on the given sub-grid dimensions?", "io_requirements": "Input:\n  `matrix` (list of lists of integers): A 2D list representing the Sudoku grid. Each sublist represents a row in the grid.\n  `rows` (integer): The number of rows in each sub-grid of the Sudoku.\n  `columns` (integer): The number of columns in each sub-grid of the Sudoku.\n\nOutput:\n  `return` (boolean): `True` if the Sudoku grid is valid according to the rules of Sudoku, `False` otherwise.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef is_sudoku(matrix, rows, columns):\n    size = rows * columns\n    matrix = np.array(matrix)\n\n    # check if Matrix has correct size\n    if matrix.size != size * size:\n        return False\n\n    if not rows_ok(matrix):\n        return False\n\n    if not columns_ok(matrix):\n        return False\n\n    if not tiles_ok(matrix, rows, columns):\n        return False\n    return True\n\n\ndef rows_ok(matrix):\n    for row in matrix:\n        if not check_duplicates(row):\n            return False\n    return True\n\n\ndef columns_ok(matrix):\n    for i in range(0, matrix.shape[0]):\n        if not check_duplicates(matrix[:, i]):\n            return False\n    return True\n\n\ndef tiles_ok(matrix, rows, columns):\n    size = rows * columns\n    for i in range(0, int(matrix.shape[1] / columns)):\n        for j in range(0, int(matrix.shape[0] / rows)):\n            tile = []\n            for number in range(0, size):\n                tile.append(matrix[int(number / rows)][int(number % columns)])\n            tile = np.array(tile)\n            if not check_duplicates(tile):\n                return False\n    return True\n\n\ndef check_duplicates(matrix):\n    # check if there are duplicates\n    numbers = set()\n    for number in matrix:\n        numbers.add(number)\n    OKnumbers = set(range(1, matrix.shape[0]+1))\n    return numbers == OKnumbers\n\n# main function\ndef main_solution(matrix, rows, columns):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    matrix = np.array(matrix)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return is_sudoku(matrix, rows, columns)", "funcname": "main_solution", "ios": [{"input": {"matrix": [[2, 1, 1, 4], [2, 2, 4, 1], [2, 1, 4, 4], [4, 2, 2, 1]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[3, 1, 1, 1], [3, 3, 3, 2], [3, 2, 2, 1], [1, 2, 1, 2]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[4, 1, 1, 1], [4, 1, 1, 4], [1, 4, 1, 2], [4, 4, 2, 3]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[4, 2, 2, 2], [2, 4, 1, 1], [4, 1, 4, 4], [3, 1, 2, 3]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[4, 2, 2, 2], [4, 4, 2, 1], [1, 2, 3, 4], [2, 3, 3, 4]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[3, 4, 2, 3], [1, 4, 1, 3], [1, 1, 1, 3], [4, 2, 3, 3]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[4, 4, 2, 3], [1, 4, 4, 4], [4, 4, 2, 1], [3, 4, 4, 2]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[2, 3, 2, 3], [1, 4, 2, 3], [1, 2, 1, 1], [1, 4, 4, 2]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[1, 1, 2, 3], [3, 4, 4, 3], [3, 1, 4, 1], [3, 4, 4, 4]], "rows": 2, "columns": 2}, "output": false}, {"input": {"matrix": [[2, 3, 1, 3], [2, 2, 3, 2], [3, 3, 2, 1], [2, 2, 1, 2]], "rows": 2, "columns": 2}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "maxmsi/Dobre-Praktyki-Programowania", "path": "/Python_scripts/Sudoku.py", "msgidx": 1395}}
{"problem_description": "In Conway's Game of Life, a cellular automaton simulates the life cycle of cells on a grid. Given an initial grid configuration and a number of iterations, what will be the state of the grid after the specified number of iterations?", "io_requirements": "Input:\n  `initial_grid` (list of lists of int): A 2D list representing the initial state of the grid. Each element is either 0 (dead cell) or 1 (live cell).\n  `steps` (int): The number of iterations to perform on the grid.\n\nOutput:\n  `return` (list of lists of int): A 2D list representing the state of the grid after the specified number of iterations. Each element is either 0 (dead cell) or 1 (live cell).", "refcode": "# import necessary packages\nimport numpy as np\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\nclass Conways:\n    def __init__(self, initial):\n        assert type(initial) == np.ndarray\n        self.grid = initial\n        \n    def update(self):\n        new = np.copy(self.grid)\n        for i,j in np.ndenumerate(self.grid):\n            count = self.check_surrounding(i[0], i[1])\n\n            # Cell being born\n            if count == 3:\n                new[i[0],i[1]] = 1\n            # Isolation and throng\n            elif count < 2 or count > 3:\n               new[i[0],i[1]] = 0\n        self.grid = new \n\n    def check_surrounding(self, row, col):\n        # Count how many objects surround the current one\n        self.grid[row,col]\n        count = 0\n        l = [[0, -1, 1],[0, -1, 1]]\n        \n        for r in product(l[0], l[1]):\n            try:\n                if self.grid[row + r[0], col + r[1]] and not (r[0] == 0 and r[1] == 0):\n                    count += 1\n            except IndexError:\n                pass\n\n        return count\n\n# main function\ndef main_solution(initial_grid, steps):\n    # Convert JSON serializable input to the required format\n    initial_grid = np.array(initial_grid, dtype=int)\n    \n    # Initialize the Conways object\n    conway = Conways(initial_grid)\n    \n    # Perform the specified number of updates\n    for _ in range(steps):\n        conway.update()\n    \n    # Convert the result to a JSON serializable format\n    final_grid = conway.grid.tolist()\n    \n    return final_grid", "funcname": "main_solution", "ios": [{"input": {"initial_grid": [[1, 1, 0], [0, 0, 0], [1, 1, 1], [1, 1, 0], [1, 0, 1]], "steps": 1}, "output": [[1, 1, 0], [0, 0, 1], [0, 0, 1], [0, 0, 0], [1, 0, 0]]}, {"input": {"initial_grid": [[0, 1, 1, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 1]], "steps": 4}, "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": {"initial_grid": [[1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1], [0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1]], "steps": 1}, "output": [[1, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0]]}, {"input": {"initial_grid": [[0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1]], "steps": 4}, "output": [[0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": {"initial_grid": [[1, 1, 0], [1, 1, 0], [1, 1, 1]], "steps": 5}, "output": [[0, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": {"initial_grid": [[0, 1, 0, 1, 1], [0, 1, 0, 1, 1], [0, 1, 1, 1, 1]], "steps": 5}, "output": [[1, 0, 1, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 0, 0]]}, {"input": {"initial_grid": [[0, 1, 0], [0, 1, 1], [1, 1, 1]], "steps": 1}, "output": [[0, 0, 0], [0, 0, 0], [0, 0, 1]]}, {"input": {"initial_grid": [[0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1]], "steps": 1}, "output": [[1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0]]}, {"input": {"initial_grid": [[0, 0, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0]], "steps": 1}, "output": [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": {"initial_grid": [[1, 1, 1, 0], [0, 0, 0, 0], [1, 0, 0, 1], [1, 1, 0, 0]], "steps": 5}, "output": [[0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sjudin/Conways-game-of-life", "path": "/Conways.py", "msgidx": 1830}}
{"problem_description": "Given a spiral pattern formed by numbers starting from 1 and moving to the right in a clockwise direction, what is the sum of the numbers on the diagonals of a spiral of size `spiral_size` by `spiral_size`?", "io_requirements": "Input:\n  `spiral_size` (str): A string representing the size of the spiral (an odd integer). For example, \"5\" for a 5x5 spiral.\n\nOutput:\n  `return` (str): A string representing the sum of the numbers on the diagonals of the spiral. For example, \"101\" for a 5x5 spiral.", "refcode": "# import necessary packages\nfrom itertools import count, takewhile\n\n# main function\ndef main_solution(spiral_size):\n    # Convert the spiral_size to an integer\n    spiral_size = int(spiral_size)\n    \n    # Function to generate spiral corners\n    def spiralCorners():\n        yield 1\n        for ring in count(3, 2):\n            for corner in sorted(range(ring**2, (ring - 2)**2, 1 - ring)):\n                yield corner\n    \n    # Calculate the sum of the numbers on the diagonals\n    ans = sum(takewhile(lambda n: n <= spiral_size**2, spiralCorners()))\n    \n    # Return the result as a string\n    return str(ans)", "funcname": "main_solution", "ios": [{"input": {"spiral_size": "737"}, "output": "267149601"}, {"input": {"spiral_size": "267"}, "output": "12725441"}, {"input": {"spiral_size": "837"}, "output": "391268901"}, {"input": {"spiral_size": "733"}, "output": "262824845"}, {"input": {"spiral_size": "423"}, "output": "50548005"}, {"input": {"spiral_size": "327"}, "output": "23364421"}, {"input": {"spiral_size": "285"}, "output": "15473741"}, {"input": {"spiral_size": "883"}, "output": "459367945"}, {"input": {"spiral_size": "947"}, "output": "566635081"}, {"input": {"spiral_size": "307"}, "output": "19337161"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "stewSquared/project-euler", "path": "/p028.py", "msgidx": 2051}}
{"problem_description": "Given two parse trees represented as strings with nested parentheses and words, how can we shrink the trees by identifying and merging identical subtrees, and then reconstruct the trees into their final form?", "io_requirements": "Input:\n- `parse1` (str): A string representing the first parse tree in the format of nested parentheses and words.\n- `parse2` (str): A string representing the second parse tree in the format of nested parentheses and words.\n\nOutput:\n- `return` (dict): A dictionary containing two keys:\n  - `result1` (str): The reconstructed string of the first parse tree after shrinking.\n  - `result2` (str): The reconstructed string of the second parse tree after shrinking.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\nclass Tree(object):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n        self.canGo = False\n\n    def enumerateSubtrees(self):\n        subtrees = []\n        if not isinstance(self.left, Leaf):\n            subtrees.append(self.left)\n            subtrees += self.left.enumerateSubtrees()\n        if not isinstance(self.right, Leaf):\n            subtrees.append(self.right)\n            subtrees += self.right.enumerateSubtrees()\n        return subtrees\n\n    def printInorder(self):\n        traversal = \"\"\n        if isinstance(self.left, Leaf):\n            traversal += self.left.word + \"_\"\n        else:\n            traversal += self.left.printInorder()\n        if isinstance(self.right, Leaf):\n            traversal += self.right.word + \"_\"\n        else:\n            traversal += self.right.printInorder()\n        return traversal\n\n    def treeEquality(self, other):\n        selfLeftTree = isinstance(self.left, Tree)\n        selfRightTree = isinstance(self.right, Tree)\n        otherLeftTree = isinstance(other.left, Tree)\n        otherRightTree = isinstance(other.right, Tree)\n\n        if not selfLeftTree == otherLeftTree or not selfRightTree == otherRightTree:\n            return False\n\n        if not selfLeftTree:\n            if not self.left.word == other.left.word:\n                return False\n\n        if not selfRightTree:\n            if not self.right.word == other.right.word:\n                return False\n\n        isEqual = True\n        if selfLeftTree:\n            isEqual = isEqual and Tree.treeEquality(self.left, other.left)\n        if selfRightTree:\n            isEqual = isEqual and Tree.treeEquality(self.right, other.right)\n        return isEqual\n\n    def shrink(self):\n        if self.canGo:\n            x = self.printInorder()[:-1]\n            head = x.split('_')[1]\n            return Leaf(head + \":\" + x)\n        if not isinstance(self.left, Leaf):\n            self.left = self.left.shrink()\n        if not isinstance(self.right, Leaf):\n            self.right = self.right.shrink()\n        return self\n\n    def reconstruct(self):\n        parse = \" ( \"\n        if isinstance(self.left, Leaf):\n            parse += self.left.word + \" \"\n        else:\n            parse = parse + self.left.reconstruct()\n        if isinstance(self.right, Leaf):\n            parse += self.right.word + \" \"\n        else:\n            parse = parse + self.right.reconstruct()\n        parse += \" ) \"\n        return parse\n\n\nclass Leaf(object):\n    def __init__(self, word):\n        self.word = word\n\n\ndef makeTree(parse):\n    parts = parse.split()\n    stack = [None] * len(parts)\n    stackTop = 0\n    for part in parts:\n        if part == ')':\n            r = stack[stackTop]\n            l = stack[stackTop - 1]\n            stackTop -= 1\n            stack[stackTop] = Tree(l, r)\n        elif not part == '(':\n            stack[stackTop + 1] = Leaf(part)\n            stackTop += 1\n    return stack[stackTop]\n\n\n# main function\ndef main_solution(parse1, parse2):\n    # Convert input strings to Tree objects\n    pTree = makeTree(parse1)\n    hTree = makeTree(parse2)\n\n    # Enumerate subtrees and check for equality\n    for pSub in pTree.enumerateSubtrees():\n        for hSub in hTree.enumerateSubtrees():\n            if pSub.treeEquality(hSub):\n                pSub.canGo = True\n                hSub.canGo = True\n\n    # Shrink the trees\n    pTree = pTree.shrink()\n    hTree = hTree.shrink()\n\n    # Reconstruct the trees into strings\n    result1 = pTree.reconstruct()\n    result2 = hTree.reconstruct()\n\n    # Return the reconstructed tree strings\n    return {\"result1\": result1, \"result2\": result2}", "funcname": "main_solution", "ios": [{"input": {"parse1": "( ( ( word2 word1 ) ( word2 word1 ) ) ( ( word1 word1 ) ( word1 word1 ) ) )", "parse2": "( ( ( word1 word3 ) ( word1 word3 ) ) ( ( word1 word1 ) ( word1 word2 ) ) )"}, "output": {"result1": " (  (  ( word2 word1  )  ( word2 word1  )  )  ( word1:word1_word1 word1:word1_word1  )  ) ", "result2": " (  (  ( word1 word3  )  ( word1 word3  )  )  ( word1:word1_word1  ( word1 word2  )  )  ) "}}, {"input": {"parse1": "( word3 word2 )", "parse2": "( word1 word3 )"}, "output": {"result1": " ( word3 word2  ) ", "result2": " ( word1 word3  ) "}}, {"input": {"parse1": "( ( word3 word3 ) ( word3 word1 ) )", "parse2": "( ( word1 word3 ) ( word2 word1 ) )"}, "output": {"result1": " (  ( word3 word3  )  ( word3 word1  )  ) ", "result2": " (  ( word1 word3  )  ( word2 word1  )  ) "}}, {"input": {"parse1": "( word3 word2 )", "parse2": "( word2 word3 )"}, "output": {"result1": " ( word3 word2  ) ", "result2": " ( word2 word3  ) "}}, {"input": {"parse1": "( word3 word2 )", "parse2": "( word3 word1 )"}, "output": {"result1": " ( word3 word2  ) ", "result2": " ( word3 word1  ) "}}, {"input": {"parse1": "( word3 word3 )", "parse2": "( word2 word2 )"}, "output": {"result1": " ( word3 word3  ) ", "result2": " ( word2 word2  ) "}}, {"input": {"parse1": "( word1 word3 )", "parse2": "( word1 word2 )"}, "output": {"result1": " ( word1 word3  ) ", "result2": " ( word1 word2  ) "}}, {"input": {"parse1": "( ( ( word3 word1 ) ( word2 word2 ) ) ( ( word3 word2 ) ( word1 word3 ) ) )", "parse2": "( ( ( word2 word3 ) ( word3 word2 ) ) ( ( word2 word2 ) ( word3 word3 ) ) )"}, "output": {"result1": " (  (  ( word3 word1  ) word2:word2_word2  )  ( word2:word3_word2  ( word1 word3  )  )  ) ", "result2": " (  (  ( word2 word3  ) word2:word3_word2  )  ( word2:word2_word2  ( word3 word3  )  )  ) "}}, {"input": {"parse1": "( word2 word2 )", "parse2": "( word3 word2 )"}, "output": {"result1": " ( word2 word2  ) ", "result2": " ( word3 word2  ) "}}, {"input": {"parse1": "( ( word3 word3 ) ( word2 word2 ) )", "parse2": "( ( word3 word1 ) ( word3 word2 ) )"}, "output": {"result1": " (  ( word3 word3  )  ( word2 word2  )  ) ", "result2": " (  ( word3 word1  )  ( word3 word2  )  ) "}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "NehaNayak/vector-entailment", "path": "/alignmentPreprocessing/exactAlignConstituency.py", "msgidx": 1513}}
{"problem_description": "Given a grid where each cell can either be open or a wall, and a specific number (`favorite_number`) that determines the nature of each cell, how many unique positions can be visited starting from a given position (`start_position`) within a specified number of moves (`max_distance`)? The nature of a cell is determined by whether the binary representation of a specific calculation involving its coordinates and the `favorite_number` has an even or odd number of '1's.", "io_requirements": "Input:\n  `favorite_number` (int): A number used in the calculation to determine valid moves.\n  `start_position` (list of int): A list containing two integers representing the starting position on a grid.\n  `max_distance` (int): The maximum distance (number of moves) to explore from the starting position.\n\nOutput:\n  `return` (int): The number of unique positions visited within the specified maximum distance.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(favorite_number, start_position, max_distance):\n    # Convert JSON serializable inputs to original input variables\n    start = tuple(start_position)\n    distance = 0\n    queue = deque()\n    visited = []\n\n    def unvisited(move):\n        if move in visited:\n            return False\n        visited.append(move)\n        return True\n\n    def valid_move(pos):\n        x, y = pos\n        if x >= 0 and y >= 0:\n            calc = format(x * x + 3 * x + 2 * x * y + y + y * y + favorite_number, 'b')\n            if calc.count('1') % 2 == 0:\n                return True\n        return False\n\n    def calc_moves(pos):\n        x, y = pos\n        possible_moves = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n        valid_moves = []\n\n        for move in possible_moves:\n            if valid_move(move) and unvisited(move):\n                valid_moves.append(move)\n\n        return valid_moves\n\n    queue.append(start)\n\n    while True:\n        distance += 1\n        moves = []\n\n        while len(queue) > 0:\n            moves = moves + calc_moves(queue.popleft())\n\n        if distance == max_distance:\n            # Convert output to JSON serializable\n            return len(visited)\n\n        queue.extend(moves)", "funcname": "main_solution", "ios": [{"input": {"favorite_number": 1395, "start_position": [4, 5], "max_distance": 48}, "output": 52}, {"input": {"favorite_number": 1458, "start_position": [1, 7], "max_distance": 62}, "output": 0}, {"input": {"favorite_number": 1218, "start_position": [3, 10], "max_distance": 37}, "output": 42}, {"input": {"favorite_number": 1171, "start_position": [5, 7], "max_distance": 61}, "output": 113}, {"input": {"favorite_number": 1411, "start_position": [3, 6], "max_distance": 56}, "output": 135}, {"input": {"favorite_number": 1925, "start_position": [8, 5], "max_distance": 56}, "output": 54}, {"input": {"favorite_number": 1999, "start_position": [0, 5], "max_distance": 35}, "output": 30}, {"input": {"favorite_number": 1860, "start_position": [1, 2], "max_distance": 33}, "output": 10}, {"input": {"favorite_number": 1420, "start_position": [2, 8], "max_distance": 34}, "output": 52}, {"input": {"favorite_number": 1855, "start_position": [6, 10], "max_distance": 49}, "output": 32}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "masenius/aveso-advent-of-code", "path": "/2016/davidm-python/d13c2.py", "msgidx": 1820}}
{"problem_description": "In the ancient puzzle of the Tower of Hanoi, how many moves are required to transfer `n` disks from the source rod `x` to the destination rod `z` using an auxiliary rod `y`?", "io_requirements": "Input:\n  `n` (int): The number of disks.\n  `x` (str): The name of the source rod.\n  `y` (str): The name of the auxiliary rod.\n  `z` (str): The name of the destination rod.\n\nOutput:\n  `return` (int): The total number of moves required to solve the Tower of Hanoi problem with `n` disks.", "refcode": "# import necessary packages\nimport datetime\n\n# main function\ndef main_solution(n, x, y, z):\n    \"\"\"\n    Solves the Tower of Hanoi problem using a stack-based iterative approach.\n    \n    Parameters:\n    n (int): The number of disks.\n    x (str): The name of the source rod.\n    y (str): The name of the auxiliary rod.\n    z (str): The name of the destination rod.\n    \n    Returns:\n    int: The total number of moves required to solve the Tower of Hanoi problem with n disks.\n    \"\"\"\n    count = 0\n    stack = [{0, 0, 0, 0, 0}]\n    elements = [n, n, x, y, z]\n    stack.append(elements)\n    \n    while len(stack) != 1:\n        elem = elements = stack.pop()\n        if elements[0] == 1:\n            count += 1\n        else:\n            elements = [elem[0] - 1, elem[1] - 1, elem[3], elem[2], elem[4]]\n            stack.append(elements)\n            elements = [1, elem[1], elem[2], elem[3], elem[4]]\n            stack.append(elements)\n            elements = [elem[0] - 1, elem[1] - 1, elem[2], elem[4], elem[3]]\n            stack.append(elements)\n    \n    return count", "funcname": "main_solution", "ios": [{"input": {"n": 10, "x": "B", "y": "C", "z": "A"}, "output": 1023}, {"input": {"n": 2, "x": "C", "y": "A", "z": "B"}, "output": 3}, {"input": {"n": 20, "x": "A", "y": "B", "z": "C"}, "output": 1048575}, {"input": {"n": 17, "x": "B", "y": "A", "z": "C"}, "output": 131071}, {"input": {"n": 19, "x": "A", "y": "B", "z": "C"}, "output": 524287}, {"input": {"n": 15, "x": "A", "y": "B", "z": "C"}, "output": 32767}, {"input": {"n": 17, "x": "C", "y": "A", "z": "B"}, "output": 131071}, {"input": {"n": 20, "x": "B", "y": "C", "z": "A"}, "output": 1048575}, {"input": {"n": 8, "x": "A", "y": "C", "z": "B"}, "output": 255}, {"input": {"n": 1, "x": "A", "y": "B", "z": "C"}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hooluupog/TestLanguagePerformance", "path": "/recursion/\u6c49\u8bfa\u5854/\u6808\u6a21\u62df\u9012\u5f52\u7248\u672c/hanoi_stack_python.py", "msgidx": 1802}}
{"problem_description": "Given a positive integer N, how can it be approximated using a sequence of operations consisting only of multiplying by 3 and dividing by 2 (discarding the decimal part), starting from 1? What is the sequence of operations that results in N, given a maximum number of operations allowed?", "io_requirements": "Input:\n  `N` (int): The positive integer number to be approximated.\n  `maxlength` (int): The maximum number of factors (operations) allowed in the approximation.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `N` (int): The original number to be approximated.\n    - `maxlength` (int): The maximum number of factors allowed.\n    - `factors` (list): A list of integers (either 3 or 2) representing the sequence of operations *3 and /2 that approximate the number N. If no sequence is found, the list will be empty.", "refcode": "# import necessary packages\nimport itertools as it\n\n# Function to check if a sequence of factors results in the target number\ndef check(fl):\n    m = 1\n    for i in range(len(fl)):\n        if fl[i] == 3:\n            m *= 3\n        else:\n            m //= 2\n    return m\n\n# Function to approximate the target number using a sequence of *3 and /2 operations\ndef approximate(N, maxlength):\n    for lth in range(1, maxlength):\n        tries = it.product([3, 2], repeat=lth)\n        for fact in tries:\n            if check(fact) == N:\n                return list(fact)\n    return []\n\n# Main function to solve the problem\ndef main_solution(N, maxlength):\n    # Convert input to appropriate types if necessary\n    N = int(N)\n    maxlength = int(maxlength)\n    \n    # Calculate the factors\n    factors = approximate(N, maxlength)\n    \n    # Convert the result to a JSON serializable format\n    result = {\n        \"N\": N,\n        \"maxlength\": maxlength,\n        \"factors\": factors\n    }\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"N": 26, "maxlength": 2}, "output": {"N": 26, "maxlength": 2, "factors": []}}, {"input": {"N": 35, "maxlength": 8}, "output": {"N": 35, "maxlength": 8, "factors": []}}, {"input": {"N": 21, "maxlength": 8}, "output": {"N": 21, "maxlength": 8, "factors": []}}, {"input": {"N": 96, "maxlength": 4}, "output": {"N": 96, "maxlength": 4, "factors": []}}, {"input": {"N": 57, "maxlength": 4}, "output": {"N": 57, "maxlength": 4, "factors": []}}, {"input": {"N": 21, "maxlength": 1}, "output": {"N": 21, "maxlength": 1, "factors": []}}, {"input": {"N": 11, "maxlength": 1}, "output": {"N": 11, "maxlength": 1, "factors": []}}, {"input": {"N": 40, "maxlength": 6}, "output": {"N": 40, "maxlength": 6, "factors": [3, 3, 3, 3, 2]}}, {"input": {"N": 59, "maxlength": 6}, "output": {"N": 59, "maxlength": 6, "factors": []}}, {"input": {"N": 20, "maxlength": 2}, "output": {"N": 20, "maxlength": 2, "factors": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kantal/WPC", "path": "/ISSUE-40/SOLUTION-10/approximate_3_2.py", "msgidx": 2028}}
{"problem_description": "Given an N by N chessboard, how many different ways can you place N queens on the board such that no two queens threaten each other?", "io_requirements": "Input:\n  `N` (int): The size of the N by N board. It represents the number of rows and columns in the board.\n\nOutput:\n  `return` (int): The number of possible arrangements of the board where N queens can be placed without threatening each other.", "refcode": "# import necessary packages\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef queens_path(N, a, b):\n    directions = [-1, 0, 1]\n    for x in directions:\n        for y in directions:\n            if x == y == 0:\n                continue\n            ax = a + x\n            by = b + y\n            while 0 <= ax < N and 0 <= by < N:\n                yield ax, by\n                ax += x\n                by += y\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    grid = [[False for x in range(N)] for _ in range(N)]\n    grids = []\n\n    numbers = [_ for _ in range(N)]\n\n    x_last = N\n    y_last = N\n\n    current_x = 0\n    while current_x < x_last:\n        current_y = 0\n        while current_y < y_last:\n            current_grid = deepcopy(grid)\n            queens = 0\n            for x in numbers[current_x:] + numbers[:current_x]:\n                for y in numbers[current_y:] + numbers[:current_y]:\n                    if not current_grid[x][y]:\n                        queens += 1\n                        current_grid[x][y] = 'Q'\n                        for a, b in queens_path(N, x, y):\n                            current_grid[a][b] = ' '\n            if queens == N:\n                if current_grid not in grids:\n                    grids.append(current_grid)\n            current_y += 1\n        current_x += 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(grids)", "funcname": "main_solution", "ios": [{"input": {"N": 8}, "output": 3}, {"input": {"N": 6}, "output": 1}, {"input": {"N": 5}, "output": 5}, {"input": {"N": 9}, "output": 0}, {"input": {"N": 2}, "output": 0}, {"input": {"N": 1}, "output": 1}, {"input": {"N": 3}, "output": 0}, {"input": {"N": 10}, "output": 4}, {"input": {"N": 7}, "output": 2}, {"input": {"N": 4}, "output": 2}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MaxTechniche/dcp", "path": "/DCP_038 Number of Queens on Board.py", "msgidx": 1932}}
{"problem_description": "Given a spiral grid where each cell's value is the sum of its neighboring cells, what is the first value in the grid that exceeds a given target number?", "io_requirements": "Input:\n  `input_value` (int): The target value to find in the spiral grid. It represents the number that the spiral grid should exceed.\n\nOutput:\n  `return` (int): The first value in the spiral grid that is greater than `input_value`.", "refcode": "# import necessary packages\nfrom itertools import *\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef spiral():\n    x, y = 0, 0\n    dx, dy = 1, 0\n    while True:\n        if (abs(x) == abs(y) and [dx, dy] != [1, 0]) or (x > 0 and y == 1 - x):\n            dx, dy = -dy, dx  # corner, change direction\n        yield x, y\n        x, y = x + dx, y + dy\n\ndef neighbor_coords(x, y):\n    return ((x - 1, y + 1), (x, y + 1), (x + 1, y + 1),\n            (x - 1, y), (x + 1, y),\n            (x - 1, y - 1), (x, y - 1), (x + 1, y - 1))\n\n# main function\ndef main_solution(input_value):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    grid = {(0, 0): 1}\n    spiral_gen = spiral()\n    next(spiral_gen)\n    for (x, y) in spiral_gen:\n        v = 0\n        for coord in neighbor_coords(x, y):\n            v += grid.get(coord, 0)\n        grid[(x, y)] = v\n        if v > input_value:\n            # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n            return v", "funcname": "main_solution", "ios": [{"input": {"input_value": 282698}, "output": 295229}, {"input": {"input_value": 206540}, "output": 266330}, {"input": {"input_value": 236063}, "output": 266330}, {"input": {"input_value": 142416}, "output": 266330}, {"input": {"input_value": 266644}, "output": 279138}, {"input": {"input_value": 153277}, "output": 266330}, {"input": {"input_value": 213960}, "output": 266330}, {"input": {"input_value": 298574}, "output": 312453}, {"input": {"input_value": 121082}, "output": 123363}, {"input": {"input_value": 199181}, "output": 266330}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nathanalderson/advent-of-code-2017", "path": "/day03/day3.py", "msgidx": 1989}}
{"problem_description": "Given a logical expression in infix notation, how can we convert it to postfix notation for easier evaluation? Specifically, what is the postfix equivalent of the given infix expression?", "io_requirements": "Input:\n  `infix_expression` (str): A string representing an infix logical expression. The expression can contain logical operators (`and`, `or`, `not`) and parentheses. Operands are single words separated by spaces.\n\nOutput:\n  `return` (str): A string representing the postfix equivalent of the input infix expression. The operands and operators are separated by spaces.", "refcode": "# import necessary packages\nimport re\n\n# Class to convert the expression \nclass Conversion: \n\t\n\t# Constructor to initialize the class variables \n\tdef __init__(self, query): \n\t\tself.query = query\n\t\tself.top = -1\n\t\tself.array = [] #buat isi stack nya\n\t\tself.postfix = [] \n\t\tself.prioritas = {'not':1, 'and':2, 'or':2}\n\n\t# check if the stack is empty \n\tdef isEmpty(self): \n\t\treturn self.top == -1\n\t\n\t# Return the value of the top of the stack \n\tdef peek(self): \n\t\treturn self.array[-1] \n\t\n\t# Pop the element from the stack \n\tdef pop(self): \n\t\tif self.isEmpty() == False: \n\t\t\tself.top -= 1\n\t\t\treturn self.array.pop() \n\t\n\t# Push the element to the stack \n\tdef push(self, el): \n\t\tself.top += 1\n\t\tself.array.append(el) \n\n\t# A utility function to check is the given character \n\t# is operand\n\n\tdef isChars(self, cha):\n\t\tops = {\"not\", \"and\", \"or\", \"(\", \")\"}\n\t\treturn cha not in ops\n\n\t# Check if the precedence of operator is strictly \n\t# less than top of stack or not \n\tdef notGreater(self, i): \n\t\ttry: \n\t\t\treturn self.prioritas[i] <= self.prioritas[self.peek()]\n\t\texcept KeyError:  \n\t\t\treturn False\n\n\tdef splitted(self, word):\n\t\treturn list(filter(lambda x : x != \" \", re.split(r\"\\b\",word)))\n\n\tdef infixToPostfix(self, query):\n\t\twords = self.splitted(query)\n\t\tfor word in words:\n\t\t\tif self.isChars(word): \n\t\t\t\tself.postfix.append(word) #kalo bukan operator masukin ke postfix\n\t\t\telif word == '(': \n\t\t\t\tself.push(word) #masukin ke stack nya \n\t\t\telif word == ')': #kalo ketemu ini pop semua sampe ketemu (\n\t\t\t\twhile(self.isEmpty() == False and self.peek() != '('): \n\t\t\t\t\tx = self.pop() \n\t\t\t\t\tself.postfix.append(x) \n\t\t\t\tif (self.isEmpty() == False and self.peek() != '('): #apaini???\n\t\t\t\t\treturn -1\n\t\t\t\telse: \n\t\t\t\t\tself.pop() \n\t\t\telse: #ngecek operator nya\n\t\t\t\twhile(self.isEmpty() == False and self.notGreater(word)): \n\t\t\t\t\tself.postfix.append(self.pop()) \n\t\t\t\tself.push(word)\n\t\twhile self.isEmpty() == False: \n\t\t\tself.postfix.append(self.pop())\n\t\t\n\t\treturn \" \".join(self.postfix)\n\n# main function\ndef main_solution(infix_expression):\n  # Convert the infix expression to postfix\n  obj = Conversion(infix_expression)\n  postfix_expression = obj.infixToPostfix(infix_expression)\n  return postfix_expression", "funcname": "main_solution", "ios": [{"input": {"infix_expression": "telur and ayam"}, "output": " telur ayam  and"}, {"input": {"infix_expression": "daging or goreng telur goreng and"}, "output": " daging goreng telur goreng or  and"}, {"input": {"infix_expression": "( ayam not telur not nasi not )"}, "output": "(  ayam telur not nasi not  ) not"}, {"input": {"infix_expression": "ijo or ayam ayam or"}, "output": " ijo ayam ayam or  or"}, {"input": {"infix_expression": "( goreng ijo )"}, "output": "(  goreng ijo  )"}, {"input": {"infix_expression": "( daging nasi nasi telur and daging and )"}, "output": "(  daging nasi nasi telur daging and  ) and"}, {"input": {"infix_expression": "telur not ayam ayam"}, "output": " telur ayam ayam  not"}, {"input": {"infix_expression": "ayam daging not telur"}, "output": " ayam daging telur  not"}, {"input": {"infix_expression": "( ijo nasi or )"}, "output": "(  ijo nasi  ) or"}, {"input": {"infix_expression": "daging or ayam not"}, "output": " daging ayam or  not"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rifkisrg/STKI-final-project", "path": "/conversion.py", "msgidx": 1666}}
{"problem_description": "In a game of poker, a player is dealt a hand of five cards. Each card is represented by a value and a suit. The values range from 2 to Ace (represented as \"T\" for 10, \"J\" for Jack, \"Q\" for Queen, \"K\" for King, and \"A\" for Ace), and the suits are Hearts (H), Diamonds (D), Clubs (C), and Spades (S). Given a hand of five cards, what is the highest-ranking poker hand that can be formed?", "io_requirements": "Input:\n  `hand` (str): A string representing a poker hand, where each card is represented by two characters (value and suit), separated by spaces. For example, \"JS 2H JC AC 2D\".\n\nOutput:\n  `return` (str): A string representing the type of poker hand. Possible values are: \"Royal Flush\", \"Straight Flush\", \"Four of a Kind\", \"Full House\", \"Flush\", \"Straight\", \"Three of a Kind\", \"Two Pairs\", \"One Pair\", \"High Card\".", "refcode": "import collections\n\ndefaultdict = collections.defaultdict\n\ncard_order_dict = {\"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5, \"6\": 6, \"7\": 7, \"8\": 8, \"9\": 9, \"T\": 10, \"J\": 11, \"Q\": 12, \"K\": 13, \"A\": 14}\n\ndef check_royal_flush(hand):\n    values = [card[0] for card in hand]\n    count = 0\n    for value in values:\n        if value in \"TJQKA\":\n            count += 1\n    return check_flush(hand) and count == 5\n\ndef check_straight_flush(hand):\n    return check_flush(hand) and check_straight(hand)\n\ndef check_four_of_a_kind(hand):\n    values = [i[0] for i in hand]\n    value_counts = defaultdict(lambda: 0)\n    for v in values:\n        value_counts[v] += 1\n    return sorted(value_counts.values()) == [1, 4]\n\ndef check_full_house(hand):\n    values = [i[0] for i in hand]\n    value_counts = defaultdict(lambda: 0)\n    for v in values:\n        value_counts[v] += 1\n    return sorted(value_counts.values()) == [2, 3]\n\ndef check_flush(hand):\n    suits = [i[1] for i in hand]\n    return len(set(suits)) == 1\n\ndef check_straight(hand):\n    values = [i[0] for i in hand]\n    value_counts = defaultdict(lambda: 0)\n    for v in values:\n        value_counts[v] += 1\n    rank_values = [card_order_dict[i] for i in values]\n    value_range = max(rank_values) - min(rank_values)\n    if len(set(value_counts.values())) == 1 and (value_range == 4):\n        return True\n    else:\n        if set(values) == set([\"A\", \"2\", \"3\", \"4\", \"5\"]):\n            return True\n    return False\n\ndef check_three_of_a_kind(hand):\n    values = [i[0] for i in hand]\n    value_counts = defaultdict(lambda: 0)\n    for v in values:\n        value_counts[v] += 1\n    return set(value_counts.values()) == set([3, 1])\n\ndef check_two_pairs(hand):\n    values = [i[0] for i in hand]\n    value_counts = defaultdict(lambda: 0)\n    for v in values:\n        value_counts[v] += 1\n    return sorted(value_counts.values()) == [1, 2, 2]\n\ndef check_one_pair(hand):\n    values = [i[0] for i in hand]\n    value_counts = defaultdict(lambda: 0)\n    for v in values:\n        value_counts[v] += 1\n    return 2 in value_counts.values()\n\ndef main_solution(hand):\n    hand = hand.split()\n    i = 0\n    for card in hand:\n        suite = card[-1]\n        value = card[0:len(card) - 1]\n        if value == \"10\":\n            hand[i] = 'T' + suite\n        i += 1\n\n    if check_royal_flush(hand):\n        return \"Royal Flush\"\n    elif check_straight_flush(hand):\n        return \"Straight Flush\"\n    elif check_four_of_a_kind(hand):\n        return \"Four of a Kind\"\n    elif check_full_house(hand):\n        return \"Full House\"\n    elif check_flush(hand):\n        return \"Flush\"\n    elif check_straight(hand):\n        return \"Straight\"\n    elif check_three_of_a_kind(hand):\n        return \"Three of a Kind\"\n    elif check_two_pairs(hand):\n        return \"Two Pairs\"\n    elif check_one_pair(hand):\n        return \"One Pair\"\n    else:\n        return \"High Card\"", "funcname": "main_solution", "ios": [{"input": {"hand": "AC AC 5C 6H TC"}, "output": "One Pair"}, {"input": {"hand": "3D 6H TC 7S 3C"}, "output": "One Pair"}, {"input": {"hand": "9S 4D 6C AH 5D"}, "output": "High Card"}, {"input": {"hand": "2S 4D 3S KS 9D"}, "output": "High Card"}, {"input": {"hand": "QC 8C TH 9D 6C"}, "output": "High Card"}, {"input": {"hand": "9C 5H 8D 8S 6H"}, "output": "One Pair"}, {"input": {"hand": "3H TD 6H TH TC"}, "output": "Three of a Kind"}, {"input": {"hand": "6S 7S 5H 2S TS"}, "output": "High Card"}, {"input": {"hand": "6D 6H AD 7D 2C"}, "output": "One Pair"}, {"input": {"hand": "TH KH 5H 5S 8H"}, "output": "One Pair"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chankruze/challenges", "path": "/sololearn/PokerHand/PokerHand.py", "msgidx": 1603}}
{"problem_description": "In a basket, there are a certain number of balls. If you group them into piles of 2, 3, 4, 5, or 6 balls, there will always be one ball left over. However, if you group them into piles of 7 balls, there will be no balls left over. What is the minimum number of balls that satisfy these conditions?", "io_requirements": "Input:\n  `multiplier` (int): A multiplier used to find the minimum number of balls. This value is always set to 7 in the original code.\n\nOutput:\n  `return` (int): The minimum number of balls that satisfy the given conditions.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(multiplier):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    balls = 7\n    i = 1\n    while True:\n        balls1 = balls * i\n        if balls1 % 6 == 1 and balls1 % 5 == 1 and balls1 % 4 == 1 and balls1 % 3 == 1 and balls1 % 2 == 1:\n            break\n        else:\n            i += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return balls1", "funcname": "main_solution", "ios": [{"input": {"multiplier": 7}, "output": 301}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Dubovskii/Curs-1.2", "path": "/Home_Work14.py", "msgidx": 2290}}
{"problem_description": "In a game of Tic-Tac-Toe, given the current state of the board and the symbols used by the player and the computer, what is the optimal move for the computer to make next?", "io_requirements": "Input:\n  `board_state` (list of lists of strings): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be either an empty string `\"\"`, `\"X\"`, or `\"O\"`.\n  `player_symbol` (string): The symbol representing the player, either `\"X\"` or `\"O\"`.\n  `comp_symbol` (string): The symbol representing the computer, either `\"X\"` or `\"O\"`.\n\nOutput:\n  `return` (dictionary): A dictionary containing:\n    - `best_move` (tuple of integers): The coordinates of the best move for the computer in the format `(row, column)`.\n    - `board_state` (list of lists of strings): The updated 3x3 grid after the best move is made.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef won(board):\n    # Check if player has won horizontally\n    for row in board:\n        if row[0] == row[1] == row[2] and row[0] != \"\":\n            return True, row[0]\n    \n    # Check if player has won vertically\n    for col in board.T:\n        if col[0] == col[1] == col[2] and col[0] != \"\":\n            return True, col[0]\n\n    # Check if player has won diagonally\n    if (board[0][0] == board[1][1] == board[2][2] or board[0][2] == board[1][1] == board[2][0]) and board[1][1] != \"\":\n        return True, board[1][1]\n\n    return False, \"\"\n\ndef game_over(board):\n    for row in board:\n        if \"\" in row:\n            return False\n    return True\n\ndef minimax(board, depth, maxP, player, comp):\n    has_won, winner = won(board)\n    if has_won and winner == comp:\n        return 10\n    elif has_won and winner == player:\n        return -10\n    elif game_over(board):\n        return 0\n\n    if maxP:\n        maxEval = -10000\n        for i in range(len(board[0])):\n            for j in range(len(board[0])):\n                if board[i][j] == \"\":\n                    board[i][j] = comp\n                    eval = minimax(board, depth+1, False, player, comp)\n                    board[i][j] = \"\"\n                    maxEval = max(maxEval, eval)\n        return maxEval\n    else:\n        minEval = 10000\n        for i in range(len(board[0])):\n            for j in range(len(board[0])):\n                if board[i][j] == \"\":\n                    board[i][j] = player\n                    eval = minimax(board, depth+1, True, player, comp)\n                    board[i][j] = \"\"\n                    minEval = min(minEval, eval)\n        return minEval\n\ndef findBestMove(board, player, comp):\n    bestVal = -1000\n    bestMove = (-1, -1)\n\n    for i in range(len(board[0])):\n        for j in range(len(board[0])):\n            if board[i][j] == \"\":\n                board[i][j] = comp\n                moveVal = minimax(board, 0, False, player, comp)\n                board[i][j] = \"\"\n                if moveVal > bestVal:\n                    bestMove = (i, j)\n                    bestVal = moveVal\n    return bestMove\n\n# main function\ndef main_solution(board_state, player_symbol, comp_symbol):\n    # Convert the board_state from list to numpy array\n    board = np.array(board_state)\n    \n    # Find the best move for the computer\n    best_move = findBestMove(board, player_symbol, comp_symbol)\n    \n    # Convert the board back to list for JSON serializable output\n    board_state = board.tolist()\n    \n    # Return the best move and the updated board state\n    return {\"best_move\": best_move, \"board_state\": board_state}", "funcname": "main_solution", "ios": [{"input": {"board_state": [["", "", ""], ["", "X", "O"], ["", "O", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [0, 2], "board_state": [["", "", ""], ["", "X", "O"], ["", "O", ""]]}}, {"input": {"board_state": [["", "", ""], ["X", "", ""], ["", "O", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [1, 1], "board_state": [["", "", ""], ["X", "", ""], ["", "O", ""]]}}, {"input": {"board_state": [["", "", ""], ["", "O", ""], ["", "", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [0, 0], "board_state": [["", "", ""], ["", "O", ""], ["", "", ""]]}}, {"input": {"board_state": [["", "", ""], ["", "", "X"], ["X", "", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [0, 0], "board_state": [["", "", ""], ["", "", "X"], ["X", "", ""]]}}, {"input": {"board_state": [["", "", ""], ["", "", ""], ["", "", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [0, 0], "board_state": [["", "", ""], ["", "", ""], ["", "", ""]]}}, {"input": {"board_state": [["", "X", ""], ["O", "", ""], ["X", "", ""]], "player_symbol": "X", "comp_symbol": "O"}, "output": {"best_move": [1, 1], "board_state": [["", "X", ""], ["O", "", ""], ["X", "", ""]]}}, {"input": {"board_state": [["", "", ""], ["", "X", ""], ["", "X", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [0, 0], "board_state": [["", "", ""], ["", "X", ""], ["", "X", ""]]}}, {"input": {"board_state": [["", "", ""], ["X", "", "X"], ["", "O", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [0, 0], "board_state": [["", "", ""], ["X", "", "X"], ["", "O", ""]]}}, {"input": {"board_state": [["", "", ""], ["", "", ""], ["", "", ""]], "player_symbol": "X", "comp_symbol": "O"}, "output": {"best_move": [0, 0], "board_state": [["", "", ""], ["", "", ""], ["", "", ""]]}}, {"input": {"board_state": [["", "", ""], ["", "", "X"], ["", "X", ""]], "player_symbol": "O", "comp_symbol": "X"}, "output": {"best_move": [0, 0], "board_state": [["", "", ""], ["", "", "X"], ["", "X", ""]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pelpuo/tic-tac-toe_minimax", "path": "/main.py", "msgidx": 1049}}
{"problem_description": "Given a partially filled Sudoku board, how can we determine if it is valid according to the rules of Sudoku? The board is represented as a list of 9 strings, where each string contains exactly 9 characters. Each character can be a digit (1-9) or a period ('.') representing an empty cell. A valid Sudoku board means that no digit appears more than once in any row, column, or 3x3 sub-grid. What is the result indicating the validity of the Sudoku board?", "io_requirements": "Input:\n  `sudoku_board` (list of strings): A list of 9 strings, each representing a row of the Sudoku board. Each string contains exactly 9 characters, where each character is either a digit (1-9) or a period ('.') representing an empty cell.\n\nOutput:\n  `return` (integer): An integer indicating whether the Sudoku board is valid (1 for true, 0 for false).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isValidSudoku(self, A):\n        location_set = set()\n        for r, row in enumerate(A):\n            for c, num in enumerate(row):\n                if num != '.':\n                    rowstr = str(num) + \" in row \" + str(r)\n                    columnstr = str(num) + \" in column \" + str(c)\n                    squarestr = str(num) + \" in square \" + str(r//3) + \"-\" + str(c//3)\n                    for locstring in [rowstr, columnstr, squarestr]:\n                        if locstring in location_set:\n                            return 0\n                        else:\n                            location_set.add(locstring)\n        return 1\n\n# main function\ndef main_solution(sudoku_board):\n    # Convert the input list of strings to a tuple of strings\n    sudoku_tuple = tuple(sudoku_board)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the isValidSudoku method and return the result\n    result = solution.isValidSudoku(sudoku_tuple)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"sudoku_board": [".24119846", "161.88546", ".83448665", "343.5942.", "592889443", "459771937", "285262314", "819765542", "35991198."]}, "output": 0}, {"input": {"sudoku_board": ["857931239", "3.5818627", "273112697", "542318734", "78.16816.", "8875..558", "947374462", "3.7227573", "92.473774"]}, "output": 0}, {"input": {"sudoku_board": ["432..9174", "394239923", "745248883", "26829.672", "7617.3537", "657616391", "9114.6922", "488923951", "8232762.9"]}, "output": 0}, {"input": {"sudoku_board": ["683176851", "957118623", "284322933", "..5345.62", ".49122442", "555682792", "659883212", "..2137237", "41.126219"]}, "output": 0}, {"input": {"sudoku_board": ["768154.75", "6.1471..4", "92288.631", "187381927", "15577.548", ".51389689", "711862127", "335549978", "176818349"]}, "output": 0}, {"input": {"sudoku_board": ["959495486", "7133.38.3", "534114928", "837686814", ".6.182974", "4315.271.", ".99885935", "..3385929", "863524498"]}, "output": 0}, {"input": {"sudoku_board": ["2.94.5914", "629.53361", "225.9351.", "4.1413376", "614497427", "1.3.8.172", ".1217.756", "3.6871465", "8119814.2"]}, "output": 0}, {"input": {"sudoku_board": ["622423741", "2.755466.", "683918521", ".37253965", "871466641", ".572.2848", "317749367", "8629..799", "98.735166"]}, "output": 0}, {"input": {"sudoku_board": ["8.9.48973", "9598.3468", "782256344", "648485255", "5622898.9", "859781777", "918.96.83", "436113828", ".93265329"]}, "output": 0}, {"input": {"sudoku_board": ["337924216", "787816288", ".28155164", "22639.892", ".2972.812", "89315565.", "639387618", "846685166", ".638976.7"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pranavg189/Data-Structures", "path": "/InterviewBit/Hashing/valid-sudoku.py", "msgidx": 1765}}
{"problem_description": "Given a number `n` that is a power of 3, how can you generate a fractal star pattern where each star is composed of smaller stars in a specific arrangement? The pattern should be represented as a string where each line of the pattern is separated by a newline character.", "io_requirements": "Input:\n  `n` (int): The size of the star pattern to generate. It must be a power of 3 (e.g., 3, 9, 27, etc.).\n\nOutput:\n  `return` (str): A string representing the star pattern. Each line of the pattern is separated by a newline character (`\\n`).", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef stars(star):\n    matrix = []\n    for i in range(3 * len(star)):\n        if i // len(star) == 1:\n            matrix.append(star[i % len(star)] + \" \" * len(star) + star[i % len(star)])\n        else:\n            matrix.append(star[i % len(star)] * 3)\n    return matrix\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required format\n    k = int(math.log(n, 3))\n    star = [\"***\", \"* *\", \"***\"]\n    \n    for _ in range(k):\n        star = stars(star)\n    \n    # Convert the output to a JSON serializable format\n    result = \"\\n\".join(star)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": "*********\n* ** ** *\n*********\n***   ***\n* *   * *\n***   ***\n*********\n* ** ** *\n*********"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Greek-and-Roman-God/Apollo", "path": "/baekjoon/10_recursion/stamp_star.py", "msgidx": 2136}}
{"problem_description": "Imagine you are at a store where you can exchange three empty soda bottles for one full soda bottle. You have a certain number of empty soda bottles. How many full soda bottles can you get by making exchanges according to the store's rules?", "io_requirements": "Input:\n  `empty_num` (int): The number of empty soda bottles initially available.\n\nOutput:\n  `return` (int): The maximum number of full soda bottles that can be obtained by exchanging empty bottles according to the given rules.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef exchange(empty, exchanged):\n    rest = 0\n    excha = empty // 3\n    exchanged += excha\n    rest += empty % 3 + excha\n    \n    if rest >= 3:\n        return exchange(rest, exchanged)\n    elif rest == 2:\n        exchanged += 1\n    return exchanged\n\n# main function\ndef main_solution(empty_num):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  exchanged = 0\n  result = exchange(empty_num, exchanged)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"empty_num": 11}, "output": 5}, {"input": {"empty_num": 34}, "output": 17}, {"input": {"empty_num": 36}, "output": 18}, {"input": {"empty_num": 41}, "output": 20}, {"input": {"empty_num": 77}, "output": 38}, {"input": {"empty_num": 49}, "output": 24}, {"input": {"empty_num": 40}, "output": 20}, {"input": {"empty_num": 93}, "output": 46}, {"input": {"empty_num": 3}, "output": 1}, {"input": {"empty_num": 38}, "output": 19}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lonsty/online-programing", "path": "/soda_bottle_exchange.py", "msgidx": 2411}}
{"problem_description": "Given a historical text that contains Roman numerals, you are tasked with converting these numerals into their corresponding integer values. The text may contain standard Roman numerals, generalized Roman numerals (using a custom set of symbols), or minimally defined Roman numerals (where the symbols are inferred from the pattern of the numeral). How would you convert these numerals to their integer equivalents?", "io_requirements": "Input:\n  `input_type` (str): Type of input. Possible values: \"integer\", \"roman\", \"generalized\", \"minimally\".\n  `value` (str): The value to be converted. For \"integer\" and \"generalized\" types, it should be a valid integer string. For \"roman\" and \"minimally\" types, it should be a valid Roman numeral string.\n  `keyword` (str, optional): Required only for \"generalized\" type. It should be a string of unique alphabetical characters.\n\nOutput:\n  `return` (str): The result of the conversion. If the input is invalid, it returns \"Invalid input\".", "refcode": "# import necessary packages\nimport re\nimport sys\n\n# all class and function definitions in the code file, if any\ncomn_num_roman = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n                  100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X',\n                  9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\ncomn_roman_num = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\n\ndef num_to_roman(num, dict_num_roman):\n    symbol_num_ls = []\n    keys = list(dict_num_roman.keys())\n    for k in range(0, len(keys)):\n        while num >= keys[k]:\n            num -= keys[k]\n            symbol_num_ls.append(dict_num_roman[keys[k]])\n    roman_num = ''.join(symbol_num_ls)\n    return roman_num\n\ndef num_legal(word, dict_num_roman):\n    if '.' in word or int(word) not in range(0, max(dict_num_roman.keys()) * 4) or word[0] == '0':\n        return False\n    else:\n        return True\n\ndef roman_to_num(roman, dict_roman_num):\n    sum, i = 0, 0\n    while i <= len(roman) - 2:\n        if dict_roman_num[roman[i]] >= dict_roman_num[roman[i + 1]]:\n            sum += dict_roman_num[roman[i]]\n        else:\n            sum -= dict_roman_num[roman[i]]\n        i += 1\n    sum += dict_roman_num[roman[i]]\n    return sum\n\ndef q1_roman_legal(roman):\n    if not re.match('^[MDCLXVI]+$', roman):\n        return False\n    elif roman.count('I') > 4 or roman.count('X') > 4 or roman.count('C') > 4 \\\n            or roman.count('V') > 1 or roman.count('D') > 1 or roman.count('L') > 1:\n        return False\n    for i in range(len(roman) - 1):\n        if comn_roman_num[roman[i]] < comn_roman_num[roman[i + 1]]:\n            if (roman[i] + roman[i + 1]) not in comn_num_roman.values():\n                return False\n    return True\n\ndef generalized_roman_dict(key_word):\n    gen_roman_num, gen_num_roman = {}, {}\n    unit = 1\n    for i in reversed(key_word):\n        gen_roman_num[i] = unit\n        if str(unit)[0] == '1':\n            unit *= 5\n        elif str(unit)[0] == '5':\n            unit *= 2\n    gen_num_roman = {j: i for i, j in gen_roman_num.items()}\n    gen_num_roman = {i: j for i, j in sorted(gen_num_roman.items(), reverse=True)}\n    keys, vals = list(gen_num_roman.keys()), list(gen_num_roman.values())\n    for i in range(len(keys)):\n        if keys[i] != 1:\n            if str(keys[i])[0] == '5':\n                gen_num_roman[keys[i] - keys[i + 1]] = vals[i + 1] + vals[i]\n            elif str(keys[i])[0] == '1':\n                gen_num_roman[keys[i] - keys[i + 2]] = vals[i + 2] + vals[i]\n        else:\n            break\n    gen_num_roman = {i: j for i, j in sorted(gen_num_roman.items(), reverse=True)}\n    return gen_roman_num, gen_num_roman\n\ndef q2_roman_legal(roman, gen_roman_num, gen_num_roman):\n    for i in range(len(roman) - 1):\n        if roman[i] not in gen_roman_num.keys():\n            return False\n        elif str(gen_roman_num[roman[i]])[0] == '5' and roman.count(roman[i]) > 1:\n            return False\n        elif roman.count(roman[i]) > 4:\n            return False\n        elif gen_roman_num[roman[i]] < gen_roman_num[roman[i + 1]]:\n            if (roman[i] + roman[i + 1]) not in gen_num_roman.values():\n                return False\n    return True\n\ndef keyword_legal(keyword):\n    if re.match('^[A-Za-z]+$', keyword):\n        for k in keyword:\n            if keyword.count(k) > 1:\n                return False\n        return True\n    else:\n        return False\n\ndef q3_word_legal(word):\n    if word.encode('UTF-8').isalpha():\n        return True\n    return False\n\ndef q3_find_pattern(word):\n    word_num_dict = {w: word.count(w) for w in word}\n    visited_ls = []\n    ret = ''\n    for w in range(len(word) - 1, -1, -1):\n        a = word[w]\n        append_ls = []\n        if word[w] in visited_ls:\n            continue\n        if word_num_dict[word[w]] == 1:\n            if w >= 1:\n                if word_num_dict[word[w - 1]] == 1:\n                    if len(ret) % 2 == 0:\n                        append_ls = [word[w - 1], word[w]]\n                        visited_ls.append(word[w])\n                        visited_ls.append(word[w - 1])\n                    else:\n                        append_ls = [word[w]]\n                else:\n                    append_ls = [word[w]]\n            else:\n                append_ls = word[w]\n\n        elif word_num_dict[word[w]] == 2:\n            if word[w] not in visited_ls:\n                visited_ls.append(word[w])\n            if word[w] == word[w - 1]:\n                if len(ret) % 2 == 1:\n                    append_ls = ['_', word[w]]\n                else:\n                    append_ls = [word[w]]\n\n            elif word[w] == word[w - 2]:\n                if word_num_dict[word[w - 1]] > 1:\n                    return False, False\n                if len(ret) % 2 == 0:\n                    append_ls = [word[w - 1], '_', word[w]]\n                else:\n                    append_ls = ['_', word[w - 1], '_', word[w]]\n\n                visited_ls.append(word[w - 1])\n\n            elif word[w] == word[w - 3]:\n                if word[w - 1] == word[w - 2]:\n                    return False, False\n                elif word[w - 1] not in visited_ls and word[w - 2] not in visited_ls:\n                    if len(ret) % 2 == 0:\n                        if word.count(word[w-1])>=2:\n                            append_ls = [word[w - 1], '_', word[w],'_', word[w - 2]]\n                        else:\n                            append_ls = [word[w - 1], '_', word[w],'_', word[w - 2]]\n                    else:\n                        if word.count(word[w - 1]) >= 2:\n                            pass\n                        else:\n                            append_ls = ['_', word[w - 1], '_', word[w], word[w - 2]]\n\n                elif word[w - 1] in visited_ls:\n                    return False, False\n\n                visited_ls.append(word[w - 1])\n                visited_ls.append(word[w - 2])\n\n            else:\n                return False, False\n\n        elif word_num_dict[word[w]] == 3:\n            visited_ls.append(word[w])\n            if word[w] == word[w - 1] == word[w - 2]:\n                if len(ret) % 2 == 0:\n                    append_ls = [word[w]]\n                else:\n                    append_ls = ['_', word[w]]\n\n            elif word[w] == word[w - 2] == word[w - 3] and word[w] != word[w - 1]:\n                if len(ret) % 2 == 0:\n                    append_ls = [word[w - 1], '_', word[w]]\n                else:\n                    append_ls = ['_', word[w - 1], '_', word[w]]\n                visited_ls.append(word[w - 1])\n            else:\n                return False, False\n\n        elif word_num_dict[word[w]] == 4:\n            visited_ls.append(word[w])\n            if word[w] == word[w - 2] == word[w - 3] == word[w - 4]:\n                if len(ret) % 2 == 0:\n                    append_ls = [word[w - 1],'_', word[w]]\n                else:\n                    append_ls = ['_', word[w - 1], '_', word[w]]\n                visited_ls.append(word[w - 1])\n            else:\n                return False, False\n\n        else:\n            return False, False\n\n        for i in append_ls:\n            ret += i\n\n    q3_roman_num_dict, max_unit = {}, 0\n    for i in range(len(ret)):\n        if max_unit == 0:\n            q3_roman_num_dict[ret[i]] = 1\n            max_unit = 1\n        else:\n            if ret[i] == '_':\n                if str(max_unit)[0] == '1':\n                    max_unit *= 5\n                else:\n                    max_unit *= 2\n            else:\n                if str(max_unit)[0] == '1':\n                    max_unit *= 5\n                    q3_roman_num_dict[ret[i]] = max_unit\n                else:\n                    max_unit *= 2\n                    q3_roman_num_dict[ret[i]] = max_unit\n    ret = ret[::-1]\n    return ret, q3_roman_num_dict\n\n# main function\ndef main_solution(input_type, value, keyword=None):\n    if input_type == 'integer':\n        if num_legal(value, comn_num_roman):\n            return num_to_roman(int(value), comn_num_roman)\n        else:\n            return \"Invalid input\"\n    elif input_type == 'roman':\n        if q1_roman_legal(value) and value == num_to_roman(roman_to_num(value, comn_roman_num), comn_num_roman):\n            return str(roman_to_num(value, comn_roman_num))\n        else:\n            return \"Invalid input\"\n    elif input_type == 'generalized':\n        if keyword_legal(keyword):\n            gen_roman_num, gen_num_roman = generalized_roman_dict(keyword)\n            if value.isdigit():\n                if num_legal(value, gen_num_roman):\n                    return num_to_roman(int(value), gen_num_roman)\n                else:\n                    return \"Invalid input\"\n            else:\n                if q2_roman_legal(value, gen_roman_num, gen_num_roman) and value == num_to_roman(roman_to_num(value, gen_roman_num), gen_num_roman):\n                    return str(roman_to_num(value, gen_roman_num))\n                else:\n                    return \"Invalid input\"\n        else:\n            return \"Invalid input\"\n    elif input_type == 'minimally':\n        if q3_word_legal(value):\n            pattern, q3_roman_num_dict = q3_find_pattern(value)\n            if pattern:\n                return str(roman_to_num(value, q3_roman_num_dict))\n            else:\n                return \"Invalid input\"\n        else:\n            return \"Invalid input\"\n    else:\n        return \"Invalid input\"", "funcname": "main_solution", "ios": [{"input": {"input_type": "roman", "value": "XII", "keyword": null}, "output": "12"}, {"input": {"input_type": "integer", "value": "42", "keyword": null}, "output": "XLII"}, {"input": {"input_type": "generalized", "value": "591", "keyword": "MYKDx"}, "output": "Invalid input"}, {"input": {"input_type": "integer", "value": "1534", "keyword": null}, "output": "MDXXXIV"}, {"input": {"input_type": "minimally", "value": "lIADs", "keyword": null}, "output": "144"}, {"input": {"input_type": "integer", "value": "3544", "keyword": null}, "output": "MMMDXLIV"}, {"input": {"input_type": "integer", "value": "3051", "keyword": null}, "output": "MMMLI"}, {"input": {"input_type": "integer", "value": "159", "keyword": null}, "output": "CLIX"}, {"input": {"input_type": "integer", "value": "3493", "keyword": null}, "output": "MMMCDXCIII"}, {"input": {"input_type": "generalized", "value": "881", "keyword": "UMkaA"}, "output": "Invalid input"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "VigoWong/UNSW_summary", "path": "/9021/quiz_finish/assign1/roman_arabic.py", "msgidx": 707}}
{"problem_description": "Given a number `n`, how many unique binary search trees can be constructed using nodes with values from 1 to `n`? Describe the structure of each unique binary search tree.", "io_requirements": "Input:\n  `n` (int): The number of nodes in the binary search tree, where `0 <= n <= 8`.\n\nOutput:\n  `return` (list): A list of dictionaries, where each dictionary represents the structure of a unique binary search tree. Each dictionary has the following keys:\n    - `val` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as a dictionary if it exists, otherwise `None`.\n    - `right` (dict or None): The right child of the node, represented as a dictionary if it exists, otherwise `None`.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def to_dict(self):\n        \"\"\"Convert TreeNode to a dictionary for JSON serialization.\"\"\"\n        return {\n            'val': self.val,\n            'left': self.left.to_dict() if self.left else None,\n            'right': self.right.to_dict() if self.right else None\n        }\n\nclass Solution(object):\n    def generate_trees(self, l):\n        length = len(l)\n        if length == 0:\n            return []\n        if length == 1:\n            return [TreeNode(l[0])]\n        if length == 2:\n            return [\n                TreeNode(l[0], left=None, right=TreeNode(l[1])),\n                TreeNode(l[1], left=TreeNode(l[0]), right=None)\n            ]\n        result = []\n        for i in range(length):\n            left_list = self.generate_trees(l[0:i])\n            right_list = self.generate_trees(l[i + 1:])\n            if left_list and right_list:\n                for left in left_list:\n                    for right in right_list:\n                        result.append(TreeNode(l[i], left=left, right=right))\n            elif not left_list and right_list:\n                for right in right_list:\n                    result.append(TreeNode(l[i], left=None, right=right))\n            elif left_list and not right_list:\n                for left in left_list:\n                    result.append(TreeNode(l[i], left=left, right=None))\n            else:\n                pass\n        return result\n\n    def generateTrees(self, n):\n        return self.generate_trees(range(1, n+1))\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Generate all unique binary search trees that can be constructed with nodes from 1 to n.\n\n    Args:\n        n (int): The number of nodes in the binary search tree.\n\n    Returns:\n        list: A list of dictionaries representing the structure of each unique binary search tree.\n    \"\"\"\n    solution = Solution()\n    trees = solution.generateTrees(n)\n    return [tree.to_dict() for tree in trees]", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": [{"val": 1, "left": null, "right": null}]}, {"input": {"n": 0}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lanzhiwang/common_algorithm", "path": "/leetcode/30_95.py", "msgidx": 1930}}
{"problem_description": "Given a number, we are interested in finding prime numbers that remain prime when digits are continuously removed from either the left or the right. Specifically, we want to find the sum of all such truncatable primes within a certain limit. What is the sum of these truncatable primes when the limit is set to a randomly generated value between 100,000 and 1,000,000?", "io_requirements": "Input:\n  `limit` (int): The upper limit for generating prime numbers. This should be a positive integer.\n\nOutput:\n  `return` (int): The sum of all truncatable primes within the given limit. A truncatable prime is a prime number that remains prime when digits are removed from either the left or the right.", "refcode": "# import necessary packages\nfrom sympy import primerange\n\n# all class and function definitions in the code file, if any\ndef generate_number(digits, index):\n    result = 0\n    m = 1\n    for i in range(index + 1):\n        result += digits[i] * m\n        m *= 10\n    return result\n\ndef remove_from_right(n):\n    n = str(n)\n    result = set()\n    for i in range(1, len(n)):\n        result.add(int(n[:-i]))\n    return result\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    primes = set(primerange(0, limit))\n    l = len(str(limit))\n    digits = [1] * l\n    digits[0] = 3  # last digit has to be 3 or 7\n\n    selected_primes = set()\n    index = 1\n    while index >= 0 and index < l and digits[0] < 10:\n        current_number = generate_number(digits, index)\n        if current_number in primes:\n            index += 1\n            selected_primes.add(current_number)\n        else:\n            if digits[index] >= 9:\n                digits[index] = 1\n                index -= 1\n            if index == 0:\n                digits[index] += 4  # last digit has to be 3 or 7\n            else:\n                digits[index] += 1\n\n    truncatable_primes = set()\n    for prime in selected_primes:\n        if prime < 10:\n            continue\n        if remove_from_right(prime).issubset(primes):\n            truncatable_primes.add(prime)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(truncatable_primes)", "funcname": "main_solution", "ios": [{"input": {"limit": 400425}, "output": 0}, {"input": {"limit": 491003}, "output": 0}, {"input": {"limit": 322340}, "output": 0}, {"input": {"limit": 962182}, "output": 0}, {"input": {"limit": 221588}, "output": 0}, {"input": {"limit": 512974}, "output": 0}, {"input": {"limit": 951421}, "output": 0}, {"input": {"limit": 302181}, "output": 0}, {"input": {"limit": 774173}, "output": 0}, {"input": {"limit": 434806}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "WeijieH/ProjectEuler", "path": "/PythonScripts/Truncatable primes.py", "msgidx": 1849}}
{"problem_description": "Given a number of rows `N`, how can we generate a pattern of stars that resembles a fractal structure, where each row of the pattern is constructed based on specific rules? Specifically, what is the list of strings that represents each row of the pattern for the given `N`?", "io_requirements": "Input:\n  `N` (int): The total number of rows for the output pattern. It should be a positive integer.\n\nOutput:\n  `return` (list): A list of strings representing each row of the pattern. Each string in the list corresponds to a row in the pattern.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(N):\n    \"\"\"\n    Generates a pattern of stars based on the input number of rows N.\n    \n    Args:\n    N (int): The total number of rows for the output pattern.\n    \n    Returns:\n    list: A list of strings representing each row of the pattern.\n    \"\"\"\n    def getString(n):\n        \"\"\"\n        Returns a partial string for the nth line.\n        \n        Args:\n        n (int): The nth row in the printed output (starting from 0).\n        \n        Returns:\n        str: The partial string needed for the nth line.\n        \"\"\"\n        additional_space = \"\"\n        if n // 3 != 0:\n            additional_space = \" \"\n        if n % 3 == 0:\n            return \"  *  \" + additional_space\n        elif n % 3 == 1:\n            return \" * * \" + additional_space\n        elif n % 3 == 2:\n            return \"*****\" + additional_space\n\n    def getRequiredSpace(n, N):\n        \"\"\"\n        Returns the string of white spaces needed before and after the actual print.\n        \n        Args:\n        n (int): The nth row in the printed output (starting from 0).\n        N (int): The total number of rows for the output.\n        \n        Returns:\n        str: The string of white spaces needed before and after the actual print.\n        \"\"\"\n        WHITE_SPACE = \"   \"\n        return WHITE_SPACE * (N // 3 - n // 3 - 1)\n\n    pattern = []\n    for i in range(N):\n        space_before = getRequiredSpace(i, N)\n        space_after = getRequiredSpace(i, N)\n        string = getString(i) * (i // 3 + 1)\n        pattern.append(space_before + string + space_after)\n    \n    return pattern", "funcname": "main_solution", "ios": [{"input": {"N": 6}, "output": ["     *     ", "    * *    ", "   *****   ", "  *     *   ", " * *   * *  ", "***** ***** "]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AliceSeo/preparationForCodingCompetition", "path": "/star_printing.py", "msgidx": 2139}}
{"problem_description": "Given a string composed of lowercase letters, what are all the possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Generate all permutations of the input string\n    permutations = [''.join(p) for p in itertools.permutations(input_string)]\n    # Convert the list of permutations to a JSON serializable format\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "jvn"}, "output": ["jvn", "jnv", "vjn", "vnj", "njv", "nvj"]}, {"input": {"input_string": "liy"}, "output": ["liy", "lyi", "ily", "iyl", "yli", "yil"]}, {"input": {"input_string": "rtc"}, "output": ["rtc", "rct", "trc", "tcr", "crt", "ctr"]}, {"input": {"input_string": "iks"}, "output": ["iks", "isk", "kis", "ksi", "sik", "ski"]}, {"input": {"input_string": "hwk"}, "output": ["hwk", "hkw", "whk", "wkh", "khw", "kwh"]}, {"input": {"input_string": "csx"}, "output": ["csx", "cxs", "scx", "sxc", "xcs", "xsc"]}, {"input": {"input_string": "zmy"}, "output": ["zmy", "zym", "mzy", "myz", "yzm", "ymz"]}, {"input": {"input_string": "zhz"}, "output": ["zhz", "zzh", "hzz", "hzz", "zzh", "zhz"]}, {"input": {"input_string": "xly"}, "output": ["xly", "xyl", "lxy", "lyx", "yxl", "ylx"]}, {"input": {"input_string": "zna"}, "output": ["zna", "zan", "nza", "naz", "azn", "anz"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "icoding2016/study", "path": "/PY/free_exercise/permutation_str.py", "msgidx": 1919}}
{"problem_description": "Given a number of digits `n`, what is the largest pandigital prime number that can be formed using exactly `n` distinct digits from 1 to `n`?", "io_requirements": "Input:\n  `n` (int): The number of digits (1 to 9) for which we want to find the largest pandigital prime number.\n\nOutput:\n  `return` (int): The largest pandigital prime number with `n` digits, or `None` if no such number exists.", "refcode": "# import necessary packages\nimport math\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef is_prime(x):\n    if x == 1:\n        return False\n    elif x < 4:\n        return True\n    elif x % 2 == 0:\n        return False\n    elif x < 9:\n        return True\n    elif x % 3 == 0:\n        return False\n    else:\n        r = math.floor(math.sqrt(x))\n        f = 5\n        while f <= r:\n            if x % f == 0:\n                return False\n            if x % (f + 2) == 0:\n                return False\n            f += 6\n        return True\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    largest_pandigital_prime = None\n    for i in reversed(list(permutations('123456789'[:n]))):\n        num = int(''.join(i))\n        if is_prime(num):\n            largest_pandigital_prime = num\n            break\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return largest_pandigital_prime", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": 4231}, {"input": {"n": 7}, "output": 7652413}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gamersover/project_euler-python", "path": "/src/pro_41.py", "msgidx": 1786}}
{"problem_description": "In a social gathering, people's happiness is influenced by their seating arrangement. Each pair of people has a specific happiness value associated with them, indicating how much happiness one gains or loses when sitting next to the other. Given the happiness values for each pair of people, what is the maximum possible happiness change that can be achieved by arranging the seating?", "io_requirements": "Input:\n  `happiness_values` (dict): A dictionary where keys are strings in the format \"person1-person2\" and values are integers representing the happiness units gained or lost when person1 sits next to person2.\n\nOutput:\n  `return` (int): The maximum happiness change possible for any seating arrangement.", "refcode": "# import necessary packages\nimport re\nfrom itertools import permutations\n\n# main function\ndef main_solution(happiness_values):\n  # Convert the input dictionary to a format suitable for the happiness_change function\n  happines_values = {k: v for k, v in happiness_values.items()}\n  \n  # Extract people from the happiness values\n  people = set()\n  for key in happines_values.keys():\n    person1, person2 = key.split('-')\n    people.add(person1)\n    people.add(person2)\n  \n  # Generate all possible seating arrangements\n  arrangements = list(permutations(people))\n  \n  # Calculate happiness change for each arrangement\n  def happiness_change(arrangement):\n    arrangement = list(arrangement) + [arrangement[0]]\n    s = 0\n    for i in range(len(arrangement) - 1):\n      this = arrangement[i]\n      next = arrangement[i + 1]\n      s += happines_values[this + '-' + next] + happines_values[next + '-' + this]\n    return s\n  \n  # Find the maximum happiness change\n  happines_deltas = [happiness_change(a) for a in arrangements]\n  max_happiness = max(happines_deltas)\n  \n  # Return the maximum happiness change\n  return max_happiness", "funcname": "main_solution", "ios": [{"input": {"happiness_values": {"Person0-Person1": 3, "Person1-Person0": 3, "Person0-Person2": 8, "Person2-Person0": 8, "Person1-Person2": 9, "Person2-Person1": 9}}, "output": 40}, {"input": {"happiness_values": {"Person0-Person1": 9, "Person1-Person0": 9, "Person0-Person2": 5, "Person2-Person0": 5, "Person1-Person2": 10, "Person2-Person1": 10}}, "output": 48}, {"input": {"happiness_values": {"Person0-Person1": 1, "Person1-Person0": 1, "Person0-Person2": -8, "Person2-Person0": -8, "Person1-Person2": 4, "Person2-Person1": 4}}, "output": -6}, {"input": {"happiness_values": {"Person0-Person1": -5, "Person1-Person0": -5, "Person0-Person2": 9, "Person2-Person0": 9, "Person1-Person2": -2, "Person2-Person1": -2}}, "output": 4}, {"input": {"happiness_values": {"Person0-Person1": 8, "Person1-Person0": 8, "Person0-Person2": -6, "Person2-Person0": -6, "Person1-Person2": 0, "Person2-Person1": 0}}, "output": 4}, {"input": {"happiness_values": {"Person0-Person1": -8, "Person1-Person0": -8, "Person0-Person2": -2, "Person2-Person0": -2, "Person1-Person2": -1, "Person2-Person1": -1}}, "output": -22}, {"input": {"happiness_values": {"Person0-Person1": 2, "Person1-Person0": 2, "Person0-Person2": 4, "Person2-Person0": 4, "Person1-Person2": -9, "Person2-Person1": -9}}, "output": -6}, {"input": {"happiness_values": {"Person0-Person1": 8, "Person1-Person0": 8, "Person0-Person2": -9, "Person2-Person0": -9, "Person1-Person2": 8, "Person2-Person1": 8}}, "output": 14}, {"input": {"happiness_values": {"Person0-Person1": 6, "Person1-Person0": 6, "Person0-Person2": 6, "Person2-Person0": 6, "Person1-Person2": 2, "Person2-Person1": 2}}, "output": 28}, {"input": {"happiness_values": {"Person0-Person1": 8, "Person1-Person0": 8, "Person0-Person2": 4, "Person2-Person0": 4, "Person1-Person2": -2, "Person2-Person1": -2}}, "output": 20}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "natemago/adventofcode-solutions", "path": "/day-13/day13p1.py", "msgidx": 1903}}
{"problem_description": "Given a binary tree, determine whether it is symmetric around its center. A tree is symmetric if the left subtree is a mirror reflection of the right subtree. What is the result of checking the symmetry of the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (list): A list representing the binary tree. Each element in the list corresponds to a node value, with `None` indicating a missing node. The list is structured such that the root node is at index 0, its left child at index 1, its right child at index 2, and so on.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetric. `True` if the tree is symmetric, `False` otherwise.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        else:\n            return self.helper(root.left, root.right)\n\n    def helper(self, l, r):\n        if not l and not r:\n            return True\n        elif l and not r:\n            return False\n        elif not l and r:\n            return False\n        else:\n            return l.val == r.val and self.helper(l.left, r.right) and self.helper(l.right, r.left)\n\n    def isSymmetric_iterative(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        else:\n            if not root.left and not root.right:\n                return True\n            elif (not root.left and root.right) or (not root.right and root.left):\n                return False\n            else:\n                stackl = [root.left]\n                stackr = [root.right]\n                while stackl and stackr:\n                    lnode = stackl.pop()\n                    rnode = stackr.pop()\n                    if not lnode and not rnode:\n                        continue\n                    elif (not lnode and rnode) or (not rnode and lnode):\n                        return False\n                    else:\n                        if lnode.val == rnode.val:\n                            stackl.append(lnode.left)\n                            stackl.append(lnode.right)\n                            stackr.append(rnode.right)\n                            stackr.append(rnode.left)\n                        else:\n                            return False\n                return True\n\n# main function\ndef main_solution(tree_structure: list) -> bool:\n    # Convert the list representation of the tree to a TreeNode structure\n    def list_to_tree(tree_list):\n        if not tree_list:\n            return None\n        root = TreeNode(tree_list[0])\n        queue = deque([root])\n        index = 1\n        while queue:\n            node = queue.popleft()\n            if index < len(tree_list):\n                if tree_list[index] is not None:\n                    node.left = TreeNode(tree_list[index])\n                    queue.append(node.left)\n                index += 1\n                if index < len(tree_list):\n                    if tree_list[index] is not None:\n                        node.right = TreeNode(tree_list[index])\n                        queue.append(node.right)\n                    index += 1\n        return root\n\n    root = list_to_tree(tree_structure)\n    solution = Solution()\n    return solution.isSymmetric(root)", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [54, null, 66, 18, 53, null, 98, 93, null, null, null, null, 74, 69, 0, null]}, "output": false}, {"input": {"tree_structure": [6, null, null, null, 79, 88, 75, 77]}, "output": true}, {"input": {"tree_structure": [89, null, null, null, null, 58, 22, null]}, "output": true}, {"input": {"tree_structure": [87, null]}, "output": true}, {"input": {"tree_structure": [11, null, null, null, null, 78, null, 52]}, "output": true}, {"input": {"tree_structure": [44, null, null, null]}, "output": true}, {"input": {"tree_structure": [96, null]}, "output": true}, {"input": {"tree_structure": [5, null]}, "output": true}, {"input": {"tree_structure": [76, 28, null, null]}, "output": false}, {"input": {"tree_structure": [52, null, 60, 17, null, null, null, 47, 34, null, 99, null, null, 99, null, 100]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "llenroc/LeetCode-28", "path": "/Binary_Tree/Basic_Single_Recursion_Problems/Returning_boolean(check_property)/101_Symmetric_tree_easy.py", "msgidx": 1880}}
{"problem_description": "In an infinite chessboard, a knight starts at the origin (0, 0). Given the coordinates (x, y) of a target square, how many minimum steps does the knight need to take to reach the target square?", "io_requirements": "Input:\n  `x` (int): The x-coordinate of the target square on the chessboard.\n  `y` (int): The y-coordinate of the target square on the chessboard.\n\nOutput:\n  `return` (int): The minimum number of steps required for the knight to move from the origin (0, 0) to the target square (x, y).", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(x, y):\n    \"\"\"\n    Calculate the minimum number of steps needed for a knight to move from the origin (0, 0) to the target square (x, y) on an infinite chessboard.\n    \n    :param x: int, the x-coordinate of the target square.\n    :param y: int, the y-coordinate of the target square.\n    :return: int, the minimum number of steps required.\n    \"\"\"\n    x, y = abs(x), abs(y)  # Use symmetry to reduce the problem size\n    \n    queue = deque([(0, 0)])\n    depth = 0\n    visited = {(0, 0)}\n    \n    while queue:\n        for _ in range(len(queue)):\n            i, j = queue.popleft()\n            if i == x and j == y:\n                return depth\n            for v in [(2, 1), (2, -1), (1, 2), (-1, 2), \n                      (-2, 1), (-2, -1), (1, -2), (-1, -2)]:\n                p, q = i + v[0], j + v[1]\n                if (p, q) not in visited and p >= 0 and q >= 0:\n                    visited.add((p, q))\n                    queue.append((p, q))\n        depth += 1", "funcname": "main_solution", "ios": [{"input": {"x": 156, "y": 233}, "output": 131}, {"input": {"x": 213, "y": 253}, "output": 156}, {"input": {"x": 132, "y": 59}, "output": 67}, {"input": {"x": 78, "y": 295}, "output": 149}, {"input": {"x": 212, "y": 284}, "output": 166}, {"input": {"x": 59, "y": 244}, "output": 123}, {"input": {"x": 52, "y": 148}, "output": 74}, {"input": {"x": 273, "y": 51}, "output": 138}, {"input": {"x": 286, "y": 149}, "output": 145}, {"input": {"x": 240, "y": 236}, "output": 160}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pwang867/LeetCode-Solutions-Python", "path": "/1197. Minimum Knight Moves.py", "msgidx": 2150}}
{"problem_description": "In a game of marbles, players take turns placing marbles in a circle. Each turn, a player either places a marble in a specific position or scores points by removing a marble from a special position. Given the number of players and the total number of marbles, what is the highest score achieved by any player at the end of the game?", "io_requirements": "Input:\n  `num_players` (int): The number of players participating in the game.\n  `num_marbles` (int): The total number of marbles to be used in the game.\n\nOutput:\n  `return` (int): The highest score achieved by any player after all marbles have been used.", "refcode": "# import necessary packages\nfrom itertools import cycle\n\n# all class and function definitions in the code file, if any\nclass circle(object):\n    def __init__(self):\n        self.list = [0]\n        self.current_idx = 0\n\n    def add_marble(self, marble_num):\n        if marble_num % 23:\n            if len(self.list) < 2:\n                index_to_place = len(self.list)\n            else:\n                index_to_place = (self.current_idx + 2) % (len(self.list))\n            if index_to_place == 0:\n                index_to_place = len(self.list)\n            self.current_idx = index_to_place\n            self.list.insert(index_to_place, marble_num)\n            return 0\n        else:\n            index_to_pop = self.current_idx - 7\n            self.current_idx -= 7\n            if self.current_idx < 0:\n                self.current_idx = len(self.list) + self.current_idx\n            popped_value = self.list.pop(index_to_pop)\n            return marble_num + popped_value\n\ndef calc_score(num_players, num_marbles):\n    score = dict.fromkeys(range(num_players), 0)\n    c = circle()\n    for player, marble in zip(cycle(sorted(score)), range(1, num_marbles)):\n        j = c.add_marble(marble)\n        score[player] += j\n    return max(score.values())\n\n# main function\ndef main_solution(num_players, num_marbles):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return calc_score(num_players, num_marbles)", "funcname": "main_solution", "ios": [{"input": {"num_players": 94, "num_marbles": 2277}, "output": 3335}, {"input": {"num_players": 50, "num_marbles": 8801}, "output": 51092}, {"input": {"num_players": 16, "num_marbles": 2695}, "output": 15099}, {"input": {"num_players": 99, "num_marbles": 7152}, "output": 21202}, {"input": {"num_players": 82, "num_marbles": 3660}, "output": 7706}, {"input": {"num_players": 68, "num_marbles": 195}, "output": 227}, {"input": {"num_players": 44, "num_marbles": 4228}, "output": 15037}, {"input": {"num_players": 11, "num_marbles": 6968}, "output": 129856}, {"input": {"num_players": 100, "num_marbles": 3597}, "output": 6784}, {"input": {"num_players": 98, "num_marbles": 9125}, "output": 32911}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "david-hoffman/advent-of-code-2018", "path": "/Day 09/day9.py", "msgidx": 1969}}
{"problem_description": "In a game of chess, a knight is placed on a board of size NxN at a specific initial position (x0, y0). The knight moves according to the rules of chess, where it can move in an L-shape (two squares in one direction and then one square perpendicular). Given the initial position of the knight and the number of moves it will make, what are the expected values of the distance from the origin and the standard deviation of this distance after the specified number of moves?", "io_requirements": "Input:\n- `N` (int): The size of the board, where the board is an NxN grid.\n- `x0` (int): The initial x-coordinate of the knight's position on the board.\n- `y0` (int): The initial y-coordinate of the knight's position on the board.\n- `Moves` (int): The number of moves the knight will make.\n\nOutput:\n- `return` (dict): A dictionary containing the expected value of r (`rExpected`) and the expected value of the standard deviation (`sigmaExpected`).\n  - `rExpected` (float): The expected value of the distance from the origin after the specified number of moves.\n  - `sigmaExpected` (float): The expected value of the standard deviation of the distance from the origin after the specified number of moves.", "refcode": "import numpy as np\n\ndef FillNextMove(NextMove, x, y, n):\n    c = 0\n    if (x + 1) < n:\n        if (y + 2) < n:\n            NextMove[x + 1, y + 2] = 1\n            c += 1\n        if (y - 2) >= 0:\n            NextMove[x + 1, y - 2] = 1\n            c += 1\n    if (x + 2) < n:\n        if (y + 1) < n:\n            NextMove[x + 2, y + 1] = 1\n            c += 1\n        if (y - 1) >= 0:\n            NextMove[x + 2, y - 1] = 1\n            c += 1\n    if (x - 1) >= 0:\n        if (y + 2) < n:\n            NextMove[x - 1, y + 2] = 1\n            c += 1\n        if (y - 2) >= 0:\n            NextMove[x - 1, y - 2] = 1\n            c += 1\n    if (x - 2) >= 0:\n        if (y + 1) < n:\n            NextMove[x - 2, y + 1] = 1\n            c += 1\n        if (y - 1) >= 0:\n            NextMove[x - 2, y - 1] = 1\n            c += 1\n    return c\n\ndef main_solution(N, x0, y0, Moves):\n    n = N - 1\n    Board = np.zeros((N, N))\n    Probabilities = np.zeros((N, N))\n    TotalProbabilities = np.zeros((N, N))\n    CurrentPosition = np.zeros((N, N))\n    CurrentPosition[x0, y0] = 1\n    Probabilities[x0, y0] = 1\n    TotalProbabilities[x0, y0] = 1\n    M = 0\n    while M < Moves:\n        for i in range(N):\n            for j in range(N):\n                if CurrentPosition[i, j] != 0:\n                    x = i\n                    y = j\n                    NextMove = np.zeros((N, N))\n                    Ptemp = np.zeros((N, N))\n                    count = FillNextMove(NextMove, x, y, N)\n                    for k in range(N):\n                        for l in range(N):\n                            if NextMove[k, l] != 0:\n                                p = 1.0 / count\n                                Ptemp[k, l] = p * Probabilities[x, y]\n                    Probabilities[x, y] = 0\n                    Probabilities += Ptemp\n        CurrentPosition = NextMove\n        M += 1\n    rExpected = 0\n    for i in range(N):\n        for j in range(N):\n            rExpected += np.sqrt(i * i + j * j) * Probabilities[i, j]\n    sigmaExpected = 0\n    sig = 0\n    for i in range(N):\n        for j in range(N):\n            r2 = i * i + j * j\n            sig += ((np.sqrt(r2) - rExpected) ** 2.0) * Probabilities[i, j]\n    sigmaExpected = np.sqrt(sig)\n    return {\"rExpected\": rExpected, \"sigmaExpected\": sigmaExpected}", "funcname": "main_solution", "ios": [{"input": {"N": 9, "x0": 4, "y0": 6, "Moves": 3}, "output": {"rExpected": 6.982665576272434, "sigmaExpected": 1.8402387541191911}}, {"input": {"N": 8, "x0": 6, "y0": 5, "Moves": 4}, "output": {"rExpected": 6.439696859874846, "sigmaExpected": 1.476742129107518}}, {"input": {"N": 8, "x0": 4, "y0": 0, "Moves": 2}, "output": {"rExpected": 4.508405100480505, "sigmaExpected": 1.8728632580342595}}, {"input": {"N": 6, "x0": 5, "y0": 3, "Moves": 5}, "output": {"rExpected": 3.8745235155949045, "sigmaExpected": 1.5590288332400082}}, {"input": {"N": 9, "x0": 7, "y0": 7, "Moves": 1}, "output": {"rExpected": 8.622115403981628, "sigmaExpected": 0.8118657280749746}}, {"input": {"N": 7, "x0": 1, "y0": 2, "Moves": 1}, "output": {"rExpected": 2.9795090503812074, "sigmaExpected": 1.5671181040463444}}, {"input": {"N": 5, "x0": 2, "y0": 4, "Moves": 5}, "output": {"rExpected": 2.936439033381583, "sigmaExpected": 1.4507778461186212}}, {"input": {"N": 9, "x0": 4, "y0": 4, "Moves": 4}, "output": {"rExpected": 6.018731303187892, "sigmaExpected": 2.1791814594841603}}, {"input": {"N": 8, "x0": 0, "y0": 7, "Moves": 2}, "output": {"rExpected": 5.681862725716077, "sigmaExpected": 1.543730103607793}}, {"input": {"N": 8, "x0": 5, "y0": 1, "Moves": 1}, "output": {"rExpected": 5.432310849540647, "sigmaExpected": 1.6802774078396452}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "stalei/DIProject", "path": "/Knight4.py", "msgidx": 1588}}
{"problem_description": "In a game of Tic Tac Toe, given a partially filled board, determine the utility value of the current state. The utility value is defined as `1` if `X` has won, `-1` if `O` has won, and `0` if the game is a draw or still ongoing. What is the utility value of the given board?", "io_requirements": "Input:\n  `board` (list of lists of strings and `None`): A 3x3 grid representing the Tic Tac Toe board. Each cell can be `\"X\"`, `\"O\"`, or `None` (representing an empty cell).\n\nOutput:\n  `return` (int): The utility value of the board. Returns `1` if `X` has won, `-1` if `O` has won, and `0` if the game is a draw or still ongoing.", "refcode": "# import necessary packages\nimport math\nimport copy\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    countX = sum(row.count(X) for row in board)\n    countO = sum(row.count(O) for row in board)\n    return O if countO < countX else X\n\n# Function to get all possible actions\ndef actions(board):\n    return {(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY}\n\n# Function to get the result of an action\ndef result(board, action):\n    new_board = copy.deepcopy(board)\n    new_board[action[0]][action[1]] = player(board)\n    return new_board\n\n# Function to determine the winner\ndef winner(board):\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] and board[i][0] != EMPTY:\n            return board[i][0]\n        if board[0][i] == board[1][i] == board[2][i] and board[0][i] != EMPTY:\n            return board[0][i]\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != EMPTY:\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != EMPTY:\n        return board[0][2]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or all(all(cell is not EMPTY for cell in row) for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == X:\n        return 1\n    elif win == O:\n        return -1\n    else:\n        return 0\n\n# Function to get the max value\ndef maxvalue(board):\n    if terminal(board):\n        return utility(board)\n    v = -math.inf\n    for action in actions(board):\n        v = max(v, minvalue(result(board, action)))\n    return v\n\n# Function to get the min value\ndef minvalue(board):\n    if terminal(board):\n        return utility(board)\n    v = math.inf\n    for action in actions(board):\n        v = min(v, maxvalue(result(board, action)))\n    return v\n\n# Main function\ndef main_solution(board):\n    if terminal(board):\n        return utility(board)\n    if player(board) == X:\n        return maxvalue(board)\n    else:\n        return minvalue(board)", "funcname": "main_solution", "ios": [{"input": {"board": [[null, null, null], [null, "X", null], ["O", null, "X"]]}, "output": 0}, {"input": {"board": [["O", "X", null], [null, null, null], [null, "X", "O"]]}, "output": 1}, {"input": {"board": [[null, "X", "X"], ["O", "O", "X"], [null, null, null]]}, "output": 1}, {"input": {"board": [["O", "O", null], ["X", "X", "X"], [null, "O", "X"]]}, "output": 1}, {"input": {"board": [["X", "O", "O"], ["X", null, null], ["X", null, null]]}, "output": 1}, {"input": {"board": [[null, "X", null], [null, null, null], [null, null, null]]}, "output": 0}, {"input": {"board": [["O", "O", "X"], ["O", "X", "O"], ["X", "X", "X"]]}, "output": 1}, {"input": {"board": [["X", "O", "X"], ["X", "O", "X"], [null, "O", "O"]]}, "output": -1}, {"input": {"board": [["X", "O", null], [null, "O", null], ["X", null, "X"]]}, "output": -1}, {"input": {"board": [["X", null, null], [null, null, null], [null, null, null]]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vamsikrishna-tkv/tic-tac-toe", "path": "/tictactoe.py", "msgidx": 2122}}
{"problem_description": "You are given a set of rules that describe how different colored bags can contain other bags. Each rule specifies the number and color of bags that can be contained within a particular bag color. Based on these rules, how many bag colors can eventually contain at least one shiny gold bag, and how many individual bags are required inside a single shiny gold bag?", "io_requirements": "Input:\n  `bag_rules` (str): A JSON string representing a dictionary where each key is a bag color (str) and each value is a list of tuples. Each tuple contains a bag color (str) and a count (int) indicating how many of that bag color are contained within the outer bag.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `part1` (int): The number of bag colors that can eventually contain at least one shiny gold bag.\n    - `part2` (int): The total number of individual bags required inside a single shiny gold bag.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef parse(line):\n    line = line.removesuffix('.\\n')\n    outer, inners = line.split(' bags contain ')\n    if inners == 'no other bags':\n        return outer, []\n    inners = [\n        (inner[2:].removesuffix(' bag').removesuffix(' bags'), int(inner[0]))\n        for inner in inners.split(', ')]\n    return outer, inners\n\ndef search(bags, current):\n    return current == 'shiny gold' or any(search(bags, bag) for bag, _ in bags[current])\n\ndef bag_count(bags, current):\n    return sum(count * (1 + bag_count(bags, bag)) for bag, count in bags[current])\n\n# main function\ndef main_solution(bag_rules):\n    # Convert the JSON serializable input to the original input format\n    bags = json.loads(bag_rules)\n    \n    # Part 1: Count how many bag colors can eventually contain at least one shiny gold bag\n    part1 = sum(search(bags, bag) for bag in bags if bag != 'shiny gold')\n    \n    # Part 2: Count how many individual bags are required inside a single shiny gold bag\n    part2 = bag_count(bags, 'shiny gold')\n    \n    # Return the results as JSON serializable outputs\n    return {\"part1\": part1, \"part2\": part2}", "funcname": "main_solution", "ios": [{"input": {"bag_rules": "{\"bag0\": [], \"bag1\": [], \"bag2\": [], \"bag3\": [], \"bag4\": [], \"shiny gold\": [[\"bag3\", 2]]}"}, "output": {"part1": 0, "part2": 2}}, {"input": {"bag_rules": "{\"bag0\": [], \"bag1\": [], \"bag2\": [], \"bag3\": [], \"bag4\": [], \"shiny gold\": [[\"bag4\", 2]]}"}, "output": {"part1": 0, "part2": 2}}, {"input": {"bag_rules": "{\"bag0\": [], \"bag1\": [], \"bag2\": [], \"bag3\": [], \"bag4\": [], \"shiny gold\": [[\"bag4\", 3]]}"}, "output": {"part1": 0, "part2": 3}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "prplz/aoc-2020", "path": "/python/day07.py", "msgidx": 2229}}
{"problem_description": "You have a certain number of bottles of wine, and exactly one bottle is poisoned. You need to find the poisoned wine before your party starts in an hour. You have a limited number of rats to test on to find out which bottle is deadly. The poison takes effect after an hour of consumption, so you only have one chance to run your rat poison experiment. How many rats are required to identify the poisoned bottle?", "io_requirements": "Input:\n  `n` (int): The number of bottles of wine, where exactly one bottle is poisoned.\n\nOutput:\n  `return` (int): The minimum number of rats required to identify the poisoned bottle.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # Calculate the minimum number of rats required to identify the poisoned bottle\n    result = math.ceil(math.log2(n))\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 198}, "output": 8}, {"input": {"n": 704}, "output": 10}, {"input": {"n": 904}, "output": 10}, {"input": {"n": 995}, "output": 10}, {"input": {"n": 869}, "output": 10}, {"input": {"n": 328}, "output": 9}, {"input": {"n": 197}, "output": 8}, {"input": {"n": 523}, "output": 10}, {"input": {"n": 540}, "output": 10}, {"input": {"n": 369}, "output": 9}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dshubham25/Algorithm-practice", "path": "/poison wine.py", "msgidx": 2215}}
{"problem_description": "Given a chessboard of size `n` x `n`, how many distinct ways can you place `n` queens such that no two queens threaten each other? Each solution should be represented as a configuration of the chessboard where 'Q' indicates the position of a queen and '.' indicates an empty space.", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of solutions, where each solution is represented as a list of strings. Each string represents a row on the chessboard, with 'Q' indicating the position of a queen and '.' indicating an empty space.", "refcode": "# import necessary packages\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        self.board = [['.' for row in range(n)] for col in range(n)]\n        self.result = []\n        self.n = n\n        self.dfs(0)\n        result = []\n        for bo in self.result:\n            ans = [''.join(l) for l in bo]\n            result.append(ans)\n        return result\n\n    def dfs(self, row):\n        if row == self.n:\n            self.result.append(deepcopy(self.board))\n            return\n\n        for i in range(self.n):\n            if self.display(row, i):\n                self.board[row][i] = 'Q'\n                self.dfs(row + 1)\n                self.board[row][i] = '.'\n\n    def display(self, x, y):\n        # x row\n        for col in range(self.n):\n            if self.board[x][col] != '.':\n                return False\n        # x col\n        for row in range(self.n):\n            if self.board[row][y] != '.':\n                return False\n        # left up\n        m, n = x, y\n        while m >= 0 and n >= 0:\n            if self.board[m][n] != '.':\n                return False\n            m -= 1\n            n -= 1\n        # left down\n        m, n = x, y\n        while m < self.n and n >= 0:\n            if self.board[m][n] != '.':\n                return False\n            m += 1\n            n -= 1\n        m, n = x, y\n        # right up\n        while m >= 0 and n < self.n:\n            if self.board[m][n] != '.':\n                return False\n            m -= 1\n            n += 1\n        # right down\n        m, n = x, y\n        while m < self.n and n < self.n:\n            if self.board[m][n] != '.':\n                return False\n            m += 1\n            n += 1\n\n        return True\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "feizhihui/LeetCode", "path": "/page2/main51.py", "msgidx": 1940}}
{"problem_description": "Given a binary tree, where each node is labeled with a unique integer value, and the nodes are arranged in a level-order traversal, what is the maximum width of the tree at any level? The width of a level is defined as the number of nodes between the leftmost and rightmost non-null nodes, inclusive.", "io_requirements": "Input:\n  `tree_list` (list of integers or None): A list representing the binary tree. Each element in the list corresponds to a node value, with `None` indicating a missing node. The list is structured such that the index represents the node's position in a level-order traversal of the tree.\n\nOutput:\n  `return` (integer): The maximum width of the binary tree, which is the maximum number of nodes between the leftmost and rightmost nodes at any level.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Function to convert a list representation of a binary tree to a TreeNode object\ndef list_to_tree(lst):\n    if not lst:\n        return None\n    root = TreeNode(lst[0])\n    queue = [root]\n    idx = 1\n    while queue and idx < len(lst):\n        node = queue.pop(0)\n        if lst[idx] is not None:\n            node.left = TreeNode(lst[idx])\n            queue.append(node.left)\n        idx += 1\n        if idx < len(lst) and lst[idx] is not None:\n            node.right = TreeNode(lst[idx])\n            queue.append(node.right)\n        idx += 1\n    return root\n\n# main function\ndef main_solution(tree_list):\n    # Convert the JSON serializable input to a TreeNode object\n    root = list_to_tree(tree_list)\n    \n    # Calculate the width of the binary tree\n    q = [(root, 1)]\n    ans = 0\n    while q:\n        width = q[-1][-1] - q[0][-1] + 1\n        ans = max(ans, width)\n        q0 = []\n        for n, i in q:\n            if n.left: \n                q0.append((n.left, i * 2))\n            if n.right:\n                q0.append((n.right, i * 2 + 1))\n        q = q0\n    \n    # Return the result as a JSON serializable output\n    return ans", "funcname": "main_solution", "ios": [{"input": {"tree_list": [54, 39, 36, 98, 88, 15, 50, null, 21, 29, 46, 78, 53, 87, 79]}, "output": 7}, {"input": {"tree_list": [62, 74, null, 83, 35, 82, null]}, "output": 2}, {"input": {"tree_list": [51, 83, 16, 41, 39, 73, null, 66, 65, null, 41, null, 67, 86, 26]}, "output": 6}, {"input": {"tree_list": [84]}, "output": 1}, {"input": {"tree_list": [52, 68, 47, null, 87, 86, 31, 89, 4, 64, 77, 1, 82, 22, 4]}, "output": 6}, {"input": {"tree_list": [82]}, "output": 1}, {"input": {"tree_list": [null]}, "output": 1}, {"input": {"tree_list": [65, 17, null, 87, 60, null, 93]}, "output": 2}, {"input": {"tree_list": [null, 13, 87, null, 27, null, 23]}, "output": 3}, {"input": {"tree_list": [84, 64, 16, null, null, 22, 70]}, "output": 2}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "a12590/LeetCode_My", "path": "/650_699/tree_math_level_widthOfBinaryTree.py", "msgidx": 2228}}
{"problem_description": "Given a chessboard of a certain size, how can we determine all possible ways to place a number of queens on the board such that no two queens can attack each other? Specifically, what are the valid permutations of queen placements for a board of size `size`?", "io_requirements": "Input:\n  `size` (int): The size of the board, which determines the number of queens and the dimensions of the board.\n\nOutput:\n  `return` (list of tuples): A list of valid permutations where each tuple represents a valid placement of queens on the board such that no two queens threaten each other. Each tuple contains integers representing the column positions of the queens in each row.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\nclass solutions:\n    @staticmethod\n    def is_valid_perm(perm):\n        for row1, row2 in permutations(range(len(perm)), 2):\n            if abs(row1 - row2) == abs(perm[row1] - perm[row2]):\n                return False\n        return True\n\n# main function\ndef main_solution(size):\n    # Convert the input size to an integer\n    size = int(size)\n    \n    # Generate all permutations of the range of the given size\n    all_permutations = permutations(range(size))\n    \n    # Filter valid permutations\n    valid_combinations = [perm for perm in all_permutations if solutions.is_valid_perm(perm)]\n    \n    # Convert valid permutations to a list of tuples\n    valid_combinations = [tuple(perm) for perm in valid_combinations]\n    \n    # Return the valid combinations as a list of tuples\n    return valid_combinations", "funcname": "main_solution", "ios": [{"input": {"size": 4}, "output": [[1, 3, 0, 2], [2, 0, 3, 1]]}, {"input": {"size": 6}, "output": [[1, 3, 5, 0, 2, 4], [2, 5, 1, 4, 0, 3], [3, 0, 4, 1, 5, 2], [4, 2, 0, 5, 3, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rajeshvalluri/NQueens", "path": "/solutions.py", "msgidx": 2297}}
{"problem_description": "In a game of poker, a player is dealt a hand of five cards. What is the ranking of the hand, the highest card value, and the kicker values?", "io_requirements": "Input:\n  `hand_cards` (list of str): A list of 5 strings representing the cards in the hand. Each string is in the format \"XY\" where X is the card value (2-9, 0, J, Q, K, A) and Y is the suit (D, C, H, S).\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `rank` (int): The rank of the hand from 1 (Royal Flush) to 10 (High Card).\n    - `high_card` (int): The highest card value in the hand.\n    - `kicker` (list of int): A list of kicker card values.", "refcode": "# import necessary packages\nfrom collections import Counter as counter\n\n# all class and function definitions in the code file, if any\ncards = {\"2\" : 2, \"3\" : 3, \"4\" : 4, \"5\" : 5, \"6\" : 6, \"7\" : 7,\n         \"8\" : 8, \"9\" : 9, \"0\" : 10, \"J\" : 11, \"Q\" : 12, \"K\" : 13, \"A\" : 14,}\n\nsuits = {\"D\" : \"Diamonds\", \"C\" : \"Clubs\", \"H\" : \"Hearts\", \"S\" : \"Spades\"}\n\nclass card():\n    \"\"\"Card object with the card number/value and card suit\"\"\"\n\n    def __init__(self, card):\n        if type(card) is not str:\n            raise TypeError(\"Parameter must be of type string\")\n        if card[0] not in cards or card[1] not in suits or len(card) != 2:\n            raise ValueError\n        self.card = cards[card[0]]\n        self.suit = suits[card[1]]\n\n    def __str__(self):\n        return str(self.card) + \" of \" + self.suit\n\nclass hand():\n    \"\"\"Hand object with a list of five card objects\"\"\"\n \n    def __init__(self, cards):\n        if type(cards) is not list:\n            raise TypeError(\"Parameter must be a list of 5 card objects\")\n        if not all(isinstance(x, card) for x in cards) or len(cards) != 5:\n            raise ValueError\n        self.cards = cards\n        self.ranking()\n\n    def check_straight(self):\n        \"\"\"Store the cards in the hand in sorted order by value\"\"\"\n        return sorted([c.card for c in self.cards])\n\n    def card_numbers(self):\n        \"\"\"Store the cards in the hand without sorting by value\"\"\"\n        return [c.card for c in self.cards]\n\n    def card_suits(self):\n        \"\"\"Store the cards in the hand without sorting by suits\"\"\"\n        return [c.suit for c in self.cards]\n\n    def ranking(self):\n        \"\"\"Determine the poker hand ranking and sets the hand's ranking from 1 to 10\"\"\"\n\n        sorted_card_numbers = self.check_straight() #Sorted card numbers\n        card_numbers = self.card_numbers() #Card numbers\n        card_suits = self.card_suits()  #Card suits\n\n        if len(counter(card_suits)) == 1:\n            if (sorted_card_numbers == [10, 11, 12, 13, 14]):\n                self.rank = 1 #Royal Flush\n                self.high_card = 14\n                self.kicker = [14]\n            elif set(sorted_card_numbers) == set(range(sorted_card_numbers[0], sorted_card_numbers[0] + 5)):\n                self.rank = 2 #Straight Flush\n                self.high_card = sorted_card_numbers[4]\n                self.kicker = [sorted_card_numbers[4]]\n            else:\n                self.rank = 5 #Flush\n                self.high_card = sorted_card_numbers[4]\n                self.kicker = sorted_card_numbers[:4][::-1]\n        elif len(counter(card_numbers).keys()) == 2:\n            if counter(card_numbers).most_common(1)[0][1] == 4:\n                self.rank = 3 #4 of a kind\n                self.high_card = counter(card_numbers).most_common(1)[0][0]\n                self.kicker = [counter(card_numbers).most_common(2)[1][0]]\n            else:\n                self.rank = 4 #full house\n                self.high_card = counter(card_numbers).most_common(1)[0][0]\n                self.kicker = [counter(card_numbers).most_common(2)[1][0]]\n        elif set(sorted_card_numbers) == set(range(sorted_card_numbers[0], sorted_card_numbers[0] + 5)):\n            self.rank = 6 #Straight\n            self.high_card = sorted_card_numbers[4]\n            self.kicker = [sorted_card_numbers[4]]\n        elif len(counter(card_numbers).keys()) == 3:\n            if counter(card_numbers).most_common(1)[0][1] == 3:\n                if 2 not in counter(card_numbers).values():\n                    kickers = counter(card_numbers).most_common(3)\n                    self.rank = 7 #3 of a kind\n                    self.high_card = counter(card_numbers).most_common(1)[0][0]\n                    self.kicker = [max(kickers[1][0], kickers[2][0])]\n                    self.kicker.append(min(kickers[1][0], kickers[2][0]))\n            else:\n                kickers = counter(card_numbers).most_common(3)\n                self.rank = 8 #2 pair\n                self.high_card1 = max(kickers[0][0], kickers[1][0])\n                self.high_card2 = min(kickers[0][0], kickers[1][0])\n                self.kicker = [counter(card_numbers).most_common(3)[2][0]]\n\n        elif len(counter(card_numbers).keys()) == 4:\n            self.rank = 9 #1 pair\n            self.high_card = counter(card_numbers).most_common(1)[0][0]\n            self.kicker = sorted([counter(card_numbers).most_common(4)[1][0],\n                                  counter(card_numbers).most_common(4)[2][0],\n                                  counter(card_numbers).most_common(4)[3][0]])\n        else:\n            self.rank = 10\n            self.high_card = sorted_card_numbers[4]\n            self.kicker = sorted_card_numbers[:4][::-1]\n\n# main function\ndef main_solution(hand_cards):\n    \"\"\"\n    Determines the ranking of a poker hand and returns the rank, high card, and kicker.\n    \n    Parameters:\n    hand_cards (list of str): A list of 5 strings representing the cards in the hand.\n                              Each string is in the format \"XY\" where X is the card value (2-9, 0, J, Q, K, A)\n                              and Y is the suit (D, C, H, S).\n    \n    Returns:\n    dict: A dictionary with the following keys:\n          - 'rank' (int): The rank of the hand from 1 (Royal Flush) to 10 (High Card).\n          - 'high_card' (int): The highest card value in the hand.\n          - 'kicker' (list of int): A list of kicker card values.\n    \"\"\"\n    # Convert the input strings to card objects\n    card_objects = [card(card_str) for card_str in hand_cards]\n    \n    # Create a hand object\n    hand_obj = hand(card_objects)\n    \n    # Prepare the output dictionary\n    result = {\n        'rank': hand_obj.rank,\n        'high_card': hand_obj.high_card,\n        'kicker': hand_obj.kicker\n    }\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"hand_cards": ["QH", "AC", "6C", "2S", "5D"]}, "output": {"rank": 10, "high_card": 14, "kicker": [12, 6, 5, 2]}}, {"input": {"hand_cards": ["7H", "QS", "0C", "3S", "JH"]}, "output": {"rank": 10, "high_card": 12, "kicker": [11, 10, 7, 3]}}, {"input": {"hand_cards": ["KH", "KD", "AH", "0D", "KC"]}, "output": {"rank": 7, "high_card": 13, "kicker": [14, 10]}}, {"input": {"hand_cards": ["AH", "AS", "KC", "9S", "0D"]}, "output": {"rank": 9, "high_card": 14, "kicker": [9, 10, 13]}}, {"input": {"hand_cards": ["KC", "9H", "0H", "2D", "3D"]}, "output": {"rank": 10, "high_card": 13, "kicker": [10, 9, 3, 2]}}, {"input": {"hand_cards": ["6S", "JD", "5D", "5D", "AS"]}, "output": {"rank": 9, "high_card": 5, "kicker": [6, 11, 14]}}, {"input": {"hand_cards": ["6H", "QC", "5S", "9S", "7C"]}, "output": {"rank": 10, "high_card": 12, "kicker": [9, 7, 6, 5]}}, {"input": {"hand_cards": ["5C", "0S", "6C", "JH", "JS"]}, "output": {"rank": 9, "high_card": 11, "kicker": [5, 6, 10]}}, {"input": {"hand_cards": ["QD", "6S", "KS", "0C", "9H"]}, "output": {"rank": 10, "high_card": 13, "kicker": [12, 10, 9, 6]}}, {"input": {"hand_cards": ["QD", "7S", "JC", "AH", "7C"]}, "output": {"rank": 9, "high_card": 7, "kicker": [11, 12, 14]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "victorgong16/poker_evaluator", "path": "/card_objects.py", "msgidx": 1344}}
{"problem_description": "Given a list of sorted integers from 1 to n, you repeatedly remove every other number, alternating between removing from the left and from the right, until only one number remains. What is the last number that remains starting with a list of length n?", "io_requirements": "Input:\n  `n` (int): The length of the initial list of integers from 1 to n.\n\nOutput:\n  `return` (int): The last remaining number after repeatedly removing every other number from the list, alternating between left-to-right and right-to-left.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass SolutionTony:\n    def lastRemaining(self, n: int) -> int:\n        head, step, remain = 1, 1, n\n        is_left = True\n        while remain != 1:\n            # if from left or (from right but has odd numbers)\n            if is_left or (not is_left and remain % 2 == 1):\n                head += step\n            remain //= 2\n            step *= 2\n            is_left = not is_left\n        return head\n\n# main function\ndef main_solution(n: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = SolutionTony()\n    result = solution.lastRemaining(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 252}, "output": 126}, {"input": {"n": 828}, "output": 382}, {"input": {"n": 848}, "output": 342}, {"input": {"n": 736}, "output": 502}, {"input": {"n": 756}, "output": 502}, {"input": {"n": 842}, "output": 352}, {"input": {"n": 59}, "output": 32}, {"input": {"n": 269}, "output": 94}, {"input": {"n": 774}, "output": 344}, {"input": {"n": 641}, "output": 470}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Taoge123/OptimizedLeetcode", "path": "/LeetcodeNew/python/LC_390.py", "msgidx": 2470}}
{"problem_description": "Given a square matrix of size NxN, where N is a positive integer, how can we arrange the numbers from 1 to N^2 in a clockwise spiral order within the matrix? Specifically, what is the sequence of numbers when read in a spiral pattern starting from the top-left corner and moving towards the center?", "io_requirements": "Input:\n  `n` (int): The size of the NxN matrix. It should be a positive integer.\n\nOutput:\n  `return` (list of int): A list of integers representing the elements of the NxN matrix in a clockwise spiral order.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer if it's not already\n    n = int(n)\n    \n    # Initialize the matrix and the number generator\n    n2 = n ** 2\n    numbers = iter(range(1, n2 + 1))\n    L = [[0 for _ in range(n)] for _ in range(n)]\n\n    # Function to check if the matrix is full\n    def isfull(L):\n        return True if 0 not in list(itertools.chain(*L)) else False\n\n    # Function to fill the periphery of the matrix\n    def fill_periphery(padding=0):\n        try:\n            # Top row\n            for i in range(padding, n - padding):\n                L[padding][i] = next(numbers)\n            # Right column\n            for i in range(padding + 1, n - padding - 1):\n                L[i][-1 - padding] = next(numbers)\n            # Bottom row\n            for i in range(padding, n - padding):\n                L[-1 - padding][-1 - i] = next(numbers)\n            # Left column\n            for i in range(padding + 1, n - padding - 1):\n                L[-1 - i][0 + padding] = next(numbers)\n        except StopIteration:\n            pass\n\n        if not isfull(L):\n            fill_periphery(padding + 1)\n        return L\n\n    # Fill the matrix in a spiral order\n    L = fill_periphery()\n    \n    # Flatten the matrix to a list in spiral order\n    spiral_list = []\n    while L:\n        spiral_list.extend(L.pop(0))  # Top row\n        if L and L[0]:\n            for row in L:\n                spiral_list.append(row.pop())  # Right column\n        if L:\n            spiral_list.extend(L.pop()[::-1])  # Bottom row\n        if L and L[0]:\n            for row in L[::-1]:\n                spiral_list.append(row.pop(0))  # Left column\n\n    # Return the spiral list as the output\n    return spiral_list", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": [1, 2, 3, 4]}, {"input": {"n": 4}, "output": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]}, {"input": {"n": 3}, "output": [1, 2, 3, 4, 5, 6, 7, 8, 9]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RohanGautam/Hour-of-code-programs", "path": "/hour of code_ question 1.py", "msgidx": 2194}}
{"problem_description": "In the Game of Life, a cellular automaton devised by the British mathematician John Conway, cells on a grid evolve over discrete time steps according to specific rules. Given an initial configuration of a grid where each cell is either dead (0) or alive (1), what will be the state of the grid after one iteration of the Game of Life rules?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the initial state of the game board. Each element in the list is an integer (0 for dead cell, 1 for alive cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the state of the game board after one iteration of the Game of Life rules. Each element in the list is an integer (0 for dead cell, 1 for alive cell).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> List[List[int]]:\n        N, M = len(board), len(board[0])\n        def neighbors(i, j):\n            for a, b in (i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1):\n                if 0 <= a < N and 0 <= b < M:\n                    yield board[a][b]\n        for i, row in enumerate(board):\n            for j, n in enumerate(row):\n                alive_count = 0\n                for state in neighbors(i, j):\n                    if state == 1 or state == 2:\n                        alive_count += 1\n                if n == 1:\n                    if alive_count != 2 and alive_count != 3:\n                        board[i][j] = 2\n                elif n == 0:\n                    if alive_count == 3:\n                        board[i][j] = 3\n        for i, row in enumerate(board):\n            for j, n in enumerate(row):\n                if n == 2:\n                    board[i][j] = 0\n                elif n == 3:\n                    board[i][j] = 1\n        return board\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # Convert input to the required format\n    solution = Solution()\n    # Call the gameOfLife method and return the result\n    result = solution.gameOfLife(board)\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 0, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0]]}, "output": [[1, 0, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0]]}, {"input": {"board": [[1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [1, 0, 1, 0, 1]]}, "output": [[1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [1, 0, 1, 0, 1]]}, {"input": {"board": [[0, 1, 1, 0], [1, 0, 1, 1], [0, 0, 1, 1]]}, "output": [[0, 1, 1, 0], [1, 0, 1, 1], [0, 0, 1, 1]]}, {"input": {"board": [[0, 1, 1, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 1, 1, 1, 0]]}, "output": [[0, 1, 1, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 1, 1, 1, 0]]}, {"input": {"board": [[1, 0, 1, 0, 1], [1, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 1, 0, 0, 0]]}, "output": [[1, 0, 1, 0, 1], [1, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 1, 0, 0, 0]]}, {"input": {"board": [[1, 0, 1, 0], [1, 0, 0, 0], [1, 0, 1, 1]]}, "output": [[1, 0, 1, 0], [1, 0, 0, 0], [1, 0, 1, 1]]}, {"input": {"board": [[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 0, 1]]}, "output": [[1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 0, 1]]}, {"input": {"board": [[0, 0, 0], [1, 0, 1], [1, 0, 1], [0, 0, 1]]}, "output": [[0, 0, 0], [1, 0, 1], [1, 0, 1], [0, 0, 1]]}, {"input": {"board": [[0, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]}, "output": [[0, 1, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]}, {"input": {"board": [[1, 1, 0, 0], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]}, "output": [[1, 1, 0, 0], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GavinPHR/code", "path": "/phase1/289.py", "msgidx": 2294}}
{"problem_description": "In a Tic-Tac-Toe game, what is the current status of the game given the board state? The board state is represented by a string of exactly 9 characters, where 'X' and 'O' represent the players' moves, and ' ' represents an empty spot. The possible outcomes are: \"Invalid\" if the board state is not valid, \"X\" if player 'X' has won, \"O\" if player 'O' has won, \"Moves\" if the game is still ongoing, and \"Even\" if the game is a draw.", "io_requirements": "Input:\n  `board_state` (str): A string representing the state of a Tic-Tac-Toe board. The string should be exactly 9 characters long and contain only the characters 'X', 'O', and ' ' (space) to represent the positions of the players and empty spots respectively.\n\nOutput:\n  `return` (str): A string indicating the result of the Tic-Tac-Toe game. Possible values are:\n  - \"Invalid\": If the board state is invalid (e.g., more than 9 moves, inconsistent number of moves between players, or both players winning).\n  - \"X\": If player 'X' has won the game.\n  - \"O\": If player 'O' has won the game.\n  - \"Moves\": If the game is still ongoing (i.e., there are empty spaces and no winner yet).\n  - \"Even\": If the game is a draw (i.e., all spaces are filled and no player has won).", "refcode": "# import necessary packages\nimport re\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\nclass TicTacToe(str):\n\n    def __init__(self, value):\n        super(TicTacToe, self).__init__()\n        self.value = value\n\n    @staticmethod\n    def __cleanUp__(value):\n        return re.sub(\"[\\W]\", \"\", value).lower()\n\n    def isPalindrome(self):\n        clean = TicTacToe.__cleanUp__(self.value)\n        return reduce(lambda x,y: x and y, map(lambda x: x[0]==x[1], zip(clean, clean[::-1])))\n\n    @staticmethod\n    def __compose_columns__(matrix):\n        return [\"\".join([matrix[x][y] for x in range(3)]) for y in range(3)]\n\n    @staticmethod\n    def __compose_diagonal__(matrix):\n        return [\"\".join([matrix[x][x] for x in range(3)]), \"\".join([matrix[x][2-x] for x in range(3)])]\n\n    def __is_winner__(self, player):\n        if self.value.count(player) < 3:\n            return False\n        lines = [self.value[i] if len(self.value) > i else \" \" for i in range(9)]\n        matrix = [lines[0:3], lines[3:6], lines[6:9]]\n        winning_rows = [\"\".join(matrix[0]), \"\".join(matrix[1]), \"\".join(matrix[2])] + TicTacToe.__compose_columns__(matrix) + TicTacToe.__compose_diagonal__(matrix)\n        return reduce(lambda x,y: x or y, map(lambda x: x.count(player) == 3, winning_rows))\n\n    def validate(self):\n        x = self.value.count(\"X\")\n        o = self.value.count(\"O\")\n        empty = self.value.count(\" \")\n        if (x + o > 9) or (x + o + empty < len(self.value)) or (abs(x - o) > 1):\n            return \"Invalid\"\n        wx = self.__is_winner__(\"X\")\n        wo = self.__is_winner__(\"O\")\n        if (wx and wo) or (wx and o > x) or (wo and x > o):\n            return \"Invalid\"\n        return (wx and \"X\") or (wo and \"O\") or (x + o < 9 and \"Moves\") or \"Even\"\n\n# main function\ndef main_solution(board_state):\n    # Convert the input to a TicTacToe object\n    tic_tac_toe = TicTacToe(board_state)\n    # Validate the board state and get the result\n    result = tic_tac_toe.validate()\n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"board_state": "OXOXXOXO "}, "output": "Moves"}, {"input": {"board_state": "XXO   OXO"}, "output": "Moves"}, {"input": {"board_state": "OXXXOXO X"}, "output": "Invalid"}, {"input": {"board_state": "OOX  X XX"}, "output": "Invalid"}, {"input": {"board_state": " OO O  OO"}, "output": "Invalid"}, {"input": {"board_state": "  OX  X X"}, "output": "Invalid"}, {"input": {"board_state": " XXO X XO"}, "output": "Invalid"}, {"input": {"board_state": "  OO  OXX"}, "output": "Moves"}, {"input": {"board_state": "  OXXOOOX"}, "output": "Moves"}, {"input": {"board_state": "OX    OXX"}, "output": "Moves"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "frollo/AdvancedProgramming", "path": "/Lab-5/es1.py", "msgidx": 2201}}
{"problem_description": "In the ancient tale of Josephus, a group of soldiers found themselves trapped and decided to form a circle to perform a specific sequence of eliminations. Given a list of items representing the soldiers and a step count indicating how many positions to skip before eliminating the next soldier, what is the order in which the soldiers are eliminated?", "io_requirements": "Input:\n  `items` (list of any JSON serializable objects): The initial list of items to be permuted.\n  `k` (int): The step count for the Josephus permutation.\n\nOutput:\n  `return` (list of any JSON serializable objects): The Josephus permutation of the input list.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(items, k):\n    # Convert the input list to a deque\n    d = deque(items)\n    res = []\n    # Perform the Josephus permutation\n    while len(d) > 0:\n        d.rotate(-k)\n        res.append(d.pop())\n    # Return the result as a list\n    return res", "funcname": "main_solution", "ios": [{"input": {"items": [6, 17, 5, 53, 84, 84, 78, 97], "k": 4}, "output": [53, 97, 84, 17, 6, 5, 78, 84]}, {"input": {"items": [9, 3, 55, 14, 47, 87], "k": 2}, "output": [3, 14, 87, 55, 9, 47]}, {"input": {"items": [38, 61, 48, 19, 15, 58, 26, 45], "k": 2}, "output": [61, 19, 58, 45, 48, 26, 15, 38]}, {"input": {"items": [61, 90, 19, 30, 66, 70], "k": 2}, "output": [90, 30, 70, 19, 61, 66]}, {"input": {"items": [80, 24, 46, 15, 19, 59, 56, 53, 3, 26], "k": 5}, "output": [19, 26, 59, 24, 3, 53, 80, 15, 56, 46]}, {"input": {"items": [14, 8, 35, 91, 98, 45, 93, 16], "k": 3}, "output": [35, 45, 14, 98, 8, 16, 91, 93]}, {"input": {"items": [42, 60, 4, 42, 15, 36, 65, 22, 11, 77], "k": 1}, "output": [42, 60, 4, 42, 15, 36, 65, 22, 11, 77]}, {"input": {"items": [86, 30, 2, 15, 19], "k": 3}, "output": [2, 86, 19, 30, 15]}, {"input": {"items": [54, 27, 75, 88, 100, 18, 83, 98, 27, 31], "k": 5}, "output": [100, 31, 18, 27, 27, 98, 54, 88, 83, 75]}, {"input": {"items": [33, 27, 78, 16, 2, 1], "k": 5}, "output": [2, 16, 1, 27, 78, 33]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kelpasa/Code_Wars_Python", "path": "/5 \u043a\u044e/Josephus Permutation.py", "msgidx": 2187}}
{"problem_description": "In a mysterious village, there are tales of ghosts that appear with varying degrees of transparency. According to ancient folklore, the transparency of a ghost is directly related to its age. A newborn ghost has a transparency of 10000, and as it ages, its transparency changes based on its age. Specifically, on each \"birthday,\" the ghost's transparency decreases by its age if the age is a Fibonacci number; otherwise, it increases by one. Given the degree of transparency of a ghost, what is its age?", "io_requirements": "Input:\n  `opacity` (int): The degree of transparency of the ghost, ranging from 0 to 10000 inclusive.\n\nOutput:\n  `return` (int): The age of the ghost in years, corresponding to the given degree of transparency. If no age matches the given transparency, it returns `None`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nfibo = {0: True}\n\ndef fib(a):\n    if a in fibo:\n        return fibo[a]\n    else:\n        fib_prev, fib_next = 0, 1\n        n = 1\n        while fib_next <= a:\n            if fib_next not in fibo: fibo[a] = True\n            if fib_next == a:\n                return True\n            fib_prev, fib_next = fib_next, fib_prev + fib_next\n            n += 1\n        else:\n            fibo[a] = False\n            return False\n\n# main function\ndef main_solution(opacity):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    life = 10000\n    for i in range(5000):\n        if fib(i):\n            life -= i\n        else:\n            life += 1\n        if life == opacity:\n            return i\n    return None", "funcname": "main_solution", "ios": [{"input": {"opacity": 8549}, "output": 1146}, {"input": {"opacity": 9023}, "output": 632}, {"input": {"opacity": 7710}, "output": 1905}, {"input": {"opacity": 5832}, "output": 2612}, {"input": {"opacity": 8029}, "output": 2224}, {"input": {"opacity": 9383}, "output": 381}, {"input": {"opacity": 3283}, "output": 4245}, {"input": {"opacity": 5909}, "output": 2689}, {"input": {"opacity": 8541}, "output": 1138}, {"input": {"opacity": 3537}, "output": 4499}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "smoksmk/check.io", "path": "/oreilly/GhostAge.py", "msgidx": 2415}}
{"problem_description": "Given a binary tree, determine whether it is a mirror of itself (i.e., symmetric around its center). What is the result of checking if the given binary tree structure is symmetric?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys:\n    - `value` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as another dictionary or None if there is no right child.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is a mirror of itself (i.e., symmetric around its center).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Tree:\n    def __init__(self, value=None, left=None, right=None):\n        self._left = left\n        self._right = right\n        self._value = value\n        self.children = [self._left, self._right]\n\n    def __repr__(self, level=0):\n        \"\"\"\n        >>> print(Tree(1))\n        1\n        >>> print(Tree(1, Tree(2), Tree(2)))\n          1\n        2   2\n        >>> print(Tree(1, Tree(2, Tree(3), Tree(3)), Tree(2), Tree(3), Tree(3)))\n            1\n          2    2\n        3   3 3  3\n        \"\"\"\n        if self._value == None:\n            return None\n        print(self._right, level+1)\n        print('  ' * level + str(self._value))\n        print(self._left, level+1)\n\n\ndef is_mirror(left_tree=None, right_tree=None):\n    '''\n    >>> t1 = Tree(1, Tree(2), Tree(2))\n    >>> t2 = Tree(1, Tree(2, None, Tree(3)), Tree(2))\n    >>> t3 = Tree(1, Tree(2, Tree(4, None, None), Tree(3, None, None)), Tree(2, Tree(3, None, None), Tree(4, None, None)))\n    >>> print is_mirror(t1._left, t1._right)\n    True\n    >>> print is_mirror(t2._left, t2._right)\n    False\n    >>> print is_mirror(t3._left, t3._right)\n    True\n    '''\n    if left_tree is None or right_tree is None:\n        return (not left_tree) and (not right_tree)\n\n    same_values = left_tree._value == right_tree._value\n    is_mirror_left = is_mirror(left_tree._left, right_tree._right)\n    is_mirror_right = is_mirror(right_tree._left, left_tree._right)\n    return same_values and is_mirror_left and is_mirror_right\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(tree_dict):\n        if tree_dict is None:\n            return None\n        return Tree(\n            value=tree_dict['value'],\n            left=build_tree(tree_dict['left']),\n            right=build_tree(tree_dict['right'])\n        )\n\n    tree = build_tree(tree_structure)\n    \n    # Check if the tree is a mirror of itself\n    if tree is None:\n        return False\n    \n    result = is_mirror(tree._left, tree._right)\n    \n    # Return the result, which is JSON serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"value": 97, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 30, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 12, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 42, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 67, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 14, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 63, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 81, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 88, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 79, "left": null, "right": null}}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GuidoBR/learning-python", "path": "/data-structures/tree.py", "msgidx": 1945}}
{"problem_description": "Given a sequence of digits, where each digit (1-26) corresponds to a letter in the alphabet (a -> 1 through z -> 26), what are all the possible translations of the sequence back to letters? For example, the sequence \"123\" can be translated to \"abc\", \"aw\", or \"lc\". What are the possible translations for a given sequence of digits?", "io_requirements": "Input:\n  `digit_string` (str): A string of digits (0-9) that represents a sequence of numbers.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a possible translation of the input digit string into letters based on the mapping a -> 1 through z -> 26.", "refcode": "# import necessary packages\nimport string\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef alphabet_dict():\n    #-- alphabet dictionary -----------------------------------\n    alpha_dict = dict(zip(string.ascii_lowercase, range(1, 27)))\n    return alpha_dict\n\ndef slicer(N):\n    '''gives usable slices of one\n    or two to cut up the string'''\n    masterlist = []\n    temp_list = []\n    comb_list = list(itertools.product([1, 2], repeat=N))\n    for lst in comb_list:\n        sum_temp_list = 0\n        temp_list = []\n        for element in lst:\n            temp_list.append(element)\n            sum_temp_list = sum(temp_list)\n            if sum_temp_list == N:\n                masterlist.append(temp_list)\n                break\n            elif sum_temp_list > N:\n                break\n\n    output = []\n    for lst in masterlist:\n        if lst not in output:\n            output.append(lst)\n    return output\n\ndef letter_sequence(s, N):\n    '''apply the string to the slices'''\n    combin_list = []\n    chunks = slicer(N)\n    for indice in chunks:\n        combin = ''\n        start = 0\n        for length in indice:\n            slice = s[start:start + length]\n            a_dict = alphabet_dict()\n            for k, v in a_dict.items():\n                if v == int(slice):\n                    combin += k\n                    break\n            start += length\n        combin_list.append(combin)\n    return combin_list\n\n# main function\ndef main_solution(digit_string):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  N = len(digit_string)\n  result = letter_sequence(digit_string, N)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"digit_string": "45512"}, "output": ["deeab", "deel", "deb", "dab", "dl", "eab", "el", "b"]}, {"input": {"digit_string": "6849"}, "output": ["fhdi", "fh", "fi", "di", ""]}, {"input": {"digit_string": "28324"}, "output": ["bhcbd", "bhcx", "bhd", "bbd", "bx", "cbd", "cx", "d"]}, {"input": {"digit_string": "273"}, "output": ["bgc", "b", "c"]}, {"input": {"digit_string": "42"}, "output": ["db", ""]}, {"input": {"digit_string": "3"}, "output": ["c"]}, {"input": {"digit_string": "85"}, "output": ["he", ""]}, {"input": {"digit_string": "85684"}, "output": ["hefhd", "hef", "hed", "hhd", "h", "fhd", "f", "d"]}, {"input": {"digit_string": "93727"}, "output": ["icgbg", "icg", "icg", "ibg", "i", "gbg", "g", "g"]}, {"input": {"digit_string": "7"}, "output": ["g"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bermec/challenges", "path": "/challenges_complete/challenge107_easytest.py", "msgidx": 2156}}
{"problem_description": "In a space navigation system, each celestial object orbits around another object. Given a set of relationships between these objects, how many direct and indirect orbits are there in the system, and what is the minimum number of orbital transfers required to move from the object YOU are orbiting to the object SAN is orbiting?", "io_requirements": "Input:\n  `input_str` (str): A string representing the input data. Each line in the string represents a relationship between two nodes in the format \"parent)child\".\n\nOutput:\n  `return` (dict): A dictionary containing the results of two parts of the solution.\n    - `part1_result` (int): The total number of direct and indirect orbits in the system.\n    - `part2_result` (int): The minimum number of orbital transfers required to move from the object YOU are orbiting to the object SAN is orbiting.", "refcode": "# import necessary packages\nfrom dataclasses import dataclass\nimport typing\n\n# all class and function definitions in the code file, if any\n@dataclass\nclass Node:\n    id: str\n    orbiting: typing.Type[\"Node\"] = None\n\n    def __repr__(self):\n        return self.id\n\ndef make_nodes(input_str):\n    def get_node(nodes, id):\n        if id not in nodes:\n            nodes[id] = Node(id)\n        return nodes[id]\n\n    all_nodes = {}\n    for line in input_str.splitlines():\n        ids = line.split(\")\")\n        p = get_node(all_nodes, ids[0])\n        s = get_node(all_nodes, ids[1])\n        assert not s.orbiting\n        s.orbiting = p\n    return all_nodes\n\ndef distance(node, primary=None):\n    if node is primary:\n        return 0\n    return 1 + distance(node.orbiting, primary)\n\ndef count_orbits(nodes, sun_id=None):\n    d = 0\n    i = 0\n    sun = nodes.get(sun_id, None)\n    for id in nodes:\n        total = distance(nodes[id], sun)\n        if total:\n            d += 1\n            i += total - 1\n    return d, i\n\ndef common_orbiting(nodes):\n    visited = set()\n    q = [n.orbiting for n in nodes]\n    while q:\n        current = q.pop(0)\n        if current.id in visited:\n            return current\n        visited.add(current.id)\n        if current.orbiting:\n            q.append(current.orbiting)\n\n    return None\n\n# main function\ndef main_solution(input_str):\n    # Convert input_str to nodes\n    nodes = make_nodes(input_str)\n    \n    # Calculate part1 result\n    d, i = count_orbits(nodes, \"COM\")\n    part1_result = d + i\n    \n    # Calculate part2 result\n    a = nodes[\"YOU\"].orbiting\n    b = nodes[\"SAN\"].orbiting\n    common = common_orbiting([a, b])\n    part2_result = distance(a, common) + distance(b, common)\n    \n    # Return results as a dictionary\n    return {\"part1_result\": part1_result, \"part2_result\": part2_result}", "funcname": "main_solution", "ios": [{"input": {"input_str": "COM)N1\nN1)N2\nN2)N3\nN2)N4\nN3)YOU\nN2)SAN"}, "output": {"part1_result": 16, "part2_result": 3}}, {"input": {"input_str": "COM)N1\nN1)N2\nN1)N3\nN3)N4\nN3)YOU\nN3)SAN"}, "output": {"part1_result": 14, "part2_result": 2}}, {"input": {"input_str": "COM)N1\nCOM)N2\nN1)N3\nN2)N4\nN4)N5\nN1)N6\nN4)N7\nN1)N8\nN5)N9\nN7)YOU\nN2)SAN"}, "output": {"part1_result": 26, "part2_result": 4}}, {"input": {"input_str": "COM)N1\nN1)N2\nN2)N3\nN2)N4\nN2)N5\nN3)YOU\nN1)SAN"}, "output": {"part1_result": 18, "part2_result": 4}}, {"input": {"input_str": "COM)N1\nCOM)N2\nCOM)N3\nN3)N4\nN3)N5\nN5)N6\nN3)N7\nCOM)N8\nN1)N9\nN7)YOU\nN3)SAN"}, "output": {"part1_result": 20, "part2_result": 3}}, {"input": {"input_str": "COM)N1\nN1)N2\nCOM)N3\nN1)N4\nN2)YOU\nN1)SAN"}, "output": {"part1_result": 11, "part2_result": 3}}, {"input": {"input_str": "COM)N1\nN1)N2\nN2)N3\nN1)N4\nN4)N5\nN3)N6\nN4)N7\nN6)YOU\nN1)SAN"}, "output": {"part1_result": 25, "part2_result": 5}}, {"input": {"input_str": "COM)N1\nCOM)N2\nN2)N3\nCOM)N4\nN2)N5\nN1)N6\nN5)N7\nCOM)N8\nN2)N9\nN9)YOU\nN2)SAN"}, "output": {"part1_result": 20, "part2_result": 3}}, {"input": {"input_str": "COM)N1\nCOM)N2\nN2)N3\nN3)N4\nN2)N5\nN2)YOU\nN1)SAN"}, "output": {"part1_result": 13, "part2_result": 2}}, {"input": {"input_str": "COM)N1\nN1)N2\nCOM)N3\nCOM)N4\nN3)N5\nCOM)N6\nN3)N7\nN7)N8\nN8)YOU\nN7)SAN"}, "output": {"part1_result": 20, "part2_result": 3}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shahvirb/adventOfCode2019", "path": "/day6.py", "msgidx": 2302}}
{"problem_description": "Given a range of integers, how many numbers within this range are considered suBrimes? A number is a suBrime if it is a prime number and both the sum of its digits and the sum of the digits of its binary representation are also prime numbers.", "io_requirements": "Input:\n  `start` (int): The starting integer of the range for which to count the suBrimes.\n  `stop` (int): The ending integer of the range for which to count the suBrimes.\n\nOutput:\n  `return` (int): The count of numbers in the range `[start, stop]` that are suBrimes.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass SitoE:\n    \"Sito Eratostenesa\"\n\n    def __init__(self, nmax: int):\n        self._nmax = nmax\n        self._primes = {i: True for i in range(2, nmax + 1)}\n        g = int(math.sqrt(nmax)) + 1\n\n        for i in range(2, g):\n            if self._primes[i]:\n                w = i * i\n                while w <= nmax:\n                    self._primes[w] = False\n                    w += i\n\n    def __contains__(self, item: int) -> bool:\n        # pozwala u\u017cy\u0107 operatora 'in' do sprawdzenia, czy liczba jest pierwsza\n        if not isinstance(item, int):\n            raise TypeError(f\"Nieprawid\u0142owy typ ({type(item)})\")\n        if item > self._nmax:\n            raise ValueError(\n                f\"Sprawdzana warto\u015b\u0107 ({item}) poza zakresem sita ({self._nmax}).\"\n            )\n        return self._primes.get(item, False)\n\n# main function\ndef main_solution(start: int, stop: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    sito = SitoE(1006700)\n\n    def suprime(liczba: int) -> bool:\n        suma = 0\n        for i in str(liczba):\n            suma += int(i)\n        return liczba in sito and suma in sito\n\n    def suBrime(liczba: int) -> bool:\n        zapis_binarny = f\"{liczba:b}\"\n        suma = 0\n        for i in zapis_binarny:\n            suma += int(i)\n        return suprime(liczba) and suma in sito\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(1 for i in range(start, stop + 1) if suBrime(i))", "funcname": "main_solution", "ios": [{"input": {"start": 8883, "stop": 37858}, "output": 439}, {"input": {"start": 8476, "stop": 20070}, "output": 194}, {"input": {"start": 1801, "stop": 5986}, "output": 103}, {"input": {"start": 3404, "stop": 60306}, "output": 804}, {"input": {"start": 5712, "stop": 89423}, "output": 1030}, {"input": {"start": 7613, "stop": 96818}, "output": 1073}, {"input": {"start": 9966, "stop": 25393}, "output": 233}, {"input": {"start": 1342, "stop": 48050}, "output": 736}, {"input": {"start": 2056, "stop": 88400}, "output": 1126}, {"input": {"start": 8863, "stop": 19390}, "output": 175}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pragiark/pymatura", "path": "/S_2007/zad5.py", "msgidx": 2164}}
{"problem_description": "Given a list of integers and a target sum, what are all the unique combinations of integers from the list that add up to the target sum?", "io_requirements": "Input:\n  `candidates` (List[int]): A list of integers from which combinations are to be formed.\n  `target` (int): The target sum that the combinations should add up to.\n\nOutput:\n  `return` (List[List[int]]): A list of lists, where each inner list represents a combination of integers from `candidates` that add up to the `target`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(candidates: List[int], target: int) -> List[List[int]]:\n    res = []\n\n    def dfs(candidates, index, remain, value):\n        n = len(candidates)\n        if remain < 0:\n            return\n        if remain == 0:\n            res.append(value)\n            return\n        for i in range(index, n):\n            if remain < 0:\n                break\n            dfs(candidates, i, remain - candidates[i], value + [candidates[i]])\n\n    dfs(candidates, 0, target, [])\n    return res", "funcname": "main_solution", "ios": [{"input": {"candidates": [1, 5, 2, 3, 8], "target": 3}, "output": [[1, 1, 1], [1, 2], [3]]}, {"input": {"candidates": [2, 6, 1, 9, 5], "target": 2}, "output": [[2], [1, 1]]}, {"input": {"candidates": [10, 1, 8], "target": 11}, "output": [[10, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 8]]}, {"input": {"candidates": [8, 2, 6, 3], "target": 3}, "output": [[3]]}, {"input": {"candidates": [2, 3, 4, 10, 5, 6], "target": 9}, "output": [[2, 2, 2, 3], [2, 2, 5], [2, 3, 4], [3, 3, 3], [3, 6], [4, 5]]}, {"input": {"candidates": [8, 4, 9, 6, 1, 10], "target": 1}, "output": [[1]]}, {"input": {"candidates": [3, 10, 7], "target": 14}, "output": [[7, 7]]}, {"input": {"candidates": [3, 1, 4, 5, 8, 7], "target": 2}, "output": [[1, 1]]}, {"input": {"candidates": [10, 1, 3, 4], "target": 2}, "output": [[1, 1]]}, {"input": {"candidates": [2, 1, 9], "target": 6}, "output": [[2, 2, 2], [2, 2, 1, 1], [2, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Jiaget/LeetCode-Python3", "path": "/\u56de\u6eaf.py", "msgidx": 2679}}
{"problem_description": "Given a binary tree and a target sum, can you determine all the paths from the root node to the leaf nodes where the sum of the node values equals the target sum?", "io_requirements": "Input:\n  `tree_structure` (list of int or None): A list representing the binary tree in level order traversal. Each element represents the value of a node, with `None` indicating a missing node.\n  `target_sum` (int): The target sum for the paths in the binary tree.\n\nOutput:\n  `return` (str): A JSON serialized string representing a list of lists. Each inner list represents a path in the binary tree that sums up to the target sum.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def FindPath(self, root, expectNumber):\n        if not root or root.val > expectNumber:\n            return []\n        if root and not root.left and not root.right and root.val == expectNumber:\n            return [[root.val]]\n        ans = []\n        left = self.FindPath(root.left, expectNumber - root.val)\n        right = self.FindPath(root.right, expectNumber - root.val)\n        for ele in left + right:\n            ans.append([root.val] + ele)\n        return ans\n\n# main function\ndef main_solution(tree_structure, target_sum):\n    # Convert JSON serializable input to original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    solution = Solution()\n    paths = solution.FindPath(root, target_sum)\n    \n    # Convert output to JSON serializable format\n    return json.dumps(paths)", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [8, null, 15], "target_sum": 20}, "output": "[]"}, {"input": {"tree_structure": [7, null, 10, 16], "target_sum": 40}, "output": "[]"}, {"input": {"tree_structure": [2, null, 3, 1, 10], "target_sum": 12}, "output": "[]"}, {"input": {"tree_structure": [20, 5, null, 11], "target_sum": 47}, "output": "[]"}, {"input": {"tree_structure": [16, null, 10, 1], "target_sum": 47}, "output": "[]"}, {"input": {"tree_structure": [8, 13, null, 6, 18], "target_sum": 29}, "output": "[]"}, {"input": {"tree_structure": [17, null, 11], "target_sum": 39}, "output": "[]"}, {"input": {"tree_structure": [17, 10], "target_sum": 46}, "output": "[]"}, {"input": {"tree_structure": [6, 18, 1, null, 16], "target_sum": 40}, "output": "[[6, 18, 16]]"}, {"input": {"tree_structure": [16, 4, null, 4, 4], "target_sum": 22}, "output": "[]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hluculent/GetAJob", "path": "/Algorithm/Tree/FindPath.py", "msgidx": 2235}}
{"problem_description": "Given a number of pairs of parentheses, how can we generate all possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate. It should be a positive integer.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a valid combination of parentheses. Each string has exactly `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def generateParenthesis(self, n):\n        list1 = list()\n        self.backtracks(n, list1, S='', l=0, r=0)\n        return list1\n\n    def backtracks(self, n, list1, S, l, r):\n        if l < n:\n            self.backtracks(n, list1, S+'(', l+1, r)\n        if r < l:\n            self.backtracks(n, list1, S+')', l, r+1)\n        if len(S) == 2*n:\n            list1.append(S)\n            return\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Git-emily/Python-Leetcode", "path": "/LeetCode\u5237\u9898/22 \u62ec\u53f7\u751f\u6210.py", "msgidx": 2748}}
{"problem_description": "Given a grid with empty cells, a starting point, an ending point, and obstacles, how many unique paths are there from the starting point to the ending point, visiting all empty cells exactly once? The grid is represented by a 2D list where `0` denotes an empty cell, `1` denotes the starting point, `2` denotes the ending point, and `-1` denotes an obstacle.", "io_requirements": "Input:\n  `grid` (List[List[int]]): A 2D list representing the grid. Each element in the grid can be one of the following:\n    - `0`: An empty cell.\n    - `1`: The starting point.\n    - `2`: The ending point.\n    - `-1`: An obstacle.\n\nOutput:\n  `return` (int): The number of unique paths from the starting point to the ending point, visiting all empty cells exactly once.", "refcode": "# import necessary packages\nfrom typing import List\nimport json\n\n# all class and function definitions in the code file, if any\ndef uniquePathsIII(grid: List[List[int]]) -> int:\n    \n    # Initialize unvisited set\n    unvisited = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] in {0, 1}:\n                unvisited.add((i, j))\n            if grid[i][j] == 1:\n                starti = i\n                startj = j\n\n    # Dimensions\n    n = len(grid)\n    m = len(grid[0])\n\n    def backtrack(i: int, j: int, visited: set, unvisited: set) -> int:\n   \n        # Reached the end\n        if grid[i][j] == 2:\n            if len(unvisited) == 0:\n                return 1\n            else:\n                return 0\n        # Reached obstacle\n        if grid[i][j] == -1:\n            return 0\n        # Mark as visited\n        visited = visited.union({(i, j)})\n        unvisited = unvisited - {(i, j)}\n        moves = 0\n        # Left\n        if j > 0 and (i, j - 1) not in visited:\n            moves += backtrack(i, j - 1, visited, unvisited)\n        # Right\n        if j < m - 1 and (i, j + 1) not in visited:\n            moves += backtrack(i, j + 1, visited, unvisited)\n        # Up\n        if i > 0 and (i - 1, j) not in visited:\n            moves += backtrack(i - 1, j, visited, unvisited)\n        # Down\n        if i < n - 1 and (i + 1, j) not in visited:\n            moves += backtrack(i + 1, j, visited, unvisited)\n\n        return moves\n\n    return backtrack(starti, startj, set(), unvisited) \n        \n\nclass Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        return uniquePathsIII(grid)\n\n# main function\ndef main_solution(grid: List[List[int]]) -> int:\n    # Convert JSON serializable input to the original input variables\n    grid = json.loads(json.dumps(grid))\n    \n    # Call the original function\n    result = uniquePathsIII(grid)\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"grid": [[0, -1, -1, -1, 1], [0, 0, 0, 0, 2]]}, "output": 0}, {"input": {"grid": [[0, -1], [0, 0], [0, 0], [1, 0], [2, 0]]}, "output": 0}, {"input": {"grid": [[2, -1, 1], [0, 0, -1], [0, 0, 0], [0, 0, -1]]}, "output": 0}, {"input": {"grid": [[1, 0, 0], [0, -1, 2]]}, "output": 0}, {"input": {"grid": [[-1, 0], [2, 0], [0, 0], [0, 1]]}, "output": 0}, {"input": {"grid": [[2, 0, 0, 0], [0, 0, 0, -1], [-1, 0, 1, 0]]}, "output": 0}, {"input": {"grid": [[-1, 0], [0, 0], [1, 0], [0, -1], [0, 2]]}, "output": 0}, {"input": {"grid": [[0, 0, -1, 0, 0], [2, 0, 0, 0, 0], [-1, 1, -1, -1, -1]]}, "output": 0}, {"input": {"grid": [[-1, -1, 0, 0], [-1, 0, 0, 2], [1, 0, 0, 0]]}, "output": 0}, {"input": {"grid": [[-1, 0], [0, 0], [2, 1]]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ryandavis3/leetcode", "path": "/unique_paths3/unique_paths.py", "msgidx": 1798}}
{"problem_description": "Given a grid of letters, determine if a specific word can be formed by connecting adjacent letters in the grid. The word can be formed by moving horizontally, vertically, or diagonally, but each letter in the grid can only be used once. What is the result of checking if the word can be found in the grid?", "io_requirements": "Input:\n  `board` (str): A string representation of the board where each row is separated by a newline character (`\\n`). Each character in the row represents a letter on the board.\n  `word` (str): The word to be searched for in the board.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the word can be found in the board (`True` if found, `False` otherwise).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef find_word(board, word):\n    grid = [l + [''] for l in board] + [[''] * (len(board[0]) + 1)]\n    def rc(x, y, i):\n        if i == len(word): return True\n        if grid[x][y] != word[i]: return False\n        grid[x][y] = ''\n        r = any(rc(x + u, y + v, i + 1)\n                for u in range(-1, 2)\n                for v in range(-1, 2))\n        grid[x][y] = word[i]\n        return r\n    return any(rc(x, y, 0)\n               for x in range(len(board))\n               for y in range(len(board[x])))\n\n# main function\ndef main_solution(board, word):\n    # Convert the board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [list(row) for row in board.split('\\n')]\n    \n    # Call the find_word function\n    result = find_word(board, word)\n    \n    # Return the result as a boolean\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": "VUSHAT\nOTMAVY\nUQNHLE\nIBSANO", "word": "BIQH"}, "output": false}, {"input": {"board": "LOJ\nWCL\nMKU\nJIP", "word": "WGIUBGYU"}, "output": false}, {"input": {"board": "YYR\nOKG\nAJL\nIUP", "word": "ZXOUZET"}, "output": false}, {"input": {"board": "WPV\nJNZ\nDCO", "word": "GTK"}, "output": false}, {"input": {"board": "ZFLB\nNTNG\nRYRB\nIXRI", "word": "PIBQRWB"}, "output": false}, {"input": {"board": "ELME\nETBX\nFSYE\nZLTU\nTUGE", "word": "OYN"}, "output": false}, {"input": {"board": "QSI\nCQC\nESM\nTLT\nMFA", "word": "LDVA"}, "output": false}, {"input": {"board": "HFDLR\nMDSXP\nHPOXC\nCYRHH\nYKUEE", "word": "ZRHLBQT"}, "output": false}, {"input": {"board": "APGQQ\nNUOCH\nLZZUN", "word": "KFPVGX"}, "output": false}, {"input": {"board": "SQDN\nMMFG\nOKRO\nECPG\nCVHA\nBQRG", "word": "MDIXVDA"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Muneer320/CodeWars-Solved-Katas", "path": "/4 Kyu/boggleWordChecker.py", "msgidx": 2568}}
{"problem_description": "In a game of Yahtzee, players roll five dice and try to achieve certain combinations. Given a set of possible outcomes and a specific length, what are all the possible sequences of outcomes that can be generated? Additionally, given a hand of dice, what are all the possible choices of dice that can be held?", "io_requirements": "Input:\n  `outcomes` (list): A list of possible outcomes, where each outcome is a JSON serializable object (e.g., int, str).\n  `length` (int): The length of the sequences to generate.\n  `hand` (list): A list representing the full Yahtzee hand, where each element is a JSON serializable object (e.g., int, str).\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `all_sequences` (list of tuples): A list of tuples representing all possible sequences of outcomes.\n    - `all_holds` (list of tuples): A list of tuples representing all possible choices of dice to hold.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(outcomes, length, hand):\n    \"\"\"\n    Generates all possible sequences of outcomes of a given length and all possible choices of dice to hold from a hand.\n\n    Args:\n    outcomes (list): A list of possible outcomes.\n    length (int): The length of the sequences to generate.\n    hand (list): A list representing the full Yahtzee hand.\n\n    Returns:\n    dict: A dictionary containing two keys:\n          - 'all_sequences': A list of tuples representing all possible sequences of outcomes.\n          - 'all_holds': A list of tuples representing all possible choices of dice to hold.\n    \"\"\"\n    # Convert outcomes and hand to lists if they are not already\n    outcomes = list(outcomes)\n    hand = list(hand)\n\n    # Generate all sequences of outcomes of given length\n    all_sequences = list(itertools.product(outcomes, repeat=length))\n\n    # Generate all possible choices of dice to hold from the hand\n    all_holds = [tuple(subset) for r in range(len(hand) + 1) for subset in itertools.combinations(hand, r)]\n\n    return {\n        'all_sequences': all_sequences,\n        'all_holds': all_holds\n    }", "funcname": "main_solution", "ios": [{"input": {"outcomes": [2, 6], "length": 2, "hand": [2, 6]}, "output": {"all_sequences": [[2, 2], [2, 6], [6, 2], [6, 6]], "all_holds": [[], [2], [6], [2, 6]]}}, {"input": {"outcomes": [2, 4], "length": 2, "hand": [4, 2]}, "output": {"all_sequences": [[2, 2], [2, 4], [4, 2], [4, 4]], "all_holds": [[], [4], [2], [4, 2]]}}, {"input": {"outcomes": [1, 1], "length": 2, "hand": [1, 1]}, "output": {"all_sequences": [[1, 1], [1, 1], [1, 1], [1, 1]], "all_holds": [[], [1], [1], [1, 1]]}}, {"input": {"outcomes": [2, 4], "length": 2, "hand": [2, 2]}, "output": {"all_sequences": [[2, 2], [2, 4], [4, 2], [4, 4]], "all_holds": [[], [2], [2], [2, 2]]}}, {"input": {"outcomes": [2, 6], "length": 2, "hand": [6, 6]}, "output": {"all_sequences": [[2, 2], [2, 6], [6, 2], [6, 6]], "all_holds": [[], [6], [6], [6, 6]]}}, {"input": {"outcomes": [5, 1], "length": 2, "hand": [1, 5]}, "output": {"all_sequences": [[5, 5], [5, 1], [1, 5], [1, 1]], "all_holds": [[], [1], [5], [1, 5]]}}, {"input": {"outcomes": [3, 3], "length": 2, "hand": [3, 3]}, "output": {"all_sequences": [[3, 3], [3, 3], [3, 3], [3, 3]], "all_holds": [[], [3], [3], [3, 3]]}}, {"input": {"outcomes": [1, 6], "length": 2, "hand": [1, 6]}, "output": {"all_sequences": [[1, 1], [1, 6], [6, 1], [6, 6]], "all_holds": [[], [1], [6], [1, 6]]}}, {"input": {"outcomes": [3, 2], "length": 2, "hand": [2, 2]}, "output": {"all_sequences": [[3, 3], [3, 2], [2, 3], [2, 2]], "all_holds": [[], [2], [2], [2, 2]]}}, {"input": {"outcomes": [1, 6], "length": 2, "hand": [1, 1]}, "output": {"all_sequences": [[1, 1], [1, 6], [6, 1], [6, 6]], "all_holds": [[], [1], [1], [1, 1]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jiajingchen/Projects-for-Rice-Coursera-Programming-in-Python", "path": "/Yahtzee/2.py", "msgidx": 2419}}
{"problem_description": "In an alien language, we have a list of known words. Each word is composed of lowercase English letters. We also have several test cases, where each test case is a string that may contain parentheses indicating possible combinations of letters. For each test case, how many combinations of the letters can form words that are in the list of known alien words?", "io_requirements": "Input:\n- `alien_words` (list of strings): A list of known alien words. Each word is a string.\n- `test_cases` (list of strings): A list of test cases. Each test case is a string that may contain parentheses indicating possible combinations.\n\nOutput:\n- `return` (list of integers): A list where each integer represents the number of successful combinations for each test case that match any of the alien words.", "refcode": "# import necessary packages\nimport re\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef extract_paretheses(value: str) -> list:\n    return [\n        [char for char in token]\n        for token in re.split(r'\\((.*?)\\)', value)\n        if token != ''\n    ]\n\ndef combinations(case: list) -> list:\n    return [\n        ''.join(combination)\n        for combination in list(product(*case))\n    ]\n\ndef get_cases_with_matrix(cases: list) -> list:\n    return [\n        [[char for char in token] for token in case]\n        if not re.search(r'\\((.*?)\\)', case)\n        else extract_paretheses(case)\n        for case in cases\n    ]\n\ndef get_success_cases(words: list, cases: list) -> list:\n    new_list_cases = get_cases_with_matrix(cases)\n    results = list()\n    for case in new_list_cases:\n        combinations_of_case = combinations(case)\n        success_words = [\n            combination\n            for combination in combinations_of_case\n            if combination in words\n        ]\n        results.append(len(success_words))\n    return results\n\n# main function\ndef main_solution(alien_words: list, test_cases: list) -> list:\n    # Convert JSON serializable inputs to original input variables\n    words = alien_words\n    cases = test_cases\n    \n    # Core solution logic\n    results = get_success_cases(words, cases)\n    \n    # Convert results to JSON serializable output\n    return results", "funcname": "main_solution", "ios": [{"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["qwoo", "(nm)sb(xi)", "xxpx"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["(av)el", "jjzd", "(pn)ap"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["(xs)", "yj", "ig"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["(nt)(ka)", "okjh(ly)", "(gh)(ny)vs"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["(xz)pm(lo)", "ncjn", "(qx)"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["ir", "(mj)zs", "nn"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["ub(zy)vy", "hhoi(hv)", "mwog"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["(tc)", "(of)(qk)", "aigj"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["(br)jsqf", "(lj)osre", "(eh)(rr)"]}, "output": [0, 0, 0]}, {"input": {"alien_words": ["abc", "bca", "dac", "dbc", "cba"], "test_cases": ["ee(vo)vy", "qt(nv)(pg)", "of"]}, "output": [0, 0, 0]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Diego-AC/decrypt-alien-messages", "path": "/main.py", "msgidx": 1979}}
{"problem_description": "Given a target sum, can you find all possible combinations of the numbers from 1 to 9, with the operators '+', '-', or no operator, that evaluate to the target sum?", "io_requirements": "Input:\n  `target_sum` (int): The target sum that the expression should evaluate to.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a valid mathematical expression that evaluates to the target sum.", "refcode": "# import necessary packages\nimport itertools\nfrom itertools import chain\n\n# all class and function definitions in the code file, if any\ndef tupleToList(lst):\n    return list(chain.from_iterable(lst))\n\n# main function\ndef main_solution(target_sum):\n    signs = ['+', '-', '']\n    numbers = [i for i in range(1, 10)]\n    options = []\n    signlist = [list(p) for p in itertools.product(signs, repeat=8)]  # creates lists of all possible permutations of the 3 signs\n    num = 0\n    results = []\n    while num < 9:\n        for combinations in signlist:\n            options = list(zip(numbers, combinations))  # tuples of numbers and signs\n            options.append((9, ''))\n            options = tupleToList(options)\n            a = ''.join(str(x) for x in options)\n            if eval(a) == target_sum:\n                results.append(a)\n            num += 1\n    return results", "funcname": "main_solution", "ios": [{"input": {"target_sum": 147}, "output": ["1+2-3+4+56+78+9", "1+2-3+45+6+7+89", "1+2-3-4-5+67+89", "1+234+5-6-78-9", "12-3+45+6+78+9"]}, {"input": {"target_sum": 179}, "output": ["1+23+4-5+67+89", "1-23+45+67+89"]}, {"input": {"target_sum": 130}, "output": ["1+2+34+5+6-7+89", "1+2-34+5+67+89", "1-2+34-5+6+7+89", "1-2-3-4+56-7+89", "12-3+45-6-7+89", "12-3-4+56+78-9", "12-34+56+7+89", "123+4+5+6-7+8-9", "123-4-5+6-7+8+9"]}, {"input": {"target_sum": 155}, "output": ["1+2-3+4-5+67+89", "1+234-5-6-78+9", "1+234-56-7-8-9"]}, {"input": {"target_sum": 140}, "output": ["1+2+3-4+56-7+89", "1+234-5+6-7-89", "1-2+3+45+6+78+9", "1-2+34+5+6+7+89", "123+4-5-6+7+8+9", "123+4-56+78-9", "123-4+5+6-7+8+9"]}, {"input": {"target_sum": 80}, "output": ["1+2+3+4-5+6+78-9", "1+2-3+4-5-6+78+9", "1-2-3+4+5+6+78-9", "1-2-3+4+56+7+8+9", "1-2-3-4-5+6+78+9", "1-23+4+5+6+78+9", "12+3+4-5+67+8-9", "123+45-6+7-89", "123-45-6+7-8+9"]}, {"input": {"target_sum": 156}, "output": ["1+2-3+4+56+7+89", "1+234+5-67-8-9", "12-3+4+56+78+9", "12-3+45+6+7+89", "12-3-4-5+67+89", "123+45-6-7-8+9"]}, {"input": {"target_sum": 112}, "output": ["1+2-34+56+78+9", "1-2+34-5+67+8+9", "1-23-4+56-7+89", "12+3+4+5+6-7+89", "12+34+56-7+8+9", "12-3-4+5+6+7+89", "123-4+5-6-7-8+9", "123-4-5+6-7+8-9"]}, {"input": {"target_sum": 198}, "output": ["1+2+34+5+67+89", "12+34+56+7+89", "123+4+5+67+8-9", "123+4-5-6-7+89", "123+45+6+7+8+9", "123-4-5+67+8+9"]}, {"input": {"target_sum": 139}, "output": ["1+2+3+45+6-7+89", "1+2-3-4+56+78+9", "12+34+5+6-7+89", "12-34+5+67+89"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lplx55/Beadando", "path": "/ex_5.py", "msgidx": 2672}}
{"problem_description": "Given a range of single-digit integers, identify the product of numerators and denominators for fractions that exhibit a curious property where the fraction can be incorrectly simplified by canceling out a common digit in the numerator and denominator. What are the products of the numerators and denominators for such fractions within the specified digit range?", "io_requirements": "Input:\n  `digit_range` (int): The range of digits to consider for the numerator and denominator. This should be a single digit integer (1-9).\n\nOutput:\n  `return` (dict): A dictionary containing the product of numerators and denominators of the fractions that satisfy the curious fraction condition.\n    - `numerator_product` (int): The product of all numerators.\n    - `denominator_product` (int): The product of all denominators.", "refcode": "# import necessary packages\nimport time\n\n# main function\ndef main_solution(digit_range):\n    denproduct = 1\n    nomproduct = 1\n    for i in range(1, 10):\n        for den in range(1, i):\n            for nom in range(1, den):\n                if (nom * 10 + i) * den == nom * (i * 10 + den):\n                    denproduct *= den\n                    nomproduct *= nom\n    return {\"numerator_product\": nomproduct, \"denominator_product\": denproduct}", "funcname": "main_solution", "ios": [{"input": {"digit_range": 5}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 3}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 2}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 4}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 8}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 9}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 6}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 1}, "output": {"numerator_product": 8, "denominator_product": 800}}, {"input": {"digit_range": 7}, "output": {"numerator_product": 8, "denominator_product": 800}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lastmayday/Euler", "path": "/33.py", "msgidx": 2702}}
{"problem_description": "In a memory system, data is stored in a spiral pattern on a grid, starting from square 1 and spiraling outward. Each square is allocated a number, and the data must be carried back to the access port at square 1. The shortest path to the access port is calculated using the Manhattan Distance. Additionally, each square's value is determined by summing the values of its adjacent squares. Given a specific square number, what are the Manhattan Distance to the access port and the first value written on the grid that is larger than the given square number?", "io_requirements": "Input:\n  `data` (int): The number of the square on the grid for which to calculate the Manhattan Distance and the first value larger than the input.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `manhattan_distance` (int): The Manhattan Distance from the given square to the center (square 1).\n    - `first_value_larger_than_input` (int): The first value written on the grid that is larger than the input `data`.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef generate_walk():\n    directions = itertools.cycle([(1, 0), (0, -1), (-1, 0), (0, 1)])\n    i, j = 0, 0\n    n = 1\n    run = 1\n    while True:\n        for x in range(2):\n            direction = next(directions)\n            for s in range(run):\n                i += direction[0]\n                j += direction[1]\n                n += 1\n                yield n, i, j\n        run += 1\n\ndef calc_03a(data):\n    if data == 1:\n        return 0\n    walk = generate_walk()\n    for n, i, j in walk:\n        if n == data:\n            return abs(i) + abs(j)\n    assert False, f\"{data} was not found!\"\n\ndef sum_neighbours(values, i, j):\n    offsets = [\n        (-1, -1), (0, -1), (1, -1),\n        (-1, 0),           (1, 0),\n        (-1, 1), (0, 1), (1, 1)\n    ]\n    return sum([values.get((i + n, j + m), 0) for n, m in offsets])\n\ndef calc_03b(data):\n    if data == 1:\n        return 2\n    values = {(0, 0): 1}\n    walk = generate_walk()\n    for n, i, j in walk:\n        neighbours = sum_neighbours(values, i, j)\n        if neighbours > data:\n            return neighbours\n        values[(i, j)] = neighbours\n    assert False, f\"Failed on input {data}!\"\n\n# main function\ndef main_solution(data):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result_03a = calc_03a(data)\n    result_03b = calc_03b(data)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"manhattan_distance\": result_03a, \"first_value_larger_than_input\": result_03b}", "funcname": "main_solution", "ios": [{"input": {"data": 851852}, "output": {"manhattan_distance": 845, "first_value_larger_than_input": 875851}}, {"input": {"data": 748358}, "output": {"manhattan_distance": 733, "first_value_larger_than_input": 752688}}, {"input": {"data": 702618}, "output": {"manhattan_distance": 465, "first_value_larger_than_input": 752688}}, {"input": {"data": 749972}, "output": {"manhattan_distance": 851, "first_value_larger_than_input": 752688}}, {"input": {"data": 233289}, "output": {"manhattan_distance": 482, "first_value_larger_than_input": 266330}}, {"input": {"data": 775923}, "output": {"manhattan_distance": 642, "first_value_larger_than_input": 787032}}, {"input": {"data": 618440}, "output": {"manhattan_distance": 643, "first_value_larger_than_input": 752688}}, {"input": {"data": 107024}, "output": {"manhattan_distance": 233, "first_value_larger_than_input": 109476}}, {"input": {"data": 350276}, "output": {"manhattan_distance": 403, "first_value_larger_than_input": 363010}}, {"input": {"data": 317811}, "output": {"manhattan_distance": 286, "first_value_larger_than_input": 330785}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "owbear/aoc_2017", "path": "/ac_03.py", "msgidx": 2370}}
{"problem_description": "Given a specific year and a chemical polymer chain, how many times does Friday the 13th occur in that year, and what is the final stable form of the polymer chain after all possible reactive pairs have been removed?", "io_requirements": "Input:\n  `year` (int): The year for which to calculate the number of Friday the 13ths.\n  `polymer_string` (str): The polymer string to be processed and have reactive pairs removed.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `friday_13_count` (int): The number of Friday the 13ths in the given year.\n    - `processed_polymer` (str): The processed polymer string after removing reactive pairs.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(year, polymer_string):\n    \"\"\"\n    This function calculates the number of Friday the 13ths in a given year and processes a polymer string to remove reactive pairs.\n    \n    Parameters:\n    year (int): The year for which to calculate the number of Friday the 13ths.\n    polymer_string (str): The polymer string to be processed and have reactive pairs removed.\n    \n    Returns:\n    dict: A dictionary containing the number of Friday the 13ths and the processed polymer string.\n    \"\"\"\n    \n    # Calculate the number of Friday the 13ths in the given year\n    def friday13(year):\n        from datetime import datetime\n        count = 0\n        for month in range(1, 13):\n            date = datetime(year, month, 13)\n            if date.strftime(\"%A\") == \"Friday\":\n                count += 1\n        return count\n    \n    # Process the polymer string to remove reactive pairs\n    def react(polymer_string):\n        while bool(re.search(r'([a-zA-Z])(?!\\1)(?i:\\1)', polymer_string)):\n            for x in re.finditer(r'([a-zA-Z])(?!\\1)(?i:\\1)', polymer_string):\n                polymer_string = polymer_string.replace(x.group(), '')\n        return polymer_string\n    \n    # Calculate the number of Friday the 13ths\n    friday_13_count = friday13(year)\n    \n    # Process the polymer string\n    processed_polymer = react(polymer_string)\n    \n    # Return the results as a dictionary\n    return {\n        \"friday_13_count\": friday_13_count,\n        \"processed_polymer\": processed_polymer\n    }", "funcname": "main_solution", "ios": [{"input": {"year": 1994, "polymer_string": "OBRDxDWWQHSLHCdfcDMcjkLVQIXSMSAaOmLQDzYDDIhuxmDSP"}, "output": {"friday_13_count": 1, "processed_polymer": "OBRDxDWWQHSLHCdfcDMcjkLVQIXSMSOmLQDzYDDIhuxmDSP"}}, {"input": {"year": 2021, "polymer_string": "uksUPIokKdrkDPPiiSOPlyFraZSfKupFdGRXXeHbUEJa"}, "output": {"friday_13_count": 1, "processed_polymer": "uksUPIodrkDPPiiSOPlyFraZSfKupFdGRXXeHbUEJa"}}, {"input": {"year": 1999, "polymer_string": "AHOKWxNKkUAQYlbSkpMaW"}, "output": {"friday_13_count": 1, "processed_polymer": "AHOKWxNUAQYlbSkpMaW"}}, {"input": {"year": 1992, "polymer_string": "eBLRyzdkPaZOsYpsumeTgwXhVYlJgWYHldiDpMKwsrHCWbHw"}, "output": {"friday_13_count": 2, "processed_polymer": "eBLRyzdkPaZOsYpsumeTgwXhVYlJgWYHldiDpMKwsrHCWbHw"}}, {"input": {"year": 2092, "polymer_string": "fejKGFWAMNAuLEvCeHJJOBZbMsWE"}, "output": {"friday_13_count": 1, "processed_polymer": "fejKGFWAMNAuLEvCeHJJOBZbMsWE"}}, {"input": {"year": 1989, "polymer_string": "IHznYFLEvowcdttEGAdVclwZP"}, "output": {"friday_13_count": 2, "processed_polymer": "IHznYFLEvowcdttEGAdVclwZP"}}, {"input": {"year": 1952, "polymer_string": "gpUlTYqKHtvsvNCcRrKKfafwFpGxslQMuqBcNmsunoFPVhwYC"}, "output": {"friday_13_count": 1, "processed_polymer": "gpUlTYqKHtvsvNKKfafwFpGxslQMuqBcNmsunoFPVhwYC"}}, {"input": {"year": 2050, "polymer_string": "HnAfBVGhJsDIgWskhdbWDljeiZYjQkCNjOT"}, "output": {"friday_13_count": 1, "processed_polymer": "HnAfBVGhJsDIgWskhdbWDljeiZYjQkCNjOT"}}, {"input": {"year": 1964, "polymer_string": "DNlnUimjKcidYORAVewMVniylfoioOmCWW"}, "output": {"friday_13_count": 2, "processed_polymer": "DNlnUimjKcidYORAVewMVniylfoimCWW"}}, {"input": {"year": 2079, "polymer_string": "RlDUupiNkxaWOGIWmonyZpJsgXfJzVfGoLxSBAH"}, "output": {"friday_13_count": 2, "processed_polymer": "RlDpiNkxaWOGIWmonyZpJsgXfJzVfGoLxSBAH"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ChrisClaude/data-structure-algorithms", "path": "/challenges/devskill.py", "msgidx": 2434}}
{"problem_description": "In a tic-tac-toe tournament, Player 1 makes moves based on a predefined probability matrix, while Player 2 makes random moves. How many games will Player 1 win, Player 2 win, and how many games will end in a draw after a specified number of games?", "io_requirements": "Input:\n  `numberOfGames` (int): The number of games to simulate in the tournament.\n  `probabilityMatrix` (list of lists): A 3x3 matrix representing the probability values for each cell position in the tic-tac-toe board. Each element in the matrix is a float between 0 and 1.\n\nOutput:\n  `return` (dict): A dictionary containing the number of wins for Player 1, Player 2, and draws. The keys are:\n    - `\"winsPlayer1\"` (int): Number of wins by Player 1.\n    - `\"winsPlayer2\"` (int): Number of wins by Player 2.\n    - `\"draws\"` (int): Number of draws.", "refcode": "# import necessary packages\nimport numpy as np\nimport pandas as pd\n\n# all class and function definitions in the code file, if any\ndef move_still_possible(S):\n    return not (S[S==0].size == 0)\n\ndef move_at_random(S, p):\n    xs, ys = np.where(S==0)\n    i = np.random.permutation(np.arange(xs.size))[0]\n    S[xs[i],ys[i]] = p\n    return S\n\ndef move_was_winning_move(S, p):\n    if np.max((np.sum(S, axis=0)) * p) == 3:\n        return True\n    if np.max((np.sum(S, axis=1)) * p) == 3:\n        return True\n    if (np.sum(np.diag(S)) * p) == 3:\n        return True\n    if (np.sum(np.diag(np.rot90(S))) * p) == 3:\n        return True\n    return False\n\ndef move_with_probability(S, p, pm):\n    xs, ys = np.where(S==0)\n    max_val = 0\n    index = 0\n    for i in range(len(xs)):\n        if pm[xs[i],ys[i]] > max_val:\n            max_val = pm[xs[i],ys[i]]\n            index = i\n    S[xs[index],ys[index]] = p\n    return S\n\ndef readFromGameStatsFile():\n    df = pd.read_excel('Game Stats.xlsx')\n    probabilityMatrix = np.reshape(np.array(df.loc['Probability','(0,0)':'(2,2)'].tolist()),(-1,3))\n    return probabilityMatrix\n\n# main function\ndef main_solution(numberOfGames, probabilityMatrix):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    probabilityMatrix = np.array(probabilityMatrix)\n    \n    # counters for wins of player 1, player 2 and draws\n    winsPlayer1 = 0\n    winsPlayer2 = 0\n    draws = 0\n    \n    for _ in range(numberOfGames):\n        # initialize 3x3 tic tac toe board\n        gameState = np.zeros((3,3), dtype=int)\n        \n        # initialize player number, move counter\n        player = 1\n        mvcntr = 1\n        \n        # initialize flag that indicates win\n        noWinnerYet = True\n        \n        while move_still_possible(gameState) and noWinnerYet:\n            # let player 1 move with probability and player 2 move at random\n            if player == 1:\n                gameState = move_with_probability(gameState, player, probabilityMatrix)\n            else:\n                gameState = move_at_random(gameState, player)\n                \n            # evaluate game state\n            if move_was_winning_move(gameState, player):\n                if player == 1:\n                    winsPlayer1 += 1\n                else:\n                    winsPlayer2 += 1\n                noWinnerYet = False\n            \n            # switch player and increase move counter\n            player *= -1\n            mvcntr += 1\n\n        if noWinnerYet:\n            draws += 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"winsPlayer1\": winsPlayer1, \"winsPlayer2\": winsPlayer2, \"draws\": draws}", "funcname": "main_solution", "ios": [{"input": {"numberOfGames": 6681, "probabilityMatrix": [[0.6584673802426368, 0.050839799139309805, 0.9042390704945121], [0.8031105762409191, 0.7587760784260216, 0.4636793306344096], [0.9882351287036635, 0.9732556246309003, 0.5158395332491514]]}, "output": {"winsPlayer1": 4104, "winsPlayer2": 2253, "draws": 324}}, {"input": {"numberOfGames": 7051, "probabilityMatrix": [[0.9644624712109147, 0.6383305963571726, 0.36217108510755014], [0.6458809960329404, 0.9016684415979392, 0.8511155537981956], [0.05901664676950846, 0.015051210888082034, 0.01767079874720434]]}, "output": {"winsPlayer1": 4364, "winsPlayer2": 1734, "draws": 953}}, {"input": {"numberOfGames": 4228, "probabilityMatrix": [[0.08760130817765455, 0.5490764675255615, 0.7273926282338815], [0.7821521143841625, 0.1512386131236756, 0.4433024388693724], [0.08592219456712702, 0.535828177202009, 0.3459491479368868]]}, "output": {"winsPlayer1": 1679, "winsPlayer2": 1679, "draws": 870}}, {"input": {"numberOfGames": 4879, "probabilityMatrix": [[0.7798353802110316, 0.026405302394319596, 0.842372518111853], [0.9286288733450367, 0.9733507195885011, 0.4210457407021002], [0.9764714436869774, 0.36785904244187784, 0.9241820971039929]]}, "output": {"winsPlayer1": 3476, "winsPlayer2": 980, "draws": 423}}, {"input": {"numberOfGames": 5795, "probabilityMatrix": [[0.04863002282730078, 0.5136351595625311, 0.36217146926727095], [0.33424637048941785, 0.45382464322375315, 0.8928427354711232], [0.06854477530465841, 0.31243311951038155, 0.7523508903132861]]}, "output": {"winsPlayer1": 3521, "winsPlayer2": 1741, "draws": 533}}, {"input": {"numberOfGames": 5586, "probabilityMatrix": [[0.04129697104739649, 0.6122843616175776, 0.8785801913116372], [0.6068164132821446, 0.21281011036623754, 0.12162357674766922], [0.23271904060860515, 0.5633881692772129, 0.0632950453511203]]}, "output": {"winsPlayer1": 2482, "winsPlayer2": 2178, "draws": 926}}, {"input": {"numberOfGames": 3724, "probabilityMatrix": [[0.02616254233191062, 0.6273557349630274, 0.7554375295896352], [0.3490217390229611, 0.0014974801294346252, 0.2105199546204659], [0.47130239422716846, 0.2559069982304968, 0.7498929079865645]]}, "output": {"winsPlayer1": 1831, "winsPlayer2": 1227, "draws": 666}}, {"input": {"numberOfGames": 3577, "probabilityMatrix": [[0.5004437217339869, 0.9946558052202626, 0.5461700979124041], [0.018367605945604493, 0.3097531629034954, 0.1415300350892167], [0.625936930767374, 0.22961661081785834, 0.3288039076408511]]}, "output": {"winsPlayer1": 2353, "winsPlayer2": 725, "draws": 499}}, {"input": {"numberOfGames": 4581, "probabilityMatrix": [[0.9478992746769811, 0.9211669605842563, 0.5087936517517763], [0.8931451790023763, 0.5866234090700313, 0.08753772087530498], [0.7518711689654873, 0.23184165049540806, 0.009033293349253513]]}, "output": {"winsPlayer1": 3138, "winsPlayer2": 1227, "draws": 216}}, {"input": {"numberOfGames": 8827, "probabilityMatrix": [[0.08176219572845067, 0.0635127729022048, 0.6387427245014965], [0.6047202521853426, 0.8779724537314649, 0.8434624098211281], [0.519291075117023, 0.8524085744189897, 0.22980022119677934]]}, "output": {"winsPlayer1": 5240, "winsPlayer2": 2194, "draws": 1393}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "TDeepanshPandey/Tic_Tac_Toe_Using_AI", "path": "/Assignment 1.2.2.py", "msgidx": 2045}}
{"problem_description": "Given a number, imagine a spiral where each cell is filled with a value based on the sum of its adjacent cells. Starting from the center, the spiral expands outward. What is the first value in the spiral that is greater than the given number?", "io_requirements": "Input:\n  `number` (int): The target number to find in the spiral. It should be a positive integer.\n\nOutput:\n  `return` (int): The value of the spiral cell that is greater than the input `number`.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef spiralSplicer(inp):\n    step_count = 1\n    step_limit = 2\n    adder = 1\n    x, y = 0, 0\n\n    for n in range(2, inp + 1):\n        if (step_count <= .5 * step_limit):\n            x += adder\n        elif (step_count <= step_limit):\n            y += adder\n\n        if (step_count == step_limit):\n            adder *= -1\n            step_limit += 2\n            step_count = 0\n        step_count += 1\n    return abs(x) + abs(y)\n\ndef get_next(spiral, coord):\n    x, y = coord\n    next_move = ()\n    if spiral[(x+1, y)] == 0 and spiral[(x, y + 1)] != 0:\n        next_move =  (x+1, y)\n    elif spiral[(x-1, y)] != 0 and spiral[(x, y+1)] == 0:\n        next_move = (x, y+1)\n    elif spiral[(x+1, y)] != 0 and spiral[(x, y-1)] == 0:\n        next_move = (x, y - 1)\n    else:\n        next_move = (x-1, y)\n    return next_move\n\ndef get_number(spiral, coord):\n    x, y = coord\n    number = 0\n    number += spiral[(x+1, y)]\n    number += spiral[(x+1, y+1)]\n    number += spiral[(x, y+1)]\n    number += spiral[(x-1, y+1)]\n    number += spiral[(x-1, y)]\n    number += spiral[(x-1, y-1)]\n    number += spiral[(x, y-1)]\n    number += spiral[(x+1, y-1)]\n    return number\n\n# main function\ndef main_solution(number):\n    currentNumber = 1\n    coord = (0, 0)\n    spiral = defaultdict(int)\n    spiral[coord] = currentNumber\n    coord = (1, 0)\n    spiral[coord] = currentNumber\n    while currentNumber < number:\n        currentNumber += 1\n        coord = get_next(spiral, coord)\n        currentNumber = get_number(spiral, coord)\n        spiral[coord] = currentNumber\n    currentNumber = get_number(spiral, coord)\n    return currentNumber", "funcname": "main_solution", "ios": [{"input": {"number": 59460}, "output": 98098}, {"input": {"number": 526687}, "output": 752688}, {"input": {"number": 864786}, "output": 875851}, {"input": {"number": 739064}, "output": 752688}, {"input": {"number": 670448}, "output": 752688}, {"input": {"number": 229295}, "output": 266330}, {"input": {"number": 733943}, "output": 752688}, {"input": {"number": 717918}, "output": 752688}, {"input": {"number": 535611}, "output": 752688}, {"input": {"number": 463833}, "output": 752688}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rbark/aoc2017", "path": "/dag3/day3.py", "msgidx": 2651}}
{"problem_description": "Given a list of words, how can we group them into anagram sets such that the larger anagram groups come before the smaller ones, and within each group, the words are sorted in a case-insensitive ascending order? Additionally, if two anagram groups have the same count, the group with the smaller starting word should come first.", "io_requirements": "Input:\n  `words` (str): A comma-separated string of words. Each word is a string of characters.\n\nOutput:\n  `return` (str): A string where each anagram group is separated by a newline character, and each word within an anagram group is also separated by a newline character.", "refcode": "# import necessary packages\nimport collections\nimport string\n\n# all class and function definitions in the code file, if any\ndef are_anagrams(first, second):\n    if first == None or second == None:\n        return False\n    if first == [] or second == []:\n        return []\n    if first == \"\" or second == \"\":\n        return False\n    if type(first) != str or type(second) != str:\n        return -1\n    first = ''.join(e for e in first if e.isalnum())\n    second = ''.join(e for e in second if e.isalnum())\n    first = first.lower()\n    second = second.lower()\n    letters = collections.Counter(first)\n    letters1 = collections.Counter(second)\n    if letters == letters1:\n        return 1\n    else:\n        return 0\n\n# main function\ndef main_solution(words):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    list_of_words = words.split(',')\n    result = []\n    processed = []\n    tuple = ()\n\n    for word in list_of_words:\n        if word in processed:\n            continue\n        else:\n            processed.append(word)\n            tuple += (word,)\n            for word1 in list_of_words:\n                if word1 in processed:\n                    continue\n                if are_anagrams(word, word1) == 1:\n                    tuple += (word1,)\n                    processed.append(word1)\n\n            l = sorted(tuple, key=lambda x: (not x.islower(), x))\n            result.append(l)\n            tuple = ()\n\n    result.sort(key=lambda x: x[0].lower())\n    result.sort(key=lambda t: len(t), reverse=True)\n\n    # Convert the result to a JSON serializable format\n    output = '\\n'.join(['\\n'.join(group) for group in result])\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return output", "funcname": "main_solution", "ios": [{"input": {"words": "jEGDa,tfOw,NIGv,sPI,XZJ,ItQrUD,kvsuC,jJcjQR,krd"}, "output": "ItQrUD\njEGDa\njJcjQR\nkrd\nkvsuC\nNIGv\nsPI\ntfOw\nXZJ"}, {"input": {"words": "bPmu,UxSEiH,CIn,iIiis,nCPhy,qGgtr,FWI,rQeP,DxdCI"}, "output": "bPmu\nCIn\nDxdCI\nFWI\niIiis\nnCPhy\nqGgtr\nrQeP\nUxSEiH"}, {"input": {"words": "xlXfV,Zyyj,GEb,IrdI,pGdLa"}, "output": "GEb\nIrdI\npGdLa\nxlXfV\nZyyj"}, {"input": {"words": "Pcfb,PgMg,HIhUd,guac,zmItT,kOnpz,WkA,eFUT"}, "output": "eFUT\nguac\nHIhUd\nkOnpz\nPcfb\nPgMg\nWkA\nzmItT"}, {"input": {"words": "bxb,UeBt,auQUjc,HZVXsE,kMaxA,Tcjff,AUn"}, "output": "AUn\nauQUjc\nbxb\nHZVXsE\nkMaxA\nTcjff\nUeBt"}, {"input": {"words": "VzMYN,RQiLFg,VeHfYN,cDWI,Gng,GIQB"}, "output": "cDWI\nGIQB\nGng\nRQiLFg\nVeHfYN\nVzMYN"}, {"input": {"words": "zepl,iZk,QcptwU,ivfv,XxuCXR,NjrDL,tIPK,UsQOGN"}, "output": "ivfv\niZk\nNjrDL\nQcptwU\ntIPK\nUsQOGN\nXxuCXR\nzepl"}, {"input": {"words": "GLZ,iOYzZE,ITu,tqMHEQ,steOmG,JDWE,sHaFG,vwQU"}, "output": "GLZ\niOYzZE\nITu\nJDWE\nsHaFG\nsteOmG\ntqMHEQ\nvwQU"}, {"input": {"words": "ows,AycTI,lyWQB,OyCT,vrYqyJ,SNK,oMqz,gfCzO,nja"}, "output": "AycTI\ngfCzO\nlyWQB\nnja\noMqz\nows\nOyCT\nSNK\nvrYqyJ"}, {"input": {"words": "pPvJV,DOkO,FmUfua,KNj,NIU,QRswX,kTZ,UmY,BrzkBI"}, "output": "BrzkBI\nDOkO\nFmUfua\nKNj\nkTZ\nNIU\npPvJV\nQRswX\nUmY"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "meena98/pythoncode", "path": "/unit6_assignment_03.py", "msgidx": 2495}}
{"problem_description": "Imagine you are participating in a game where you simulate random walks up a building. Each walk consists of a series of random steps, and you have a chance to fall back to the first floor due to clumsiness. Given the number of simulations, the number of steps in each walk, the floor number that is considered a win, and the probability of falling due to clumsiness, what is the probability of reaching or exceeding the win floor in the random walk simulations?", "io_requirements": "Input:\n  `num_simulations` (int): The number of random walk simulations to perform.\n  `num_steps` (int): The number of steps in each random walk.\n  `win_floor` (int): The floor number that is considered a win.\n  `clumsiness_chance` (float): The probability of falling down to the first floor when taking any step.\n\nOutput:\n  `return` (dict): A dictionary containing the key `probability_of_winning` with a float value representing the probability of reaching or exceeding the `win_floor` in the random walk simulations.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(num_simulations, num_steps, win_floor, clumsiness_chance):\n    # Convert JSON serializable inputs to appropriate types\n    num_simulations = int(num_simulations)\n    num_steps = int(num_steps)\n    win_floor = int(win_floor)\n    clumsiness_chance = float(clumsiness_chance)\n\n    all_walks = []\n\n    for i in range(num_simulations):\n        rand_walk = [0]\n        for x in range(num_steps):\n            step = rand_walk[-1]\n            die_roll = np.random.randint(1, 7)\n            if die_roll <= 2:\n                step = max(0, step - 1)\n            elif die_roll <= 5:\n                step = step + 1\n            else:\n                step = step + np.random.randint(1, 7)\n            if np.random.rand() <= clumsiness_chance:\n                step = 0\n            rand_walk.append(step)\n        all_walks.append(rand_walk)\n\n    np_all_walks = np.array(all_walks)\n    np_all_walks_t = np.transpose(np_all_walks)\n    ends = np_all_walks_t[-1, :]\n\n    # Calculate the probability of winning\n    prob_win = len(ends[ends >= win_floor]) / float(len(ends))\n\n    # Convert the output to JSON serializable\n    return {\"probability_of_winning\": prob_win}", "funcname": "main_solution", "ios": [{"input": {"num_simulations": 999, "num_steps": 78, "win_floor": 52, "clumsiness_chance": 0.003246241460447923}, "output": {"probability_of_winning": 0.5775775775775776}}, {"input": {"num_simulations": 401, "num_steps": 76, "win_floor": 79, "clumsiness_chance": 0.00262878381992247}, "output": {"probability_of_winning": 0.06982543640897755}}, {"input": {"num_simulations": 578, "num_steps": 130, "win_floor": 65, "clumsiness_chance": 0.002599565888904986}, "output": {"probability_of_winning": 0.8079584775086506}}, {"input": {"num_simulations": 648, "num_steps": 115, "win_floor": 77, "clumsiness_chance": 0.0059357128228465115}, "output": {"probability_of_winning": 0.41203703703703703}}, {"input": {"num_simulations": 810, "num_steps": 74, "win_floor": 56, "clumsiness_chance": 0.006697195306094453}, "output": {"probability_of_winning": 0.34814814814814815}}, {"input": {"num_simulations": 672, "num_steps": 168, "win_floor": 64, "clumsiness_chance": 0.004604028205644021}, "output": {"probability_of_winning": 0.6473214285714286}}, {"input": {"num_simulations": 673, "num_steps": 71, "win_floor": 79, "clumsiness_chance": 0.009060564798078312}, "output": {"probability_of_winning": 0.020802377414561663}}, {"input": {"num_simulations": 725, "num_steps": 116, "win_floor": 75, "clumsiness_chance": 0.004094741142284331}, "output": {"probability_of_winning": 0.496551724137931}}, {"input": {"num_simulations": 940, "num_steps": 94, "win_floor": 97, "clumsiness_chance": 0.002673153533180822}, "output": {"probability_of_winning": 0.04893617021276596}}, {"input": {"num_simulations": 354, "num_steps": 60, "win_floor": 82, "clumsiness_chance": 0.003180879903799797}, "output": {"probability_of_winning": 0.002824858757062147}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pjmslc/Python-Codes", "path": "/random_walk.py", "msgidx": 2438}}
{"problem_description": "Given a chessboard of size NxN, where N is a positive integer, and a mode that specifies whether to place N rooks or N queens on the board, determine how many distinct configurations exist such that no two pieces can attack each other. Additionally, a specific cell on the board may be blocked, preventing any piece from being placed there. What is the total number of valid configurations for the given board size, mode, and blocked cell (if specified)?", "io_requirements": "Input:\n- `mode` (str): The mode of the problem, either \"nrooks\" or \"nqueens\".\n- `N` (int): The dimension of the board, i.e., the size of the NxN chessboard.\n- `x` (int, optional): The 1-based x-coordinate of the blocked cell. Defaults to `None` if no blocked cell is specified.\n- `y` (int, optional): The 1-based y-coordinate of the blocked cell. Defaults to `None` if no blocked cell is specified.\n\nOutput:\n- `return` (int): The number of solutions found for the given problem configuration.", "refcode": "# import necessary packages\nimport sys\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# Utility functions\ndef printSolutions(allSolutions, mode):\n    pass  # Removed for brevity as it's not needed in the main_solution function\n\n# Validity functions\ndef isValidRook(board, row, col):\n    for i in range(0, row):  # Found a Rook in the same col.\n        if board[i][col] == 1:\n            return False\n    return True\n\ndef isValidQueen(board, row, col, N):\n    for i in range(0, row):  # Checking the same column\n        if board[i][col] == 1:\n            return False\n\n    for (i, j) in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):  # First Diagonal\n        if board[i][j] == 1:\n            return False\n\n    for (i, j) in zip(range(row - 1, -1, -1), range(col + 1, N)):  # Second Diagonal\n        if board[i][j] == 1:\n            return False\n\n    return True\n\n# Backtracking functions\ndef solveNRooks(board, row, N, numSolutions, allSolutions):\n    if row == N:\n        allSolutions.append(deepcopy(board))\n        numSolutions += 1\n        return\n    for col in range(0, N):\n        if isValidRook(board, row, col):\n            if board[row][col]:\n                continue\n            board[row][col] = 1\n            solveNRooks(board, row + 1, N, numSolutions, allSolutions)\n            board[row][col] = 0\n\ndef solveNQueens(board, row, N, numSolutions, allSolutions):\n    if row == N:\n        allSolutions.append(deepcopy(board))\n        numSolutions += 1\n        return\n    for col in range(0, N):\n        if isValidQueen(board, row, col, N):\n            if board[row][col]:\n                continue\n            board[row][col] = 1\n            solveNQueens(board, row + 1, N, numSolutions, allSolutions)\n            board[row][col] = 0\n\n# main function\ndef main_solution(mode, N, x=None, y=None):\n    # Convert inputs to appropriate types\n    N = int(N)\n    x = int(x) - 1 if x is not None else -1\n    y = int(y) - 1 if y is not None else -1\n\n    # Initialize the board and the solutions container\n    board = [[0 for _ in range(N)] for _ in range(N)]\n    allSolutions = []\n\n    # For placing the blank piece\n    if 0 <= x < N and 0 <= y < N:\n        board[x][y] = -1\n\n    # Control for mode\n    if mode == \"nrooks\":\n        solveNRooks(board, 0, N, 0, allSolutions)\n    elif mode == \"nqueens\":\n        solveNQueens(board, 0, N, 0, allSolutions)\n    else:\n        raise ValueError(\"Incorrect mode entered. Please check your arguments again.\")\n\n    # Return the number of solutions found\n    return len(allSolutions)", "funcname": "main_solution", "ios": [{"input": {"mode": "nrooks", "N": 4, "x": null, "y": null}, "output": 24}, {"input": {"mode": "nrooks", "N": 7, "x": 4, "y": null}, "output": 5040}, {"input": {"mode": "nqueens", "N": 5, "x": null, "y": null}, "output": 10}, {"input": {"mode": "nqueens", "N": 4, "x": 2, "y": null}, "output": 2}, {"input": {"mode": "nrooks", "N": 6, "x": null, "y": 4}, "output": 720}, {"input": {"mode": "nrooks", "N": 5, "x": 1, "y": null}, "output": 120}, {"input": {"mode": "nqueens", "N": 6, "x": 3, "y": 1}, "output": 3}, {"input": {"mode": "nqueens", "N": 6, "x": null, "y": 2}, "output": 4}, {"input": {"mode": "nqueens", "N": 8, "x": 2, "y": 5}, "output": 84}, {"input": {"mode": "nrooks", "N": 7, "x": null, "y": null}, "output": 5040}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DhavalNiphade/N-Queens", "path": "/a0.py", "msgidx": 2173}}
{"problem_description": "Given a circle of `n` people numbered from 0 to `n-1`, starting from person 0, every `m`-th person is removed from the circle. What is the index of the last person remaining in the circle?", "io_requirements": "Input:\n  `n` (int): The number of people in the circle.\n  `m` (int): The step count to determine which person to remove next.\n\nOutput:\n  `return` (int): The index of the last remaining person in the circle.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def lastRemaining(self, n: int, m: int) -> int:\n        return (self.lastRemaining(n - 1, m) + m) % n if n else 0\n\n# main function\ndef main_solution(n: int, m: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.lastRemaining(n, m)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 22, "m": 1}, "output": 21}, {"input": {"n": 4, "m": 10}, "output": 3}, {"input": {"n": 28, "m": 7}, "output": 8}, {"input": {"n": 5, "m": 7}, "output": 3}, {"input": {"n": 78, "m": 5}, "output": 27}, {"input": {"n": 64, "m": 1}, "output": 63}, {"input": {"n": 37, "m": 10}, "output": 32}, {"input": {"n": 65, "m": 1}, "output": 64}, {"input": {"n": 47, "m": 8}, "output": 16}, {"input": {"n": 1, "m": 8}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "guzhi-zxy/leetCodeLearning", "path": "/example/lastRemaining.py", "msgidx": 2601}}
{"problem_description": "A professor has encoded a simple mathematical expression using runes, where some digits are represented by '?'. The expression is of the form `[number][op][number]=[number]`, where `op` is one of `+`, `-`, or `*`. The numbers can range from -1000000 to 1000000 and consist of digits 0-9, possibly a leading `-`, and maybe a few `?`s. Each '?' represents the same digit (0-9) that is not already present in the expression. What is the digit that replaces '?' to make the expression valid, or is it impossible to determine such a digit?", "io_requirements": "Input:\n  `expression` (str): A string representing a mathematical expression with '?' as the unknown digit. The expression is of the form `[number][op][number]=[number]`, where `op` is one of `+`, `-`, or `*`. The numbers can range from -1000000 to 1000000 and consist of digits 0-9, possibly a leading `-`, and maybe a few `?`s.\n\nOutput:\n  `return` (int): The digit that replaces '?' to make the expression valid, or -1 if no such digit exists.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(expression: str) -> int:\n    \"\"\"\n    Solves the given mathematical expression with a missing digit represented by '?'.\n    Returns the digit that replaces '?' to make the expression valid, or -1 if no such digit exists.\n    \n    Parameters:\n    expression (str): A string representing a mathematical expression with '?' as the unknown digit.\n    \n    Returns:\n    int: The digit that replaces '?' to make the expression valid, or -1 if no such digit exists.\n    \"\"\"\n    for d in sorted(set(\"0123456789\") - set(expression)):\n        toTest = expression.replace(\"?\", d)\n        if re.search(r'([^\\d]|\\b)0\\d+', toTest):\n            continue\n        l, r = toTest.split(\"=\")\n        try:\n            if eval(l) == eval(r):\n                return int(d)\n        except:\n            continue\n    return -1", "funcname": "main_solution", "ios": [{"input": {"expression": "-7?4683+-647?13=-?401996"}, "output": -1}, {"input": {"expression": "93911?*8?165=79?40193150"}, "output": -1}, {"input": {"expression": "-4?5122*-4321?=17507347?30"}, "output": -1}, {"input": {"expression": "2?5701+-?01799=-?06098"}, "output": -1}, {"input": {"expression": "-59?412*-6?5042=3999?2981304"}, "output": -1}, {"input": {"expression": "-?26067*3860?3=-28029308288?"}, "output": -1}, {"input": {"expression": "-?15467*?17269=-13?40699623"}, "output": -1}, {"input": {"expression": "-6?4195*-5?9143=340?71274885"}, "output": -1}, {"input": {"expression": "85724?*7?0414=64328564?774"}, "output": -1}, {"input": {"expression": "-?38998+5?0939=-3?8059"}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "VIVERA83/Codewars", "path": "/4/Find the unknown digit 4.py", "msgidx": 2555}}
{"problem_description": "Given four distinct integers, what is the maximum length of consecutive positive integers that can be formed using any combination of arithmetic operations (addition, subtraction, multiplication, division) on these numbers? The integers should be between 1 and 9.", "io_requirements": "Input:\n  `a` (int): The first integer in the set of four numbers.\n  `b` (int): The second integer in the set of four numbers.\n  `c` (int): The third integer in the set of four numbers.\n  `d` (int): The fourth integer in the set of four numbers.\n\nOutput:\n  `return` (int): The maximum length of consecutive positive integers that can be formed using the set of four numbers.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef two_combination(a, b):\n    if a != 0:\n        if b != 0:\n            return {a + b, a - b, a * b, a / b, b - a, b / a}\n    return {a + b, a - b, a * b, b - a}\n\ndef three_combination(a, b, c):\n    two_combinations = (\n        two_combination(*pair)\n        for pair in itertools.combinations((a, b, c), 2)\n    )\n    three = set()\n    for combination, single in zip(\n            two_combinations, (c, b, a)\n    ):\n        for n in combination:\n            three.update(two_combination(n, single))\n    return three\n\ndef four_combination(a, b, c, d):\n    four = set()\n    two_combinations = tuple(\n        two_combination(*pair)\n        for pair in itertools.combinations((a, b, c, d), 2)\n    )\n    for i in range(len(two_combinations) // 2):\n        for comb1 in two_combinations[i]:\n            for comb2 in two_combinations[-1 - i]:\n                four.update(two_combination(comb1, comb2))\n    three_combinations = (\n        three_combination(*trio)\n        for trio in itertools.combinations((a, b, c, d), 3)\n    )\n    for combination, single in zip(\n            three_combinations, (d, c, b, a)\n    ):\n        for n in combination:\n            four.update(two_combination(n, single))\n    return four\n\ndef clean(s):\n    return set(round(i) for i in s if i >= 0 and abs(i - round(i)) < 1e-3)\n\ndef result(a, b, c, d):\n    return clean(four_combination(a, b, c, d))\n\ndef length(res):\n    i = 1\n    while i in res:\n        i += 1\n    return i - 1\n\n# main function\ndef main_solution(a, b, c, d):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    res = result(a, b, c, d)\n    max_length = length(res)\n    return max_length", "funcname": "main_solution", "ios": [{"input": {"a": 9, "b": 3, "c": 4, "d": 9}, "output": 4}, {"input": {"a": 6, "b": 8, "c": 9, "d": 8}, "output": 7}, {"input": {"a": 9, "b": 8, "c": 1, "d": 1}, "output": 3}, {"input": {"a": 2, "b": 4, "c": 6, "d": 9}, "output": 18}, {"input": {"a": 8, "b": 6, "c": 8, "d": 5}, "output": 2}, {"input": {"a": 4, "b": 3, "c": 7, "d": 2}, "output": 35}, {"input": {"a": 5, "b": 1, "c": 1, "d": 1}, "output": 12}, {"input": {"a": 5, "b": 5, "c": 9, "d": 9}, "output": 2}, {"input": {"a": 7, "b": 1, "c": 6, "d": 4}, "output": 19}, {"input": {"a": 4, "b": 5, "c": 1, "d": 7}, "output": 10}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sanyassh/project_euler", "path": "/python/problem93.py", "msgidx": 2394}}
{"problem_description": "Given a directed graph with a set of vertices and edges, each edge having a cost associated with it, what is the minimum cost of a Hamiltonian cycle that visits each vertex exactly once and returns to the starting vertex? Additionally, what is the order of vertices in this optimal cycle?", "io_requirements": "Input:\n  `vertices` (list of integers): A list of vertex identifiers.\n  `edges` (list of tuples): A list of tuples where each tuple represents an edge in the format (source vertex, destination vertex, cost).\n\nOutput:\n  `return` (dictionary): A dictionary containing:\n    - `minimumCost` (integer): The minimum cost of the Hamiltonian cycle.\n    - `cycle` (list of integers): The vertices in the Hamiltonian cycle in order.", "refcode": "# import necessary packages\nimport itertools\nfrom math import inf\n\n# all class and function definitions in the code file, if any\nclass DiGraph:\n    def __init__(self, vertices, outEdges, inEdges, visited):\n        self.vertices = vertices\n        self.outEdges = outEdges\n        self.inEdges = inEdges\n        self.visited = visited\n\n    def getVertices(self):\n        return len(self.vertices)\n\n    def addVertex(self, v):\n        try:\n            v = int(v)\n        except ValueError:\n            return \"> Invalid input.\"\n\n        if v in self.vertices.keys():\n            return \"> Vertex already exists.\"\n\n        self.vertices[v] = []\n        return \"> Vertex was successfully added.\"\n\n    def removeVertex(self, v):\n        try:\n            v = int(v)\n        except ValueError:\n            return \"> Invalid input.\"\n\n        if v not in self.vertices.keys():\n            return \"> Vertex does not exist.\"\n\n        if v in self.outEdges:\n            for node in self.outEdges[v]:\n                self.inEdges[node].remove(v)\n\n        if v in self.inEdges:\n            for node in self.inEdges[v]:\n                self.outEdges[node].remove(v)\n            for node in self.inEdges[v]:\n                for t in self.vertices[node]:\n                    if t[0] == v:\n                        self.vertices[node].remove(t)\n\n        if v in self.inEdges:\n            self.inEdges.pop(v)\n        if v in self.outEdges:\n            self.outEdges.pop(v)\n        if v in self.vertices:\n            self.vertices.pop(v)\n\n        return \"> Vertex was successfully removed.\"\n\n    def isEdge(self, x, y):\n        try:\n            x = int(x)\n            y = int(y)\n        except ValueError:\n            return 2\n\n        if x in self.outEdges:\n            if y in self.outEdges[x]:\n                return 1\n\n        return 0\n\n    def addEdge(self, x, y, c):\n        try:\n            x = int(x)\n            y = int(y)\n            c = int(c)\n        except ValueError:\n            return \"> Invalid input.\"\n\n        if x not in self.vertices.keys():\n            return \"> Vertex \" + str(x) + \"does not exist.\"\n\n        if y not in self.vertices.keys():\n            return \"> Vertex \" + str(y) + \"does not exist.\"\n\n        if self.isEdge(x, y):\n            return \"> Edge already exists, cannot overwrite.\"\n\n        self.vertices[x].append((y, c))\n\n        if y in self.inEdges.keys():\n            self.inEdges[y].append(x)\n        else:\n            self.inEdges[y] = [x]\n\n        if x in self.outEdges.keys():\n            self.outEdges[x].append(y)\n        else:\n            self.outEdges[x] = [y]\n\n        return \"> Edge was successfully added.\"\n\n    def removeEdge(self, x, y):\n        x = int(x)\n        y = int(y)\n\n        self.outEdges[x].remove(y)\n        self.inEdges[y].remove(x)\n\n        for t in self.vertices[x]:\n            if t[0] == y:\n                self.vertices[x].remove(t)\n                break\n\n        return \"> Edge was successfully removed.\"\n\n    def get_cost(self, x, y):\n        for t in self.vertices[x]:\n            if t[0] == y:\n                return t[1]\n\n    def HamiltonianCycle(self):\n        l = [x for x in self.vertices.keys()]\n        p = list(itertools.permutations(l))\n\n        x = p[0][0]\n\n        minimumCost = inf\n        sol = []\n\n        for i in p:\n            if i[0] != x:\n                break\n\n            auxCost = 0\n            ok = 1\n\n            for j in range(1, len(i)):\n                n = i[j-1]\n                m = i[j]\n\n                if self.isEdge(n, m) == 0:\n                    ok = 0\n                    break\n\n                auxCost += self.get_cost(n, m)\n\n            if ok == 0:\n                continue\n\n            if self.isEdge(i[0], i[len(i)-1]) == 0:\n                ok = 0\n            else:\n                auxCost += self.get_cost(i[0], i[len(i)-1])\n\n            if ok == 1:\n                if auxCost < minimumCost:\n                    minimumCost = auxCost\n                    sol = i\n\n        return minimumCost, sol\n\n# main function\ndef main_solution(vertices, edges):\n    # Convert JSON serializable inputs to the original input variables\n    vertices_dict = {v: [] for v in vertices}\n    outEdges = {v: [] for v in vertices}\n    inEdges = {v: [] for v in vertices}\n    visited = set()\n\n    for edge in edges:\n        x, y, c = edge\n        vertices_dict[x].append((y, c))\n        outEdges[x].append(y)\n        inEdges[y].append(x)\n\n    graph = DiGraph(vertices_dict, outEdges, inEdges, visited)\n\n    # Call the HamiltonianCycle method\n    minimumCost, sol = graph.HamiltonianCycle()\n\n    # Convert the output to JSON serializable format\n    return {\"minimumCost\": minimumCost, \"cycle\": list(sol)}", "funcname": "main_solution", "ios": [{"input": {"vertices": [0, 1, 2], "edges": [[2, 1, 97], [2, 1, 24], [1, 2, 90]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2], "edges": [[2, 1, 96], [1, 0, 46], [2, 0, 10]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2], "edges": [[0, 2, 7], [0, 2, 14], [1, 0, 60]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2], "edges": [[2, 0, 81], [1, 0, 31], [2, 0, 6]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2], "edges": [[2, 0, 29], [1, 2, 59], [2, 1, 3]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2], "edges": [[2, 0, 29], [2, 0, 44], [0, 2, 27]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2, 3], "edges": [[1, 2, 81], [1, 2, 47], [3, 2, 60], [1, 0, 44]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2, 3], "edges": [[1, 3, 72], [3, 2, 9], [2, 0, 78], [3, 0, 78]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2], "edges": [[1, 2, 46], [1, 2, 70], [1, 0, 13]]}, "output": {"minimumCost": Infinity, "cycle": []}}, {"input": {"vertices": [0, 1, 2], "edges": [[1, 2, 68], [0, 1, 39], [0, 1, 35]]}, "output": {"minimumCost": Infinity, "cycle": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "TripleChoco/ubb", "path": "/sem2/Algoritmica Grafelor/practical work no. 5/digraph/digraph.py", "msgidx": 2227}}
{"problem_description": "Given a sorted list of integers representing the nodes of a binary tree, and two specific nodes identified by their indices in the tree, what is the data of the nearest common parent node of these two nodes?", "io_requirements": "Input:\n  `arr` (list of int): A sorted list of integers representing the nodes of the binary tree.\n  `node1_index` (int): The index of the first node in the binary tree.\n  `node2_index` (int): The index of the second node in the binary tree.\n\nOutput:\n  `return` (int): The data of the nearest common parent node of the two nodes specified by `node1_index` and `node2_index`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass BiTNode:\n    def __init__(self):\n        self.data = None\n        self.lchild = None\n        self.rchild = None\n\nclass IntRef:\n    def __init__(self):\n        self.num = None\n\ndef arraytotree(arr, start, end):\n    root = None\n    if end >= start:\n        root = BiTNode()\n        mid = (start + end + 1) // 2\n        root.data = arr[mid]\n        root.lchild = arraytotree(arr, start, mid - 1)\n        root.rchild = arraytotree(arr, mid + 1, end)\n    else:\n        root = None\n    return root\n\ndef getNo(root, node, number):\n    if root == None:\n        return False\n    if root == node:\n        return True\n    tmp = number.num\n    number.num = 2 * tmp\n    if getNo(root.lchild, node, number):\n        return True\n    else:\n        number.num = tmp * 2 + 1\n        return getNo(root.rchild, node, number)\n\ndef getNodeFromNum(root, number):\n    if root == None or number < 0:\n        return None\n    if number == 1:\n        return root\n    lens = int((math.log(number) / math.log(2)))\n    number -= 1 << lens\n    while lens > 0:\n        if (1 << (lens - 1)) & number == 1:\n            root = root.rchild\n        else:\n            root = root.lchild\n        lens -= 1\n    return root\n\ndef FindParentNode(root, node1, node2):\n    ref1 = IntRef()\n    ref1.num = 1\n    ref2 = IntRef()\n    ref2.num = 1\n    getNo(root, node1, ref1)\n    getNo(root, node2, ref2)\n    num1 = ref1.num\n    num2 = ref2.num\n    while num1 != num2:\n        if num1 > num2:\n            num1 //= 2\n        else:\n            num2 //= 2\n    return getNodeFromNum(root, num1)\n\n# main function\ndef main_solution(arr, node1_index, node2_index):\n    # Convert the array to a binary tree\n    root = arraytotree(arr, 0, len(arr) - 1)\n    \n    # Find the nodes corresponding to the given indices\n    node1 = getNodeFromNum(root, node1_index)\n    node2 = getNodeFromNum(root, node2_index)\n    \n    # Find the common parent node\n    common_parent = FindParentNode(root, node1, node2)\n    \n    # Return the data of the common parent node\n    return common_parent.data", "funcname": "main_solution", "ios": [{"input": {"arr": [4, 9, 11, 13, 14], "node1_index": 6, "node2_index": 1}, "output": 11}, {"input": {"arr": [4, 5, 7, 8, 13, 14, 17, 18, 19], "node1_index": 11, "node2_index": 7}, "output": 13}, {"input": {"arr": [2, 4, 5, 6, 8, 10, 12, 16], "node1_index": 3, "node2_index": 5}, "output": 8}, {"input": {"arr": [1, 2, 9, 12, 14, 15, 16, 18, 19], "node1_index": 2, "node2_index": 11}, "output": 14}, {"input": {"arr": [4, 8, 16, 18, 19], "node1_index": 4, "node2_index": 6}, "output": 4}, {"input": {"arr": [5, 6, 9, 13, 15], "node1_index": 1, "node2_index": 1}, "output": 9}, {"input": {"arr": [1, 3, 5, 6, 8, 11, 12, 14, 15], "node1_index": 6, "node2_index": 6}, "output": 3}, {"input": {"arr": [1, 2, 11, 13, 19], "node1_index": 6, "node2_index": 5}, "output": 11}, {"input": {"arr": [2, 4, 5, 10, 17, 19], "node1_index": 7, "node2_index": 3}, "output": 10}, {"input": {"arr": [2, 3, 7, 9, 11, 12, 13, 14, 15, 17], "node1_index": 14, "node2_index": 9}, "output": 12}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cjjhust/python_datastucture", "path": "/3-8-2.py", "msgidx": 2632}}
{"problem_description": "In a mysterious ancient maze, each cell is marked with a symbol: '.' for an empty space, '/' for a forward slash, and '\\\\' for a backward slash. The maze is surrounded by impenetrable walls. The maze contains distinct regions, which can be either contiguous empty spaces or diamond shapes formed by adjacent '/' and '\\\\' characters. How many distinct regions are there in the given maze?", "io_requirements": "Input:\n  `maze_str` (str): A string representing the maze. Each character in the string represents a cell in the maze. The characters can be '.', '/', or '\\\\'. The maze is represented as a grid of characters separated by newline characters.\n\nOutput:\n  `return` (int): The number of distinct regions in the maze. A region is defined as a contiguous area of empty cells ('.') or a diamond shape formed by '/' and '\\\\' characters.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(maze_str):\n    # Convert the input string to a maze matrix\n    maze, width, height = parse_maze(maze_str)\n    \n    # Fill the border cells\n    fill_border(maze, width, height)\n    \n    # Count the regions\n    region_count = count_regions(maze, width, height)\n    \n    # Return the number of regions\n    return region_count\n\ndef parse_maze(maze_str):\n    lines = maze_str.split('\\n')\n    height = len(lines)\n    width = len(lines[0])\n    maze = [[-1] * (width + 2)]\n    for line in lines:\n        row = [-1] + [encode_maze(c) for c in line] + [-1]\n        maze.append(row)\n    maze.append([-1] * (width + 2))\n    return maze, width + 2, height + 2\n\ndef encode_maze(c):\n    if c == '.':\n        return 0\n    elif c == '/':\n        return 1\n    else:\n        return 2\n\ndef fill_border(maze, width, height):\n    for y in range(height):\n        fill_border_cell(maze, 1, y)\n        fill_border_cell(maze, width - 2, y)\n    for x in range(width):\n        fill_border_cell(maze, x, 1)\n        fill_border_cell(maze, x, height - 2)\n\ndef fill_border_cell(maze, x, y):\n    if maze[y][x] == 0:\n        flood_fill(maze, x, y)\n\ndef flood_fill(maze, x0, y0):\n    q = deque([(x0, y0)])\n    maze[y0][x0] = -1\n    while q:\n        (x, y) = q.popleft()\n        flood_check(maze, x + 1, y, q)\n        flood_check(maze, x - 1, y, q)\n        flood_check(maze, x, y + 1, q)\n        flood_check(maze, x, y - 1, q)\n        y1 = y + 1\n        if maze[y1][x] == 1:\n            flood_check(maze, x - 1, y1, q)\n        elif maze[y1][x] == 2:\n            flood_check(maze, x + 1, y1, q)\n        ym1 = y - 1\n        if maze[ym1][x] == 1:\n            flood_check(maze, x + 1, ym1, q)\n        elif maze[ym1][x] == 2:\n            flood_check(maze, x - 1, ym1, q)\n\ndef flood_check(maze, x, y, q):\n    if maze[y][x] == 0:\n        maze[y][x] = -1\n        q.append((x, y))\n\ndef count_regions(maze, width, height):\n    region_count = 0\n    for y in range(height):\n        for x in range(width):\n            if maze[y][x] == 0:\n                region_count += 1\n                flood_fill(maze, x, y)\n            elif is_a_diamond(maze, x, y):\n                region_count += 1\n    return region_count\n\ndef is_a_diamond(maze, x, y):\n    return maze[y][x] == 1 and maze[y][x + 1] == 2 \\\n        and maze[y + 1][x] == 2 and maze[y + 1][x + 1] == 1", "funcname": "main_solution", "ios": [{"input": {"maze_str": "\\/\\..../\n/\\\\\\..//\n.\\\\.\\./\\\n...\\\\/..\n/\\..//./\n//\\.//\\.\n/..\\\\/\\\\\n\\/.///.\\\n\\////..\\\n..\\/\\./."}, "output": 2}, {"input": {"maze_str": "/./\\/\\/.\n/\\.\\.\\..\n/.\\\\.//\\\n..\\\\/\\./\n.\\/\\.\\//"}, "output": 2}, {"input": {"maze_str": "\\///\\.///\n/\\/.\\.\\\\\\\n/.\\..///\\\n..\\/\\\\.\\\\\n//\\.\\./\\.\n.\\\\///\\./\n\\.../\\\\//\n/\\\\/\\\\/./\n../\\/\\//\\\n\\..//\\\\\\."}, "output": 4}, {"input": {"maze_str": "\\\\/\\/.\\\\\n/..//\\\\.\n\\/\\\\/\\\\\\\n/\\/\\\\\\\\\\\n/./\\/..."}, "output": 2}, {"input": {"maze_str": "\\\\./.\n/././\n/\\\\/.\n\\.\\/.\n\\/.//"}, "output": 0}, {"input": {"maze_str": "..\\\\//..\n\\\\.\\\\/\\/\n/\\//.\\\\/\n\\/.\\\\\\.\\\n/../\\/\\\\\n/......\\\n\\\\\\..\\..\n....\\/./\n\\/.\\.\\\\.\n///\\\\\\//"}, "output": 3}, {"input": {"maze_str": "./..//\n.\\\\/./\n/../\\\\\n.\\/\\..\n/\\..\\\\\n/./.\\/\n/.\\//\\\n\\.\\//.\n//..\\\\\n/\\\\/\\/"}, "output": 3}, {"input": {"maze_str": "\\\\\\\\\\/./\n\\../.\\\\.\n/.\\\\\\//\\\n\\//../\\.\n\\\\//.\\.\\\n\\\\/\\.//\\\n\\\\/./\\./\n\\////\\\\."}, "output": 5}, {"input": {"maze_str": "/\\..///.\\\\\n..\\\\..././\n.\\///\\\\/..\n//\\\\\\..../\n\\.//\\\\//\\\\\n\\\\.//\\..\\/\n\\./..\\/\\\\\\\n.\\///../.\\\n\\\\.\\\\\\.../"}, "output": 2}, {"input": {"maze_str": "\\/\\./\n//\\\\/\n\\./\\/\n//\\/.\n//\\\\\\\n//\\/\\\n...\\/\n/./\\/"}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yuanz4/Codeforces", "path": "/2019-2020 Pacific Northwest (Div. 1)/editorial/M. Maze Connect/accepted/mazeconnect_sjz.py", "msgidx": 2442}}
{"problem_description": "Given a sequence of numbers from 1 to 9, and a set of 8 operators ('+', '-', or '') that can be inserted between these numbers, what are the possible equations that result in the sum of 100?", "io_requirements": "Input:\n  `operators` (list of str): A list of 8 strings where each string is either '+', '-', or ''.\n\nOutput:\n  `return` (list of str): A list of strings where each string is an equation that evaluates to 100.", "refcode": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(operators):\n    \"\"\"\n    This function generates all possible combinations of operators ('+', '-', '') between the numbers 1 to 9,\n    and returns a list of strings that represent the equations which evaluate to 100.\n    \n    Parameters:\n    operators (list of str): A list of 8 strings where each string is either '+', '-', or ''.\n    \n    Returns:\n    list of str: A list of strings where each string is an equation that evaluates to 100.\n    \"\"\"\n    number = range(1, 10)\n    number_tuple = zip(number, operators + [''])\n    combine = ''.join([str(x) + y for x, y in number_tuple])\n    if eval(combine) == 100:\n        return [combine + \"=100\"]\n    return []", "funcname": "main_solution", "ios": [{"input": {"operators": ["+", "-", "-", "-", "+", "", "", "+"]}, "output": []}, {"input": {"operators": ["+", "-", "", "-", "+", "+", "+", ""]}, "output": []}, {"input": {"operators": ["-", "+", "+", "", "", "+", "-", "-"]}, "output": []}, {"input": {"operators": ["", "-", "+", "", "+", "-", "", ""]}, "output": []}, {"input": {"operators": ["-", "", "", "-", "", "+", "+", "-"]}, "output": []}, {"input": {"operators": ["+", "-", "-", "-", "-", "+", "+", "-"]}, "output": []}, {"input": {"operators": ["", "+", "", "-", "+", "-", "+", ""]}, "output": []}, {"input": {"operators": ["", "-", "-", "+", "+", "-", "-", "+"]}, "output": []}, {"input": {"operators": ["-", "", "", "", "+", "-", "", "+"]}, "output": []}, {"input": {"operators": ["-", "-", "+", "", "+", "+", "-", ""]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GriefSeed/Wheels", "path": "/\u7b97\u6cd5/\u975e\u7ecf\u5178\u7b97\u6cd5/100sum.py", "msgidx": 2858}}
{"problem_description": "Given a chessboard of size `n` by `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (int): The total number of distinct solutions to the N-Queens problem for the given board size `n`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        res = [0]\n        pos_list = [-1 for i in range(n)]\n        self.dfs(pos_list, 0, n, res, 0, 0, 0)\n        return res[0]\n\n    def dfs(self, pos_list, index, n, res, vertical, left, right):\n        if index == n:\n            res[0] += 1\n            return\n        for i in range(n):\n            if vertical & ( 1 << i) or left & (1 << (i-index+n-1)) or right & (1 << (i+index)):\n                continue\n            pos_list[index] = i\n            next_vertical = vertical | ( 1<< i)\n            next_left = left | (1<<(i-index+n-1))\n            next_right = right | (1<<(i+index))\n            self.dfs(pos_list, index+1, n, res, next_vertical, next_left, next_right)\n\n# main function\ndef main_solution(n):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.totalNQueens(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 10}, "output": 724}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 5}, "output": 10}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 8}, "output": 92}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "txjzwzz/leetCodeJuly", "path": "/N-Queens_II.py", "msgidx": 2706}}
{"problem_description": "Given a number `n`, what is the sequence of the first `n` elements in the Fibonacci word sequence?", "io_requirements": "Input:\n  `n` (int): The number of elements to generate in the Fibonacci word sequence. Must be a positive integer.\n\nOutput:\n  `return` (str): A string representing the first `n` elements of the Fibonacci word sequence, separated by commas. If `n` is less than 2, it returns \"invalid\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generate_word(n, w=None):\n    if w is None:\n        w = ['b', 'a']\n    return 'invalid' if n < 2 else ', '.join(w) if len(w) == n else generate_word(n, w + [w[-2] + w[-1]])\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = generate_word(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 6}, "output": "b, a, ba, aba, baaba, ababaaba"}, {"input": {"n": 4}, "output": "b, a, ba, aba"}, {"input": {"n": 2}, "output": "b, a"}, {"input": {"n": 7}, "output": "b, a, ba, aba, baaba, ababaaba, baabaababaaba"}, {"input": {"n": 5}, "output": "b, a, ba, aba, baaba"}, {"input": {"n": 8}, "output": "b, a, ba, aba, baaba, ababaaba, baabaababaaba, ababaababaabaababaaba"}, {"input": {"n": 3}, "output": "b, a, ba"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/hvPiBiwE9TfLnsfz4_1.py", "msgidx": 3190}}
{"problem_description": "Given a binary tree with distinct nodes, what is the path between any two specified nodes in the tree? The path should be represented as a sequence of node values starting from the first specified node to the second specified node.", "io_requirements": "Input:\n  `node1` (int): The data value of the first node.\n  `node2` (int): The data value of the second node.\n\nOutput:\n  `return` (str): A JSON serialized string representing the path between `node1` and `node2` in the binary tree. The path is a list of integers.", "refcode": "# import necessary packages\nimport json\n\n# structure of a node of binary tree\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n# Function to find the path from root to a given node\ndef findPath(root, path, k):\n    if root is None:\n        return False\n\n    path.append(root.data)\n\n    if root.data == k:\n        return True\n\n    if ((root.left is not None and findPath(root.left, path, k)) or\n            (root.right is not None and findPath(root.right, path, k))):\n        return True\n\n    path.pop()\n    return False\n\n# Function to print the path between two nodes\ndef printPathBetweenNodes(root, n1, n2):\n    path1 = []\n    path2 = []\n\n    findPath(root, path1, n1)\n    findPath(root, path2, n2)\n\n    i = 0\n    while i < len(path1) and i < len(path2):\n        if path1[i] != path2[i]:\n            break\n        i += 1\n\n    result = path1[:i-1:-1] + path2[i-1:]\n    return result\n\n# main function\ndef main_solution(node1, node2):\n    # Construct the binary tree\n    root = Node(0)\n    root.left = Node(1)\n    root.left.left = Node(3)\n    root.left.left.left = Node(7)\n    root.left.right = Node(4)\n    root.left.right.left = Node(8)\n    root.left.right.right = Node(9)\n    root.right = Node(2)\n    root.right.left = Node(5)\n    root.right.right = Node(6)\n\n    # Find and return the path between the two nodes\n    path = printPathBetweenNodes(root, node1, node2)\n    return json.dumps(path)", "funcname": "main_solution", "ios": [{"input": {"node1": 7, "node2": 8}, "output": "[7, 3, 1, 4, 8]"}, {"input": {"node1": 3, "node2": 8}, "output": "[3, 1, 4, 8]"}, {"input": {"node1": 2, "node2": 3}, "output": "[2, 0, 1, 3]"}, {"input": {"node1": 6, "node2": 0}, "output": "[6, 2, 0]"}, {"input": {"node1": 8, "node2": 4}, "output": "[8, 4]"}, {"input": {"node1": 6, "node2": 9}, "output": "[6, 2, 0, 1, 4, 9]"}, {"input": {"node1": 2, "node2": 4}, "output": "[2, 0, 1, 4]"}, {"input": {"node1": 9, "node2": 4}, "output": "[9, 4]"}, {"input": {"node1": 1, "node2": 9}, "output": "[1, 4, 9]"}, {"input": {"node1": 8, "node2": 5}, "output": "[8, 4, 1, 0, 2, 5]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sshukla31/leetcode", "path": "/print_path_between_2_nodes.py", "msgidx": 2707}}
{"problem_description": "Given the preorder and inorder traversal sequences of a binary tree, how can we reconstruct the original binary tree structure? The preorder and inorder sequences are provided as JSON strings. What is the JSON representation of the reconstructed binary tree?", "io_requirements": "Input:\n  `preorder` (str): A JSON string representing the preorder traversal of the binary tree. Example: `'[1,2,4,7,3,5,6,8]'`\n  `inorder` (str): A JSON string representing the inorder traversal of the binary tree. Example: `'[4,7,2,1,5,3,8,6]'`\n\nOutput:\n  `return` (str): A JSON string representing the reconstructed binary tree in the form of a nested dictionary. Each node is represented as `{\"val\": value, \"left\": left_subtree, \"right\": right_subtree}`, where `left_subtree` and `right_subtree` are either `None` or another nested dictionary representing the respective subtree.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def reConstructBinaryTree(self, pre, tin):\n        if pre == []:\n            return None\n        tmpnode = TreeNode(0)\n        sroot = pre[0]\n        tmpnode.val = sroot\n        left = tin.index(sroot)  # \u521a\u597d\u5c31\u662f\u6839\u8282\u70b9\u5de6\u5b50\u6811\u8282\u70b9\u4e2a\u6570\u3002\n        right = len(tin) - left - 1  # \u6839\u8282\u70b9\u53f3\u8282\u70b9\u4e2a\u6570\n        tmpnode.left = self.reConstructBinaryTree(pre[1:left + 1], tin[0:left])\n        tmpnode.right = self.reConstructBinaryTree(pre[left + 1:], tin[left + 1:])\n        return tmpnode\n\n# main function\ndef main_solution(preorder, inorder):\n    # Convert input lists to JSON serializable format\n    preorder = json.loads(preorder)\n    inorder = json.loads(inorder)\n    \n    # Reconstruct the binary tree\n    solution = Solution()\n    root = solution.reConstructBinaryTree(preorder, inorder)\n    \n    # Convert the tree to a JSON serializable format\n    def tree_to_dict(node):\n        if node is None:\n            return None\n        return {\n            \"val\": node.val,\n            \"left\": tree_to_dict(node.left),\n            \"right\": tree_to_dict(node.right)\n        }\n    \n    result = tree_to_dict(root)\n    \n    # Return the JSON serializable output\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"preorder": "[97]", "inorder": "[97]"}, "output": "{\"val\": 97, \"left\": null, \"right\": null}"}, {"input": {"preorder": "[77, 9]", "inorder": "[77, 9]"}, "output": "{\"val\": 77, \"left\": null, \"right\": {\"val\": 9, \"left\": null, \"right\": null}}"}, {"input": {"preorder": "[48, 96]", "inorder": "[96, 48]"}, "output": "{\"val\": 48, \"left\": {\"val\": 96, \"left\": null, \"right\": null}, \"right\": null}"}, {"input": {"preorder": "[58, 93]", "inorder": "[93, 58]"}, "output": "{\"val\": 58, \"left\": {\"val\": 93, \"left\": null, \"right\": null}, \"right\": null}"}, {"input": {"preorder": "[2, 76]", "inorder": "[2, 76]"}, "output": "{\"val\": 2, \"left\": null, \"right\": {\"val\": 76, \"left\": null, \"right\": null}}"}, {"input": {"preorder": "[21]", "inorder": "[21]"}, "output": "{\"val\": 21, \"left\": null, \"right\": null}"}, {"input": {"preorder": "[32, 1]", "inorder": "[1, 32]"}, "output": "{\"val\": 32, \"left\": {\"val\": 1, \"left\": null, \"right\": null}, \"right\": null}"}, {"input": {"preorder": "[93, 74]", "inorder": "[93, 74]"}, "output": "{\"val\": 93, \"left\": null, \"right\": {\"val\": 74, \"left\": null, \"right\": null}}"}, {"input": {"preorder": "[3, 98]", "inorder": "[98, 3]"}, "output": "{\"val\": 3, \"left\": {\"val\": 98, \"left\": null, \"right\": null}, \"right\": null}"}, {"input": {"preorder": "[12, 87]", "inorder": "[12, 87]"}, "output": "{\"val\": 12, \"left\": null, \"right\": {\"val\": 87, \"left\": null, \"right\": null}}"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "IPostYellow/SwordTarget-OFFER", "path": "/\u91cd\u5efa\u4e8c\u53c9\u6811.py", "msgidx": 2612}}
{"problem_description": "In a game of chess, a knight moves in an L-shape pattern: two squares in one direction and then one square perpendicular, or one square in one direction and then two squares perpendicular. Given the starting and target positions of a knight on a standard 8x8 chessboard, how many moves are required for the knight to reach the target position from the starting position?", "io_requirements": "Input:\n  `src_encoded` (int): The encoded position of the knight's starting point on a chessboard, where the position is encoded as `8 * y + x` (0 \u2264 `src_encoded` \u2264 63).\n  `dest_encoded` (int): The encoded position of the knight's target point on a chessboard, where the position is encoded as `8 * y + x` (0 \u2264 `dest_encoded` \u2264 63).\n\nOutput:\n  `return` (int): The minimum number of moves required for a knight to travel from the starting position (`src_encoded`) to the target position (`dest_encoded`) on a standard 8x8 chessboard. If the target is unreachable, the function returns `None`.", "refcode": "# import necessary packages\nfrom collections import deque, namedtuple\nimport itertools as it\n\n# all class and function definitions in the code file, if any\nclass Position(namedtuple('Position', ['x', 'y'])):\n\n    def encode(self):\n        return 8 * self.y + self.x\n\n    @staticmethod\n    def decode(position):\n        y, x = divmod(position, 8)\n        return Position(x, y)\n\n    def to_tuple(self):\n        return self.x, self.y\n\n    def offset(self, dx, dy):\n        return Position(self.x + dx, self.y + dy)\n\n    def is_valid(self):\n        return 0 <= self.x < 8 and 0 <= self.y < 8\n\n\nTraversal = namedtuple('Traversal', ['distances', 'routes'])\n\n\nclass Knight:\n\n    moves = None  # replaced with build moves\n\n    def __init__(self):\n        self.position = None\n\n    @staticmethod\n    def build_moves():\n        moves = [sign * distance for sign, distance in it.product([+1, -1], [1, 2])]\n        moves = [(dx, dy) for dx, dy in it.product(moves, moves) if abs(dx) != abs(dy)]\n        return moves\n\n    @classmethod\n    def next_positions(cls, position):\n        \"\"\"generates up to eight possible positions\"\"\"\n        for dx, dy in cls.moves:\n            result = position.offset(dx, dy)\n            if result.is_valid():\n                yield result\n\n    def traverse(self):\n        queue, distances, routes, visited = deque(), dict(), dict(), set()\n\n        queue.append(self.position)\n        distances[self.position] = 0\n        routes[self.position] = None\n        visited.add(self.position)\n\n        while len(queue) > 0:\n            position = queue.popleft()\n            distance = distances[position]\n            for neighbor in self.next_positions(position):\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n\n                    current_distance_to_neighbor = distances.get(neighbor)\n                    potential_distance_to_neighbor = distance + 1\n\n                    if current_distance_to_neighbor is None or potential_distance_to_neighbor < current_distance_to_neighbor:\n                        distances[neighbor] = potential_distance_to_neighbor\n                        routes[neighbor] = position\n\n        return Traversal(distances, routes)\n\n    def distance_to(self, target):\n        \"\"\"\n        shortest distance to target\n        :param target: Position\n        :return: Optional[int]\n        \"\"\"\n\n        traversal = self.traverse()\n        return traversal.distances.get(target)\n\n    def path_to(self, target):\n        \"\"\"\n        shortest path to target\n        :param target: Position\n        :return: Optional[List[Position]]\n        \"\"\"\n\n        traversal = self.traverse()\n        if target in traversal.routes:\n            node, path = target, []\n            while node:\n                path.insert(0, node)\n                node = traversal.routes[node]\n            return path\n\n\nKnight.moves = Knight.build_moves()\n\n# main function\ndef main_solution(src_encoded, dest_encoded):\n    src = Position.decode(src_encoded)\n    dest = Position.decode(dest_encoded)\n    knight = Knight()\n    knight.position = src\n    distance = knight.distance_to(dest)\n    return distance", "funcname": "main_solution", "ios": [{"input": {"src_encoded": 54, "dest_encoded": 5}, "output": 3}, {"input": {"src_encoded": 18, "dest_encoded": 45}, "output": 2}, {"input": {"src_encoded": 35, "dest_encoded": 42}, "output": 2}, {"input": {"src_encoded": 31, "dest_encoded": 17}, "output": 3}, {"input": {"src_encoded": 32, "dest_encoded": 41}, "output": 2}, {"input": {"src_encoded": 50, "dest_encoded": 20}, "output": 2}, {"input": {"src_encoded": 26, "dest_encoded": 44}, "output": 4}, {"input": {"src_encoded": 26, "dest_encoded": 59}, "output": 3}, {"input": {"src_encoded": 63, "dest_encoded": 34}, "output": 4}, {"input": {"src_encoded": 59, "dest_encoded": 7}, "output": 5}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rkhullar/google-foobar", "path": "/dont_get_volunteered/solution.py", "msgidx": 2594}}
{"problem_description": "Given a string consisting of letters and spaces, determine if it can be rearranged to form a palindrome. What is the result of this determination?", "io_requirements": "Input:\n  `phrase` (str): A string that may contain letters and spaces. The string should not contain any special characters or numbers.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string is a permutation of a palindrome. Returns `True` if it is, otherwise `False`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef get_char_number(c):\n    if ord(\"a\") <= ord(c) <= ord(\"z\"):\n        return ord(c) - ord(\"a\")\n    elif ord(\"A\") <= ord(c) <= ord(\"Z\"):\n        return ord(c) - ord(\"A\")\n    return -1\n\ndef create_bit_vector(phrase):\n    vector = 0\n    for c in phrase:\n        value = get_char_number(c)\n        vector = toggle(vector, value)\n    return vector\n\ndef toggle(vector, index):\n    if index < 0:\n        return vector\n    mask = 1 << index\n    if (vector & mask) == 0:\n        vector |= mask\n    else:\n        vector &= ~mask\n    return vector\n\ndef is_exactly_one_bit_set(vector):\n    return ((vector - 1) & vector) == 0\n\n# main function\ndef main_solution(phrase):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    bit_vector = create_bit_vector(phrase)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return bit_vector == 0 or is_exactly_one_bit_set(bit_vector)", "funcname": "main_solution", "ios": [{"input": {"phrase": "RJz"}, "output": false}, {"input": {"phrase": "LQMqG"}, "output": false}, {"input": {"phrase": "QOBlzzrt"}, "output": false}, {"input": {"phrase": "grqPWro"}, "output": false}, {"input": {"phrase": "cQSNqwwnW"}, "output": false}, {"input": {"phrase": "HFfDvtpqwT"}, "output": false}, {"input": {"phrase": "exlivNQNo"}, "output": false}, {"input": {"phrase": "BqxAf"}, "output": false}, {"input": {"phrase": "cbtEro"}, "output": false}, {"input": {"phrase": "FLUQDAre"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sudhanshu-jha/python", "path": "/python3/Python-algorithm/ArraysAndStrings/IsPermutationOfPalidrome/IsPermutationOfPalindrome.py", "msgidx": 2797}}
{"problem_description": "Given a range of numbers, how many numbers within that range meet the criteria of having at least one pair of adjacent digits that are the same (like \"112233\") and all digits in the number being in non-decreasing order (like \"123456\")? The range is defined by `start_range` and `end_range`.", "io_requirements": "Input:\n  `start_range` (int): The starting number of the range to check for valid passwords.\n  `end_range` (int): The ending number of the range to check for valid passwords.\n\nOutput:\n  `return` (int): The number of valid passwords within the given range.", "refcode": "# import necessary packages\nimport re\nimport functools\n\n# all class and function definitions in the code file, if any\ndef check_increment(test_string):\n    last_pos = ''\n    for index, char in enumerate(test_string):\n        if index == 0:\n            last_pos = 0\n            continue\n        \n        if int(char) < int(test_string[last_pos]):\n            return False\n        else:\n            last_pos = index\n    \n    return True\n\ndef double_test(test_string):\n    last_pos = 0\n    repeat_count = 0\n    double_exists = False\n    for index, char in enumerate(test_string):\n        if index == 0:\n            repeat_count += 1\n            continue\n        \n        if char == test_string[last_pos]:\n            repeat_count += 1\n        else:\n            # Different character, how many repeats were there?\n            if repeat_count == 2:\n                double_exists = True\n\n            last_pos = index\n            repeat_count = 1\n\n    if repeat_count == 2:\n        double_exists = True\n\n    return double_exists\n\n# main function\ndef main_solution(start_range, end_range):\n    accepted = set()\n    for i in range(start_range, end_range + 1):\n        digits = str(i)\n        if not double_test(digits):\n            continue\n        if not check_increment(digits):\n            continue\n        accepted.add(i)\n\n    return len(list(accepted))", "funcname": "main_solution", "ios": [{"input": {"start_range": 780728, "end_range": 784493}, "output": 0}, {"input": {"start_range": 711475, "end_range": 768185}, "output": 0}, {"input": {"start_range": 460652, "end_range": 619667}, "output": 107}, {"input": {"start_range": 242302, "end_range": 685794}, "output": 737}, {"input": {"start_range": 750215, "end_range": 782215}, "output": 9}, {"input": {"start_range": 703071, "end_range": 763540}, "output": 0}, {"input": {"start_range": 364733, "end_range": 619189}, "output": 272}, {"input": {"start_range": 248317, "end_range": 407676}, "output": 383}, {"input": {"start_range": 255231, "end_range": 728048}, "output": 659}, {"input": {"start_range": 776037, "end_range": 778282}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ryanbillingsley/advent19-py", "path": "/day4/part2.py", "msgidx": 2307}}
{"problem_description": "Babul is fascinated with the number 17 and enjoys finding the largest number that is divisible by 17 by rearranging the digits of a given number N. Given multiple test cases, each containing a number N, what are the largest numbers, if any, that can be formed by rearranging the digits of N and are divisible by 17? If no such number exists for a given N, indicate \"Not Possible\".", "io_requirements": "Input:\n  `T` (int): The number of test cases.\n  `test_cases` (list of int): A list of integers where each integer represents a number N for which we need to find the largest number divisible by 17 by rearranging its digits.\n\nOutput:\n  `return` (list of str): A list of strings where each string is either the largest number divisible by 17 obtained by rearranging the digits of the corresponding number N, or \"Not Possible\" if no such number exists.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(T, test_cases):\n    results = []\n    for n in test_cases:\n        tmp = n\n        nums = []\n        while tmp > 0:\n            num = tmp % 10\n            nums.append(num)\n            tmp = tmp // 10\n        res = []\n\n        ans = permutations(nums)\n        while True:\n            try:\n                an = next(ans)\n                t = 0\n                for i in an:\n                    t = t * 10 + i\n                res.append(t)\n            except Exception:\n                break\n\n        maximum = -1\n        for i in res:\n            if i > maximum and i % 17 == 0:\n                maximum = i\n\n        if maximum == -1:\n            maximum = \"Not Possible\"\n        \n        results.append(maximum)\n    \n    return results", "funcname": "main_solution", "ios": [{"input": {"T": 4, "test_cases": [774896, 553948, 560221, 507436]}, "output": [984776, 985354, 652120, 765340]}, {"input": {"T": 1, "test_cases": [146382]}, "output": [863124]}, {"input": {"T": 3, "test_cases": [287046, 818074, 470021]}, "output": [872406, 884170, 741200]}, {"input": {"T": 4, "test_cases": [94330, 560447, 177598, 395384]}, "output": [39304, 764405, 987751, 894353]}, {"input": {"T": 6, "test_cases": [628148, 658320, 271981, 663505, 97521, 559497]}, "output": [886142, 862053, 981172, 660535, 97512, 994755]}, {"input": {"T": 6, "test_cases": [747664, 916708, 875229, 925821, 649900, 76728]}, "output": [746674, 986170, 972825, 928251, 990046, 77826]}, {"input": {"T": 4, "test_cases": [908562, 237078, 977393, 315116]}, "output": [982056, 877302, 997373, 351611]}, {"input": {"T": 5, "test_cases": [447457, 80379, 644785, 651831, 780474]}, "output": [574447, 98073, 867544, 865113, 877404]}, {"input": {"T": 8, "test_cases": [452981, 176340, 176393, 302493, 842588, 633435, 794403, 880882]}, "output": [984521, 764031, 971363, 934320, 885428, 534633, 974304, "Not Possible"]}, {"input": {"T": 1, "test_cases": [713760]}, "output": [773160]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "know-no/algorithm-homework", "path": "/k3/3.1.py", "msgidx": 2545}}
{"problem_description": "Given a 2D grid of letters and a word, determine if the word can be constructed from letters in the grid by moving from one cell to an adjacent cell (horizontally or vertically), without reusing any cell's letter. What is the result of this search?", "io_requirements": "Input:\n  `board` (List[List[str]]): A 2D list of characters representing the grid. Each character is a single letter (either uppercase or lowercase).\n  `word` (str): A string representing the word to be searched in the grid. The word consists of uppercase or lowercase letters.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the word can be found in the grid following the specified rules.", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(board: List[List[str]], word: str) -> bool:\n    # Convert input to JSON serializable format\n    R, C = len(board), len(board[0])\n\n    def need_walk_pos(i, j, visited):\n        return 0 <= i <= R - 1 and 0 <= j <= C - 1 and (i, j) not in visited\n\n    def dfs(px, py, curr, visited, k):\n        if curr == word:\n            return True\n        for x, y in [(px, py - 1), (px, py + 1), (px - 1, py), (px + 1, py)]:\n            if need_walk_pos(x, y, visited) and board[x][y] == word[k + 1]:\n                visited.append((x, y))\n                if dfs(x, y, curr + board[x][y], visited, k + 1):\n                    return True\n                visited.pop()\n        return False\n\n    for i in range(R):\n        for j in range(C):\n            if board[i][j] == word[0]:\n                if dfs(i, j, word[0], [(i, j)], 0):\n                    return True\n    return False", "funcname": "main_solution", "ios": [{"input": {"board": [["t", "V", "v", "c", "o"]], "word": "sxBr"}, "output": false}, {"input": {"board": [["E"]], "word": "nLgRi"}, "output": false}, {"input": {"board": [["B"], ["R"], ["T"], ["H"]], "word": "x"}, "output": false}, {"input": {"board": [["G"], ["f"], ["i"]], "word": "oluY"}, "output": false}, {"input": {"board": [["U"]], "word": "AaaFR"}, "output": false}, {"input": {"board": [["e"], ["q"], ["o"], ["U"]], "word": "FeZOA"}, "output": false}, {"input": {"board": [["u"]], "word": "DhED"}, "output": false}, {"input": {"board": [["I"]], "word": "w"}, "output": false}, {"input": {"board": [["I"], ["y"], ["q"], ["I"]], "word": "bzTM"}, "output": false}, {"input": {"board": [["r", "s", "n"]], "word": "TaVw"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Wang-Yann/LeetCodeMe", "path": "/python/_0001_0500/0079_word-search.py", "msgidx": 2958}}
{"problem_description": "You are a linguist studying a newly discovered language. You have a list of sorted words in this language, but you don't know the order of the letters. What is the correct order of letters in this language based on the given list of sorted words?", "io_requirements": "Input:\n  `words` (list of strings): A list of sorted words in a language. Each word is a string of characters.\n\nOutput:\n  `return` (list of strings): A list of characters representing the correct order of letters in the language.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef compare(x, y):\n    for i in range(min(len(x), len(y))):\n        if x[i] != y[i]:\n            return x[i], y[i]\n    return None, None\n\n# main function\ndef main_solution(words):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    order = []\n    for i in range(len(words) - 1):\n        x, y = compare(words[i], words[i+1])\n        if x is None:\n            continue\n        if x not in order:\n            if y not in order:\n                order.append(x)\n                order.append(y)\n            else:\n                order.insert(order.index(y), x)\n        else:\n            if y not in order:\n                order.append(y)\n            else:\n                ix, iy = order.index(x), order.index(y)\n                if ix > iy:\n                    order[ix] = y\n                    order[iy] = x\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return order", "funcname": "main_solution", "ios": [{"input": {"words": ["fkpl", "xtum", "yncz"]}, "output": ["f", "x", "y"]}, {"input": {"words": ["hgpn", "mfuj", "sdml", "yrav"]}, "output": ["h", "m", "s", "y"]}, {"input": {"words": ["agxi", "gses", "idbr", "sfoo"]}, "output": ["a", "g", "i", "s"]}, {"input": {"words": ["dwer", "jkqg", "slom", "sttc", "vnol"]}, "output": ["d", "j", "s", "l", "t", "v"]}, {"input": {"words": ["ajz", "dwl", "jqn", "rkg"]}, "output": ["a", "d", "j", "r"]}, {"input": {"words": ["gmpw", "lpsl", "tdou", "ytor"]}, "output": ["g", "l", "t", "y"]}, {"input": {"words": ["jpcb", "jrzg", "qrys", "qtzt", "znzn"]}, "output": ["p", "r", "j", "q", "t", "z"]}, {"input": {"words": ["akw", "cqi", "ecq", "hbr", "ilf"]}, "output": ["a", "c", "e", "h", "i"]}, {"input": {"words": ["eky", "lve", "mvr"]}, "output": ["e", "l", "m"]}, {"input": {"words": ["dpm", "efz", "ojv"]}, "output": ["d", "e", "o"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kemingy/daily-coding-problem", "path": "/src/sort_order.py", "msgidx": 2548}}
{"problem_description": "Given a range of numbers from `minNumber` to `maxNumber`, identify all pairs of numbers (m, n) such that the sum of these numbers is valid and the product of these numbers has unique factors that also satisfy the sum condition. What are the pairs of numbers that meet these criteria?", "io_requirements": "Input:\n- `minNumber` (int): The minimum number in the range for which factors are to be considered.\n- `maxNumber` (int): The maximum number in the range for which factors are to be considered.\n\nOutput:\n- `return` (list of tuples): A list of tuples where each tuple represents a pair of numbers (m, n) that satisfy the conditions of the problem.", "refcode": "# import necessary packages\nimport math\n\n# Constants\nminNumber = 2\nmaxNumber = 100\n\n# Caches\nfactorsCache = {}\nvalidSumCache = {}\n\n# Function to find factors of a number within a specified range\ndef factors(N):\n    if N in factorsCache:\n        return factorsCache[N]\n\n    _factors = [(a, b) for a, (b, c) in [(a, divmod(N, a)) for a in range(2, int(math.sqrt(N)) + 1)]\n                if c == 0 and minNumber <= a <= maxNumber and minNumber <= b <= maxNumber]\n\n    factorsCache[N] = _factors\n    return _factors\n\n# Function to check if a sum is valid based on the factors\ndef isValidSum(N):\n    if N in validSumCache:\n        return validSumCache[N]\n\n    for m in range(minNumber, maxNumber + 1):\n        n = N - m\n        if n < minNumber:\n            break\n        if n > maxNumber:\n            continue\n        if len(factors(m * n)) == 1:\n            validSumCache[N] = False\n            return False\n\n    validSumCache[N] = True\n    return True\n\n# Main solution function\ndef main_solution(minNumber, maxNumber):\n    possibleSums = {}\n\n    for m in range(minNumber, maxNumber + 1):\n        for n in range(m, maxNumber + 1):\n            if not isValidSum(m + n):\n                continue\n            possible = factors(m * n)\n            if len(possible) == 1:\n                continue\n            possible = [(a, b) for a, b in possible if isValidSum(a + b)]\n            if len(possible) > 1:\n                continue\n            possibleSums.setdefault(m + n, []).append(possible[0])\n\n    result = []\n    for v in possibleSums.values():\n        if len(v) == 1:\n            result.append(v[0])\n\n    return result", "funcname": "main_solution", "ios": [{"input": {"minNumber": 25, "maxNumber": 26}, "output": []}, {"input": {"minNumber": 5, "maxNumber": 28}, "output": []}, {"input": {"minNumber": 7, "maxNumber": 38}, "output": []}, {"input": {"minNumber": 14, "maxNumber": 27}, "output": [[26, 27]]}, {"input": {"minNumber": 10, "maxNumber": 73}, "output": [[10, 13]]}, {"input": {"minNumber": 29, "maxNumber": 60}, "output": []}, {"input": {"minNumber": 20, "maxNumber": 35}, "output": []}, {"input": {"minNumber": 28, "maxNumber": 74}, "output": []}, {"input": {"minNumber": 24, "maxNumber": 27}, "output": [[26, 27]]}, {"input": {"minNumber": 24, "maxNumber": 50}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nightjuggler/puzzles", "path": "/twonumbers.py", "msgidx": 2859}}
{"problem_description": "Given a string of characters, what are all the possible unique arrangements of the characters in the string?", "io_requirements": "Input:\n  `input_string` (str): A string of characters for which all unique permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the characters in the input string. The order of permutations in the list is not guaranteed.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all unique permutations of the characters\n    unique_permutations = list(set(itertools.permutations(char_list)))\n    \n    # Convert each permutation tuple back to a string\n    result = [''.join(permutation) for permutation in unique_permutations]\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "lax"}, "output": ["lax", "xla", "lxa", "xal", "alx", "axl"]}, {"input": {"input_string": "afk"}, "output": ["afk", "kfa", "fak", "fka", "kaf", "akf"]}, {"input": {"input_string": "htk"}, "output": ["htk", "kht", "thk", "hkt", "tkh", "kth"]}, {"input": {"input_string": "hhps"}, "output": ["pshh", "hshp", "shhp", "shph", "sphh", "phsh", "hhsp", "hpsh", "hhps", "phhs", "hphs", "hsph"]}, {"input": {"input_string": "uzh"}, "output": ["huz", "zuh", "zhu", "hzu", "uhz", "uzh"]}, {"input": {"input_string": "azl"}, "output": ["alz", "zal", "laz", "azl", "lza", "zla"]}, {"input": {"input_string": "gpgr"}, "output": ["ggpr", "pgrg", "rgpg", "rggp", "grgp", "rpgg", "pggr", "prgg", "gprg", "gpgr", "grpg", "ggrp"]}, {"input": {"input_string": "juj"}, "output": ["juj", "ujj", "jju"]}, {"input": {"input_string": "fiq"}, "output": ["qfi", "qif", "ifq", "fqi", "iqf", "fiq"]}, {"input": {"input_string": "fri"}, "output": ["fir", "rif", "ifr", "fri", "rfi", "irf"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Clint-cc/Leecode", "path": "/\u529b\u6263/\u7b80\u5355\u7ec3\u4e60/038-\u5b57\u7b26\u4e32\u7684\u6392\u5217.py", "msgidx": 3034}}
{"problem_description": "Given the \"look and say\" sequence, where each term describes the digits of the previous term, what is the Nth term in this sequence?", "io_requirements": "Input:\n  `N` (int): The position in the \"look and say\" sequence for which the term is to be generated.\n\nOutput:\n  `return` (str): The Nth term of the \"look and say\" sequence as a string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef _look_and_say(arr):\n    result = []\n    digit_count = 0\n    digit_val = arr[0]\n\n    for val in arr:\n        if val == digit_val:\n            digit_count += 1\n        else:\n            result.extend([digit_count, digit_val])\n            digit_val = val\n            digit_count = 1\n\n    result.extend([digit_count, digit_val])\n    return result\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    ls = [1]\n    for _ in range(N):\n        ls = _look_and_say(ls)\n    \n    # Convert the list to a string for JSON serialization\n    return ''.join(map(str, ls))", "funcname": "main_solution", "ios": [{"input": {"N": 10}, "output": "11131221133112132113212221"}, {"input": {"N": 3}, "output": "1211"}, {"input": {"N": 7}, "output": "1113213211"}, {"input": {"N": 14}, "output": "311311222113111231131112132112311321322112111312211312111322212311322113212221"}, {"input": {"N": 6}, "output": "13112221"}, {"input": {"N": 9}, "output": "13211311123113112211"}, {"input": {"N": 13}, "output": "11131221131211131231121113112221121321132132211331222113112211"}, {"input": {"N": 4}, "output": "111221"}, {"input": {"N": 11}, "output": "3113112221232112111312211312113211"}, {"input": {"N": 1}, "output": "11"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "thewordisbird/interview_prep", "path": "/arrays_and_strings/dcp_412.py", "msgidx": 3013}}
{"problem_description": "Given a linked list where each node contains an integer data value, determine the data value of the node where a potential loop in the linked list starts. If there is no loop, return `None`. What is the data value of the node at the start of the loop?", "io_requirements": "Input:\n  `node_data_list` (list of int): A list of integers representing the data of nodes in a linked list. The last node may point to a node within the list, creating a loop.\n\nOutput:\n  `return` (int or None): The data of the node where the loop starts, or `None` if there is no loop in the linked list.", "refcode": "# import necessary packages\nimport sys\n\n# all class and function definitions in the code file, if any\nclass Node():\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n\ndef meeting_node(node):\n    slow = node\n    fast = slow.next\n    while fast != None and fast.next != None and fast != slow:\n        fast = fast.next.next\n        slow = slow.next\n    if fast == None or fast.next == None:\n        return None\n    return fast\n\ndef entry_node(node):\n    if not isinstance(node, Node) or not node:\n        return None\n    meet_node = meeting_node(node)\n    if meet_node == None:\n        return None\n        \n    nodes_in_loop = 1\n    p_node = meet_node\n    while p_node.next != meet_node:\n        p_node = p_node.next\n        nodes_in_loop += 1\n    left = node\n    right = left\n    for i in range(nodes_in_loop):\n        right = right.next\n    while left != right:\n        left = left.next\n        right = right.next\n    return left\n\n# main function\ndef main_solution(node_data_list):\n    # Convert the input list to a linked list with a potential loop\n    nodes = [Node(data) for data in node_data_list]\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i + 1]\n    \n    # Introduce a loop if the last node points to a node within the list\n    if len(nodes) > 1:\n        nodes[-1].next = nodes[len(nodes) // 2]\n    \n    # Find the entry node of the loop\n    entry = entry_node(nodes[0])\n    \n    # Return the data of the entry node or None if there is no loop\n    return entry.data if entry else None", "funcname": "main_solution", "ios": [{"input": {"node_data_list": [13, 30, 92, 18, 89, 75, 57, 27, 55]}, "output": 89}, {"input": {"node_data_list": [12, 99, 80, 64, 45, 60]}, "output": 64}, {"input": {"node_data_list": [26, 34, 42, 28, 76, 99, 62, 85, 59, 41]}, "output": 99}, {"input": {"node_data_list": [64, 40, 85, 74, 95, 35, 1, 78, 76]}, "output": 95}, {"input": {"node_data_list": [53, 2, 67, 26, 40, 55, 35, 89, 97]}, "output": 40}, {"input": {"node_data_list": [91, 37, 33, 38, 22, 73, 32, 5]}, "output": 22}, {"input": {"node_data_list": [91, 39, 42, 46, 30, 24]}, "output": 46}, {"input": {"node_data_list": [95, 41, 18, 79, 83, 74, 18]}, "output": 79}, {"input": {"node_data_list": [31, 58, 48, 33, 33, 87, 31, 70, 44]}, "output": 33}, {"input": {"node_data_list": [50, 48, 64, 68, 58, 53]}, "output": 68}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "feitenglee/target_offer", "path": "/23_\u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u8282\u70b9.py", "msgidx": 2902}}
{"problem_description": "Given the size of an alphabet rangoli, what is the pattern that forms when the letters are arranged in a specific manner to create a symmetrical design? The size determines the number of letters used and the complexity of the pattern.", "io_requirements": "Input:\n  `size` (int): An integer representing the size of the alphabet rangoli. The size must be a positive integer greater than or equal to 1.\n\nOutput:\n  `return` (str): A string representing the alphabet rangoli pattern. Each line of the pattern is separated by a newline character (`\\n`).", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(size):\n    # Convert the size to an integer if it's not already\n    size = int(size)\n    \n    # Generate the rangoli pattern\n    if size == 1:\n        return \"a\"\n\n    m = 4 * size - 3\n    lines = []\n    code = ord(\"a\") - 1\n\n    for i in itertools.chain(range(size), reversed(range(size - 1))):\n        line = \"\"\n        for j in range(i + 1):\n            line += chr(code + size - j) + \"-\"\n        for j in reversed(range(i)):\n            line += chr(code + size - j)\n            if j > 0:\n                line += \"-\"\n        lines.append(line.center(m, \"-\"))\n\n    # Return the pattern as a single string with newline characters\n    return \"\\n\".join(lines)", "funcname": "main_solution", "ios": [{"input": {"size": 1}, "output": "a"}, {"input": {"size": 3}, "output": "----c----\n--c-b-c--\nc-b-a-b-c\n--c-b-c--\n----c----"}, {"input": {"size": 4}, "output": "------d------\n----d-c-d----\n--d-c-b-c-d--\nd-c-b-a-b-c-d\n--d-c-b-c-d--\n----d-c-d----\n------d------"}, {"input": {"size": 2}, "output": "--b--\nb-a-b\n--b--"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ChenlingJ/cj", "path": "/hackerrank/alphabet_rangoli.py", "msgidx": 3015}}
{"problem_description": "In the game of chess, the N-Queens puzzle involves placing N queens on an N\u00d7N chessboard such that no two queens threaten each other. Given a chessboard of a certain dimension, how can we determine the positions of the queens such that they are all safe from each other? Specifically, what are the positions of the queens on a chessboard of dimension `dimensao`?", "io_requirements": "Input:\n  `dimensao` (int): The dimension of the chessboard, which is a positive integer representing the number of rows and columns in the board.\n\nOutput:\n  `return` (list of lists): A 2D list representing the chessboard with 'R' indicating the positions of the queens and empty strings indicating empty positions. The size of the list is `dimensao x dimensao`.", "refcode": "# import necessary packages\nimport numpy as np\n\n# Funcao recursiva, que testa por meio do metodo BackTracking todas as posicoes;\n# Este metodo foi implementado colocando-se uma rainha por coluna, da esquerda\n# Para a direita, e assim ajustando o tabuleiro conforme as verificacoes de ataque/defesa\ndef backTracking(tabuleiro, coluna, dimensao):\n\n    # Caso base da recursao\n    if coluna >= dimensao:\n        return True\n\n    # Verificacao das linhas, incrementa-se 1 na linha, se a posicao nao for valida\n    for linha in range(dimensao):\n\n        if verificaPosicao(tabuleiro, linha, coluna, dimensao):\n            tabuleiro[linha][coluna] = \"R\"\n            \n\n            if backTracking(tabuleiro, coluna + 1, dimensao):\n                return True\n            # Caso futuros backTracking nao deem certo, altera-se a linha, atribuindo caracter nula para a linha invalida\n            else:\n                tabuleiro[linha][coluna] = \"\"\n\n    return False\n\n\n# Funcao que verifica se a posicao da rainha e valida, ou seja,\n# Se a posicao nao esta em risco de sofrer um ataque\ndef verificaPosicao(tabuleiro, linha, coluna, dimensao):\n\n    # retira-se a rainha para a verificacao do tabuleiro\n    tabuleiro[linha][coluna] = \"\"\n\n    # Verificacao Horizontal (Fixa-se a linha)\n    for j in range(dimensao):\n        if tabuleiro[linha][j] == \"R\":\n            return False\n\n    # Verificacao de Diagonal Principal\n    # Utilizando a funcao da biblioteca numpy, diagonal, que dado um offset de uma array 2D\n    # Ela retorna um array 1D da diagonal\n    tabDiagPrinc = np.diagonal(tabuleiro, coluna - linha)\n    for i in range(np.size(tabDiagPrinc)):\n        if tabDiagPrinc[i] == \"R\":\n            return False\n\n    # Verificacao da Diagonal Secundaria\n    # Utiliza-se a funcao fliplr, que transpoe a matriz, para facilitar a obtencao da diagonal secundaria\n    # offset calculado como complemento em relacao a dimensao da matriz, alem do vetor (1, 1) da diagonal\n    tabAux = np.fliplr(tabuleiro)\n    tabDiagSec = np.diagonal(tabAux, dimensao - 1 - (coluna + linha))\n    for i in range(np.size(tabDiagSec)):\n        if tabDiagSec[i] == \"R\":\n            return False\n\n    # recolocacao da rainha, apos a verificacao\n    tabuleiro[linha][coluna] = \"R\"\n\n    # Verificacao concluida\n    return True\n\n# main function\ndef main_solution(dimensao):\n    # Convert input to the required format\n    dimensao = int(dimensao)\n\n    # Criacao do Tabuleiro\n    tabuleiro = np.zeros((dimensao, dimensao), dtype=str)\n\n    coluna = 0\n    backTracking(tabuleiro, coluna, dimensao)\n\n    # Convert the output to a JSON serializable format\n    result = tabuleiro.tolist()\n\n    return result", "funcname": "main_solution", "ios": [{"input": {"dimensao": 7}, "output": [["R", "", "", "", "", "", ""], ["", "", "", "", "R", "", ""], ["", "R", "", "", "", "", ""], ["", "", "", "", "", "R", ""], ["", "", "R", "", "", "", ""], ["", "", "", "", "", "", "R"], ["", "", "", "R", "", "", ""]]}, {"input": {"dimensao": 6}, "output": [["", "", "", "R", "", ""], ["R", "", "", "", "", ""], ["", "", "", "", "R", ""], ["", "R", "", "", "", ""], ["", "", "", "", "", "R"], ["", "", "R", "", "", ""]]}, {"input": {"dimensao": 5}, "output": [["R", "", "", "", ""], ["", "", "", "R", ""], ["", "R", "", "", ""], ["", "", "", "", "R"], ["", "", "R", "", ""]]}, {"input": {"dimensao": 4}, "output": [["", "", "R", ""], ["R", "", "", ""], ["", "", "", "R"], ["", "R", "", ""]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lucas-leme/nQueens", "path": "/nQueens.py", "msgidx": 2278}}
{"problem_description": "In England, the currency consists of pounds (\u00a3) and pence (p). Given a set of coin denominations and a target amount in pence, how many different ways can the target amount be made using any number of the given coins?", "io_requirements": "Input:\n  `coins` (str): A JSON-encoded list of integers representing the denominations of coins available.\n  `target_amount` (str): A string representing the target amount in pence (an integer).\n\nOutput:\n  `return` (str): A JSON-encoded string representing the number of different ways the target amount can be made using the given coins.", "refcode": "# import necessary packages\nimport json\n\n# main function\ndef main_solution(coins, target_amount):\n    # Convert JSON serializable inputs to the original input variables\n    coins = json.loads(coins)\n    target_amount = int(target_amount)\n    \n    # Initialize the count of ways to make the target amount\n    count = 0\n    \n    # Iterate through all possible combinations of coins\n    for num_200 in range(0, target_amount // 200 + 1):\n        for num_100 in range(0, target_amount // 100 + 1):\n            for num_50 in range(0, target_amount // 50 + 1):\n                for num_20 in range(0, target_amount // 20 + 1):\n                    for num_10 in range(0, target_amount // 10 + 1):\n                        for num_5 in range(0, target_amount // 5 + 1):\n                            for num_2 in range(0, target_amount // 2 + 1):\n                                remaining = target_amount - 200 * num_200 - 100 * num_100 - 50 * num_50 - 20 * num_20 - 10 * num_10 - 5 * num_5 - 2 * num_2\n                                if remaining >= 0:\n                                    count += 1\n    \n    # Convert the output to JSON serializable format\n    return json.dumps(count)", "funcname": "main_solution", "ios": [{"input": {"coins": "[2, 5, 20]", "target_amount": "97"}, "output": "4072"}, {"input": {"coins": "[50, 100, 200, 10, 1, 2]", "target_amount": "65"}, "output": "1022"}, {"input": {"coins": "[10, 5, 100]", "target_amount": "153"}, "output": "23630"}, {"input": {"coins": "[10]", "target_amount": "110"}, "output": "6495"}, {"input": {"coins": "[5, 2, 20]", "target_amount": "162"}, "output": "30023"}, {"input": {"coins": "[10]", "target_amount": "163"}, "output": "30698"}, {"input": {"coins": "[2, 10]", "target_amount": "112"}, "output": "6951"}, {"input": {"coins": "[20, 200, 5, 100, 1, 10, 2, 50]", "target_amount": "70"}, "output": "1311"}, {"input": {"coins": "[2, 5]", "target_amount": "153"}, "output": "23630"}, {"input": {"coins": "[1, 5, 200, 2, 10, 50, 100]", "target_amount": "178"}, "output": "44517"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rczyrnik/ProjectEuler", "path": "/E031_CoinSums.py", "msgidx": 2941}}
{"problem_description": "Given a set of N positive integers, how can you select and arrange six numbers at the base of a pyramid such that the product of the numbers in the row below the base results in the largest possible number at the apex of the pyramid?", "io_requirements": "Input:\n  `N` (int): The total number of integers given.\n  `numbers` (str): A comma-separated string of N positive integers from which the six numbers at the base need to be selected.\n\nOutput:\n  `return` (int): The maximum value of the apex of the pyramid when six integers are selected and arranged suitably at the base.", "refcode": "# import necessary packages\nfrom itertools import combinations\n\n# main function\ndef main_solution(N, numbers):\n    # Convert the input string of numbers to a list of integers\n    numbers = list(map(int, numbers.split(',')))\n    \n    # Initialize the maximum apex value\n    max_apex = 0\n    \n    # Iterate over all combinations of 6 numbers from the given list\n    for comb in combinations(numbers, 6):\n        # Sort the combination to form the base of the pyramid\n        base = sorted(comb)\n        \n        # Extract the numbers for the base\n        a, b, c, d, e, f = base\n        \n        # Calculate the two possible results for the apex\n        res1 = sum([a, 4*b, 6*c, 4*d, e])\n        res2 = sum([f, 4*b, 6*c, 4*d, e])\n        \n        # Calculate the two possible apex values\n        res11 = res1 * sum([b, 4*c, 6*d, 4*e, f])\n        res22 = res2 * sum([b, 4*c, 6*d, 4*e, a])\n        \n        # Update the maximum apex value\n        max_apex = max(max_apex, res11, res22)\n    \n    # Return the maximum apex value\n    return max_apex", "funcname": "main_solution", "ios": [{"input": {"N": 12, "numbers": "85,83,57,57,47,92,8,36,48,18,83,90"}, "output": 1814384}, {"input": {"N": 8, "numbers": "75,14,82,36,18,65,60,53"}, "output": 1007791}, {"input": {"N": 11, "numbers": "56,99,20,18,19,47,47,48,93,67,65"}, "output": 1222212}, {"input": {"N": 10, "numbers": "22,67,52,71,46,49,80,96,14,60"}, "output": 1240852}, {"input": {"N": 8, "numbers": "54,60,37,19,37,84,68,15"}, "output": 796608}, {"input": {"N": 11, "numbers": "40,95,74,37,79,85,91,13,45,72,3"}, "output": 1731456}, {"input": {"N": 10, "numbers": "16,55,20,57,13,79,38,49,85,100"}, "output": 1218198}, {"input": {"N": 10, "numbers": "31,66,4,59,2,65,33,31,96,72"}, "output": 1096088}, {"input": {"N": 9, "numbers": "36,49,52,64,45,28,61,34,15"}, "output": 672231}, {"input": {"N": 6, "numbers": "53,72,2,63,15,46"}, "output": 526593}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Krish3na/Edyst-TCS-Codevita-Solutions", "path": "/Math/Numbers/pascalpyramid.py", "msgidx": 3108}}
{"problem_description": "Given a set of digits from 1 to 9, we want to find all unique products that can be formed by multiplying two numbers with specific digit counts, such that the digits used in the multiplicands and the product together form a pandigital number (a number that uses each of the digits 1 through 9 exactly once). What is the sum of all such unique products when the digit counts for the multiplicands are `A` and `B`?", "io_requirements": "Input:\n- `A` (int): The number of digits for the first multiplicand.\n- `B` (int): The number of digits for the second multiplicand.\n\nOutput:\n- `return` (int): The sum of all unique products that can be formed by multiplying two numbers with the specified digit counts, where the digits used in the multiplicands and the product together form a pandigital number (a number that uses each of the digits 1 through 9 exactly once).", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef list_to_int(l):\n    return int(''.join(map(str, l)))\n\ndef pandigital(digits, n):\n    nums = []\n    for c in itertools.combinations(digits, n):\n        for p in itertools.permutations(c):\n            nums.append(list_to_int(p))\n    return nums\n\ndef get_pandigitals_for_sizes(A, B):\n    C = 9 - A - B\n    res = set()\n\n    digits = range(1, 10)\n    pdA = pandigital(digits, A)\n    for a in sorted(pdA):\n        digits2 = list(digits)\n        for d in str(a):\n            if int(d) in digits2:\n                digits2.remove(int(d))\n\n        pdB = pandigital(digits2, B)\n        for b in sorted(pdB):\n            digits3 = list(digits2)\n            for dd in str(b):\n                if int(dd) in digits3:\n                    digits3.remove(int(dd))\n            pdC = pandigital(digits3, C)\n            prod = a * b\n            if len(str(prod)) > 4:\n                break  # we can stop because the multiplicants are sorted:\n                # any remaining product will also be too large\n            if prod in pdC:\n                res.add(prod)\n    return res\n\n# main function\ndef main_solution(A, B):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    res1 = get_pandigitals_for_sizes(A, B)\n    res2 = get_pandigitals_for_sizes(1, 4)\n    res1.update(res2)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(res1)", "funcname": "main_solution", "ios": [{"input": {"A": 2, "B": 3}, "output": 45228}, {"input": {"A": 3, "B": 4}, "output": 14804}, {"input": {"A": 3, "B": 3}, "output": 14804}, {"input": {"A": 2, "B": 4}, "output": 14804}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dgquintas/my-code-samples", "path": "/ProjectEuler/p32/pandigital.py", "msgidx": 3123}}
{"problem_description": "In a bag, there are a certain number of marbles, each either black or white. You are allowed to draw a marble from the bag, note its color, and then replace it with a marble of the opposite color. This process is repeated a specified number of times. Given the initial distribution of marbles and the number of steps, what is the probability that a randomly drawn marble after all steps is white?", "io_requirements": "Input:\n  `marbles` (str): A string representing the initial distribution of marbles, where 'b' represents a black marble and 'w' represents a white marble. The length of the string indicates the total number of marbles.\n  `step` (int): An integer representing the number of steps or iterations to perform the marble swapping process.\n\nOutput:\n  `return` (float): A float representing the probability of drawing a white marble after the specified number of steps, rounded to two decimal places.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(marbles, step):\n    # Convert input to appropriate types if necessary\n    marbles = str(marbles)\n    step = int(step)\n    \n    swap = str.maketrans(\"bw\", \"wb\")\n    pattern_counts = {\"\".join(sorted(marbles)): 1}\n    \n    for i in range(step - 1):\n        next_pattern_counts = defaultdict(int)\n        for marbles, count in pattern_counts.items():\n            for i in range(len(marbles)):\n                swapped = marbles[:i] + \\\n                    marbles[i].translate(swap) + marbles[i + 1:]\n                next_pattern_counts[\"\".join(sorted(swapped))] += count\n        pattern_counts = next_pattern_counts\n\n    w_count = sum([marbles.count(\"w\") * count for marbles,\n                   count in pattern_counts.items()])\n    result = round(w_count / len(marbles)**(step), 2)\n    \n    # Convert output to JSON serializable format\n    return float(result)", "funcname": "main_solution", "ios": [{"input": {"marbles": "bbbbwbbbwb", "step": 3}, "output": 0.31}, {"input": {"marbles": "wwwwbbw", "step": 5}, "output": 0.56}, {"input": {"marbles": "bwwwbbbwwb", "step": 5}, "output": 0.5}, {"input": {"marbles": "bbbwbbww", "step": 2}, "output": 0.41}, {"input": {"marbles": "wwwbbb", "step": 1}, "output": 0.5}, {"input": {"marbles": "bwwbbwbwbw", "step": 2}, "output": 0.5}, {"input": {"marbles": "bbwbwbb", "step": 2}, "output": 0.35}, {"input": {"marbles": "bbwbwbww", "step": 5}, "output": 0.5}, {"input": {"marbles": "bbb", "step": 3}, "output": 0.44}, {"input": {"marbles": "bbbbb", "step": 1}, "output": 0.0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "YxiangJ/Python", "path": "/Checkiolearn/Mine/pearls_in_the_box.py", "msgidx": 3151}}
{"problem_description": "Given a positive integer `n`, what are all the possible binary combinations of length `n`?", "io_requirements": "Input:\n  `n` (int): An integer representing the length of binary combinations to generate.\n\nOutput:\n  `return` (list): A list of strings where each string is a binary combination of length `n`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generate_binaries_combinations(n: int) -> list:\n    if n == 1:  # Conditions d'arr\u00eat\n        # Si n = 1, je dois juste retourner [0, 1], comme dans l'exemple\n        return [\"0\", \"1\"]\n\n    # Si jamais n est plus grand que 1, je dois d'abord r\u00e9cup\u00e9rer toutes\n    # les combinaisons possibles pour n-1\n    previous_combinations = generate_binaries_combinations(n - 1)\n\n    # Je rajoute un 0 devant toutes les combinaisons trouv\u00e9es pour n-1\n    zeros = [\"0\" + s for s in previous_combinations]\n\n    # Je fais la m\u00eame chose mais en rajoutant un 1 devant les combinaisons trouv\u00e9es pour n-1\n    ones = [\"1\" + s for s in previous_combinations]\n\n    # Je concat\u00e8ne les deux tableaux\n    return zeros + ones\n\n# main function\ndef main_solution(n: int) -> list:\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = generate_binaries_combinations(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["0", "1"]}, {"input": {"n": 2}, "output": ["00", "01", "10", "11"]}, {"input": {"n": 3}, "output": ["000", "001", "010", "011", "100", "101", "110", "111"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "633-1-ALGO/TP01-Complexite-Recursivite-solutions", "path": "/recursivite/Exercice_4.py", "msgidx": 3002}}
{"problem_description": "Given a range of numbers, how many numbers within that range have digits that are in ascending order and contain at least one pair of consecutive duplicate digits? Additionally, how many of these numbers contain exactly one pair of consecutive duplicate digits?", "io_requirements": "Input:\n  `number_range` (list of int): A list containing two integers representing the lower and upper bounds of a range of numbers.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `part_A` (int): The count of numbers within the range that have at least one pair of consecutive duplicate digits and are in ascending order.\n    - `part_B` (int): The count of numbers within the range that have exactly one pair of consecutive duplicate digits and are in ascending order.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef number_contains_duplicate(number):\n    number_arr = np.array([int(d) for d in str(number)], dtype=int)\n    return np.isin(0, np.subtract(number_arr, np.roll(number_arr, 1))[1:])\n\ndef number_contains_double_pair(number):\n    number_arr = np.array([0]+[int(d) for d in str(number)], dtype=int)\n    differences = np.diff(number_arr)\n    accumulated_arr = np.add.accumulate(differences)\n    try:\n        return np.isin(2, np.bincount(accumulated_arr))\n    except ValueError:\n        return None\n\ndef number_in_ascending_order(number):\n    number_arr = np.array([int(d) for d in str(number)], dtype=int)\n    return all([number_arr[j] <= number_arr[j+1] for j in range(len(number_arr)-1)])\n\n# main function\ndef main_solution(number_range):\n    number_range = [int(number_range[0]), int(number_range[1])]\n    multi_count = 0\n    double_count = 0\n    for number in range(*number_range):\n        if number_in_ascending_order(number):\n            if number_contains_duplicate(number):\n                multi_count += 1\n                if number_contains_double_pair(number):\n                    double_count += 1\n    return {\"part_A\": multi_count, \"part_B\": double_count}", "funcname": "main_solution", "ios": [{"input": {"number_range": [357524, 381562]}, "output": {"part_A": 65, "part_B": 32}}, {"input": {"number_range": [813382, 873082]}, "output": {"part_A": 0, "part_B": 0}}, {"input": {"number_range": [684614, 987824]}, "output": {"part_A": 33, "part_B": 15}}, {"input": {"number_range": [279035, 409757]}, "output": {"part_A": 463, "part_B": 314}}, {"input": {"number_range": [832056, 923537]}, "output": {"part_A": 6, "part_B": 2}}, {"input": {"number_range": [738816, 983743]}, "output": {"part_A": 27, "part_B": 13}}, {"input": {"number_range": [737230, 842912]}, "output": {"part_A": 21, "part_B": 11}}, {"input": {"number_range": [247829, 784617]}, "output": {"part_A": 1038, "part_B": 671}}, {"input": {"number_range": [286469, 713470]}, "output": {"part_A": 895, "part_B": 591}}, {"input": {"number_range": [363754, 540258]}, "output": {"part_A": 307, "part_B": 193}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rfrazier716/advent_of_code_2019", "path": "/advent_of_code/day4.py", "msgidx": 2852}}
{"problem_description": "Given a number `N`, what are all the possible combinations of `N` pairs of balanced parentheses?", "io_requirements": "Input:\n  `N` (int): The number of pairs of balanced parentheses to generate.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a valid combination of balanced parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generate_valid_parentheses_rec(num, openCount, closeCount, parenthesesString, index, result):\n  # if we've reached the maximum number of open and close parentheses, add to the result\n  if openCount == num and closeCount == num:\n    result.append(''.join(parenthesesString))\n  else:\n    if openCount < num:  # if we can add an open parentheses, add it\n      parenthesesString[index] = '('\n      generate_valid_parentheses_rec(\n        num, openCount + 1, closeCount, parenthesesString, index + 1, result)\n\n    if openCount > closeCount:  # if we can add a close parentheses, add it\n      parenthesesString[index] = ')'\n      generate_valid_parentheses_rec(\n        num, openCount, closeCount + 1, parenthesesString, index + 1, result)\n\n# main function\ndef main_solution(N):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  result = []\n  parenthesesString = [0 for x in range(2 * N)]\n  generate_valid_parentheses_rec(N, 0, 0, parenthesesString, 0, result)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"N": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"N": 2}, "output": ["(())", "()()"]}, {"input": {"N": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mkoryor/Python", "path": "/coding patterns/subsets/balance_parenthese_recur.py", "msgidx": 2936}}
{"problem_description": "Given a number `M`, we need to find the next runround number that is greater than `M` and has a specific length `length`. A runround number is a number where, when moving from digit to digit, each digit is visited exactly once and the movement ends at the starting digit. What is the next runround number that meets these criteria?", "io_requirements": "Input:\n  `M` (int): The starting number from which to find the next runround number.\n  `length` (int): The length of the number to be generated.\n\nOutput:\n  `return` (int): The next runround number greater than `M` with the specified `length`, or `0` if no such number exists.", "refcode": "# import necessary packages\nfrom typing import List, Set\n\n# main function\ndef main_solution(M: int, length: int) -> int:\n    # Convert JSON serializable inputs to original input variables\n    M = int(M)\n    length = int(length)\n\n    digit_collection: List[int] = []\n    digit_set: Set[int] = set()\n\n    def check_runround() -> bool:\n        i = (0 + digit_collection[0]) % length\n        for cnt in range(1, length):\n            if i == 0:\n                return False\n            i = (i + digit_collection[i]) % length\n        return i == 0\n\n    def convert_to_int() -> int:\n        return int(\"\".join(map(str, digit_collection)))\n\n    def dfs(depth: int = 0) -> bool:\n        if depth == length:\n            return check_runround() and convert_to_int() > M\n        for digit in range(1, 10):\n            if digit in digit_set:\n                continue\n            digit_collection.append(digit)\n            digit_set.add(digit)\n            if dfs(depth + 1):\n                return True\n            digit_set.discard(digit)\n            digit_collection.pop()\n        return False\n\n    if dfs():\n        return convert_to_int()\n    return 0", "funcname": "main_solution", "ios": [{"input": {"M": 915416, "length": 6}, "output": 942531}, {"input": {"M": 242402, "length": 2}, "output": 0}, {"input": {"M": 714896, "length": 1}, "output": 0}, {"input": {"M": 191696, "length": 8}, "output": 0}, {"input": {"M": 778977, "length": 5}, "output": 0}, {"input": {"M": 293979, "length": 9}, "output": 0}, {"input": {"M": 717676, "length": 3}, "output": 0}, {"input": {"M": 751799, "length": 3}, "output": 0}, {"input": {"M": 832502, "length": 4}, "output": 0}, {"input": {"M": 874867, "length": 1}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "escape0707/usaco_trainings", "path": "/runround.py", "msgidx": 3006}}
{"problem_description": "Consider a sequence of six dice arranged in a row. Each die shows a number from 1 to 6. The operation involves flipping the first `n` dice (where `n` is the number on the first die) and appending them to the end of the sequence. This operation is repeated. Given an initial configuration of the dice, how many different sequences will never return to the initial configuration after repeated operations?", "io_requirements": "Input:\n  `initial_sequence` (list of integers): A list of 6 integers representing the initial configuration of the dice. Each integer should be between 1 and 6.\n\nOutput:\n  `return` (integer): The number of sequences that do not return to the initial configuration after repeated operations.", "refcode": "# import necessary packages\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# sequence: \uff16\u500b\u306e\u30b5\u30a4\u30b3\u30ed\u306e\u76ee\u306e\u30ea\u30b9\u30c8\n# \u53d7\u3051\u53d6\u3063\u305f sequence \u306b\u5bfe\u3057\u3066\u554f\u984c\u306e\u64cd\u4f5c\u3092\u884c\u3063\u305f\u7d50\u679c\u3092\u8fd4\u3059\ndef step(sequence):\n  idx = sequence[0]\n  flipped = [(7 - n) for n in sequence[:idx]]\n  return sequence[idx:] + flipped\n\n# sequence: \uff16\u500b\u306e\u30b5\u30a4\u30b3\u30ed\u306e\u76ee\u306e\u30ea\u30b9\u30c8\uff08\u521d\u671f\u914d\u7f6e\uff09\n# false_sequences: \u65e2\u77e5\u306e\u300c\u6700\u521d\u306e\u76ee\u306b\u623b\u3089\u306a\u3044\u914d\u7f6e\u300d\u306e\u96c6\u5408\n# true_sequences: \u65e2\u77e5\u306e\u300c\u6700\u521d\u306e\u76ee\u306b\u623b\u308b\u914d\u7f6e\u300d\u306e\u96c6\u5408\ndef check(sequence, false_sequences, true_sequences):\n  achieved = [tuple(sequence)] # \u64cd\u4f5c\u3092\u7e70\u308a\u8fd4\u3057\u3066\u5f97\u3089\u308c\u308b sequence \u3092\u4fdd\u5b58\u3059\u308b\u30ea\u30b9\u30c8\n  next_sequence = [num for num in sequence] # \u521d\u671f\u914d\u7f6e\u3092\u30b3\u30d4\u30fc\n  while True:\n    next_sequence = step(next_sequence)\n    if next_sequence == sequence: # \u521d\u671f\u914d\u7f6e\u306b\u623b\u308b \u2192 achieved \u306e\u914d\u7f6e\u306f\u3001\u5168\u3066\u521d\u671f\u914d\u7f6e\u306b\u623b\u308b\n      true_sequences |= set(achieved)\n      return\n    elif tuple(next_sequence) in achieved: # \u521d\u671f\u914d\u7f6e\u4ee5\u5916\u306e\u914d\u7f6e\u306b\u623b\u308b\n      idx = achieved.index(tuple(next_sequence))\n      false_sequences |= set(achieved[:idx]) # next_sequence \u3088\u308a\u524d\u306e sequence \u306f\u300c\u6700\u521d\u306e\u76ee\u306b\u623b\u3089\u306a\u3044\u914d\u7f6e\u300d\n      true_sequences |= set(achieved[idx:]) # next_sequence \u4ee5\u964d\u306e sequence \u306f\u300c\u6700\u521d\u306e\u76ee\u306b\u623b\u308b\u914d\u7f6e\u300d\n      return\n    achieved.append(tuple(next_sequence))\n\n# main function\ndef main_solution(initial_sequence):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  initial_sequence = list(initial_sequence)  # Ensure it's a list\n  false_sequences, true_sequences = set(), set()\n  check(initial_sequence, false_sequences, true_sequences)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return len(false_sequences)", "funcname": "main_solution", "ios": [{"input": {"initial_sequence": [3, 1, 1, 4, 5, 1]}, "output": 1}, {"input": {"initial_sequence": [2, 3, 3, 2, 3, 5]}, "output": 1}, {"input": {"initial_sequence": [6, 6, 6, 1, 3, 4]}, "output": 2}, {"input": {"initial_sequence": [6, 3, 4, 2, 3, 3]}, "output": 3}, {"input": {"initial_sequence": [6, 4, 2, 5, 4, 6]}, "output": 0}, {"input": {"initial_sequence": [1, 6, 2, 1, 4, 2]}, "output": 1}, {"input": {"initial_sequence": [1, 1, 6, 1, 5, 3]}, "output": 4}, {"input": {"initial_sequence": [4, 1, 2, 2, 5, 6]}, "output": 1}, {"input": {"initial_sequence": [6, 2, 4, 1, 4, 5]}, "output": 0}, {"input": {"initial_sequence": [1, 4, 2, 6, 6, 1]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "takecap/70puzzles", "path": "/src/q37.py", "msgidx": 2487}}
{"problem_description": "Given a Tower of Hanoi puzzle with three rods and a certain number of disks, what is the sequence of moves required to transfer all disks from the source rod to the destination rod, following the rules that only one disk can be moved at a time and a larger disk cannot be placed on top of a smaller disk? The input variables are the number of disks (`n`), the source rod (`source`), the destination rod (`dest`), and the intermediate rod (`intermediate`).", "io_requirements": "Input:\n  `n` (int): The number of disks to be moved.\n  `source` (str): The name of the source rod (e.g., 'A').\n  `dest` (str): The name of the destination rod (e.g., 'C').\n  `intermediate` (str): The name of the intermediate rod (e.g., 'B').\n\nOutput:\n  `return` (str): A JSON-serialized string representing the sequence of moves required to solve the Tower of Hanoi problem. Each move is a dictionary with keys \"from\" and \"to\", indicating the source and destination rods respectively.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef hanoi_move(n, source, dest, intermediate, moves):\n    if n >= 1:\n        hanoi_move(n - 1, source, intermediate, dest, moves)\n        moves.append({\"from\": source, \"to\": dest})\n        hanoi_move(n - 1, intermediate, dest, source, moves)\n\n# main function\ndef main_solution(n, source, dest, intermediate):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    moves = []\n    hanoi_move(n, source, dest, intermediate, moves)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return json.dumps(moves)", "funcname": "main_solution", "ios": [{"input": {"n": 2, "source": "C", "dest": "B", "intermediate": "A"}, "output": "[{\"from\": \"C\", \"to\": \"A\"}, {\"from\": \"C\", \"to\": \"B\"}, {\"from\": \"A\", \"to\": \"B\"}]"}, {"input": {"n": 2, "source": "B", "dest": "A", "intermediate": "C"}, "output": "[{\"from\": \"B\", \"to\": \"C\"}, {\"from\": \"B\", \"to\": \"A\"}, {\"from\": \"C\", \"to\": \"A\"}]"}, {"input": {"n": 2, "source": "A", "dest": "B", "intermediate": "C"}, "output": "[{\"from\": \"A\", \"to\": \"C\"}, {\"from\": \"A\", \"to\": \"B\"}, {\"from\": \"C\", \"to\": \"B\"}]"}, {"input": {"n": 2, "source": "B", "dest": "C", "intermediate": "A"}, "output": "[{\"from\": \"B\", \"to\": \"A\"}, {\"from\": \"B\", \"to\": \"C\"}, {\"from\": \"A\", \"to\": \"C\"}]"}, {"input": {"n": 2, "source": "A", "dest": "C", "intermediate": "B"}, "output": "[{\"from\": \"A\", \"to\": \"B\"}, {\"from\": \"A\", \"to\": \"C\"}, {\"from\": \"B\", \"to\": \"C\"}]"}, {"input": {"n": 2, "source": "C", "dest": "A", "intermediate": "B"}, "output": "[{\"from\": \"C\", \"to\": \"B\"}, {\"from\": \"C\", \"to\": \"A\"}, {\"from\": \"B\", \"to\": \"A\"}]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "CriusCrius/PythonDataStructure", "path": "/11-2_recursion_hanoi.py", "msgidx": 2986}}
{"problem_description": "Given a string composed of various types of brackets (e.g., \"(\", \"[\", \"{\", \")\", \"]\", \"}\"), how can we determine if the string is balanced, meaning that each opening bracket has a corresponding closing bracket in the correct order and no brackets overlap incorrectly?", "io_requirements": "Input:\n  `string` (str): A string made up of brackets (\"(\", \"[\", \"{\", \")\", \"]\", and \"}\") and other optional characters. The string should not contain any non-bracket characters that are not explicitly allowed.\n\nOutput:\n  `return` (bool): A boolean value representing whether the string is balanced in regards to brackets. `True` if the string is balanced, `False` otherwise.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_opening_bracket(b):\n    return b in ['(', '{', '[']\n\ndef has_matching_brackets(string):\n    return True if string == \"[]\" or string == \"{}\" or string == \"()\" else False\n\n# main function\ndef main_solution(string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    stack = []\n    for char in string:\n        if is_opening_bracket(char):\n            stack.append(char)\n        else:\n            if len(stack) == 0:\n                return False\n            opening_bracket = stack.pop()\n            string_to_match = opening_bracket + char\n            if not has_matching_brackets(string_to_match):\n                return False\n\n    if len(stack) > 0:\n        return False\n\n    return True", "funcname": "main_solution", "ios": [{"input": {"string": "(]})))]{"}, "output": false}, {"input": {"string": "}()]{()"}, "output": false}, {"input": {"string": "[{[{"}, "output": false}, {"input": {"string": "[{}[]()((])"}, "output": false}, {"input": {"string": "({)){"}, "output": false}, {"input": {"string": "({{(([((("}, "output": false}, {"input": {"string": "]){][(}"}, "output": false}, {"input": {"string": "))(}{[}[[({[({}]]("}, "output": false}, {"input": {"string": "[)"}, "output": false}, {"input": {"string": "{(}[]{"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sunnysidesounds/InterviewQuestions", "path": "/general/balanced_brackets.py", "msgidx": 3521}}
{"problem_description": "Given a binary tree, determine if it is symmetric around its center. A tree is symmetric if the left subtree is a mirror reflection of the right subtree. What is the result of checking the symmetry of the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented as a dictionary with keys `\"val\"` (int), `\"left\"` (dict or null), and `\"right\"` (dict or null).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetric.", "refcode": "# import necessary packages\nimport sys\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution2:\n    def isSymmetric(self, root_1: TreeNode, root_2: TreeNode) -> bool:\n        if root_1 is None and root_2 is None:\n            return True\n        if root_1 is None or root_2 is None:\n            return False\n        return (root_1.val == root_2.val) and self.isSymmetric(root_1.left, root_2.right) and self.isSymmetric(root_1.right, root_2.left)\n\n# main function\ndef main_solution(tree_structure: str) -> bool:\n    # Convert JSON serializable input to original input variables\n    tree_dict = json.loads(tree_structure)\n    def build_tree(node_dict):\n        if not node_dict:\n            return None\n        node = TreeNode(node_dict['val'])\n        node.left = build_tree(node_dict['left'])\n        node.right = build_tree(node_dict['right'])\n        return node\n    \n    root = build_tree(tree_dict)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution2()\n    result = solution.isSymmetric(root, root)\n    \n    # Return the result, which is JSON serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": "{\"val\": 3, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 25, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 97, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 80, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 44, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 100, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 45, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 10, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 39, \"left\": null, \"right\": null}"}, "output": true}, {"input": {"tree_structure": "{\"val\": 87, \"left\": null, \"right\": null}"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ccs258/python_algothrim", "path": "/\u6811/\u5bf9\u79f0\u4e8c\u53c9\u6811/is_symmetric.py", "msgidx": 3021}}
{"problem_description": "Given a set of disks on a source rod, how can you move all the disks to a target rod using a helper rod, following the rules of the Tower of Hanoi puzzle? The rules state that you can only move one disk at a time, and a larger disk cannot be placed on top of a smaller disk. What sequence of moves would achieve this for a given number of disks and specified rods?", "io_requirements": "Input:\n  `n` (int): The number of disks to be moved.\n  `source` (str): The name of the source rod.\n  `target` (str): The name of the target rod.\n  `helper` (str): The name of the helper rod.\n\nOutput:\n  `return` (str): A JSON-serialized string containing a list of moves, where each move is a string formatted as \"n : source -> target\".", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef hanoi(n, source, target, helper, moves):\n    if n == 1:\n        moves.append(f\"{n} : {source} -> {target}\")\n    else:\n        hanoi(n - 1, source, helper, target, moves)\n        moves.append(f\"{n} : {source} -> {target}\")\n        hanoi(n - 1, helper, target, source, moves)\n\n# main function\ndef main_solution(n, source, target, helper):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    moves = []\n    hanoi(n, source, target, helper, moves)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return json.dumps(moves)", "funcname": "main_solution", "ios": [{"input": {"n": 2, "source": "C", "target": "A", "helper": "B"}, "output": "[\"1 : C -> B\", \"2 : C -> A\", \"1 : B -> A\"]"}, {"input": {"n": 2, "source": "C", "target": "B", "helper": "A"}, "output": "[\"1 : C -> A\", \"2 : C -> B\", \"1 : A -> B\"]"}, {"input": {"n": 1, "source": "B", "target": "A", "helper": "C"}, "output": "[\"1 : B -> A\"]"}, {"input": {"n": 3, "source": "A", "target": "C", "helper": "B"}, "output": "[\"1 : A -> C\", \"2 : A -> B\", \"1 : C -> B\", \"3 : A -> C\", \"1 : B -> A\", \"2 : B -> C\", \"1 : A -> C\"]"}, {"input": {"n": 2, "source": "A", "target": "C", "helper": "B"}, "output": "[\"1 : A -> B\", \"2 : A -> C\", \"1 : B -> C\"]"}, {"input": {"n": 3, "source": "A", "target": "B", "helper": "C"}, "output": "[\"1 : A -> B\", \"2 : A -> C\", \"1 : B -> C\", \"3 : A -> B\", \"1 : C -> A\", \"2 : C -> B\", \"1 : A -> B\"]"}, {"input": {"n": 3, "source": "C", "target": "B", "helper": "A"}, "output": "[\"1 : C -> B\", \"2 : C -> A\", \"1 : B -> A\", \"3 : C -> B\", \"1 : A -> C\", \"2 : A -> B\", \"1 : C -> B\"]"}, {"input": {"n": 3, "source": "B", "target": "A", "helper": "C"}, "output": "[\"1 : B -> A\", \"2 : B -> C\", \"1 : A -> C\", \"3 : B -> A\", \"1 : C -> B\", \"2 : C -> A\", \"1 : B -> A\"]"}, {"input": {"n": 3, "source": "B", "target": "C", "helper": "A"}, "output": "[\"1 : B -> C\", \"2 : B -> A\", \"1 : C -> A\", \"3 : B -> C\", \"1 : A -> B\", \"2 : A -> C\", \"1 : B -> C\"]"}, {"input": {"n": 1, "source": "C", "target": "B", "helper": "A"}, "output": "[\"1 : C -> B\"]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "LingChenBill/python_first_introduce", "path": "/finance-base-learning/05-02-hanoi.py", "msgidx": 2963}}
{"problem_description": "Given a number of bracket pairs, what are all the possible combinations of balanced brackets that can be formed?", "io_requirements": "Input:\n  `n` (int): An integer representing the number of pairs of left and right brackets.\n\nOutput:\n  `return` (list of strings): A list containing all possible balanced bracket strings of size `2n`. Each string in the list is a valid combination of `n` left brackets `(` and `n` right brackets `)`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef brackets(n):\n    arr = []\n    # Subroutine to get brackets\n    def brackets_(left, right, string):\n        # Base case: we are done\n        if left == 0 and right == 0:\n            arr.append(string)\n        # Recursive step: append left bracket and need a right bracket to balance\n        if left > 0:\n            brackets_(left-1, right+1, string+'(')\n        # Recursive step: append right bracket (only happens after left bracket)\n        if right > 0:\n            brackets_(left, right-1, string+')')\n    # Sub routine call\n    brackets_(n,0,'')\n    return arr\n\n# main function\ndef main_solution(n):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = brackets(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "arcaputo3/algorithms", "path": "/coderbyte/brackets.py", "msgidx": 3317}}
{"problem_description": "Given a Tower of Hanoi puzzle with `n` disks, what is the sequence of steps required to move all disks from the starting pole to the ending pole, following the rules of the Tower of Hanoi?", "io_requirements": "Input:\n  `n` (int): The number of disks to be moved in the Tower of Hanoi problem.\n\nOutput:\n  `return` (str): A string containing the sequence of steps to solve the Tower of Hanoi problem for `n` disks. Each step is formatted as \"x. Move disk from A to B.\" where `x` is the step number, and `A` and `B` are the poles involved in the move.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef moveTower(n, src, dst, aux, steps=[]):\n    if n > 0:\n        # move n-1 disks from the starting pole to the middle pole via the ending pole\n        moveTower(n-1, src, aux, dst, steps)\n        # move the the most bottom disk from the starting pole to the ending pole\n        steps.append([src, dst])\n        # move the previously moved n-1 disks from the middle pole to the destination pole\n        # with help of the starting pole\n        moveTower(n-1, aux, dst, src, steps)\n    \n    return steps\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    ops = moveTower(n, 'starting pole', 'ending pole', 'middle pole', [])\n    steps = [\"{}. Move disk from {} to {}.\".format(y+1, x[0], x[1]) for y,x in enumerate(ops)]\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return '\\n'.join(steps)", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": "1. Move disk from starting pole to ending pole."}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "unabl4/PythonCodeClub", "path": "/hanoi/hanoi.py", "msgidx": 3037}}
{"problem_description": "Given a binary tree representing an arithmetic expression, where each leaf is an integer and each internal node is one of '+', '\u2212', '\u2217', or '/', what is the result of evaluating the expression represented by the tree?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys `data` (str or int), `left` (dict or int), and `right` (dict or int). If a node is a leaf, `left` and `right` will be integers.\n\nOutput:\n  `return` (int): The result of evaluating the arithmetic expression represented by the binary tree.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n    \n    def evaluateExpressionTree(self, root): \n        if root is None: \n            return 0\n      \n        if root.left is None and root.right is None: \n            return int(root.data) \n      \n        left_sum = self.evaluateExpressionTree(root.left) \n        right_sum = self.evaluateExpressionTree(root.right) \n      \n        if root.data == '+': \n            return left_sum + right_sum \n          \n        elif root.data == '-': \n            return left_sum - right_sum \n          \n        elif root.data == '*': \n            return left_sum * right_sum \n          \n        else: \n            return left_sum / right_sum \n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(structure):\n        if isinstance(structure, dict):\n            node = Node(structure['data'])\n            node.left = build_tree(structure['left'])\n            node.right = build_tree(structure['right'])\n            return node\n        else:\n            return Node(structure)\n    \n    root = build_tree(tree_structure)\n    \n    # Evaluate the expression tree\n    result = root.evaluateExpressionTree(root)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"data": "+", "left": 10, "right": 9}}, "output": 19}, {"input": {"tree_structure": {"data": "*", "left": 8, "right": 8}}, "output": 64}, {"input": {"tree_structure": {"data": "+", "left": 8, "right": 7}}, "output": 15}, {"input": {"tree_structure": {"data": "*", "left": 3, "right": 4}}, "output": 12}, {"input": {"tree_structure": {"data": "*", "left": 5, "right": 10}}, "output": 50}, {"input": {"tree_structure": {"data": "-", "left": 1, "right": 1}}, "output": 0}, {"input": {"tree_structure": {"data": "*", "left": 10, "right": 10}}, "output": 100}, {"input": {"tree_structure": {"data": "-", "left": 5, "right": 7}}, "output": -2}, {"input": {"tree_structure": {"data": "+", "left": 7, "right": 10}}, "output": 17}, {"input": {"tree_structure": {"data": "+", "left": 8, "right": 4}}, "output": 12}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jroach20/Portfolio", "path": "/Python/ExpressionTree.py", "msgidx": 3081}}
{"problem_description": "A farmer needs to transport a wolf, a sheep, and a cabbage across a river using a boat. The boat can only carry the farmer and one of the items at a time. If left unattended together, the wolf will eat the sheep, and the sheep will eat the cabbage. How can the farmer transport all items to the other side of the river without any of them being eaten? What is the sequence of states and the number of steps required to achieve this?", "io_requirements": "Input:\n  `initial_state` (dict): A dictionary representing the initial state of the wolf, sheep, cabbage, and boat.\n    - `wolf` (bool): True if the wolf is on the starting side, False otherwise.\n    - `sheep` (bool): True if the sheep is on the starting side, False otherwise.\n    - `cabbage` (bool): True if the cabbage is on the starting side, False otherwise.\n    - `boat` (bool): True if the boat (with the farmer) is on the starting side, False otherwise.\n  `final_state` (dict): A dictionary representing the final state of the wolf, sheep, cabbage, and boat.\n    - `wolf` (bool): True if the wolf is on the final side, False otherwise.\n    - `sheep` (bool): True if the sheep is on the final side, False otherwise.\n    - `cabbage` (bool): True if the cabbage is on the final side, False otherwise.\n    - `boat` (bool): True if the boat (with the farmer) is on the final side, False otherwise.\n\nOutput:\n  `return` (dict): A dictionary containing the solution and the number of steps.\n    - `solution` (list of str): A list of strings representing the sequence of states from the initial state to the final state.\n    - `steps` (int): The number of steps taken to reach the final state.", "refcode": "# import necessary packages\nfrom itertools import product\nfrom typing import NamedTuple\n\n# all class and function definitions in the code file, if any\nclass State(NamedTuple):\n    \"\"\"\n    Represents the presence of the wolf, the sheep, the cabbage and\n    the boat (with the farmer) on the starting side\n    \"\"\"\n    wolf: bool\n    sheep: bool\n    cabbage: bool\n    boat: bool\n\n    def __str__(self):\n        return (f'({int(self.wolf)},'\n                f' {int(self.sheep)},'\n                f' {int(self.cabbage)},'\n                f' {int(self.boat)})')\n\n    def __repr__(self):\n        return str(self)\n\n\ndef valid(state):\n    w, s, c, b = state\n    return (w != s or w == b) and (s != c or s == b)\n\n\ndef has_edge(s1, s2):\n    if s1.boat == s2.boat:\n        return False\n\n    w = s1.wolf == s2.wolf\n    s = s1.sheep == s2.sheep\n    c = s1.cabbage == s2.cabbage\n\n    return (w + s + c) in (2, 3)\n\n\ndef dijkstra(graph, initial, final):\n    \"\"\"\n    A simplified Dijkstra's algorithm implementation to find the shortest path\n    in an unweighted graph.\n    \"\"\"\n    queue = [initial]\n    visited = set()\n    parent = {initial: None}\n\n    while queue:\n        current = queue.pop(0)\n        if current == final:\n            break\n        if current in visited:\n            continue\n        visited.add(current)\n\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                parent[neighbor] = current\n\n    if final not in parent:\n        return []\n\n    path = []\n    node = final\n    while node is not None:\n        path.append(node)\n        node = parent[node]\n    path.reverse()\n    return path\n\n\n# main function\ndef main_solution(initial_state, final_state):\n    # Convert JSON serializable inputs to original input variables\n    initial = State(**initial_state)\n    final = State(**final_state)\n\n    # Generate all valid states\n    states = {\n        s\n        for s in (State(*t) for t in product({True, False}, repeat=4))\n        if valid(s)\n    }\n\n    # Create the graph\n    graph = {\n        s1: {s2 for s2 in states if has_edge(s1, s2)}\n        for s1 in states\n    }\n\n    # Find the solution using Dijkstra's algorithm\n    solution = dijkstra(graph, initial, final)\n\n    # Convert the solution to JSON serializable output\n    solution_str = [str(state) for state in solution]\n\n    return {\"solution\": solution_str, \"steps\": len(solution)}", "funcname": "main_solution", "ios": [{"input": {"initial_state": {"wolf": true, "sheep": true, "cabbage": true, "boat": true}, "final_state": {"wolf": false, "sheep": false, "cabbage": false, "boat": false}}, "output": {"solution": ["(1, 1, 1, 1)", "(1, 0, 1, 0)", "(1, 0, 1, 1)", "(1, 0, 0, 0)", "(1, 1, 0, 1)", "(0, 1, 0, 0)", "(0, 1, 0, 1)", "(0, 0, 0, 0)"], "steps": 8}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "caiopo/tundra", "path": "/examples/wolf_sheep_cabbage.py", "msgidx": 2767}}
{"problem_description": "Given an 8x8 chessboard, you need to place 8 queens such that no two queens threaten each other. The first queen is placed in the first row at a specified column. What is the configuration of the queens on the board that satisfies these conditions?", "io_requirements": "Input:\n  `start` (int): The column number (1 to 8) where the first queen is placed in the first row.\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the positions of the queens on the board. Each tuple contains two integers (row, column) indicating the position of a queen. If no solution is found, an empty list is returned.", "refcode": "# import necessary packages\nimport json\n\n# main function\ndef main_solution(start):\n    board = []\n    size = 8\n\n    def danger(row, col):\n        for (i, j) in board:\n            if row == i: return True\n            if col == j: return True\n            if abs(row - i) == abs(col - j): return True\n        return False\n\n    def placeq(row):\n        if row > size:\n            return board  # Return the board configuration when all queens are placed\n        else:\n            for col in range(1, size + 1):\n                if not danger(row, col):\n                    board.append((row, col))\n                    result = placeq(row + 1)\n                    if result:  # If a valid configuration is found, return it\n                        return result\n                    board.remove((row, col))\n        return None  # Return None if no valid configuration is found\n\n    board.append((1, start))\n    result = placeq(2)\n    return result if result else []  # Return the board configuration or an empty list if no solution", "funcname": "main_solution", "ios": [{"input": {"start": 3}, "output": [[1, 3], [2, 1], [3, 7], [4, 5], [5, 8], [6, 2], [7, 4], [8, 6]]}, {"input": {"start": 5}, "output": [[1, 5], [2, 1], [3, 4], [4, 6], [5, 8], [6, 2], [7, 7], [8, 3]]}, {"input": {"start": 1}, "output": [[1, 1], [2, 5], [3, 8], [4, 6], [5, 3], [6, 7], [7, 2], [8, 4]]}, {"input": {"start": 4}, "output": [[1, 4], [2, 1], [3, 5], [4, 8], [5, 2], [6, 7], [7, 3], [8, 6]]}, {"input": {"start": 2}, "output": [[1, 2], [2, 4], [3, 6], [4, 8], [5, 3], [6, 1], [7, 7], [8, 5]]}, {"input": {"start": 8}, "output": [[1, 8], [2, 2], [3, 4], [4, 1], [5, 7], [6, 5], [7, 3], [8, 6]]}, {"input": {"start": 6}, "output": [[1, 6], [2, 1], [3, 5], [4, 2], [5, 8], [6, 3], [7, 7], [8, 4]]}, {"input": {"start": 7}, "output": [[1, 7], [2, 1], [3, 3], [4, 8], [5, 6], [6, 4], [7, 2], [8, 5]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bhushan-cool/pg", "path": "/8queen/qtest.py", "msgidx": 3028}}
{"problem_description": "Given an initial configuration of an 8-puzzle board and a goal configuration, what is the cost of the current state of the puzzle board when using a specified heuristic type to evaluate the distance to the goal state?", "io_requirements": "Input:\n  `initial_state` (list of integers): A list of 9 integers representing the initial state of the 8-puzzle board. The list should contain integers from 0 to 8, where 0 represents the blank space.\n  `goal_state` (list of integers): A list of 9 integers representing the goal state of the 8-puzzle board. The list should contain integers from 0 to 8, where 0 represents the blank space.\n  `heuristic_type` (int): An integer representing the type of heuristic to use for calculating the cost. 0 for Manhattan distance, 1 for misplaced tiles.\n\nOutput:\n  `return` (int): An integer representing the cost of the current state of the puzzle board based on the specified heuristic type.", "refcode": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\nclass EightPuzzle:\n    def __init__(self):\n        self.board = [[None for i in range(3)] for j in range(3)]\n        self.correct_positions = {}\n        self.blank_pos = []\n\n    def start_positions(self, positions):\n        k = 0\n        for i in range(3):\n            for j in range(3):\n                self.board[i][j] = positions[k]\n                if positions[k] == 0:\n                    self.blank_pos = [i, j]\n                k += 1\n\n    def set_goal_state(self, goal_state):\n        for i in range(len(goal_state)):\n            self.correct_positions[goal_state[i]] = [i // 3, i % 3]\n\n    def current_cost(self, htype):\n        cost = 0\n        if htype == 0:\n            for i in range(3):\n                for j in range(3):\n                    if not self.board[i][j] == 0:\n                        cost += abs(i - self.correct_positions[self.board[i][j]][0]) + abs(j - self.correct_positions[self.board[i][j]][1])\n        else:\n            for i in range(3):\n                for j in range(3):\n                    if not self.board[i][j] == 0:\n                        cost += 0 if abs(i - self.correct_positions[self.board[i][j]][0]) + abs(j - self.correct_positions[self.board[i][j]][1]) == 0 else 1\n        return cost\n\n    def options(self):\n        move_options = []\n        if self.blank_pos[0] - 1 >= 0:\n            up = [self.blank_pos[0] - 1, self.blank_pos[1]]\n            move_options.append(self.pseudomove(up))\n\n        if self.blank_pos[0] + 1 <= 2:\n            down = [self.blank_pos[0] + 1, self.blank_pos[1]]\n            move_options.append(self.pseudomove(down))\n\n        if self.blank_pos[1] - 1 >= 0:\n            left = [self.blank_pos[0], self.blank_pos[1] - 1]\n            move_options.append(self.pseudomove(left))\n\n        if self.blank_pos[1] + 1 <= 2:\n            right = [self.blank_pos[0], self.blank_pos[1] + 1]\n            move_options.append(self.pseudomove(right))\n\n        return move_options\n\n    def pseudomove(self, frm):\n        pseudoboard = copy.deepcopy(self.board)\n        pseudoboard[self.blank_pos[0]][self.blank_pos[1]] = pseudoboard[frm[0]][frm[1]]\n        pseudoboard[frm[0]][frm[1]] = 0\n        return pseudoboard\n\n# main function\ndef main_solution(initial_state, goal_state, heuristic_type):\n    puzzle = EightPuzzle()\n    puzzle.start_positions(initial_state)\n    puzzle.set_goal_state(goal_state)\n    cost = puzzle.current_cost(heuristic_type)\n    return cost", "funcname": "main_solution", "ios": [{"input": {"initial_state": [0, 4, 1, 3, 5, 7, 2, 6, 8], "goal_state": [0, 3, 1, 4, 6, 2, 5, 7, 8], "heuristic_type": 1}, "output": 6}, {"input": {"initial_state": [0, 4, 7, 1, 2, 8, 3, 5, 6], "goal_state": [8, 0, 1, 5, 6, 4, 2, 3, 7], "heuristic_type": 0}, "output": 17}, {"input": {"initial_state": [4, 1, 6, 5, 8, 0, 3, 2, 7], "goal_state": [8, 0, 2, 7, 4, 6, 5, 3, 1], "heuristic_type": 1}, "output": 8}, {"input": {"initial_state": [1, 8, 6, 4, 2, 5, 7, 0, 3], "goal_state": [0, 1, 6, 7, 3, 4, 5, 2, 8], "heuristic_type": 1}, "output": 7}, {"input": {"initial_state": [0, 4, 2, 1, 8, 7, 5, 3, 6], "goal_state": [3, 0, 1, 5, 8, 2, 4, 7, 6], "heuristic_type": 0}, "output": 13}, {"input": {"initial_state": [5, 7, 4, 8, 0, 1, 6, 3, 2], "goal_state": [1, 2, 0, 4, 6, 3, 8, 7, 5], "heuristic_type": 0}, "output": 20}, {"input": {"initial_state": [0, 3, 6, 2, 7, 8, 5, 1, 4], "goal_state": [1, 7, 3, 5, 0, 8, 2, 4, 6], "heuristic_type": 0}, "output": 10}, {"input": {"initial_state": [1, 8, 0, 7, 6, 3, 2, 4, 5], "goal_state": [4, 5, 1, 8, 2, 0, 3, 6, 7], "heuristic_type": 1}, "output": 8}, {"input": {"initial_state": [2, 5, 0, 1, 6, 4, 7, 8, 3], "goal_state": [2, 0, 6, 8, 4, 3, 7, 1, 5], "heuristic_type": 1}, "output": 6}, {"input": {"initial_state": [4, 8, 6, 5, 7, 0, 1, 2, 3], "goal_state": [1, 4, 6, 3, 2, 0, 7, 5, 8], "heuristic_type": 1}, "output": 7}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "anirudhnarayanan/Intelligent-Systems-Projects", "path": "/Assignment-1/EightPuzzle.py", "msgidx": 2962}}
{"problem_description": "Given a number of inputs, what are the possible decomposition patterns for these inputs, and how many such patterns exist?", "io_requirements": "Input:\n  `ni` (int): The number of inputs for which to generate decomposition patterns. Must be greater than or equal to 3.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `n_pat` (int): The number of decomposition patterns generated.\n    - `patterns` (list of lists of int): A list of decomposition patterns, where each pattern is a list of integers.", "refcode": "# import necessary packages\nimport sys\n\n# all class and function definitions in the code file, if any\ndef pg_sub(n, i0):\n    \"\"\"n \u5165\u529b\u306e\u5206\u89e3\u30d1\u30bf\u30f3\u3092\u5217\u6319\u3059\u308b\uff0e\n\n    \u4e00\u3064\u306e\u30d1\u30bf\u30f3\u306f\u6574\u6570\u306e\u30ea\u30b9\u30c8\n    \u3053\u306e\u95a2\u6570\u306f i0 \u304b\u3089\u59cb\u307e\u308b n \u500b\u306e\u30d1\u30bf\u30f3\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\uff0e\n    \"\"\"\n\n    if n == 1:\n        return [[i0]]\n\n    elif n == 2:\n        return [[-1, i0, i0 + 1]]\n\n    else:\n        pat_list = []\n        for nl in range(1, n):\n            nr = n - nl\n            pat_l_list = pg_sub(nl, i0)\n            pat_r_list = pg_sub(nr, i0 + nl)\n\n            for pat_l in pat_l_list:\n                for pat_r in pat_r_list:\n                    pat = [-1] + pat_l + pat_r\n                    pat_list.append(pat)\n\n        return pat_list\n\n# main function\ndef main_solution(ni):\n    \"\"\"ni \u500b\u306e\u5206\u89e3\u30d1\u30bf\u30f3\u7528\u306e\u914d\u5217\u30c7\u30fc\u30bf\u3092\u751f\u6210\u3059\u308b\uff0e\"\"\"\n    if ni < 3:\n        return {\"error\": \"ni must be greater than or equal to 3\"}\n\n    pat_list = pg_sub(ni, 0)\n    nl = len(pat_list)\n    ne = ni * 2 - 1\n\n    patterns = []\n    for p in range(0, nl):\n        pat = pat_list[p]\n        line = [pat[i] for i in range(0, ne)]\n        patterns.append(line)\n\n    return {\"n_pat\": nl, \"patterns\": patterns}", "funcname": "main_solution", "ios": [{"input": {"ni": 3}, "output": {"n_pat": 2, "patterns": [[-1, 0, -1, 1, 2], [-1, -1, 0, 1, 2]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yusuke-matsunaga/ym-cell", "path": "/c++-srcs/cgmgr/patgen.py", "msgidx": 3227}}
{"problem_description": "A monkey eats peaches in a peculiar way. On the first day, it eats half of the total peaches and then eats one more. Each subsequent day, it continues to eat half of the remaining peaches plus one more. On the last day, only one peach is left. How many peaches did the monkey initially have on the first day if the process lasted for a given number of days?", "io_requirements": "Input:\n  `days` (int): The number of days the monkey eats the peaches. It should be a positive integer.\n\nOutput:\n  `return` (int): The total number of peaches the monkey initially had on the first day.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(days):\n    remain = 1\n    for x in range(days - 1, 0, -1):\n        remain = (remain + 1) * 2\n    total = remain\n    return total", "funcname": "main_solution", "ios": [{"input": {"days": 6}, "output": 94}, {"input": {"days": 20}, "output": 1572862}, {"input": {"days": 16}, "output": 98302}, {"input": {"days": 15}, "output": 49150}, {"input": {"days": 14}, "output": 24574}, {"input": {"days": 11}, "output": 3070}, {"input": {"days": 12}, "output": 6142}, {"input": {"days": 13}, "output": 12286}, {"input": {"days": 8}, "output": 382}, {"input": {"days": 17}, "output": 196606}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wonderning/pythonbiteme", "path": "/quiz21.py", "msgidx": 3263}}
{"problem_description": "In a remote archipelago, a team of cartographers is mapping the islands. They have provided a grid representation of the land and water regions. Each cell in the grid is either land (represented by `1`) or water (represented by `0`). The team needs to determine the sizes of all the islands in the grid. An island is defined as a group of connected land cells, where connectivity is defined as being adjacent horizontally or vertically (not diagonally). What are the sizes of the islands in the given grid?", "io_requirements": "Input:\n  `land_map` (list of lists of int): A 2D grid representing the land map. Each cell in the grid is either `0` (water) or `1` (land). The size of the grid should be reasonable, typically less than 10x10.\n\nOutput:\n  `return` (list of int): A sorted list of integers representing the sizes of the islands found in the land map. Each integer in the list corresponds to the number of land cells in a connected island.", "refcode": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef is_neighbor(x1, y1, x2, y2):\n    return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) < 2\n\ndef get_island(point, land):\n    island = [point]\n\n    for piece in land.copy():\n        if is_neighbor(*point, *piece) and piece not in island:\n            land.remove(piece)\n            island.extend(get_island(piece, land))\n\n    return island\n\ndef checkio(land_map):\n    land = []\n    islands = []\n\n    for y, row in enumerate(land_map):\n        for x, col in enumerate(row):\n            if col:\n                land.append((x, y))\n\n    while land:\n        islands.append(len(get_island(land.pop(), land)))\n\n    return sorted(islands)\n\n# main function\ndef main_solution(land_map):\n    # Convert the input to the required format\n    land_map = [[int(cell) for cell in row] for row in land_map]\n    \n    # Call the original function\n    result = checkio(land_map)\n    \n    # Convert the result to a JSON serializable format\n    return result", "funcname": "main_solution", "ios": [{"input": {"land_map": [[0, 1, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 1]]}, "output": [1, 6]}, {"input": {"land_map": [[1, 1, 0, 1], [0, 0, 0, 0], [0, 0, 1, 1], [1, 1, 0, 1]]}, "output": [1, 2, 5]}, {"input": {"land_map": [[1, 1, 1, 0], [1, 1, 0, 1], [1, 0, 0, 0], [0, 0, 0, 0]]}, "output": [7]}, {"input": {"land_map": [[1, 0, 0, 1], [0, 0, 0, 0], [1, 1, 1, 0], [1, 1, 1, 1]]}, "output": [1, 1, 7]}, {"input": {"land_map": [[0, 0, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [1, 0, 1, 1]]}, "output": [10]}, {"input": {"land_map": [[1, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [0, 1, 0, 1]]}, "output": [11]}, {"input": {"land_map": [[0, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0]]}, "output": [2, 3]}, {"input": {"land_map": [[1, 1, 1, 1], [1, 0, 1, 1], [0, 0, 0, 0], [0, 1, 1, 0]]}, "output": [2, 7]}, {"input": {"land_map": [[0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 1, 1, 1]]}, "output": [8]}, {"input": {"land_map": [[1, 1, 1, 1], [0, 0, 1, 0], [1, 1, 0, 1], [0, 1, 1, 1]]}, "output": [11]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Volaxar/checkio", "path": "/calculate-islands.py", "msgidx": 3253}}
{"problem_description": "In the classic Tower of Hanoi puzzle, there are three rods and a number of disks of different sizes that can slide onto any rod. The puzzle starts with the disks neatly stacked in ascending order of size on one rod, the smallest at the top. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:\n1. Only one disk can be moved at a time.\n2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.\n3. No disk may be placed on top of a smaller disk.\n\nGiven the number of disks `n`, how many moves are required to solve the Tower of Hanoi puzzle?", "io_requirements": "Input:\n  `n` (int): The number of disks in the Tower of Hanoi problem.\n\nOutput:\n  `return` (int): The total number of moves required to solve the Tower of Hanoi problem with `n` disks.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef hanoi(n, x, y, z, count):\n    count[0] += 1\n    if n == 1:\n        pass  # No need to print or move, just count\n    else:\n        hanoi(n-1, x, z, y, count)  # Move n-1 disks from x to y\n        hanoi(n-1, y, x, z, count)  # Move n-1 disks from y to z\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = [0]  # Use a list to hold the count to make it mutable\n    hanoi(n, 'X', 'Y', 'Z', count)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count[0]", "funcname": "main_solution", "ios": [{"input": {"n": 6}, "output": 63}, {"input": {"n": 8}, "output": 255}, {"input": {"n": 10}, "output": 1023}, {"input": {"n": 3}, "output": 7}, {"input": {"n": 4}, "output": 15}, {"input": {"n": 2}, "output": 3}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 7}, "output": 127}, {"input": {"n": 5}, "output": 31}, {"input": {"n": 9}, "output": 511}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yebanxinghui/py_program", "path": "/py_program/\u6c49\u8bfa\u5854.py", "msgidx": 3422}}
{"problem_description": "Given a graph with a certain number of vertices and a set of edges connecting these vertices, determine whether the graph contains any cycles. The graph is undirected and does not have any self-loops or parallel edges. What is the result indicating the presence of cycles in the graph?", "io_requirements": "Input:\n  `V` (int): The number of vertices in the graph.\n  `edges` (list of tuples): Each tuple represents an edge between two vertices. Each tuple contains two integers representing the vertices connected by the edge.\n\nOutput:\n  `return` (bool): `True` if the graph contains a cycle, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self, V, edges):\n        \"\"\"\n        Args:\n            V: int, number of vertices\n            edges: list of tuples, each tuple represents an edge between two vertices\n        \"\"\"\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        for v, w in edges:\n            self.adj[v].append(w)\n            self.adj[w].append(v)\n\nclass Cycle:\n    def __init__(self, G):\n        \"\"\"\n        Args:\n            G: Graph\n        \"\"\"\n        self.marked = [False for _ in range(G.V)]\n        self.has_cycle = False\n        for s in range(G.V):\n            if not self.marked[s]:\n                self.dfs(G, s, s)\n\n    def dfs(self, G, v, u):\n        \"\"\"\n        Args:\n            G: Graph\n            v: int\n            u: int\n        \"\"\"\n        self.marked[v] = True\n        for w in G.adj[v]:\n            if not self.marked[w]:\n                self.dfs(G, w, v)\n            elif w != u:\n                self.has_cycle = True\n\n# main function\ndef main_solution(V, edges):\n    \"\"\"\n    Args:\n        V: int, number of vertices in the graph\n        edges: list of tuples, each tuple represents an edge between two vertices\n    \"\"\"\n    # Convert JSON serializable inputs to the original input variables\n    G = Graph(V, edges)\n    cycle_checker = Cycle(G)\n    \n    # Return the result, which must be JSON serializable\n    return cycle_checker.has_cycle", "funcname": "main_solution", "ios": [{"input": {"V": 3, "edges": [[0, 1], [0, 2], [1, 2]]}, "output": true}, {"input": {"V": 3, "edges": []}, "output": false}, {"input": {"V": 4, "edges": [[0, 2], [1, 3]]}, "output": false}, {"input": {"V": 5, "edges": [[0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]}, "output": true}, {"input": {"V": 5, "edges": [[0, 1], [0, 2], [0, 4], [1, 4], [3, 4]]}, "output": true}, {"input": {"V": 4, "edges": [[1, 2], [1, 3], [2, 3]]}, "output": true}, {"input": {"V": 4, "edges": [[0, 1], [0, 2], [0, 3], [2, 3]]}, "output": true}, {"input": {"V": 5, "edges": [[0, 1], [0, 3], [1, 3], [1, 4], [2, 4]]}, "output": true}, {"input": {"V": 4, "edges": [[0, 1], [1, 2], [1, 3]]}, "output": false}, {"input": {"V": 5, "edges": [[0, 2], [1, 2], [2, 3]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AiZhanghan/Algorithms-Fourth-Edition", "path": "/code/chapter4/Cycle.py", "msgidx": 3362}}
{"problem_description": "Given a set of disks arranged in ascending order on a peg, how can you move all the disks to another peg following the rules of the Tower of Hanoi puzzle, and what will be the final arrangement of the disks on the destination peg?", "io_requirements": "Input:\n  `A` (List[int]): A list of integers representing the disks on the first peg in ascending order. The length of the list represents the number of disks.\n\nOutput:\n  `return` (List[int]): A list of integers representing the disks on the third peg in ascending order after all disks have been moved from the first peg to the third peg.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef hanota(A: List[int], B: List[int], C: List[int]) -> None:\n    '''\n    \u9012\u5f52\u6cd5\n    :param A:\n    :param B:\n    :param C:\n    :return:\n    '''\n\n    def move(A, B, C, n):\n        if n == 1:\n            C.append(A.pop())\n            return\n\n        move(A, C, B, n - 1)  # \u901a\u8fc7 C \u628a A\u4e2dn-1\u79fb\u52a8\u5230B\u4e2d\n        C.append(A.pop())  # \u628aA\u4e2d\u6700\u540e\u4e00\u4e2a\u76d8\u79fb\u52a8\u5230C\n        move(B, A, C, n - 1)  # \u901a\u8fc7A\u67f1 \uff0c\u628aB\u67f1n-1\u4e2a\u76d8\u79fb\u52a8\u5230C\n\n    n = len(A)\n    move(A, B, C, n)\n\n# main function\ndef main_solution(A: List[int]) -> List[int]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    B = []\n    C = []\n    hanota(A, B, C)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return C", "funcname": "main_solution", "ios": [{"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5, 6]}, {"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}, {"input": {"A": []}, "output": [0]}, {"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5, 6, 7]}, {"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5]}, {"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5, 6, 7, 8]}, {"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5]}, {"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5, 6]}, {"input": {"A": []}, "output": [0, 1, 2, 3, 4, 5]}, {"input": {"A": []}, "output": [0, 1, 2]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "fsc2016/LeetCode", "path": "/code/32_\u6c49\u7f57\u5854.py", "msgidx": 3614}}
{"problem_description": "Given the concept of Lychrel numbers, which are numbers that do not form a palindrome through the reverse and add process within fifty iterations, how many such numbers exist below a certain threshold? Specifically, what is the count of Lychrel numbers below a given upper limit?", "io_requirements": "Input:\n  `cap` (int): The upper limit for the range of numbers to check for Lychrel numbers. It should be a positive integer.\n\nOutput:\n  `return` (int): The count of Lychrel numbers found below the given `cap`.", "refcode": "# import necessary packages\nimport time\n\n# all class and function definitions in the code file, if any\ndef isPal(n):\n    s = str(n)\n    return s == s[::-1]\n\ndef isLychrel(n):\n    count = 0\n    curr = n + int(str(n)[::-1])\n    for _ in range(50):\n        if isPal(curr):\n            return False\n        curr = curr + int(str(curr)[::-1])\n    return True\n\n# main function\ndef main_solution(cap):\n    count = 0\n    for i in range(1, cap):\n        if isLychrel(i):\n            count += 1\n    return count", "funcname": "main_solution", "ios": [{"input": {"cap": 6193}, "output": 102}, {"input": {"cap": 6832}, "output": 117}, {"input": {"cap": 1687}, "output": 19}, {"input": {"cap": 5855}, "output": 95}, {"input": {"cap": 6864}, "output": 119}, {"input": {"cap": 4711}, "output": 66}, {"input": {"cap": 7948}, "output": 150}, {"input": {"cap": 2349}, "output": 26}, {"input": {"cap": 3783}, "output": 47}, {"input": {"cap": 5653}, "output": 87}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ericthansen/ProjectEulerSolutions", "path": "/pe55.py", "msgidx": 3277}}
{"problem_description": "Given a set of unique digits, what is the largest prime number that can be formed by rearranging these digits?", "io_requirements": "Input:\n  `digits` (list of int): A list of digits from which to generate pandigital numbers. The length of the list should be between 1 and 9.\n\nOutput:\n  `return` (int): The largest prime number that can be formed by rearranging the given digits. If no prime number can be formed, the function returns 0.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isprime(x):\n    m = int(math.sqrt(x)) + 1\n    for i in range(3, m, 2):\n        if x % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    digits = list(digits)  # Ensure digits is a list\n    bigprime = 0\n\n    def pangen(ds, n, pan):\n        nonlocal bigprime\n        for i in range(0, len(ds), 2 if n == 0 else 1):\n            l = list(ds)\n            v = l.pop(i)\n            pangen(l, n + 1, 10 ** n * v + pan)\n        if n == len(digits):\n            if isprime(pan) and pan > bigprime:\n                bigprime = pan\n        return False\n\n    for i in range(len(digits)):\n        pangen(list(digits), 0, 0)\n        digits.pop()\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return bigprime", "funcname": "main_solution", "ios": [{"input": {"digits": [4, 5, 3, 8, 2, 1, 7, 6, 9]}, "output": 854213}, {"input": {"digits": [7, 4]}, "output": 47}, {"input": {"digits": [6, 3, 7]}, "output": 376}, {"input": {"digits": [5, 2, 3, 6]}, "output": 5623}, {"input": {"digits": [2, 6, 1]}, "output": 62}, {"input": {"digits": [5, 8, 7, 3, 2, 9, 4, 6, 1]}, "output": 98765234}, {"input": {"digits": [6, 8, 5, 1, 2, 7, 4, 9, 3]}, "output": 876152}, {"input": {"digits": [4, 7, 3, 8, 5, 9]}, "output": 7834}, {"input": {"digits": [6, 4, 8, 3, 9, 5]}, "output": 985346}, {"input": {"digits": [8, 4, 2, 3, 6, 7]}, "output": 84362}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Derexas/Euler", "path": "/41.py", "msgidx": 3640}}
{"problem_description": "Given a range of numbers, what are the unusual prime triplets within that range, where each triplet consists of three prime numbers that have the same digits in different orders?", "io_requirements": "Input:\n  `start_range` (int): The starting number of the range within which to search for unusual prime triplets. Must be between 1000 and 9995.\n  `end_range` (int): The ending number of the range within which to search for unusual prime triplets. Must be between 1001 and 9999.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents an unusual prime triplet found within the specified range. Each string is formatted as \"abc\" where a, b, and c are the three prime numbers forming the unusual triplet.", "refcode": "# import necessary packages\nfrom sympy import isprime\n\n# all class and function definitions in the code file, if any\ndef is_unusual(a, b, c, primes):\n    if not(primes[a] and primes[b] and primes[c]):\n        return False\n    if \"\".join(sorted(str(a))) == \"\".join(sorted(str(b))) and \"\".join(sorted(str(a))) == \"\".join(sorted(str(c))):\n        return True\n    return False\n\n# main function\ndef main_solution(start_range, end_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    primes = {i: isprime(i) for i in range(1000, 10000)}\n    unusuals = []\n\n    for i in range(start_range, end_range - 4):\n        for d in range(2, (end_range - i) // 2 + 1, 2):\n            if is_unusual(i, i + d, i + d + d, primes):\n                unusuals.append(f\"{i}{i + d}{i + d + d}\")\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return unusuals", "funcname": "main_solution", "ios": [{"input": {"start_range": 4141, "end_range": 6109}, "output": []}, {"input": {"start_range": 3974, "end_range": 7027}, "output": []}, {"input": {"start_range": 2423, "end_range": 3665}, "output": []}, {"input": {"start_range": 4303, "end_range": 4917}, "output": []}, {"input": {"start_range": 7313, "end_range": 8708}, "output": []}, {"input": {"start_range": 7811, "end_range": 9729}, "output": []}, {"input": {"start_range": 1973, "end_range": 8711}, "output": []}, {"input": {"start_range": 4407, "end_range": 8525}, "output": []}, {"input": {"start_range": 8033, "end_range": 8061}, "output": []}, {"input": {"start_range": 2881, "end_range": 5121}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sampdubs/project-euler-solutions", "path": "/49.py", "msgidx": 3396}}
{"problem_description": "In a game, you have a sequence of colored balls on a board and a set of colored balls in your hand. You need to determine the minimum number of balls from your hand that are required to clear the board by making sequences of three or more same-colored balls disappear. Given the sequence of balls on the board (`board`) and the sequence of balls in your hand (`hand`), how many balls from your hand are needed to clear the board?", "io_requirements": "Input:\n  `board` (str): A string representing the sequence of colored balls on the board. Each character represents a ball of a specific color.\n  `hand` (str): A string representing the sequence of colored balls in the hand. Each character represents a ball of a specific color.\n\nOutput:\n  `return` (int): The minimum number of balls needed from the hand to clear the board. If it's not possible to clear the board, it returns -1.", "refcode": "# import necessary packages\nimport collections\n\n# main function\ndef main_solution(board, hand):\n    # Convert the hand string to a Counter object\n    hand_counter = collections.Counter(hand)\n    \n    def dfs(board, hand):\n        if not board:\n            return 0\n        res = float(\"inf\")\n        i = 0\n        while i < len(board):\n            j = i + 1\n            while j < len(board) and board[i] == board[j]:\n                j += 1\n            need = 3 - (j - i)\n            if hand[board[i]] >= need:\n                need = max(0, need)  # To handle already connected balls, and the number of balls might be more than 3\n                hand[board[i]] -= need\n                temp = dfs(board[:i] + board[j:], hand)\n                if temp >= 0:\n                    res = min(res, need + temp)\n                hand[board[i]] += need\n            i = j\n        return res if res != float('inf') else -1\n    \n    # Call the dfs function with the board and hand counter\n    result = dfs(board, hand_counter)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": "EEEAE", "hand": "CDECDD"}, "output": -1}, {"input": {"board": "DBEAEEB", "hand": "BAAECB"}, "output": -1}, {"input": {"board": "EBABBBCEB", "hand": "ADE"}, "output": -1}, {"input": {"board": "BEEEABB", "hand": "DEBB"}, "output": -1}, {"input": {"board": "BEBAAEBC", "hand": "EDE"}, "output": -1}, {"input": {"board": "BCDEEDE", "hand": "BBB"}, "output": -1}, {"input": {"board": "ADAEBAEC", "hand": "DBDB"}, "output": -1}, {"input": {"board": "ABBDE", "hand": "AACBE"}, "output": -1}, {"input": {"board": "DAEDBCDAA", "hand": "CDB"}, "output": -1}, {"input": {"board": "EAAEA", "hand": "DACDA"}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Fangyi0917/Algorithm", "path": "/leetcode/BFS&&DFS/\u7956\u739b\u6e38\u620f.py", "msgidx": 3821}}
{"problem_description": "Imagine you have a binary watch with 4 LEDs for the hours and 6 LEDs for the minutes. Each LED represents a binary digit (0 or 1), and the number of LEDs that are currently on is given by `num`. What are all the possible times that the watch could display with exactly `num` LEDs turned on?", "io_requirements": "Input:\n  `num` (int): The number of LEDs that are currently on. It should be a non-negative integer.\n\nOutput:\n  `return` (List[str]): A list of strings representing all possible times the watch could display with the given number of LEDs on. Each time is formatted as \"HH:MM\", where \"HH\" is the hour (0-11) and \"MM\" is the minute (00-59).", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(num: int) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = []\n    for hour in range(12):\n        for minute in range(60):\n            if bin(hour).count('1') + bin(minute).count('1') == num:\n                if minute < 10:\n                    result.append(f\"{hour}:0{minute}\")\n                else:\n                    result.append(f\"{hour}:{minute}\")\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"num": 8}, "output": ["7:31", "7:47", "7:55", "7:59", "11:31", "11:47", "11:55", "11:59"]}, {"input": {"num": 1}, "output": ["0:01", "0:02", "0:04", "0:08", "0:16", "0:32", "1:00", "2:00", "4:00", "8:00"]}, {"input": {"num": 0}, "output": ["0:00"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "UX404/Leetcode-Exercises", "path": "/#401 Binary Watch.py", "msgidx": 3386}}
{"problem_description": "Given a sequence of integers representing the values of nodes in a singly-linked list, what is the sequence of values after reversing the linked list?", "io_requirements": "Input:\n  `values` (list of integers): A list of integers representing the values of the nodes in the linked list.\n\nOutput:\n  `return` (list of integers): A list of integers representing the values of the nodes in the reversed linked list.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n# Helper function to convert a list of values to a linked list\ndef list_to_linked_list(values):\n    if not values:\n        return None\n    head = ListNode(values[0])\n    current = head\n    for value in values[1:]:\n        current.next = ListNode(value)\n        current = current.next\n    return head\n\n# Helper function to convert a linked list to a list of values\ndef linked_list_to_list(head):\n    values = []\n    while head:\n        values.append(head.val)\n        head = head.next\n    return values\n\n# main function\ndef main_solution(values):\n    # Convert the input list of values to a linked list\n    head = list_to_linked_list(values)\n    \n    # Reverse the linked list using the double pointer method\n    cur = None\n    flag = head\n    while flag != None:\n        flag = head.next\n        head.next = cur\n        cur = head\n        head = flag\n    \n    # Convert the reversed linked list back to a list of values\n    reversed_values = linked_list_to_list(cur)\n    \n    # Return the reversed list of values\n    return reversed_values", "funcname": "main_solution", "ios": [{"input": {"values": [41]}, "output": [41]}, {"input": {"values": [34, 27]}, "output": [27, 34]}, {"input": {"values": [81, 32, 70, 17, 4, 22, 79, 62, 37, 76]}, "output": [76, 37, 62, 79, 22, 4, 17, 70, 32, 81]}, {"input": {"values": [34, 53, 51, 54, 90, 71]}, "output": [71, 90, 54, 51, 53, 34]}, {"input": {"values": [52, 37, 82, 87, 61, 96, 46, 18]}, "output": [18, 46, 96, 61, 87, 82, 37, 52]}, {"input": {"values": [9, 6, 57, 2]}, "output": [2, 57, 6, 9]}, {"input": {"values": [36, 54, 90]}, "output": [90, 54, 36]}, {"input": {"values": [53, 18, 86, 92, 40, 28, 41]}, "output": [41, 28, 40, 92, 86, 18, 53]}, {"input": {"values": [19, 29, 17, 59, 55]}, "output": [55, 59, 17, 29, 19]}, {"input": {"values": [61]}, "output": [61]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "NeroSong/algorithm-exercises", "path": "/leetcode/206-\u53cd\u8f6c\u5355\u94fe\u8868.py", "msgidx": 3420}}
{"problem_description": "Given a boolean expression composed of 't' (true), 'f' (false), '!', '&', '|', '(', ')', and ',', how can we determine the result of the expression after evaluating it according to the rules of boolean logic? Specifically, what is the result of the expression when evaluated?", "io_requirements": "Input:\n  `expression` (str): A string representing a boolean expression. The expression can contain the following characters: 't' (true), 'f' (false), '!', '&', '|', '(', ')', and ','. The expression follows the rules of boolean logic, where '!' represents NOT, '&' represents AND, and '|' represents OR.\n\nOutput:\n  `return` (bool): A boolean value representing the result of the evaluated boolean expression.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        ops = []\n        vs = []\n        os = ('!', '&', '|')\n\n        for letter in expression:\n            if letter == ')':\n                tmp = []\n\n                while vs[-1] != '(':\n                    tmp.append(vs.pop())\n                vs.pop()\n                o = ops.pop()\n\n                if o == '!':\n                    if tmp[0] == 'f':\n                        vs.append('t')\n                    else:\n                        vs.append('f')\n                elif o == '&':\n                    if 'f' in tmp:\n                        vs.append('f')\n                    else:\n                        vs.append('t')\n                else:\n                    if 't' in tmp:\n                        vs.append('t')\n                    else:\n                        vs.append('f')\n            elif letter in os:\n                ops.append(letter)\n            elif letter == ',':\n                continue\n            else:\n                vs.append(letter)\n\n        if vs[0] == 't':\n            return True\n\n        return False\n\n# main function\ndef main_solution(expression: str) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.parseBoolExpr(expression)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"expression": "!(t,f)"}, "output": true}, {"input": {"expression": "!(f)"}, "output": true}, {"input": {"expression": "!(t,f,t)"}, "output": false}, {"input": {"expression": "&(f)"}, "output": false}, {"input": {"expression": "|(f,t,t)"}, "output": true}, {"input": {"expression": "|(t)"}, "output": true}, {"input": {"expression": "!(f,f,t)"}, "output": false}, {"input": {"expression": "|(f)"}, "output": false}, {"input": {"expression": "|(t,t)"}, "output": true}, {"input": {"expression": "&(t)"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zzz136454872/leetcode", "path": "/parseBoolExpr.py", "msgidx": 3603}}
{"problem_description": "Given a sequence of elements that are pushed into a stack and another sequence of elements that are popped from the same stack, determine if the pop sequence is valid. A valid pop sequence means that the elements are popped in such an order that respects the stack's LIFO (Last In, First Out) principle. What is the validity of the given pop sequence for the push sequence?", "io_requirements": "Input:\n  `input_seq` (list of integers): The sequence of elements that are pushed into the stack.\n  `output_seq` (list of integers): The sequence of elements that are popped from the stack.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the `output_seq` is a valid pop sequence for the given `input_seq`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef isValid(input_seq: list, output_seq: list) -> bool:\n    flag = True\n    for i in range(len(output_seq)):\n        index = input_seq.index(output_seq[i])\n        l1 = []  # \u5b58\u5728i\u540e\u9762\u51fa\u7684\uff0c\u5e76\u5728i\u524d\u9762\u5165\u7684\u5143\u7d20 \u5e94\u8be5\u662f\u6309\u9006\u5e8f\u7684\u987a\u5e8f\u5b58\u7684\n        for j in range(i + 1, len(output_seq)):\n            if output_seq[j] in input_seq[:index + 1]:\n                l1.append(output_seq[j])\n        l2 = []  # \u5b58\u5728i\u524d\u9762\u5165\u7684\u5143\u7d20 \u5e94\u8be5\u662f\u6b63\u5e8f\u7684\n        for k in range(0, index):\n            if input_seq[k] in l1:\n                l2.append(input_seq[k])\n        if list(reversed(l1)) != l2:\n            flag = False\n            break\n    return flag\n\n# main function\ndef main_solution(input_seq: list, output_seq: list) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = isValid(input_seq, output_seq)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_seq": [1, 2, 3, 4, 5], "output_seq": [5, 2, 3, 4, 1]}, "output": false}, {"input": {"input_seq": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "output_seq": [6, 1, 5, 8, 10, 9, 2, 7, 4, 3]}, "output": false}, {"input": {"input_seq": [1, 2, 3, 4, 5, 6, 7], "output_seq": [2, 1, 4, 5, 3, 7, 6]}, "output": true}, {"input": {"input_seq": [1, 2, 3], "output_seq": [3, 2, 1]}, "output": true}, {"input": {"input_seq": [1, 2, 3], "output_seq": [1, 2, 3]}, "output": true}, {"input": {"input_seq": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "output_seq": [1, 4, 6, 9, 10, 7, 3, 8, 2, 5]}, "output": false}, {"input": {"input_seq": [1, 2, 3, 4, 5, 6, 7], "output_seq": [5, 3, 2, 4, 6, 1, 7]}, "output": false}, {"input": {"input_seq": [1, 2, 3, 4, 5, 6], "output_seq": [6, 2, 4, 5, 3, 1]}, "output": false}, {"input": {"input_seq": [1, 2, 3, 4, 5], "output_seq": [3, 4, 2, 1, 5]}, "output": true}, {"input": {"input_seq": [1, 2, 3, 4, 5, 6], "output_seq": [4, 6, 5, 3, 2, 1]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "liu-zheng-yuan/LeetCode-2019", "path": "/ByteDance/\u5408\u6cd5\u7684\u51fa\u6808\u5e8f\u5217.py", "msgidx": 3492}}
{"problem_description": "Given two natural numbers, what is the decimal representation of their fraction, considering that the decimal might be periodic?", "io_requirements": "Input:\n  `a` (int): The numerator of the fraction.\n  `b` (int): The denominator of the fraction.\n\nOutput:\n  `return` (str): The decimal representation of the fraction `a / b`, possibly periodic. The format is a string with a decimal point, and if the decimal is periodic, it is enclosed in parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef division(a, b):\n    i = str(a // b)\n    r = a % b\n    rems = []\n    dec = ''\n    while r and r not in rems:\n        rems.append(r)\n        dec += str(10 * r // b)\n        r = (10 * r) % b\n    if not dec:\n        dec = '0'\n    if r == 0:\n        return \"{}.{}\".format(i, dec)\n    idx = rems.index(r)\n    return \"{}.{}({})\".format(i, dec[:idx], dec[idx:])\n\n# main function\ndef main_solution(a, b):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = division(a, b)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"a": 18, "b": 82}, "output": "0.(21951)"}, {"input": {"a": 24, "b": 43}, "output": "0.(558139534883720930232)"}, {"input": {"a": 42, "b": 67}, "output": "0.(626865671641791044776119402985074)"}, {"input": {"a": 13, "b": 14}, "output": "0.9(285714)"}, {"input": {"a": 14, "b": 35}, "output": "0.4"}, {"input": {"a": 55, "b": 8}, "output": "6.875"}, {"input": {"a": 63, "b": 3}, "output": "21.0"}, {"input": {"a": 64, "b": 18}, "output": "3.(5)"}, {"input": {"a": 25, "b": 88}, "output": "0.284(09)"}, {"input": {"a": 47, "b": 21}, "output": "2.(238095)"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/8dkfsFEDNAbTqhAgc_0.py", "msgidx": 3179}}
{"problem_description": "Given a string, how can we determine all the unique permutations of its characters? For example, if the string is \"abc\", what are all the possible unique arrangements of the characters 'a', 'b', and 'c'?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should be a valid non-empty string with characters that can be permuted.\n\nOutput:\n  `return` (str): A JSON serialized string containing a list of all unique permutations of the input string. Each permutation is a string within the list.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef permute(string):\n    perms = []\n\n    if string is None:\n        return None\n    elif len(string) == 0:\n        perms.append(\"\")\n        return perms\n\n    words = permute(string[1:])\n    for word in words:\n        for j in range(len(word) + 1):\n            perms.append(word[:j] + string[0] + word[j:])\n\n    return perms\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters (if needed)\n    input_string = str(input_string)\n    \n    # Call the permute function to get all permutations\n    permutations = permute(input_string)\n    \n    # Convert the list of permutations to a JSON serializable format\n    permutations_json = json.dumps(permutations)\n    \n    return permutations_json", "funcname": "main_solution", "ios": [{"input": {"input_string": "ocp"}, "output": "[\"ocp\", \"cop\", \"cpo\", \"opc\", \"poc\", \"pco\"]"}, {"input": {"input_string": "dmv"}, "output": "[\"dmv\", \"mdv\", \"mvd\", \"dvm\", \"vdm\", \"vmd\"]"}, {"input": {"input_string": "jqy"}, "output": "[\"jqy\", \"qjy\", \"qyj\", \"jyq\", \"yjq\", \"yqj\"]"}, {"input": {"input_string": "wwq"}, "output": "[\"wwq\", \"wwq\", \"wqw\", \"wqw\", \"qww\", \"qww\"]"}, {"input": {"input_string": "bxk"}, "output": "[\"bxk\", \"xbk\", \"xkb\", \"bkx\", \"kbx\", \"kxb\"]"}, {"input": {"input_string": "xbl"}, "output": "[\"xbl\", \"bxl\", \"blx\", \"xlb\", \"lxb\", \"lbx\"]"}, {"input": {"input_string": "acb"}, "output": "[\"acb\", \"cab\", \"cba\", \"abc\", \"bac\", \"bca\"]"}, {"input": {"input_string": "pnb"}, "output": "[\"pnb\", \"npb\", \"nbp\", \"pbn\", \"bpn\", \"bnp\"]"}, {"input": {"input_string": "zyz"}, "output": "[\"zyz\", \"yzz\", \"yzz\", \"zzy\", \"zzy\", \"zyz\"]"}, {"input": {"input_string": "frg"}, "output": "[\"frg\", \"rfg\", \"rgf\", \"fgr\", \"gfr\", \"grf\"]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "niranjan-nagaraju/Development", "path": "/python/algorithms/combinatorics/permutations/permute.py", "msgidx": 3790}}
{"problem_description": "Given a puzzle grid of size `n x n`, where `n` is an integer between 2 and 4, and two states of the puzzle: the initial state and the goal state, what is the sequence of moves required to transform the initial state into the goal state? The moves can be up ('U'), down ('D'), left ('L'), or right ('R'). If no solution is possible, return an empty sequence of moves.", "io_requirements": "Input:\n- `initial_state` (list of integers): The initial state of the puzzle, represented as a list of integers. The list should be of length `n*n` where `n` is the size of the puzzle grid.\n- `goal_state` (list of integers): The goal state of the puzzle, represented as a list of integers. The list should be of length `n*n` where `n` is the size of the puzzle grid.\n- `n` (integer): The size of the puzzle grid (e.g., for a 3x3 puzzle, `n` would be 3).\n\nOutput:\n- `return` (list of strings): A list of moves that represent the solution path from the initial state to the goal state. Each move is represented by a string: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If no solution is found, an empty list is returned.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Vertex:\n    def __init__(self, mat, parent, direction, depth, cost):\n        self.state = mat\n        self.pai = parent\n        self.direction = direction\n        self.depth = depth\n        self.heuristic = 0\n        if parent:\n            self.cost = parent.cost + cost\n        else:\n            self.cost = cost\n\n    def isGoal(self, state):\n        return self.state == state\n\n    def discoverChildren(self, n):\n        x = self.state.index(0)\n        moves = self.available_moves(x, n)\n        children = []\n        for direction in moves:\n            temp = self.state.copy()\n            if direction == 'Right':\n                temp[x], temp[x - 1] = temp[x - 1], temp[x]\n            elif direction == 'Left':\n                temp[x], temp[x + 1] = temp[x + 1], temp[x]\n            elif direction == 'Down':\n                temp[x], temp[x - n] = temp[x - n], temp[x]\n            elif direction == 'Up':\n                temp[x], temp[x + n] = temp[x + n], temp[x]\n            children.append(Vertex(temp, self, direction, self.depth + 1, self.cost + 1))\n        return children\n\n    def solution(self):\n        solution = []\n        if self.direction == 'Up':\n            solution.append('U')\n        elif self.direction == 'Down':\n            solution.append('D')\n        elif self.direction == 'Right':\n            solution.append('R')\n        elif self.direction == 'Left':\n            solution.append('L')\n        path = self\n        while path.pai:\n            path = path.pai\n            if path.direction == 'Up':\n                solution.append('U')\n            elif path.direction == 'Down':\n                solution.append('D')\n            elif path.direction == 'Right':\n                solution.append('R')\n            elif path.direction == 'Left':\n                solution.append('L')\n        solution.reverse()\n        return solution\n\n    def available_moves(self, x, n):\n        moves = ['Up', 'Down', 'Left', 'Right']\n        if x % n == 0:\n            moves.remove('Right')\n        if x % n == n - 1:\n            moves.remove('Left')\n        if x - n < 0:\n            moves.remove('Down')\n        if x + n > n * n - 1:\n            moves.remove('Up')\n        return moves\n\n    def f(self, n):\n        return self.g() + self.h(n)\n\n    def g(self):\n        return self.cost\n\n    def h(self, n):\n        sum = 0\n        newmat = np.array(self.state.copy())\n        GS = np.array(self.generateGoalState(n))\n        newmat = np.hsplit(newmat, n)\n        newmat = np.asmatrix(newmat)\n        GS = np.hsplit(GS, n)\n        GS = np.asmatrix(GS)\n        for x in range(n):\n            for y in range(n):\n                if not newmat[x, y] == 0:\n                    x_val, y_val = x, y\n                    x_goal, y_goal = self.findVal(GS, newmat[x, y])\n                    sum += (abs(x_val - x_goal) + abs(y_val - y_goal))\n        return sum\n\n    def generateGoalState(self, n):\n        GoalState = []\n        for x in range(np.power(n, 2)):\n            GoalState.append(x + 1)\n        GoalState[np.power(n, 2) - 1] = 0\n        return GoalState\n\n    def findVal(self, mat, val):\n        for x in range(len(mat)):\n            for y in range(len(mat)):\n                if mat[x, y] == val:\n                    return x, y\n\n# main function\ndef main_solution(initial_state, goal_state, n):\n    initial_vertex = Vertex(initial_state, None, None, 0, 0)\n    if initial_vertex.isGoal(goal_state):\n        return []\n    children = initial_vertex.discoverChildren(n)\n    for child in children:\n        if child.isGoal(goal_state):\n            return child.solution()\n    return []", "funcname": "main_solution", "ios": [{"input": {"initial_state": [3, 5, 7, 8, 1, 0, 4, 6, 2], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}, {"input": {"initial_state": [1, 2, 8, 4, 5, 3, 7, 6, 0], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}, {"input": {"initial_state": [2, 6, 8, 3, 4, 1, 7, 0, 5], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}, {"input": {"initial_state": [0, 2, 3, 1], "goal_state": [1, 2, 3, 0], "n": 2}, "output": []}, {"input": {"initial_state": [6, 4, 7, 8, 1, 0, 3, 2, 5], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}, {"input": {"initial_state": [3, 2, 5, 6, 0, 8, 7, 1, 4], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}, {"input": {"initial_state": [1, 6, 0, 4, 8, 7, 3, 5, 2], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}, {"input": {"initial_state": [1, 3, 2, 0], "goal_state": [1, 2, 3, 0], "n": 2}, "output": []}, {"input": {"initial_state": [1, 6, 3, 2, 4, 5, 0, 7, 8], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}, {"input": {"initial_state": [7, 0, 4, 5, 6, 1, 2, 3, 8], "goal_state": [1, 2, 3, 4, 5, 6, 7, 8, 0], "n": 3}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Jonathan-Langer/AIProject", "path": "/Vertex.py", "msgidx": 2457}}
{"problem_description": "Given a set of nodes with their x and y coordinates, how can we determine the order of node numbers when traversing a binary search tree constructed from these nodes in preorder and postorder?", "io_requirements": "Input:\n  `nodeinfo` (list of lists): A list of lists where each inner list contains two integers representing the x and y coordinates of a node. The length of `nodeinfo` should be between 1 and 1000, and the values of x and y should be between 0 and 100000.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `preorder` (list of int): A list of integers representing the node numbers in preorder traversal.\n    - `postorder` (list of int): A list of integers representing the node numbers in postorder traversal.", "refcode": "# import necessary packages\nimport sys\nsys.setrecursionlimit(1500)\n\n# all class and function definitions in the code file, if any\nclass Node:\n    LEFT = 0\n    RIGHT = 1\n\n    def __init__(self, val):\n        self.val = val # (node_num, x)\n        self.left = None\n        self.right = None\n\n    def add(self, val):\n        if val[1] > self.val[1]:\n            if self.right is None:\n                self.right = Node(val)\n            else:\n                self.right.add(val)\n\n        else:\n            if self.left is None:\n                self.left = Node(val)\n            else:\n                self.left.add(val)\n\n    # return pre-order list\n    def preorder(self):\n        arr = [self.val] # root\n        if self.left:\n            arr.extend(self.left.preorder()) # left subtree\n        if self.right:\n            arr.extend(self.right.preorder()) # right subtree\n        return arr\n\n    def postorder(self):\n        arr = []\n        if self.left:\n            arr.extend(self.left.postorder()) # left subtree\n        if self.right:\n            arr.extend(self.right.postorder()) # right subtree\n        arr.append(self.val) # root\n        return arr\n\n# main function\ndef main_solution(nodeinfo):\n    # Convert input to JSON serializable format\n    nodeinfo = [[int(x), int(y)] for x, y in nodeinfo]\n    \n    # Build the binary search tree\n    arr = [(i+1, *nodeinfo[i]) for i in range(len(nodeinfo))] # (node number, x, y)\n    arr.sort(key=lambda x: (-x[2], x[1])) # sort by y desc x asc\n    root = None\n    for node in arr:\n        node_num, x, y = node\n        if root is None:\n            root = Node((node_num, x)) # \uac01 node\uac00 \uac16\ub294 \uac12\uc740 (node_num, x)\n        else:\n            root.add((node_num, x))\n\n    # Perform preorder and postorder traversal\n    preorder = root.preorder()\n    postorder = root.postorder()\n    \n    # Convert output to JSON serializable format\n    preorder_result = [val[0] for val in preorder]\n    postorder_result = [val[0] for val in postorder]\n    \n    return {\"preorder\": preorder_result, \"postorder\": postorder_result}", "funcname": "main_solution", "ios": [{"input": {"nodeinfo": [[96268, 52355]]}, "output": {"preorder": [1], "postorder": [1]}}, {"input": {"nodeinfo": [[25714, 14286], [32000, 57453]]}, "output": {"preorder": [2, 1], "postorder": [1, 2]}}, {"input": {"nodeinfo": [[12237, 95542], [52816, 39188], [35436, 39669]]}, "output": {"preorder": [1, 3, 2], "postorder": [2, 3, 1]}}, {"input": {"nodeinfo": [[6432, 87873], [65809, 13178]]}, "output": {"preorder": [1, 2], "postorder": [2, 1]}}, {"input": {"nodeinfo": [[98388, 79229], [66486, 73807]]}, "output": {"preorder": [1, 2], "postorder": [2, 1]}}, {"input": {"nodeinfo": [[40694, 40565], [91585, 30103]]}, "output": {"preorder": [1, 2], "postorder": [2, 1]}}, {"input": {"nodeinfo": [[92650, 22082]]}, "output": {"preorder": [1], "postorder": [1]}}, {"input": {"nodeinfo": [[78023, 51100]]}, "output": {"preorder": [1], "postorder": [1]}}, {"input": {"nodeinfo": [[93151, 32738], [65978, 1020]]}, "output": {"preorder": [1, 2], "postorder": [2, 1]}}, {"input": {"nodeinfo": [[47308, 75304], [68814, 96659], [54365, 79911]]}, "output": {"preorder": [2, 3, 1], "postorder": [1, 3, 2]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bmy4415/algorithm-and-interview", "path": "/kakao/kakao-2019-05.py", "msgidx": 3292}}
{"problem_description": "Given a square matrix of integers, determine whether it is a magic square. A magic square is a square grid filled with distinct integers such that the sum of the integers in each row, each column, and both main diagonals are equal. What is the result of checking if the provided square matrix is a magic square?", "io_requirements": "Input:\n  `square` (list of lists of int): A 2D list representing a square matrix. Each sublist represents a row in the square. The integers in the matrix should be unique and range from 1 to n^2, where n is the size of the square.\n\nOutput:\n  `return` (dict): A dictionary with the following key:\n    - `is_magic_square` (bool): Indicates whether the provided square is a magic square.\n    - `error` (str, optional): If the input square is not a valid square matrix, this key will contain an error message.", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\nclass Error(Exception):\n    '''Base class for exceptions in this module.'''\n    pass\n\nclass SquareSizeError(Error):\n    '''Raised when the square argument provided to\n        is_magic_square is a list with an unequal size\n        (length of rows not equal to length of cols).\n    '''\n    def __init__(self, message):\n        self.message = message\n\ndef get_magic_const(size):\n    return size * (size**2 + 1) / 2\n\ndef is_magic(square, size, magic_const):\n    return has_valid_cells(square, size) and \\\n           has_magic_rows(square, size, magic_const) and \\\n           has_magic_cols(square, size, magic_const) and \\\n           has_magic_left_diagonal(square, size, magic_const) and \\\n           has_magic_right_diagonal(square, size, magic_const)\n\ndef get_square_size(square):\n    num_rows = len(square)\n    cols = list(map(len, square))\n\n    if [num_rows] * num_rows == cols:\n        return num_rows\n    else:\n        raise SquareSizeError(('The list is not a square. Make sure the'\n                               ' quantity of rows is equal to the quantity of columns.'))\n\ndef has_valid_cells(square, size):\n    maximum = size**2  # maximum int permitted in cell\n    current = 1  # current int we are checking (1-n^2)\n    occurences = 0  # occurences of current int\n    status = True\n\n    while current <= maximum and status == True:\n        for row in range(size):\n            for col in range(size):\n                if square[row][col] == current:\n                    occurences += 1\n\n        if occurences <= 1:\n            # Zero or one occurance of the current int.\n            # So far, the square is unique. Move on\n            # to the next int.\n            current += 1\n            occurences = 0\n        else:\n            # Short circuit. If there are more than\n            # 1 occurences of an int, the square is\n            # not unique.\n            status = False\n\n    return status\n\ndef has_magic_rows(square, size, magic_const):\n    row_sums = []\n    for row in range(size):\n        row_sums.append(0)\n        for col in range(size):\n            row_sums[row] += square[row][col]\n    return sum_list_items(row_sums) == magic_const * size\n\ndef has_magic_cols(square, size, magic_const):\n    col_sums = []\n    for col in range(size):\n        col_sums.append(0)\n        for row in range(size):\n            col_sums[col] += square[row][col]\n    return sum_list_items(col_sums) == magic_const * size\n\ndef has_magic_left_diagonal(square, size, magic_const):\n    col_sums = []\n    for i in range(size):\n        col_sums.append(square[i][i])\n    return sum_list_items(col_sums) == magic_const\n\ndef has_magic_right_diagonal(square, size, magic_const):\n    col_sums = []\n    for i in range(size):\n        col_sums.append(square[i][(size - 1) - i])\n    return sum_list_items(col_sums) == magic_const\n\ndef sum_list_items(list):\n    return reduce(lambda x, y: x + y, list)\n\n# main function\ndef main_solution(square):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    try:\n        size = get_square_size(square)\n    except SquareSizeError:\n        return {\"is_magic_square\": False, \"error\": \"The list is not a square. Make sure the quantity of rows is equal to the quantity of columns.\"}\n    \n    magic_const = get_magic_const(size)\n    is_magic_square = is_magic(square, size, magic_const)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"is_magic_square\": is_magic_square}", "funcname": "main_solution", "ios": [{"input": {"square": [[3, 2], [1, 4]]}, "output": {"is_magic_square": false}}, {"input": {"square": [[1, 2], [4, 3]]}, "output": {"is_magic_square": false}}, {"input": {"square": [[2, 4], [3, 1]]}, "output": {"is_magic_square": false}}, {"input": {"square": [[4, 3], [1, 2]]}, "output": {"is_magic_square": false}}, {"input": {"square": [[1, 2], [3, 4]]}, "output": {"is_magic_square": true}}, {"input": {"square": [[4, 1], [2, 3]]}, "output": {"is_magic_square": false}}, {"input": {"square": [[3, 1], [2, 4]]}, "output": {"is_magic_square": false}}, {"input": {"square": [[3, 1], [4, 2]]}, "output": {"is_magic_square": true}}, {"input": {"square": [[1, 3], [4, 2]]}, "output": {"is_magic_square": false}}, {"input": {"square": [[3, 4], [2, 1]]}, "output": {"is_magic_square": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MatthewKosloski/starting-out-with-python", "path": "/homework/lo_shu_magic_square/lo_shu_magic_square.py", "msgidx": 2960}}
{"problem_description": "Given a graph represented by a dictionary where each key is a vertex and each value is a list of connected vertices, what is the size of the maximal clique and which vertices are included in it?", "io_requirements": "Input:\n  `graph_dict` (dict): A dictionary representing the graph. The keys are integers representing vertices, and the values are lists of integers representing the edges connected to each vertex.\n\nOutput:\n  `return` (dict): A dictionary containing the size of the maximal clique (`maximal_clique_size`, int) and the vertices in the maximal clique (`maximal_clique`, list of int).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Graph(object):\n    def __init__(self, vertex_num):\n        self.graph = {}  # graph is a dict, with the key as the vertex and the value as the edges in the form of a list\n        self.vertex_num = vertex_num\n\n    def add_vertex(self, v):\n        if v not in self.graph.keys():\n            self.graph[v] = []  # new vertex, avoid repeating vertex\n\n    def add_edges(self, v, e):\n        self.graph[v].append(e)\n\n# Construct a graph given an input dictionary with a specific format\ndef construct_graph_from_dict(graph_dict):\n    num_lines = len(graph_dict)\n    g = Graph(num_lines)\n\n    for vertex, edges in graph_dict.items():\n        g.add_vertex(vertex)\n        for edge in edges:\n            g.add_edges(vertex, edge)\n\n    return g\n\n# A recursive algorithm to generate the cliques starting with each vertex of the graph\ndef maximal_clique(g, position, max_clique, clique, solution):\n    #absolute base case\n    for v in clique:\n        if position not in g.graph.get(v, []) and v not in g.graph.get(position, []): # Return if vertex is not a neighbour of one of the clique vertex\n            return\n\n    # add vertex to clique\n    clique.append(position)\n    position = position + 1\n\n    # if all vertices are traversed, maximal clique\n    if len(clique) == len(g.graph.keys()):\n        max_clique = clique\n        return\n\n    # update maximal clique if larger clique found\n    if len(clique) > len(max_clique):\n        max_clique = clique\n        solution.append(max_clique)\n\n    new_clique = [i for i in clique]\n    # based on the index of the position, iterate the rest of the values in the list\n    for v in range(position, len(g.graph.keys())):\n        if v not in new_clique:\n            maximal_clique(g, v, max_clique, new_clique, solution)\n\n# main function\ndef main_solution(graph_dict):\n    # Convert the JSON serializable input to the original input variables\n    g = construct_graph_from_dict(graph_dict)\n\n    # maximal clique starting from a given vertex\n    max_clique = []\n\n    # list of cliques from each maximal clique of a given starting index\n    solution = []\n\n    for vertex in g.graph.keys():\n        maximal_clique(g, vertex, max_clique, [], solution)\n\n    # initialize largest maximal clique\n    largest_clique = solution[0]\n\n    # obtain the largest clique within the solutions\n    for s in solution:\n        if len(s) > len(largest_clique):\n            largest_clique = s\n\n    # Convert the output to JSON serializable format\n    return {\"maximal_clique_size\": len(largest_clique), \"maximal_clique\": largest_clique}", "funcname": "main_solution", "ios": [{"input": {"graph_dict": {"0": [1, 2, 3], "1": [0, 3, 4], "2": [1, 2], "3": [4, 3, 2], "4": [3, 2]}}, "output": {"maximal_clique_size": 4, "maximal_clique": [0, 1, 2, 3]}}, {"input": {"graph_dict": {"0": [0], "1": [2, 1], "2": [0, 1]}}, "output": {"maximal_clique_size": 2, "maximal_clique": [0, 2]}}, {"input": {"graph_dict": {"0": [0], "1": [0, 1], "2": [4], "3": [4, 2], "4": [0]}}, "output": {"maximal_clique_size": 3, "maximal_clique": [2, 3, 4]}}, {"input": {"graph_dict": {"0": [1, 4, 3, 0], "1": [4, 3, 1], "2": [0], "3": [1], "4": [2]}}, "output": {"maximal_clique_size": 3, "maximal_clique": [0, 1, 3]}}, {"input": {"graph_dict": {"0": [1], "1": [3, 0, 1], "2": [0], "3": [0, 2, 1]}}, "output": {"maximal_clique_size": 3, "maximal_clique": [0, 1, 3]}}, {"input": {"graph_dict": {"0": [2], "1": [0, 2, 4], "2": [4, 1, 3], "3": [3, 1], "4": [0, 3, 4, 1]}}, "output": {"maximal_clique_size": 4, "maximal_clique": [0, 1, 2, 4]}}, {"input": {"graph_dict": {"0": [4, 0, 1, 3], "1": [4, 2, 1, 0], "2": [0, 4], "3": [0], "4": [3, 2]}}, "output": {"maximal_clique_size": 4, "maximal_clique": [0, 1, 2, 4]}}, {"input": {"graph_dict": {"0": [0], "1": [2], "2": [2]}}, "output": {"maximal_clique_size": 2, "maximal_clique": [1, 2]}}, {"input": {"graph_dict": {"0": [1], "1": [0, 3], "2": [3], "3": [3, 0]}}, "output": {"maximal_clique_size": 3, "maximal_clique": [0, 1, 3]}}, {"input": {"graph_dict": {"0": [0, 1], "1": [1, 0], "2": [2, 1, 0], "3": [3]}}, "output": {"maximal_clique_size": 3, "maximal_clique": [0, 1, 2]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "justinhjy1004/CSCE310-Assignment", "path": "/Assignment 1/Assignment 1 Program C/max_clique.py", "msgidx": 3226}}
{"problem_description": "Given a set of 7 unique single-digit integers, what are all the possible arrangements of these digits that satisfy the equation \\( A \\times B \\times C = C \\times D \\times E = E \\times F \\times G \\), where each variable represents a unique digit from the set?", "io_requirements": "Input:\n  `digits` (list of integers): A list of 7 unique single-digit integers (ranging from 1 to 9) that will be used to find solutions to the equation.\n\nOutput:\n  `return` (list of lists of integers): A list of all possible solutions, where each solution is represented as a list of 7 integers that satisfy the equation \\( A \\times B \\times C = C \\times D \\times E = E \\times F \\times G \\).", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef unique(a, b, c, d, e, f, g):\n    x = [a, b, c, d, e, f, g]\n    return len(x) == len(set(x))\n\ndef test(a, b, c, d, e, f, g):\n    return unique(a, b, c, d, e, f, g) and ((a * b * c) == (c * d * e) == (e * f * g))\n\n# main function\ndef main_solution(digits):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solutions = []\n  for perm in itertools.permutations(digits, 7):\n      if test(*perm):\n          solutions.append(list(perm))\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return solutions", "funcname": "main_solution", "ios": [{"input": {"digits": [1, 6, 9, 2, 3, 5, 7]}, "output": []}, {"input": {"digits": [8, 2, 3, 1, 5, 7, 6]}, "output": []}, {"input": {"digits": [2, 1, 9, 8, 3, 7, 4]}, "output": []}, {"input": {"digits": [7, 3, 2, 1, 5, 6, 9]}, "output": []}, {"input": {"digits": [3, 9, 5, 4, 6, 7, 8]}, "output": []}, {"input": {"digits": [4, 3, 5, 9, 1, 2, 6]}, "output": []}, {"input": {"digits": [9, 8, 3, 7, 5, 2, 1]}, "output": []}, {"input": {"digits": [5, 8, 1, 9, 7, 6, 2]}, "output": []}, {"input": {"digits": [2, 9, 3, 5, 8, 4, 1]}, "output": []}, {"input": {"digits": [4, 5, 2, 6, 8, 7, 1]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RobBlackwell/py-puzzles", "path": "/mission.py", "msgidx": 3605}}
{"problem_description": "Given a range of numbers from 1 to `n`, identify all the numbers that are pandigital, meaning they use all the digits from 1 to the number of digits in the number exactly once. What are the pandigital numbers within this range?", "io_requirements": "Input:\n  `n` (int): The upper limit for the range of numbers to check for pandigital properties.\n\nOutput:\n  `return` (list of int): A list of integers that are pandigital within the range from 1 to `n`.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef check_pandigital(n):\n    digits = str(n)\n    num_digits = len(digits)\n    check_list = list(range(1, num_digits + 1))\n    set_list = set([int(i) for i in digits])\n    if len(set_list) == num_digits:\n        sorted_set_list = sorted(list(set_list))\n        for i, ss in enumerate(sorted_set_list):\n            if sorted_set_list[i] != check_list[i]:\n                return False\n        return True\n    return False\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    pandigital_numbers = []\n    for i in range(1, n + 1):\n        if check_pandigital(i):\n            pandigital_numbers.append(i)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return pandigital_numbers", "funcname": "main_solution", "ios": [{"input": {"n": 876}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 503}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 475}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 773}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 523}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 990}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 654}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 441}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}, {"input": {"n": 182}, "output": [1, 12, 21, 123, 132]}, {"input": {"n": 621}, "output": [1, 12, 21, 123, 132, 213, 231, 312, 321]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "apolshchikov/project-euler", "path": "/python/problem_0032.py", "msgidx": 3444}}
{"problem_description": "Given a rectangular area with specified dimensions, what is the side length of the largest square that can perfectly divide the rectangle into equal parts?", "io_requirements": "Input:\n  `rectangle_dimensions` (list of int): A list containing two integers representing the dimensions (length and width) of the rectangle.\n\nOutput:\n  `return` (int): The side length of the largest square that can evenly divide the given rectangle.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef max_square(x):\n    if x[0] == x[1]:\n        return x[0]\n    elif x[0] > x[1]:\n        return max_square([x[0] - x[1], x[1]])\n    else:\n        return max_square([x[1] - x[0], x[0]])\n\n# main function\ndef main_solution(rectangle_dimensions):\n    # Convert the input list to a JSON serializable format\n    dimensions = [int(dim) for dim in rectangle_dimensions]\n    \n    # Call the max_square function to get the result\n    result = max_square(dimensions)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"rectangle_dimensions": [587, 237]}, "output": 1}, {"input": {"rectangle_dimensions": [826, 810]}, "output": 2}, {"input": {"rectangle_dimensions": [39, 636]}, "output": 3}, {"input": {"rectangle_dimensions": [631, 236]}, "output": 1}, {"input": {"rectangle_dimensions": [406, 566]}, "output": 2}, {"input": {"rectangle_dimensions": [541, 253]}, "output": 1}, {"input": {"rectangle_dimensions": [959, 963]}, "output": 1}, {"input": {"rectangle_dimensions": [485, 491]}, "output": 1}, {"input": {"rectangle_dimensions": [438, 475]}, "output": 1}, {"input": {"rectangle_dimensions": [426, 579]}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RussellJi/algorithm", "path": "/PyAl/DC/max_square.py", "msgidx": 3802}}
{"problem_description": "Given a range of four-digit numbers, identify the first arithmetic sequence of three four-digit prime numbers where all three numbers have the same digits. What is the concatenated string of these three prime numbers?", "io_requirements": "Input:\n  `start_range` (int): The starting range for finding four-digit prime numbers.\n  `end_range` (int): The ending range for finding four-digit prime numbers.\n\nOutput:\n  `return` (str): A concatenated string of three four-digit prime numbers that form an arithmetic sequence and have the same digits, or an empty string if no such sequence is found.", "refcode": "# import necessary packages\nimport math\n\n# Function to check if a number is prime\ndef isPrime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(start_range, end_range):\n    # Convert input arguments to appropriate types if necessary\n    start_range = int(start_range)\n    end_range = int(end_range)\n\n    # Find all four-digit prime numbers within the given range\n    four_digit_primes = [num for num in range(start_range, end_range + 1) if isPrime(num) and len(str(num)) == 4]\n\n    # Find arithmetic sequences of three four-digit primes\n    tuples = []\n    for n in range(len(four_digit_primes) - 1, -1, -1):\n        j = four_digit_primes[n]\n        for a in range(n - 1, -1, -1):\n            i = four_digit_primes[a]\n            k = j + (j - i)\n            if k < 10000 and k in four_digit_primes:\n                tuples.append((i, j, k))\n\n    # Find the first arithmetic sequence where all three numbers have the same digits\n    target_triple = None\n    for triple in tuples:\n        a = str(triple[0])\n        b = str(triple[1])\n        c = str(triple[2])\n        if sorted(a) == sorted(b) == sorted(c):\n            target_triple = triple\n            break\n\n    # Return the concatenated string of the three numbers in the target triple\n    if target_triple:\n        return ''.join(map(str, target_triple))\n    else:\n        return \"\"", "funcname": "main_solution", "ios": [{"input": {"start_range": 7211, "end_range": 8032}, "output": ""}, {"input": {"start_range": 5254, "end_range": 9941}, "output": ""}, {"input": {"start_range": 3157, "end_range": 5602}, "output": ""}, {"input": {"start_range": 8037, "end_range": 9727}, "output": ""}, {"input": {"start_range": 5551, "end_range": 6692}, "output": ""}, {"input": {"start_range": 5731, "end_range": 7370}, "output": ""}, {"input": {"start_range": 4993, "end_range": 6351}, "output": ""}, {"input": {"start_range": 8004, "end_range": 8645}, "output": ""}, {"input": {"start_range": 1889, "end_range": 8367}, "output": ""}, {"input": {"start_range": 8833, "end_range": 9009}, "output": ""}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dandouthit/project-euler-solutions", "path": "/problem49.py", "msgidx": 3458}}
{"problem_description": "Given a set of logical clauses and a target clause size, how can we transform the clauses such that each clause in the resulting set has exactly the target size? Specifically, what is the resulting set of clauses when the input clauses are transformed to meet the target clause size?", "io_requirements": "Input:\n  `problem` (list of strings): A list of strings where each string represents a clause in the problem. Each clause is a space-separated list of literals.\n  `x_target` (int): The target size of each clause in the solution.\n\nOutput:\n  `return` (list of strings): A list of strings where each string represents a clause in the solution. Each clause is a space-separated list of literals.", "refcode": "# import necessary packages\nimport itertools\nimport copy\n\n# all class and function definitions in the code file, if any\nclass Solver():\n    def __init__(self, problem, x_target):\n        self.solution = []\n        self.var_count = 0\n        self.problem = problem\n        self.x_target = x_target\n\n    def reduct_sat(self):\n        for clause in self.problem:\n            if clause[0] == 'p':  # <- Problem configuration (ignore)\n                self.var_count = int(clause[2])\n                continue\n            clause_size = len(clause)  # <- Calculate clause size\n            if clause_size == self.x_target:  # <- If clause size is already on X-SAT add to the solution\n                self.solution.append(clause)\n                continue\n            if clause_size < self.x_target:  # <- If clause size is less than X-SAT\n                # <- Calculate the missing variables to convert from clause-size to X-SAT\n                missing_variables = self.x_target - clause_size\n                partial_solution = self.generate_clause_lesser(\n                    clause, missing_variables)\n                for clause in partial_solution:\n                    # <- Stores on the solution the new clauses (see generate_clause)\n                    self.solution.append(clause)\n                continue\n            else:\n                missing_variables = clause_size - 3\n                missing_clauses = clause_size - 2\n                self.generate_clause_greater(\n                    clause, missing_variables, missing_clauses)\n                # do something else\n\n    def generate_clause_lesser(self, clause, missing_variables):\n        new_variables = []  # <- Variable to store the new variables\n        new_clauses = []  # <- Variable to store the new clauses\n        boolean_combinations = list(itertools.product([False, True],\n                                                      repeat=missing_variables))  # <- Generates all the posible 2^missing_variables boolean combinations\n\n        # Example of boolean combinations:\n        # for missing_variables = 3\n        # Boolean combinations = [[False, False, False],\n        #                         [False, False, True],\n        #                         [False, True, False],\n        #                         [False, True, True],\n        #                         [True, False, False],\n        #                         [True, False, True],\n        #                         [True, True, False],\n        #                         [True, True, True]]\n\n        # <- Iterate for all the variables we need to add\n        for _ in range(missing_variables):\n            self.var_count += 1\n            # <- Add an unique number to each of the needed variables following the format v#\n            new_variables.append(str(self.var_count))\n\n        # <- Iterate over all the boolean combinatios generated previously [..., [..., boolean_value, ...],...]\n        for boolean_values in boolean_combinations:\n            new_clause = []\n            # <- Creates a copy of the clause\n            new_clause = copy.deepcopy(clause)\n            # <- Iterates over each of the boolean values [..., boolean_value, ...]\n            for index, boolean_value in enumerate(boolean_values):\n                if boolean_value:  # <- if boolean is True means that we need to add the new variable but positive\n                    # <- here we add the positive variable to the new_clause\n                    new_clause.append(new_variables[index])\n                else:  # <- if boolean is not True means that we need to add the new variable but negative\n                    # <- here we add the negative variable to the new_clause\n                    new_clause.append(\"-\"+new_variables[index])\n            # <- After iterate over the first boolean_values we add the new_clause to new_clauses variable\n            new_clauses.append(new_clause)\n\n        return new_clauses\n\n    def generate_clause_greater(self, clause, missing_variables, missing_clauses):\n        new_variables = []\n        aux_solution = []\n\n        self.var_count = self.var_count + 1\n\n        for i in range(self.var_count, self.var_count + missing_variables):\n            new_variables.append(str(i))\n            new_variables.append(\"-\"+str(i))\n\n        self.var_count = self.var_count + missing_variables - 1\n\n        clause_position = 0\n        new_variables_position = 0\n\n        for new_clause_index in range(missing_clauses):\n            new_clause = []\n            if new_clause_index == 0:\n                new_clause.append(clause[clause_position])\n                new_clause.append(clause[clause_position+1])\n                new_clause.append(new_variables[new_variables_position])\n                new_variables_position += 1\n                clause_position += 2\n                aux_solution.append(new_clause)\n                continue\n            if new_clause_index == missing_clauses-1:\n                new_clause.append(new_variables[new_variables_position])\n                new_clause.append(clause[clause_position])\n                new_clause.append(clause[clause_position+1])\n                new_variables_position += 1\n                clause_position += 2\n                aux_solution.append(new_clause)\n                break\n            else:\n                new_clause.append(new_variables[new_variables_position])\n                new_clause.append(clause[clause_position])\n                new_clause.append(new_variables[new_variables_position+1])\n                clause_position += 1\n                new_variables_position += 2\n                aux_solution.append(new_clause)\n\n        for new_clause in aux_solution:\n            clause_size = len(new_clause)\n            # <- Calculate the missing variables to convert from clause-size to X-SAT\n            missing_variables = self.x_target - clause_size\n            partial_solution = self.generate_clause_lesser(\n                new_clause, missing_variables)\n            for clause in partial_solution:\n                # <- Stores on the solution the new clauses (see generate_clause)\n                self.solution.append(clause)\n            continue\n\n# main function\ndef main_solution(problem, x_target):\n    # Convert input to the required format\n    problem = [clause.split() for clause in problem]\n    \n    # Initialize the Solver\n    solver = Solver(problem, x_target)\n    \n    # Perform the reduction\n    solver.reduct_sat()\n    \n    # Convert the solution to a JSON serializable format\n    solution = [' '.join(clause) for clause in solver.solution]\n    \n    return solution", "funcname": "main_solution", "ios": [{"input": {"problem": ["v3 v3 v3 v9", "v7 v9 v7 v7", "v10 v9 v8"], "x_target": 5}, "output": ["v3 v3 v3 v9 -1", "v3 v3 v3 v9 1", "v7 v9 v7 v7 -2", "v7 v9 v7 v7 2", "v10 v9 v8 -3 -4", "v10 v9 v8 -3 4", "v10 v9 v8 3 -4", "v10 v9 v8 3 4"]}, {"input": {"problem": ["v2 v6", "v4 v5 v5 v3", "v1 v2 v9"], "x_target": 3}, "output": ["v2 v6 -1", "v2 v6 1", "v4 v5 2", "-2 v5 v3", "v1 v2 v9"]}, {"input": {"problem": ["v6 v5 v4 v3", "v2 v1 v4 v7", "v7 v1 v4 v1 v7", "v4 v3 v3 v4"], "x_target": 3}, "output": ["v6 v5 1", "-1 v4 v3", "v2 v1 2", "-2 v4 v7", "v7 v1 3", "-3 v4 4", "-4 v1 v7", "v4 v3 5", "-5 v3 v4"]}, {"input": {"problem": ["v3 v9", "v5 v4 v8", "v1 v9", "v10 v1 v3 v2"], "x_target": 3}, "output": ["v3 v9 -1", "v3 v9 1", "v5 v4 v8", "v1 v9 -2", "v1 v9 2", "v10 v1 3", "-3 v3 v2"]}, {"input": {"problem": ["v3 v6 v9 v5 v4", "v1 v3 v5", "v9 v5 v2 v9 v9", "v7 v9 v7", "v2 v1 v6 v2"], "x_target": 3}, "output": ["v3 v6 1", "-1 v9 2", "-2 v5 v4", "v1 v3 v5", "v9 v5 3", "-3 v2 4", "-4 v9 v9", "v7 v9 v7", "v2 v1 5", "-5 v6 v2"]}, {"input": {"problem": ["v1 v3", "v2 v2 v2", "v9 v2", "v1 v5 v10 v3", "v8 v8 v5 v2 v3"], "x_target": 3}, "output": ["v1 v3 -1", "v1 v3 1", "v2 v2 v2", "v9 v2 -2", "v9 v2 2", "v1 v5 3", "-3 v10 v3", "v8 v8 4", "-4 v5 5", "-5 v2 v3"]}, {"input": {"problem": ["v3 v8 v2 v4 v2", "v3 v6 v8 v4 v5", "v2 v8"], "x_target": 3}, "output": ["v3 v8 1", "-1 v2 2", "-2 v4 v2", "v3 v6 3", "-3 v8 4", "-4 v4 v5", "v2 v8 -5", "v2 v8 5"]}, {"input": {"problem": ["v7 v1 v4 v3 v9", "v7 v3 v10", "v4 v7 v6 v3 v3"], "x_target": 3}, "output": ["v7 v1 1", "-1 v4 2", "-2 v3 v9", "v7 v3 v10", "v4 v7 3", "-3 v6 4", "-4 v3 v3"]}, {"input": {"problem": ["v1 v6 v10 v2", "v4 v1 v2 v7", "v10 v2"], "x_target": 3}, "output": ["v1 v6 1", "-1 v10 v2", "v4 v1 2", "-2 v2 v7", "v10 v2 -3", "v10 v2 3"]}, {"input": {"problem": ["v9 v9 v4 v3 v6", "v3 v2", "v5 v10 v4 v2 v3"], "x_target": 5}, "output": ["v9 v9 v4 v3 v6", "v3 v2 -1 -2 -3", "v3 v2 -1 -2 3", "v3 v2 -1 2 -3", "v3 v2 -1 2 3", "v3 v2 1 -2 -3", "v3 v2 1 -2 3", "v3 v2 1 2 -3", "v3 v2 1 2 3", "v5 v10 v4 v2 v3"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MarthoxGJ/SATReductor", "path": "/Reductor/solver.py", "msgidx": 2888}}
{"problem_description": "Given a map of a certain size, a goal point, and a bot's starting point, what is the shortest path the bot can take to reach the goal point, considering the map is free of obstacles?", "io_requirements": "Input:\n  `map_size_x` (int): The size of the map in the x-direction.\n  `map_size_y` (int): The size of the map in the y-direction.\n  `goal_x` (int): The x-coordinate of the goal point.\n  `goal_y` (int): The y-coordinate of the goal point.\n  `bot_x` (int): The x-coordinate of the bot's starting point.\n  `bot_y` (int): The y-coordinate of the bot's starting point.\n\nOutput:\n  `return` (dict): A dictionary containing the path from the bot's starting point to the goal point. The path is a list of tuples, where each tuple represents a point (x, y) in the path.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Point():\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n    def __eq__(self, other):\n        if self.x == other.x:\n            if self.y == other.y:\n                return True\n        return False\n    def copy(self):\n        np = Point()\n        np.x = self.x\n        np.y = self.y\n        return np\n\nclass State(object):\n    def __init__(self, x, y):\n        self.pt = Point()\n        self.pt.x = x\n        self.pt.y = y\n        self.back = Point()\n        self.back.x = 0\n        self.back.y = 0\n        self.cost = 1\n        self.h = 0\n        self.k = 0\n        self.tag = 0\n\n    def GetNeighborList(self):\n        up = State(self.pt.x + 1, self.pt.y)\n        down = State(self.pt.x - 1, self.pt.y)\n        right = State(self.pt.x, self.pt.y + 1)\n        left = State(self.pt.x, self.pt.y - 1)\n        states = list()\n        states.append(up)\n        states.append(down)\n        states.append(left)\n        states.append(right)\n        return states\n\nclass DStar():\n    def __init__(self, mapX, mapY, goal):\n        self.x = mapX\n        self.y = mapY\n        self.grid = list()\n        self.goal = goal\n        for i in range(mapX):\n            self.grid.append(list())\n            for z in range(mapY):\n                self.grid[i].append(State(i, z))\n        self.openList = list()\n        self.grid[goal.x][goal.y].tag = 1\n        self.grid[goal.x][goal.y].h = 0\n        self.grid[goal.x][goal.y].k = 0\n        self.openList.append(self.grid[goal.x][goal.y])\n\n    def GetRealNeighbors(self, X):\n        neighbors = X.GetNeighborList()\n        outbors = list()\n        for n in neighbors:\n            if n.pt.x >= 0 and n.pt.y >= 0:\n                if n.pt.x < self.x and n.pt.y < self.y:\n                    outbors.append(self.grid[n.pt.x][n.pt.y])\n        return outbors\n\n    def Min_State(self):\n        state = self.openList[0]\n        for x in self.openList:\n            if x.k < state.k:\n                state = x\n        return state\n\n    def GetKMin(self):\n        return self.Min_State().k\n\n    def Remove_State(self, x):\n        x.tag = 2\n        self.openList.remove(x)\n\n    def Insert(self, X, hnew):\n        if X.tag == 0:\n            X.k = hnew\n        if X.tag == 1 and X.k == min([X.h, hnew]):\n            X.k = min([X.k, hnew])\n        if X.tag == 2:\n            X.k = min([X.h, hnew])\n        X.h = hnew\n        X.tag = 1\n        self.openList.append(X)\n\n    def process_state(self):\n        if len(self.openList) == 0:\n            return -1\n        X = self.Min_State()\n        self.Remove_State(X)\n        Kold = X.k\n        if Kold < X.h:\n            for Y in self.GetRealNeighbors(X):\n                if Y.h <= Kold and X.h > Y.h + 1:\n                    X.back = Y.pt.copy()\n                    X.h = Y.h + 1\n        if Kold == X.h:\n            for Y in self.GetRealNeighbors(X):\n                if Y.tag == 0 or (Y.back == X.pt and Y.h != X.h + 1) or (Y.back != X.pt and Y.h > X.h + 1):\n                    Y.back = X.pt.copy()\n                    self.Insert(Y, X.h + 1)\n        else:\n            for Y in self.GetRealNeighbors(X):\n                if Y.tag == 0 or (Y.back == X.pt and Y.h != X.h + 1):\n                    Y.back = X.pt.copy()\n                    self.Insert(Y, X.h + 1)\n                else:\n                    if Y.back != X.pt and Y.h > X.h + 1:\n                        self.Insert(X, X.h)\n                    else:\n                        if Y.back != X.pt and X.h > Y.h + 1 and Y.tag == 2 and Y.h > Kold:\n                            self.Insert(Y, Y.h)\n        return self.GetKMin()\n\n    def dstar(self, bot, Realgoal):\n        while self.grid[bot.x][bot.y].tag != 2:\n            self.process_state()\n        botState = self.grid[bot.x][bot.y]\n        path = []\n        while botState.pt.x != Realgoal.x or botState.pt.y != Realgoal.y:\n            path.append((botState.pt.x, botState.pt.y))\n            botState = self.grid[botState.back.x][botState.back.y]\n        path.append((Realgoal.x, Realgoal.y))\n        return path\n\n# main function\ndef main_solution(map_size_x, map_size_y, goal_x, goal_y, bot_x, bot_y):\n    goal = Point()\n    goal.x = goal_x\n    goal.y = goal_y\n    bot = Point()\n    bot.x = bot_x\n    bot.y = bot_y\n    dstar = DStar(map_size_x, map_size_y, goal)\n    path = dstar.dstar(bot, goal)\n    return {\"path\": path}", "funcname": "main_solution", "ios": [{"input": {"map_size_x": 7, "map_size_y": 8, "goal_x": 3, "goal_y": 3, "bot_x": 2, "bot_y": 3}, "output": {"path": [[2, 3], [3, 3]]}}, {"input": {"map_size_x": 5, "map_size_y": 9, "goal_x": 0, "goal_y": 3, "bot_x": 2, "bot_y": 4}, "output": {"path": [[2, 4], [2, 3], [1, 3], [0, 3]]}}, {"input": {"map_size_x": 10, "map_size_y": 7, "goal_x": 0, "goal_y": 4, "bot_x": 1, "bot_y": 2}, "output": {"path": [[1, 2], [1, 3], [1, 4], [0, 4]]}}, {"input": {"map_size_x": 7, "map_size_y": 6, "goal_x": 1, "goal_y": 1, "bot_x": 3, "bot_y": 2}, "output": {"path": [[3, 2], [3, 1], [2, 1], [1, 1]]}}, {"input": {"map_size_x": 8, "map_size_y": 6, "goal_x": 4, "goal_y": 0, "bot_x": 1, "bot_y": 3}, "output": {"path": [[1, 3], [1, 2], [1, 1], [1, 0], [2, 0], [3, 0], [4, 0]]}}, {"input": {"map_size_x": 10, "map_size_y": 5, "goal_x": 8, "goal_y": 1, "bot_x": 5, "bot_y": 0}, "output": {"path": [[5, 0], [5, 1], [6, 1], [7, 1], [8, 1]]}}, {"input": {"map_size_x": 6, "map_size_y": 5, "goal_x": 4, "goal_y": 0, "bot_x": 2, "bot_y": 2}, "output": {"path": [[2, 2], [2, 1], [2, 0], [3, 0], [4, 0]]}}, {"input": {"map_size_x": 9, "map_size_y": 6, "goal_x": 8, "goal_y": 0, "bot_x": 6, "bot_y": 2}, "output": {"path": [[6, 2], [6, 1], [6, 0], [7, 0], [8, 0]]}}, {"input": {"map_size_x": 5, "map_size_y": 9, "goal_x": 2, "goal_y": 0, "bot_x": 1, "bot_y": 0}, "output": {"path": [[1, 0], [2, 0]]}}, {"input": {"map_size_x": 6, "map_size_y": 7, "goal_x": 0, "goal_y": 2, "bot_x": 2, "bot_y": 0}, "output": {"path": [[2, 0], [2, 1], [2, 2], [1, 2], [0, 2]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BenBallard/DStarLite", "path": "/src/dstar3.py", "msgidx": 2796}}
{"problem_description": "In the game of chess, the N-Queens puzzle is the problem of placing N queens on an N\u00d7N chessboard such that no two queens threaten each other. Given the size of the chessboard `n`, how many distinct solutions exist for placing the queens on the board without any of them being able to attack each other?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of solutions where each solution is represented as a list of strings. Each string represents a row on the chessboard, with 'Q' indicating the position of a queen and '.' indicating an empty space.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        cur = [['.'] * n for i in range(n)]\n        ans = []\n        col = [False for i in range(n)]\n\n        # \u5224\u65ad\u662f\u5426\u4f1a\u6709\u653b\u51fb\n        def attach(r, c):\n            # \u68c0\u67e5\u5217\n            if col[c]:\n                return True\n\n            # \u68c0\u67e5y=x\n            r2, c2 = r, c\n            while c2 > 0 and r2 > 0 :\n                if cur[r2-1][c2-1] == 'Q':\n                    return True\n                r2 -= 1\n                c2 -= 1\n\n            # \u68c0\u67e5y=-x\n            r2, c2 = r, c  \n            while c2 +1 < n and r2 > 0  :\n                if cur[r2-1][c2+1] == 'Q':\n                    return True\n                r2 -= 1\n                c2 += 1\n\n            return False\n\n        def dfs(r):\n            if r == n:\n                ans.append([''.join(i) for i in cur])\n                return True\n                \n            # \u679a\u4e3e\u6bcf\u4e00\u5217\n            for i in range(n):\n                if not attach(r, i):\n                    col[i] = True\n                    cur[r][i] = 'Q'\n                    dfs(r+1)\n                    col[i] = False\n                    cur[r][i] = '.'\n            return False\n\n        # \u4ece\u7b2c0\u884c\u5f00\u59cb\u679a\u4e3e\n        dfs(0)\n        return ans\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": []}, {"input": {"n": 3}, "output": []}, {"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}, {"input": {"n": 1}, "output": [["Q"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "aidway/LeetCode", "path": "/code/51_N\u7687\u540e.py", "msgidx": 3794}}
{"problem_description": "Given a directed graph represented by an adjacency list, determine whether the graph contains a cycle. If the graph is acyclic, provide the topological order of the vertices. What is the result of checking for cycles and, if applicable, the topological order of the vertices?", "io_requirements": "Input:\n  `adjacency_list` (list of lists): A list where each index represents a vertex and the list at that index contains the vertices that the vertex is connected to.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `is_cyclic` (bool): Indicates whether the graph contains a cycle.\n    - `topological_order` (list or None): If the graph is acyclic, it contains the vertices in topological order. If the graph is cyclic, it is `None`.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Vertex:\n    \"\"\" class to set up NODE (VERTEX) properties \"\"\"\n    def __init__(self):\n        self.visited = False  # flags if a VERTEX was visited or not\n        self.group = None  # keeps track of CONNECTED COMPONENTS within the graph\n        self.previsit = None  # these two are for storing the order in which DFS went in and out each NODE\n        self.postvisit = None\n\nclass Graph:\n    \"\"\" class members are dynamic because we are testing a single instance of a class, if they were static the primary values would last through other tests \"\"\"\n    def __init__(self, input_list):  # inside the constructor we commence all the preparatory work\n        self.adj = input_list  # ADJACENCY LIST, which is a representation of our test graph containing EDGES (pointers) to other VERTICES\n        self.nodes = [Vertex() for _ in range(len(input_list))]  # after we instantiate the 'nodes' we have to populate it with the 'Vertex' object to be ready\n        self.counter = 0  # field for the 'group' function\n        self.clock = 1  # field for the pre and post visiting functions\n        self.cycle_value = 0 # field for storing a potential cycle inside a group\n        self.cyclic = False  # flags if we have found a a cycle in a graph\n        self.order = deque()  # stack for the TOPOLOGICAL SORT\n\n    def explore(self, v):  # recursive DFS method that looks around the given VERTEX and finds all other connected VERTICES (direct and indirect)\n        if self.cycle_value in self.adj[v]:  # part of the 'isCyclic()' procedure which checks if the value was present\n            self.cyclic = True\n            return\n\n        self.nodes[v].visited = True\n        self.nodes[v].group = self.counter\n        self.pre_visit(v)\n\n        for w in self.adj[v]:\n            if not self.nodes[w].visited:\n                self.explore(w)  # here we call 'explore' recursively (DFS) before we even finish with looking at all the neighbors\n\n        self.post_visit(v)\n        self.order.appendleft(v)  # here we push the values on a stack for the TOPOLOGICAL SORT while we are backtracking\n\n    def pre_visit(self, v):  # two functions that should keep track of what the DFS is doing inside the GRAPH\n        self.nodes[v].previsit = self.clock\n        self.clock += 1\n\n    def post_visit(self, v):\n        self.nodes[v].postvisit = self.clock\n        self.clock += 1\n\n    def is_cyclic(self):  # function stores the value we are starting with and runs 'explore' to check if it is present in all connected components\n        for v in range(0, len(self.nodes), 1):\n            self.cycle_value = v\n            if not self.nodes[v].visited:\n                self.explore(v)\n\n        if self.cyclic == True:\n            return True\n        else:\n            return False\n\n    def topological_sort(self):  # function uses STACK, as we start placing the elements from the end to the front\n        for v in range(0, len(self.nodes), 1):\n            if not self.nodes[v].visited:\n                self.explore(v)\n        return list(self.order)\n\n# main function\ndef main_solution(adjacency_list):\n    graph = Graph(adjacency_list)\n    is_cyclic = graph.is_cyclic()\n    if is_cyclic:\n        return {\"is_cyclic\": True, \"topological_order\": None}\n    else:\n        topological_order = graph.topological_sort()\n        return {\"is_cyclic\": False, \"topological_order\": topological_order}", "funcname": "main_solution", "ios": [{"input": {"adjacency_list": [[0, 3], [0, 5, 1, 2], [2], [1], [], [2, 4, 3]]}, "output": {"is_cyclic": true, "topological_order": null}}, {"input": {"adjacency_list": [[1, 2, 4], [], [3, 0, 1, 2], [], [1]]}, "output": {"is_cyclic": true, "topological_order": null}}, {"input": {"adjacency_list": [[2, 3, 1, 0, 4], [], [0], [1], [5, 4, 2, 3, 1], [2, 0, 3]]}, "output": {"is_cyclic": true, "topological_order": null}}, {"input": {"adjacency_list": [[], [2], [], [2, 3, 0, 4], [0, 1]]}, "output": {"is_cyclic": true, "topological_order": null}}, {"input": {"adjacency_list": [[1, 4, 2, 0], [2, 1, 4], [1, 4], [3, 4], []]}, "output": {"is_cyclic": true, "topological_order": null}}, {"input": {"adjacency_list": [[0, 1, 4], [3, 4, 1, 2], [0, 3, 1], [], [4, 3, 1]]}, "output": {"is_cyclic": true, "topological_order": null}}, {"input": {"adjacency_list": [[0, 1], [4, 3], [0, 1], [2, 0, 3], [2, 4, 1]]}, "output": {"is_cyclic": true, "topological_order": null}}, {"input": {"adjacency_list": [[], [0, 2, 3], [4, 0, 2, 3], [2, 3], []]}, "output": {"is_cyclic": false, "topological_order": [1, 2, 3, 4, 0]}}, {"input": {"adjacency_list": [[5], [2, 3, 5], [2, 3], [], [1, 0, 5, 2], [3]]}, "output": {"is_cyclic": false, "topological_order": [4, 1, 2, 0, 5, 3]}}, {"input": {"adjacency_list": [[2, 3, 4, 1], [0], [], [], [0]]}, "output": {"is_cyclic": true, "topological_order": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jazywica/Algorithms", "path": "/_03_AlgorithmsOnGraphs/Python/_03_DirectedGraphs.py", "msgidx": 3229}}
{"problem_description": "Given a matrix representing the cost of assigning tasks to workers, where each row corresponds to a worker and each column corresponds to a task, what is the minimum cost of assigning each worker to a unique task such that the total cost is minimized?", "io_requirements": "Input:\n  `N` (int): The size of the matrix (N x N).\n  `N_matrix` (list of strings): A list of strings where each string represents a row of the N x N matrix. Each string contains N space-separated integers.\n\nOutput:\n  `return` (int): The minimum cost of assigning tasks to workers based on the given N x N matrix.", "refcode": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(N, N_matrix):\n    # Convert input to the required format\n    N = int(N)\n    N_matrix = [list(map(int, row.split())) for row in N_matrix]\n\n    # Initialize variables\n    min_cost = sum(N_matrix[i][i] for i in range(N))\n    cost_tmp = 0\n    visited = []\n    row = 0\n\n    # Define the backtrack function\n    def backtrack():\n        nonlocal min_cost, cost_tmp, row\n        if cost_tmp >= min_cost:\n            return\n\n        if len(visited) == N and cost_tmp < min_cost:\n            min_cost = cost_tmp\n            return\n\n        for col in range(N):\n            if col not in visited:\n                visited.append(col)\n                cost_tmp += N_matrix[row][col]\n                row += 1\n                backtrack()\n                row -= 1\n                cost_tmp -= N_matrix[row][col]\n                visited.pop()\n\n    # Call the backtrack function\n    backtrack()\n\n    # Return the result\n    return min_cost", "funcname": "main_solution", "ios": [{"input": {"N": 3, "N_matrix": ["5 4 2", "2 2 2", "1 4 7"]}, "output": 5}, {"input": {"N": 4, "N_matrix": ["6 8 6 5", "4 8 6 4", "1 10 4 10", "5 1 10 7"]}, "output": 12}, {"input": {"N": 5, "N_matrix": ["8 7 6 4 9", "1 2 7 1 1", "2 8 8 4 5", "7 5 1 3 6", "2 7 9 4 4"]}, "output": 13}, {"input": {"N": 3, "N_matrix": ["7 6 2", "5 5 2", "4 5 6"]}, "output": 11}, {"input": {"N": 4, "N_matrix": ["6 4 4 8", "4 7 5 6", "6 6 4 1", "3 10 10 3"]}, "output": 13}, {"input": {"N": 4, "N_matrix": ["3 10 3 10", "7 2 5 4", "3 1 1 5", "9 6 7 8"]}, "output": 14}, {"input": {"N": 5, "N_matrix": ["10 9 3 6 10", "5 10 3 10 2", "9 3 4 5 8", "9 3 9 2 2", "7 2 4 7 10"]}, "output": 17}, {"input": {"N": 5, "N_matrix": ["7 2 6 8 6", "5 6 3 2 7", "4 9 9 5 6", "4 2 4 10 8", "2 4 1 4 3"]}, "output": 15}, {"input": {"N": 3, "N_matrix": ["9 8 10", "1 9 6", "2 7 10"]}, "output": 16}, {"input": {"N": 3, "N_matrix": ["4 9 8", "6 2 9", "1 2 7"]}, "output": 11}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "edugieun/Algorithm-Solving", "path": "/Backtraking/5209_\ucd5c\uc18c \uc0dd\uc0b0 \ube44\uc6a9(D3, Backtracking)/5209_min_cost.py", "msgidx": 3735}}
{"problem_description": "In a scenario where you are tasked with picking values from a list, you know that the values are generated without any specific distribution. However, you need to pick one of the top-k values from the list. Given the number of values to pick from (`N`), the parameter `k`, and the list of values, which values would you pick?", "io_requirements": "Input:\n- `N` (int): Number of values to pick from.\n- `k` (int): Parameter for the agent's decision-making process.\n- `values` (list of float): List of values to be evaluated.\n\nOutput:\n- `return` (list of float): List of values that were picked by the agent.", "refcode": "# import necessary packages\nimport numpy as np\nfrom math import e\n\n# all class and function definitions in the code file, if any\nclass Agent(object):\n    def __init__(self, N):\n        self.N = N\n\n    def restart(self):\n        self.count = 0\n        self.standard = float('-inf')\n\n    def decide(self, value):\n        self.count += 1\n        if self.count >= self.N:\n            return True\n        if self.count * e < self.N:\n            self.standard = max(self.standard, value)\n            return False\n        return (value > self.standard)\n\nclass Basic_2_Agent(Agent):\n    def __init__(self, N, k):\n        self.N = N\n        self.k = k\n\n    def restart(self):\n        super(Basic_2_Agent, self).restart()\n\n    def decide(self, value):\n        self.count += 1\n        k_bound = 1 + (self.k + self.k - 3) / 10 * (0.1 + abs(1 - self.k / 100))\n        if self.count >= self.N:\n            return True\n        if self.count * e * k_bound < self.N:\n            self.standard = max(self.standard, value)\n            return False\n        return (value > self.standard)\n\n# main function\ndef main_solution(N, k, values):\n    \"\"\"\n    Parameters:\n    ----------------------------------------------------------------------------\n    N (int): Number of values to pick from.\n    k (int): Parameter for the agent's decision-making process.\n    values (list of float): List of values to be evaluated.\n    ----------------------------------------------------------------------------\n    \"\"\"\n    agent = Basic_2_Agent(N, k)\n    agent.restart()\n    picked_values = []\n\n    for value in values:\n        if agent.decide(value):\n            picked_values.append(value)\n\n    # Convert the picked values to a JSON serializable format\n    return picked_values", "funcname": "main_solution", "ios": [{"input": {"N": 11, "k": 9, "values": [1.9108388563539247, 54.26831045356151, 12.545206625276673, 74.45646765824418, 37.90137184713318, 15.592619517028595, 27.262861759407464, 43.873375814310286, 59.14904308210633, 73.35462588444781, 30.39725089412907]}, "output": [54.26831045356151, 12.545206625276673, 74.45646765824418, 37.90137184713318, 15.592619517028595, 27.262861759407464, 43.873375814310286, 59.14904308210633, 73.35462588444781, 30.39725089412907]}, {"input": {"N": 15, "k": 2, "values": [82.338911958788, 89.54414841403062, 31.0863621074417, 16.92190445940227, 73.63070581566308, 77.90462488797579, 79.14651257878742, 25.689850547906843, 41.59555978401445, 37.15814535535572, 14.156670410509753, 43.572483783543646, 81.11729985947842, 91.96877930591928, 83.53063109050622]}, "output": [91.96877930591928, 83.53063109050622]}, {"input": {"N": 15, "k": 7, "values": [16.461317189089698, 93.81435228830148, 79.36816742188178, 73.70823745852097, 46.87749297077378, 13.789593228013352, 77.23339748120492, 19.686118482176262, 22.433250693858696, 30.37794004676102, 72.78610786104137, 89.51701898339057, 96.55913150311211, 37.307557533667904, 19.91245289590283]}, "output": [96.55913150311211, 19.91245289590283]}, {"input": {"N": 15, "k": 7, "values": [95.70349902492093, 78.98755876156427, 73.76975517786055, 98.64138488504395, 96.59121023600116, 8.318054311852208, 14.901279730316308, 31.95608958362943, 48.84729968052667, 10.832094863876518, 26.24491532891976, 47.17284717315549, 0.6922701468028647, 10.980166395699753, 58.608165499665276]}, "output": [98.64138488504395, 96.59121023600116, 58.608165499665276]}, {"input": {"N": 15, "k": 9, "values": [84.32028055990938, 11.310190004001752, 21.64868401813044, 91.05993177087166, 52.802338523436966, 94.84345901233169, 28.718328092867964, 50.11616188012569, 85.7384776509339, 84.29738186474862, 80.96962580275455, 33.2023180403082, 71.47064036973615, 45.96340481916572, 89.02066309226629]}, "output": [91.05993177087166, 94.84345901233169, 85.7384776509339, 89.02066309226629]}, {"input": {"N": 13, "k": 5, "values": [7.742686543627797, 41.134722421887716, 76.1365137838844, 16.285812431898204, 51.7359813964681, 18.490619619872707, 73.96396313131925, 91.11525960282717, 88.17238463470272, 41.39416839589505, 42.44970597714366, 54.013193559084286, 63.230210897506836]}, "output": [76.1365137838844, 51.7359813964681, 73.96396313131925, 91.11525960282717, 88.17238463470272, 41.39416839589505, 42.44970597714366, 54.013193559084286, 63.230210897506836]}, {"input": {"N": 14, "k": 6, "values": [75.95191362845222, 79.72728899117718, 98.76600725420897, 19.59601433929462, 54.872078178881736, 57.97191052322008, 90.59252574004604, 25.635914748428913, 79.73303510076387, 18.983786562465443, 36.10172078016829, 50.62613444663827, 67.92336009435365, 21.28804520388099]}, "output": [98.76600725420897, 90.59252574004604, 79.73303510076387, 21.28804520388099]}, {"input": {"N": 12, "k": 7, "values": [36.87436291911891, 21.02819065656467, 86.63578290862691, 34.88002714119207, 49.65216968789352, 91.48385142002417, 96.01861724109041, 79.25938139101328, 73.7689082477836, 51.416732383446, 11.229877574990022, 51.24203916075769]}, "output": [86.63578290862691, 49.65216968789352, 91.48385142002417, 96.01861724109041, 79.25938139101328, 73.7689082477836, 51.416732383446, 51.24203916075769]}, {"input": {"N": 11, "k": 8, "values": [46.3871467041275, 18.37393008269754, 14.571471339689278, 18.460049369383867, 94.84957410728177, 0.5758482853317703, 49.05666023397467, 12.35350465181363, 42.99369010241429, 94.26132280077523, 36.998784585553565]}, "output": [94.84957410728177, 49.05666023397467, 94.26132280077523, 36.998784585553565]}, {"input": {"N": 10, "k": 2, "values": [10.540304602929096, 92.90792522052287, 74.54808161268699, 51.79540423025358, 18.407492946592185, 5.464893433139539, 59.22808435325213, 29.64408507148605, 79.84448774317752, 71.82770068575036]}, "output": [71.82770068575036]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "johnson880319/NTUProbabilityProject", "path": "/agent_define.py", "msgidx": 3354}}
{"problem_description": "In the Game of Thirteen, a deck of 13 cards numbered from 1 to 13 is shuffled and drawn one by one. A coincidence occurs if the number on the card matches the order in which it is drawn. What is the probability of winning the game, defined as drawing all 13 cards without any coincidences, after running a specified number of simulations?", "io_requirements": "Input:\n  `sims` (int): The number of simulations to run. This should be a positive integer.\n\nOutput:\n  `return` (float): The probability of winning the game, which is the fraction of games without any coincidences. This value is a float between 0 and 1.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(sims):\n    # Convert input to numpy array if necessary\n    sims = np.array(sims)\n    \n    # Pre-set constant variables\n    deck = np.arange(1, 14)\n    coincidences = 0\n    \n    for _ in range(sims):\n        # Draw all the cards without replacement to simulate one game\n        draw = np.random.choice(a=deck, size=len(deck), replace=False)\n        # Check if there are any coincidences\n        coincidence = (draw == list(np.arange(1, 14))).any()\n        \n        if coincidence: \n            coincidences += 1\n    \n    # Calculate probability of winning\n    probability_of_winning = 1 - coincidences / sims\n    \n    # Return the probability of winning as a float\n    return float(probability_of_winning)", "funcname": "main_solution", "ios": [{"input": {"sims": 66124}, "output": 0.3681719194241123}, {"input": {"sims": 72502}, "output": 0.3677967504344708}, {"input": {"sims": 26055}, "output": 0.37359431970830936}, {"input": {"sims": 87809}, "output": 0.3667847259392545}, {"input": {"sims": 19050}, "output": 0.36551181102362207}, {"input": {"sims": 84085}, "output": 0.36564190997205204}, {"input": {"sims": 88748}, "output": 0.3664195249470411}, {"input": {"sims": 65391}, "output": 0.36856753987551805}, {"input": {"sims": 69168}, "output": 0.36714954892435814}, {"input": {"sims": 56127}, "output": 0.36666844834037093}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sashakrasnov/datacamp", "path": "/29-statistical-simulation-in-python/2-probability-and-data-generation-process/03-game-of-thirteen.py", "msgidx": 3720}}
{"problem_description": "Given a triangular lattice, we want to determine the total number of regular hexagons that can fit into the lattice as its size varies from `n_start` to `n_end`. What is the total count of all such hexagons?", "io_requirements": "Input:\n  `n_start` (int): The starting size of the triangular lattice.\n  `n_end` (int): The ending size of the triangular lattice.\n\nOutput:\n  `return` (int): The total number of all regular hexagons that can fit into the triangular lattices from size `n_start` to `n_end`.", "refcode": "# import necessary packages\nfrom math import ceil\n\n# all class and function definitions in the code file, if any\ndef sum_1_to_n(n: int) -> int:\n    return n * (n + 1) // 2\n\ndef num_hex_tiles(n: int, hexagon_size: int) -> int:\n    \"\"\"Returns the number of regular hexagons of a given size that can fit into a triangular\n    lattice of size n\"\"\"\n    if n < 3 * hexagon_size:\n        return 0\n    else:\n        return hexagon_size * sum_1_to_n(n - 3 * hexagon_size + 1)\n\ndef num_all_hex_tiles(n: int) -> int:\n    \"\"\"Returns the number of all regular hexagons that can fit into a triangular lattice\n    of size n\"\"\"\n    return sum([num_hex_tiles(n, i) for i in range(1, n // 3 + 1)])\n\n# main function\ndef main_solution(n_start: int, n_end: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum([num_all_hex_tiles(n) for n in range(n_start, n_end + 1)])", "funcname": "main_solution", "ios": [{"input": {"n_start": 381, "n_end": 7412}, "output": 20741437417138928}, {"input": {"n_start": 587, "n_end": 9505}, "output": 71910653076346990}, {"input": {"n_start": 918, "n_end": 7256}, "output": 18648623387165366}, {"input": {"n_start": 493, "n_end": 11254}, "output": 167300228103256688}, {"input": {"n_start": 41, "n_end": 7816}, "output": 27042973633467936}, {"input": {"n_start": 152, "n_end": 11104}, "output": 156446022267291389}, {"input": {"n_start": 214, "n_end": 11819}, "output": 213721037280587297}, {"input": {"n_start": 454, "n_end": 11228}, "output": 165376926076261986}, {"input": {"n_start": 189, "n_end": 10078}, "output": 96356013913824784}, {"input": {"n_start": 190, "n_end": 1895}, "output": 22746060754966}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "stevenschmatz/project-euler", "path": "/problem-577.py", "msgidx": 3140}}
{"problem_description": "Given a set of sequences where each sequence contains alternating segments of characters outside and inside brackets, how many sequences contain an ABA pattern outside the brackets and a corresponding BAB pattern inside the brackets?", "io_requirements": "Input:\n  `input_text` (str): A string containing multiple lines of text, where each line represents a sequence of characters with brackets. The format should be such that each line contains alternating segments of characters outside and inside brackets.\n\nOutput:\n  `return` (int): An integer representing the total number of lines that contain an ABA pattern outside the brackets and a corresponding BAB pattern inside the brackets.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(input_text):\n    # Convert the input text to a list of strings\n    input_lines = input_text.splitlines()\n    \n    total = 0\n    \n    for line in input_lines:\n        arr = re.split(r'\\[|\\]', line)\n        outside = []\n        inside = []\n        for j in range(len(arr)):\n            for k in range(len(arr[j])-2):\n                substr = arr[j][k:k+3]\n                aba = is_aba(substr)\n                if j % 2 == 0 and aba:\n                    outside.append(substr[0:2])\n                elif aba:\n                    inside.append(substr[1:3])\n        ssl = False\n        for i in outside:\n            if i in inside:\n                ssl = True\n        if ssl:\n            total += 1\n    \n    return total\n\n# Helper function to check for ABA pattern\ndef is_aba(substr):\n    if substr[0] != substr[1] and substr[0] == substr[2]:\n        return True\n    return False", "funcname": "main_solution", "ios": [{"input": {"input_text": "kpsqm][tsdchh]\nwscivzx][qlhbzdt]\ncozxa][sylbvy]\nsthykcfqzk][kedsthb]\nldljaz]"}, "output": 0}, {"input": {"input_text": "mxgzluy][mhplupltjp]\nsxsil][obdbhln]\njjpqrxu][rqfwh]\ngfaeyqp][bfzhresa]\ndvbbl][rysgxldaek]"}, "output": 0}, {"input": {"input_text": "doevf]\nzhruezvj][huqxwkqmpb]\ncqrwqzspip][uobljjqkdw]\nkfaprg]\nwmjjf][nveqgbq][gikpjxnn]"}, "output": 0}, {"input": {"input_text": "swkjmj]\nsqobcn][pmlwcgnedq][prdfgyzust]\nlpvgrb][mfsbitg]\nprzimin]\nuusskesvi][vxljfjpy]"}, "output": 0}, {"input": {"input_text": "hrlvyaclm]\njhqvqp][rcwawkclu]\nwasoqkwez][kubccyvve]\nefcqketu][blzha]\nyhqkl]"}, "output": 0}, {"input": {"input_text": "mrddrh]\nogsct][bbfkq]\nhtidyrf]\nsxynjp][pheexptc]\nwdgnmkkyl][ireqwyv]"}, "output": 0}, {"input": {"input_text": "wftfefzoak]\nycmdy][vyvlq][xczhcq]\npwcrmav][juozlgxd]\nclynwjmfl]\nrqxwlhcnz]"}, "output": 0}, {"input": {"input_text": "gufmuzdr][blwhhfh]\nvuigaww]\nmcjxd]\nbqqfqgyk][yktprvio]\nyrprdip][pwqxjr]"}, "output": 0}, {"input": {"input_text": "gmevuubmi]\njpuwnd][mkdam][raolwiuzam]\nlhsmmyp]\niobxkzl][ayrnuqrjbf][wswxsjmoc][ziyzxtmib]\nlgbyt]"}, "output": 0}, {"input": {"input_text": "xzmkjw]\ntopnpfljfp]\nmxplujbi][klvawogly][lufcsacu][hdbfbnlp]\nrqbey][dwklun][jabtrnc][ifdgs]\ncvhxzo]"}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Lesley55/AdventOfCode", "path": "/2016/7/part2.py", "msgidx": 3725}}
{"problem_description": "Given a range of digits from `lo` to `hi`, and a maximum number `max_num`, what is the sum of all products whose multiplicand/multiplier/product identity can be written as a pandigital number using all the digits from `lo` to `hi` exactly once?", "io_requirements": "Input:\n  `lo` (int): The lower limit of the pandigital qualification range.\n  `hi` (int): The upper limit of the pandigital qualification range.\n  `max_num` (int): The maximum number to consider for pandigital products.\n\nOutput:\n  `return` (int): The sum of all products that can be written as a 1 through 9 pandigital.", "refcode": "# import necessary packages\nimport itertools\nimport math\n\n# all class and function definitions in the code file, if any\ndef factors(n):\n    \"\"\"List out the factors of the specified number.\n\n    Parameters\n    ----------\n    n : int\n        The number whose factors will be listed out.\n        If input is float, parse it into integer first.\n\n    Returns\n    -------\n    Set([int])\n        A set of all the factors (meaning no duplicates).\n\n    \"\"\"\n    n = int(n)\n    results = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            results.add(i)\n            results.add(n // i)\n    return results\n\ndef product(aList):\n    \"\"\"Multiplies each number in a list.\n\n    Parameters\n    ----------\n    aList : List[int | float]\n        A list of numbers.\n\n    Returns\n    -------\n    int | float\n        The resulting product of all the numbers in the list.\n\n    \"\"\"\n    res = 1\n    for elem in aList:\n        res *= elem\n    return res\n\ndef listOfPossibleMultiplications(n, numOfMultiplicands):\n    \"\"\"Lists out the possible ways to multiply a number, given the number of\n    multipliers and multiplicands. Depends on `itertools`.\n\n    Parameters\n    ----------\n    n : int\n        The number of which the multiplications will be listed out.\n    numOfMultiplicands : int\n        The number of multipliers and multiplicands, which has to be at least 2.\n\n    Returns\n    -------\n    Tuple(int)\n        Tuple containing the numbers which will multiply into `n`.\n        The length of the tuple is the number of multipliers and multiplicands.\n\n    Raises\n    ------\n    AssertionError\n        when number of multipliers and multiplicands is less than 2.\n\n    \"\"\"\n    # parse the inputs as integers in case it was float or otherwise\n    n = int(n)\n    numOfMultiplicands = int(numOfMultiplicands)\n    # number of multipliers and multiplicands has to be at least 2\n    assert numOfMultiplicands >= 2\n    # leave only those which factors would multiply to the product\n    return filter(lambda x: product(x) == n,\n                  list(itertools.combinations(factors(n), numOfMultiplicands)))\n\ndef pandigitalMultiplications(n, numOfMultiplicands, lo, hi):\n    \"\"\"Returns the set of multiplications and product that results in pandigital-ism.\n    Depends on `itertools`.\n\n    Parameters\n    ----------\n    n : int\n        The number of which the multiplications will be listed out.\n    numOfMultiplicands : int\n        The number of multipliers and multiplicands, which has to be at least 2.\n    lo : int\n        The lower limit of the pandigital qualification range.\n    hi : int\n        The upper limit of the pandigital qualification range.\n\n    Returns\n    -------\n    Set(Tuple(int), int)\n        A set containing a tuple of the multipliers and multiplicands,\n        and the product itself.\n\n    Raises\n    ------\n    AssertionError\n        when lower limit of the pandigital qualification range is higher than\n        the upper limit.\n\n    \"\"\"\n    # parse the inputs as integers in case it was float or otherwise\n    n, numOfMultiplicands = int(n), int(numOfMultiplicands)\n    lo, hi = int(lo), int(hi)\n    # assert that lo is lower than hi\n    assert lo <= hi\n    # using itertools, get a combination of all multiplications given\n    # the number of multipliers + multiplicands\n    multiplicationList = listOfPossibleMultiplications(n, numOfMultiplicands)\n    # this set is used for comparison, which contains numbers\n    rangeSet = set([str(num) for num in range(lo, hi + 1)])\n    # set which contains all possible multiplications to pandigital\n    pandigitalSet = set()\n    for mult in multiplicationList:\n        # store the characters of the string of the numbers\n        # for later comparison\n        pandigitalString = \"\"\n        for elem in mult:\n            pandigitalString += str(elem)\n        pandigitalString += str(n)\n        # if length of the string is the length of the range set\n        if (len(pandigitalString) == len(rangeSet) and\n                # and the sets are equal\n                set(list(pandigitalString)) == rangeSet):\n            # add to the pandigital set a tuple containing:\n            #   - multipliers/multiplicands\n            #   - the product itself\n            pandigitalSet.add((mult, n))\n    return pandigitalSet\n\ndef isUniqueChars(aString):\n    \"\"\"Check whether the input is unique in characters.\n\n    Having the characteristic of being unique in characters mean\n    not one character can be repeated. This includes spaces, dashes,\n    punctuation marks, etc.\n\n    Parameters\n    ----------\n    aString : str\n        A valid string, containing any characters in UTF-8 encoding.\n\n    Returns\n    -------\n    bool\n        True if the string is unique in characters.\n        False otherwise.\n\n    Raises\n    ------\n    TypeError\n        when the input is not of <string> type.\n\n    Examples\n    --------\n    >>> print [isUniqueChars(elem) for elem in ['abc', 'a b c', 'abba', 'a-b c!d']]\n    [True, False, False, True]\n\n    \"\"\"\n    if (type(aString) is not str):\n        raise TypeError(\"Input must be of <string> type.\")\n    # split each character into an element of a list\n    stringList = list(aString)\n    # check whether unique by comparing cardinality of the set with original\n    # list\n    return len(stringList) == len(set(stringList))\n\ndef checkForChars(aString, charList):\n    \"\"\"Check whether any character in a character list exists in the input string.\n\n    Parameters\n    ----------\n    aString : string\n        A string which will be checked for whether characters in the character list\n        exist.\n    charList : List(str)\n        A list of string characters to check whether any of them exist in the string.\n\n    Returns\n    -------\n    bool\n        True if any of the character in the character list exists in the string.\n        False if otherwise.\n\n    Raises\n    ------\n    TypeError\n        - if any element of the character list is not of <string> type\n        - if the input is not of <string> type\n\n    Examples\n    --------\n    >>> aString = \"01234\"\n    >>> charLists = [['0', '5', '05'], ['0'], ['5'], ['05']]\n    >>> print [checkForChars(aString, charList) for charList in charLists]\n    [True, True, False, False]\n    \"\"\"\n    # check if input is of string type\n    if (type(aString) is not str):\n        raise TypeError(\"Input must be of <string> type.\")\n    # check if any element in the list of characters is not of string type\n    if False in [(type(char) is str for char in charList)]:\n        raise TypeError(\"Character list should only contain string types.\")\n    # convert character list into set to avoid iterating over duplicates\n    charList = set([str(char) for char in charList])\n    for char in charList:\n        if char in aString:\n            return True\n    return False\n\n# main function\ndef main_solution(lo, hi, max_num):\n    \"\"\"\n    Finds the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.\n\n    Parameters\n    ----------\n    lo : int\n        The lower limit of the pandigital qualification range.\n    hi : int\n        The upper limit of the pandigital qualification range.\n    max_num : int\n        The maximum number to consider for pandigital products.\n\n    Returns\n    -------\n    int\n        The sum of all products that can be written as a 1 through 9 pandigital.\n    \"\"\"\n    # filter out numbers below max_num that aren't unique in characters\n    possibleNums = filter(lambda x: isUniqueChars(str(x)), range(max_num))\n    # filter out numbers from above that have numbers not included in the\n    # pandigital range\n    possibleNums = filter(lambda x: not checkForChars(str(x), [str(n) for n in range(lo)]),\n                          possibleNums)\n    # store valid numbers in a set, and then sum it up all later\n    resultSet = set()\n    for num in possibleNums:\n        pandigitalMults = pandigitalMultiplications(num, 2, lo, hi)\n        if len(pandigitalMults) > 0:\n            resultSet.add(list(pandigitalMults)[0][1])\n    # return the sum of all valid products\n    return sum(resultSet)", "funcname": "main_solution", "ios": [{"input": {"lo": 4, "hi": 8, "max_num": 7217}, "output": 0}, {"input": {"lo": 5, "hi": 9, "max_num": 5071}, "output": 0}, {"input": {"lo": 5, "hi": 9, "max_num": 6657}, "output": 0}, {"input": {"lo": 5, "hi": 6, "max_num": 6727}, "output": 0}, {"input": {"lo": 1, "hi": 6, "max_num": 1645}, "output": 162}, {"input": {"lo": 5, "hi": 6, "max_num": 7793}, "output": 0}, {"input": {"lo": 1, "hi": 6, "max_num": 7813}, "output": 162}, {"input": {"lo": 5, "hi": 6, "max_num": 3605}, "output": 0}, {"input": {"lo": 4, "hi": 8, "max_num": 8440}, "output": 0}, {"input": {"lo": 3, "hi": 6, "max_num": 9296}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "eddowh/Project-Euler", "path": "/031_to_040/032_Pandigital_Products.py", "msgidx": 2739}}
{"problem_description": "Given a list of words, determine if there exists a permutation of these words that forms a word square. A word square is an ordered sequence of K different words of length K that, when written one word per line, reads the same horizontally and vertically. For example, the list `[\"BALL\", \"AREA\", \"LEAD\", \"LADY\"]` forms a word square. What is the result of checking if a given list of words can form a word square?", "io_requirements": "Input:\n  `word_list` (list of strings): A list of words where each word is a string of uppercase letters. The length of each word should be equal to the number of words in the list.\n\nOutput:\n  `return` (boolean): Returns `True` if there exists a permutation of the input list that forms a word square, otherwise returns `False`.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef is_word_sq(words):\n    if len(words) != len(words[0]):\n        return False\n\n    for i in range(len(words)):\n        for j in range(len(words[0])):\n            if words[i][j] != words[j][i]:\n                return False\n    return True\n\n# main function\ndef main_solution(word_list):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert the input list to a list of strings\n    word_list = [str(word) for word in word_list]\n    \n    # Check if any permutation of the word list forms a word square\n    for perm in itertools.permutations(word_list, len(word_list)):\n        if is_word_sq(perm):\n            return True\n    return False", "funcname": "main_solution", "ios": [{"input": {"word_list": ["CXMVW", "XOVKK", "CFVHS", "NTOHF", "AQVXZ"]}, "output": false}, {"input": {"word_list": ["RLD", "JDA", "NUN"]}, "output": false}, {"input": {"word_list": ["LC", "SM"]}, "output": false}, {"input": {"word_list": ["IBY", "MAP", "VQL"]}, "output": false}, {"input": {"word_list": ["AIN", "NZU", "PUI"]}, "output": false}, {"input": {"word_list": ["XALXK", "CDGMR", "HRZCF", "IRLOX", "FGEHD"]}, "output": false}, {"input": {"word_list": ["OCOZW", "OSFPM", "MCUWM", "LKMFP", "OSRGH"]}, "output": false}, {"input": {"word_list": ["AP", "EG"]}, "output": false}, {"input": {"word_list": ["THBG", "TTKC", "IGVF", "OALN"]}, "output": false}, {"input": {"word_list": ["KCQ", "EJM", "LOD"]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "aarboleda1/princeton_algos", "path": "/practice/google_dev_tech/word_squares.py", "msgidx": 3917}}
{"problem_description": "Given a list of sequences, each representing a partial order of characters that must appear in a password, what is the shortest possible password that satisfies all the given sequences, up to a specified maximum length?", "io_requirements": "Input:\n  `attempts` (list of str): A list of strings where each string represents a sequence of characters that must appear in the password in the given order.\n  `max_length` (int): The maximum length of the password to be generated.\n\nOutput:\n  `return` (str): The password that satisfies all the given attempts. If no such password is found, an empty string is returned.", "refcode": "# import necessary packages\nfrom itertools import permutations\nfrom math import ceil\n\n# main function\ndef main_solution(attempts, max_length):\n    \"\"\"\n    This function finds a password that satisfies all the given attempts.\n    \n    Parameters:\n    attempts (list of str): A list of strings where each string represents a sequence of characters that must appear in the password in the given order.\n    max_length (int): The maximum length of the password to be generated.\n    \n    Returns:\n    str: The password that satisfies all the given attempts.\n    \"\"\"\n    # Convert attempts to a set to remove duplicates and sort them\n    attempts = sorted(set(attempts))\n    \n    # Extract all unique characters from the attempts\n    chars = \"\".join(sorted(set(\"\".join(attempts))))\n    \n    # Generate passwords of increasing length up to max_length\n    for i in range(len(chars), max_length + 1):\n        passwords = permutations(chars * int(ceil(i / len(chars))), i)\n        for password in passwords:\n            password_str = \"\".join(password)\n            if accept(password_str, attempts):\n                return password_str\n    \n    # If no password is found, return an empty string\n    return \"\"\n\ndef accept(password, attempts):\n    \"\"\"\n    Helper function to check if a password satisfies all the given attempts.\n    \n    Parameters:\n    password (str): The password to be checked.\n    attempts (list of str): A list of strings where each string represents a sequence of characters that must appear in the password in the given order.\n    \n    Returns:\n    bool: True if the password satisfies all the attempts, False otherwise.\n    \"\"\"\n    for attempt in attempts:\n        ni = 0\n        for letter in attempt:\n            try:\n                ni = password[ni:].index(letter) + ni\n            except ValueError:\n                return False\n    return True", "funcname": "main_solution", "ios": [{"input": {"attempts": ["vur", "udh", "wnzw", "jib"], "max_length": 7}, "output": ""}, {"input": {"attempts": ["oixp", "kctxx", "bjgtc", "gul"], "max_length": 8}, "output": ""}, {"input": {"attempts": ["vwbu", "ttya", "bam", "etsyw", "ltk", "eyt"], "max_length": 9}, "output": ""}, {"input": {"attempts": ["miqk", "euvz", "hmhu"], "max_length": 7}, "output": ""}, {"input": {"attempts": ["vbaq", "ndmr", "uawez"], "max_length": 10}, "output": ""}, {"input": {"attempts": ["gycd", "gufdx", "wvu", "zpx", "wtj"], "max_length": 8}, "output": ""}, {"input": {"attempts": ["hgstg", "crcn", "twe", "wwrzs", "gkyop", "nudrd", "rqmwk"], "max_length": 7}, "output": ""}, {"input": {"attempts": ["gaoby", "wszo", "girza", "sycuy", "dpl", "icmz", "lbai", "srhdy"], "max_length": 5}, "output": ""}, {"input": {"attempts": ["gpj", "uyjx", "epw", "idvdy", "gbwey", "thtsu", "avp"], "max_length": 5}, "output": ""}, {"input": {"attempts": ["sxn", "jyql", "fjcsc"], "max_length": 5}, "output": ""}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mastergreg/Project_Euler", "path": "/pr_079/solve.py", "msgidx": 3858}}
{"problem_description": "In a Tic-Tac-Toe game, the current state of the board is represented by a sequence of moves made by the players. Given the sequence of moves `current_game`, which move should the CPU make to maximize its chances of winning or at least draw the game?", "io_requirements": "Input:\n  `current_game` (str): A comma-separated string representing the current state of the Tic-Tac-Toe game. Each number represents a move made by the players, starting from 1 to 9. Example: \"1,2,3,4\".\n\nOutput:\n  `return` (str): A string representing the best move for the CPU in the current game state. The move is a single integer between 1 and 9.", "refcode": "# import necessary packages\nimport numpy as np\nfrom copy import deepcopy\nimport itertools\n\nclass board:\n    \"\"\"\n    This class create the board structure, update it,\n    check for winning position.\n    \"\"\"\n    def __init__(self):\n        self.board = [' '] * 10\n\n    def write_move(self, move, symbole):\n        # Write move on board\n        self.board[move] = symbole\n\n    def check_for_victory(self):\n        victory = False\n        # winning combinations\n        victory_combinations = [[1,2,3], [4,5,6], [7,8,9], [1,5,9], [7,5,3], [1,4,7], [2,5,8], [3,6,9]]\n        for combination in victory_combinations:\n            pos1, pos2, pos3 = combination[0], combination[1], combination[2]\n            if self.board[pos1] == self.board[pos2] == self.board[pos3] != \" \":\n                # return the symbole (O or X) that won the game\n                victory = self.board[pos1]\n        return victory\n\ndef copy_board(game_t, first_player):\n    brd = board()\n    if first_player == \"cpu\":\n        starter = 'O' if len(game_t) % 2 == 0 else 'X'\n        opponent = 'O' if starter == 'X' else 'X'\n    else:\n        starter = 'X' if len(game_t) % 2 == 0 else 'O'\n        opponent = 'X' if starter == 'O' else 'O'\n    # reconfigure the board as in game_t\n    for ind, move in enumerate(game_t):\n        symbole = starter if ind % 2 == 0 else opponent\n        brd.write_move(move, symbole)\n    return brd\n\ndef check_level_up(game_t, player, check_op=False):\n    # return scores at game t+1 for each possible move\n    brd = copy_board(game_t, player)\n    available_moves = np.setdiff1d(np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]), game_t)\n    var = {move:0 for move in available_moves}\n    for move in available_moves:\n        board_t =  deepcopy(brd)\n        if player == \"cpu\":\n            if check_op == False:\n                board_t.write_move(move, 'O')\n                status = board_t.check_for_victory()\n                if status != False:\n                    var[move] = 10\n            else:\n                board_t.write_move(move, 'X')\n                status = board_t.check_for_victory()\n                if status != False:\n                    var[move] = -10\n        else:\n            if check_op == False:\n                board_t.write_move(move, 'X')\n                status = board_t.check_for_victory()\n                if status != False:\n                    var[move] = -10\n            else:\n                board_t.write_move(move, 'O')\n                status = board_t.check_for_victory()\n                if status != False:\n                    var[move] = 10\n    return var\n\ndef recursion(game_t0, origin=True, var=None, move_checked=None, len_start=None):\n    # use the len of the game before starting the recursion to keep track of depth\n    if len_start == None:\n        len_start = len(game_t0)\n    # compute depth, depth == 0 before recursion\n    depth = len(game_t0) - len_start\n    # available moves for this specific recursion\n    available_moves_t0 = np.setdiff1d(np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]), game_t0)\n\n    # define the value of each possible move before starting any recursivity\n    if depth == 0:\n        var = check_level_up(game_t0, \"cpu\")\n        if min(check_level_up(game_t0, \"cpu\", check_op=True).values()) == -10:\n            value_human_wining = min(check_level_up(game_t0, \"cpu\", check_op=True), key=check_level_up(game_t0, \"cpu\", check_op=True).get)\n            losing_moves = np.setdiff1d(available_moves_t0, value_human_wining)\n            for i in losing_moves:\n                var[i] = -10\n            return var\n\n    # create a temporary evaluation of possible moves outcome\n    # temporary because could be the recursive move, not the one under evaluation\n    if depth % 2 == 0: # cpu turn:\n        var_temp0 = check_level_up(game_t0, \"cpu\")\n    else: # human turn\n        var_temp0 = check_level_up(game_t0, \"human\")\n\n    # only during recursion\n    if depth > 0:\n        # write the value of the originally evalutated move that brings\n        # an outcome (win or loose)\n        # make sure it doesnt overwrite var if already a value in it form a less deeper recursion\n        if depth % 2 == 0: # cpu turn:\n            if max(var_temp0.values()) == 10 and var[move_checked] == 0:\n                var[move_checked] = 10\n        else: # human turn\n            if min(var_temp0.values()) == -10 and var[move_checked] == 0:\n                var[move_checked] = -10\n            elif var[move_checked] == 0 and max(check_level_up(game_t0, \"human\", check_op=True).values()) == 10:\n                # if a move makes the human win, this move will be 0, all other set at -10\n                if any(i == 0 for i in var_temp0.values()):\n                    value_cpu_wining = max(check_level_up(game_t0, \"human\", check_op=True), key=check_level_up(game_t0, \"cpu\").get)\n                    available_moves_t0 = np.setdiff1d(available_moves_t0, value_cpu_wining)\n\n    # run only if more than one move left\n    if len(available_moves_t0) != 1:\n        for move in available_moves_t0:\n            # run only if there is no outcome yet for this move\n            if var_temp0[move] == 0:\n                game_t1 = game_t0 + [move]\n                # Before starting the recursion, keep track of the move under evaluation\n                if  move_checked==None:\n                    move_checked = move\n                    turn = 0\n                recursion(game_t1, origin=True, var=var, move_checked=move_checked, len_start=len_start)\n                # check if under recursivity, if not, update the move under evaluation\n                if origin == True:\n                    move_checked = move\n    return var\n\ndef minmax_cpu(current_game):\n    var = recursion(current_game)\n    return max(var, key=var.get)\n\n# main function\ndef main_solution(current_game):\n    # Convert the input to the required format\n    current_game = [int(move) for move in current_game.split(',')]\n    \n    # Get the best move for the CPU\n    best_move = minmax_cpu(current_game)\n    \n    # Return the best move as a string\n    return str(best_move)", "funcname": "main_solution", "ios": [{"input": {"current_game": "8,7,1"}, "output": "3"}, {"input": {"current_game": "2,5,4"}, "output": "1"}, {"input": {"current_game": "8,4"}, "output": "1"}, {"input": {"current_game": "8,2"}, "output": "1"}, {"input": {"current_game": "4,2"}, "output": "1"}, {"input": {"current_game": "9,4,6,3"}, "output": "5"}, {"input": {"current_game": "6,3,2,9,4,7"}, "output": "5"}, {"input": {"current_game": "3,5"}, "output": "1"}, {"input": {"current_game": "3,6,8,7,9,2"}, "output": "1"}, {"input": {"current_game": "5"}, "output": "9"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JLefortBesnard/TicTacToe_smartAI", "path": "/minmax_algo.py", "msgidx": 2890}}
{"problem_description": "Given a string that may contain nested parentheses, where each section within parentheses needs to be reversed, how would you transform the string such that all sections within parentheses are reversed, and the parentheses themselves are removed?", "io_requirements": "Input:\n  `inputString` (str): A string that may contain nested parentheses. The string can include any characters except for parentheses, which are used to denote sections that need to be reversed.\n\nOutput:\n  `return` (str): The processed string where all sections within parentheses are reversed, and the parentheses themselves are removed.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef reverse_string(inputString):\n    words = []\n    length = 0\n    index = 0 \n    \n    while index < len(inputString):\n        if inputString[index] == \"(\":\n            recurse = reverse_string(inputString[index+1:])\n            words.extend(recurse[0])\n            index += recurse[1] + 1\n            length += recurse[1] + 1\n        elif inputString[index] == \")\":\n            length += 1\n            break\n        else:\n            words.append(inputString[index])\n            index += 1\n            length += 1\n\n    return (list(reversed(words)), length)\n\n# main function\ndef main_solution(inputString):\n    # Convert the input string to a list of characters\n    inputString = list(inputString)\n    \n    # Call the reverseInParentheses function\n    result = reverseInParentheses(inputString)\n    \n    # Convert the result back to a string\n    return ''.join(result)\n\ndef reverseInParentheses(inputString):\n    words = []\n    index = 0\n    \n    while index < len(inputString):\n        if inputString[index] == '(':\n            reversed_parts = reverse_string(inputString[index+1:])\n            words.extend(reversed_parts[0])\n            index += reversed_parts[1]\n        elif inputString[index] == ')':\n            index += 1\n        else:\n            words.append(inputString[index])\n            index += 1\n            \n    return words", "funcname": "main_solution", "ios": [{"input": {"inputString": "((DHiE)ZP)gMFdO"}, "output": "PZDHiEgMFdO"}, {"input": {"inputString": "(((JDI)qgR)qKC)w"}, "output": "CKqIDJqgRw"}, {"input": {"inputString": "((fxlX)skIW)NqXXf"}, "output": "WIksfxlXNqXXf"}, {"input": {"inputString": "((RcHA)fpAE)Ur"}, "output": "EApfRcHAUr"}, {"input": {"inputString": "(((rs)l)ReD)YBBo"}, "output": "DeRsrlYBBo"}, {"input": {"inputString": "(((G)ui)IrD)yLD"}, "output": "DrIGuiyLD"}, {"input": {"inputString": "((vhd)hFn)SQ"}, "output": "nFhvhdSQ"}, {"input": {"inputString": "(EvcNz)KX"}, "output": "zNcvEKX"}, {"input": {"inputString": "(Gqb)nkXi"}, "output": "bqGnkXi"}, {"input": {"inputString": "(vkdI)QkuWL"}, "output": "IdkvQkuWL"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "therealmaxkim/Playground", "path": "/Codesignal/Arcade - Intro/reverse_in_parenthesis/code.py", "msgidx": 3765}}
{"problem_description": "In an ice cream shop, customers can buy ice cream balls in sets of three or five. Given a certain number of ice cream balls `k`, can you determine if it is possible to buy exactly `k` balls using only these sets? If it is possible, the answer should be \"YES\"; otherwise, it should be \"NO\". What is the result for a given `k`?", "io_requirements": "Input:\n  `k` (int): The number of ice cream balls to be purchased. It must be a positive integer.\n\nOutput:\n  `return` (str): A string that is either \"YES\" or \"NO\". \"YES\" indicates that it is possible to buy exactly `k` ice cream balls using combinations of 3 and 5 balls, and \"NO\" indicates that it is not possible.", "refcode": "# import necessary packages\nfrom math import modf\nimport decimal\n\n# main function\ndef main_solution(k):\n    # Convert k to a decimal for precision\n    k = decimal.Decimal(k)\n    \n    # Generate possible values for x\n    x = tuple(map(decimal.Decimal, range(int(k) // 3 + 1)))\n    \n    # Calculate corresponding y values\n    y = map(lambda j: -(decimal.Decimal(3) / decimal.Decimal(5)) * j + k / decimal.Decimal(5), x)\n    \n    # Filter out non-integer y values\n    result = filter(lambda j: False if modf(j[1])[0] else True, zip(x, y))\n    \n    # Convert to tuple of integers\n    result = tuple(map(lambda j: (int(j[0]), int(j[1])), result))\n    \n    # Return \"YES\" if there is at least one valid combination, otherwise \"NO\"\n    return \"YES\" if len(result) > 0 else \"NO\"", "funcname": "main_solution", "ios": [{"input": {"k": 79}, "output": "YES"}, {"input": {"k": 9}, "output": "YES"}, {"input": {"k": 3}, "output": "YES"}, {"input": {"k": 33}, "output": "YES"}, {"input": {"k": 77}, "output": "YES"}, {"input": {"k": 26}, "output": "YES"}, {"input": {"k": 98}, "output": "YES"}, {"input": {"k": 42}, "output": "YES"}, {"input": {"k": 6}, "output": "YES"}, {"input": {"k": 44}, "output": "YES"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ekomissarov/edu", "path": "/py-basics/uneex_homework/7_1.py", "msgidx": 3974}}
{"problem_description": "Given a chessboard of a certain size, where queens are placed in specific initial positions, determine if it is possible to rearrange the queens such that no two queens can attack each other. The queens must be placed in such a way that they do not share the same row, column, or diagonal. What is the result of attempting to solve this problem for a randomly generated board size and initial queen positions?", "io_requirements": "Input:\n  `board_size` (int): The size of the board, which is the number of rows and columns.\n  `initial_queens` (list of int): A list representing the initial positions of queens on the board. Each element in the list represents the column position of a queen in the corresponding row.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `board_size` (int): The size of the board.\n    - `initial_queens` (list of int): The initial positions of queens on the board.\n    - `solution_found` (bool): A boolean indicating whether a solution was found for the given initial queen positions.", "refcode": "# import necessary packages\nimport sys\nimport time\n\n# main function\ndef main_solution(board_size, initial_queens):\n    # Convert JSON serializable inputs to original input variables\n    BOARD_SIZE = board_size\n    queue = []\n    dom = {i: set(range(BOARD_SIZE)) for i in range(BOARD_SIZE)}\n\n    def queen(A, a, B, b):\n        return A == B or (a != b and A + a != B + b and A - a != B - b)\n\n    def neighbors(xi):\n        return set(range(BOARD_SIZE)) - {xi}\n\n    def arcons(queens, queue):\n        if len(queue) == 0:\n            queue = [(Xi, Xk) for Xi in range(BOARD_SIZE) for Xk in neighbors(Xi)]\n            while queue:\n                (x1, x2) = queue.pop()\n                if unconsist(queens, x1, x2):\n                    if not dom[x1]:\n                        return False\n                    for xk in neighbors(x1):\n                        queue.append((xk, x1))\n            return True\n\n    def unconsist(queens, x1, x2):\n        removed = False\n        for x in dom[x1]:\n            if all(not queen(x1, x, x2, y) for y in dom[x2]):\n                dom[x1].remove(x)\n                removed = True\n        return removed\n\n    # Call the main logic function\n    ans = arcons(initial_queens, queue)\n\n    # Convert the output to JSON serializable format\n    result = {\n        \"board_size\": BOARD_SIZE,\n        \"initial_queens\": initial_queens,\n        \"solution_found\": ans\n    }\n    return result", "funcname": "main_solution", "ios": [{"input": {"board_size": 6, "initial_queens": [1, 0, 4, 1, 2, 0]}, "output": {"board_size": 6, "initial_queens": [1, 0, 4, 1, 2, 0], "solution_found": true}}, {"input": {"board_size": 4, "initial_queens": [3, 3, 1, 0]}, "output": {"board_size": 4, "initial_queens": [3, 3, 1, 0], "solution_found": true}}, {"input": {"board_size": 5, "initial_queens": [0, 3, 4, 2, 0]}, "output": {"board_size": 5, "initial_queens": [0, 3, 4, 2, 0], "solution_found": true}}, {"input": {"board_size": 6, "initial_queens": [5, 4, 2, 3, 2, 3]}, "output": {"board_size": 6, "initial_queens": [5, 4, 2, 3, 2, 3], "solution_found": true}}, {"input": {"board_size": 8, "initial_queens": [3, 4, 3, 3, 0, 0, 4, 2]}, "output": {"board_size": 8, "initial_queens": [3, 4, 3, 3, 0, 0, 4, 2], "solution_found": true}}, {"input": {"board_size": 6, "initial_queens": [5, 1, 5, 4, 1, 3]}, "output": {"board_size": 6, "initial_queens": [5, 1, 5, 4, 1, 3], "solution_found": true}}, {"input": {"board_size": 5, "initial_queens": [3, 0, 1, 4, 0]}, "output": {"board_size": 5, "initial_queens": [3, 0, 1, 4, 0], "solution_found": true}}, {"input": {"board_size": 8, "initial_queens": [2, 0, 3, 1, 0, 7, 3, 0]}, "output": {"board_size": 8, "initial_queens": [2, 0, 3, 1, 0, 7, 3, 0], "solution_found": true}}, {"input": {"board_size": 7, "initial_queens": [0, 2, 2, 5, 0, 4, 1]}, "output": {"board_size": 7, "initial_queens": [0, 2, 2, 5, 0, 4, 1], "solution_found": true}}, {"input": {"board_size": 7, "initial_queens": [2, 6, 3, 3, 0, 1, 4]}, "output": {"board_size": 7, "initial_queens": [2, 6, 3, 3, 0, 1, 4], "solution_found": true}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Atieno-Ouma/AI-ML", "path": "/N_Queen_Problem/arc.py", "msgidx": 4008}}
{"problem_description": "Given a string, how can we generate all possible unique permutations of its characters? For example, if the string is \"abc\", the permutations would be \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", and \"cba\". What would be the list of all permutations for a randomly generated string?", "io_requirements": "Input:\n  `sequence` (str): A non-empty string for which permutations need to be generated.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string `sequence`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef get_permutations(sequence):\n    '''\n    Enumerate all permutations of a given string\n\n    sequence (string): an arbitrary string to permute. Assume that it is a\n    non-empty string.  \n\n    You MUST use recursion for this part. Non-recursive solutions will not be\n    accepted.\n\n    Returns: a list of all permutations of sequence\n\n    Example:\n    >>> get_permutations('abc')\n    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n\n    Note: depending on your implementation, you may return the permutations in\n    a different order than what is listed here.\n    '''\n    sequence_list = list(sequence)\n    if len(sequence) == 0:\n        print('empty sequence')\n        \n    if len(sequence) == 1:\n        return sequence_list\n\n    if len(sequence_list) > 1:\n        sequence0 = ''.join(sequence_list[0])\n        sequence_leftover_list = sequence_list[1:len(sequence_list)]\n        sequence_leftover = ''.join(sequence_leftover_list)\n        last = get_permutations(sequence_leftover)\n        final_list = []\n        for i in range(len(last)):\n            list_new = []\n            for j in range(len(sequence)):\n                list_new.append (last[i][0:j] + sequence0 + last[i][j:len(last[i])])\n            final_list += list_new\n        return final_list\n\n# main function\ndef main_solution(sequence):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    permutations = get_permutations(sequence)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"sequence": "mz"}, "output": ["mz", "zm"]}, {"input": {"sequence": "u"}, "output": ["u"]}, {"input": {"sequence": "mo"}, "output": ["mo", "om"]}, {"input": {"sequence": "c"}, "output": ["c"]}, {"input": {"sequence": "rwp"}, "output": ["rwp", "wrp", "wpr", "rpw", "prw", "pwr"]}, {"input": {"sequence": "ju"}, "output": ["ju", "uj"]}, {"input": {"sequence": "td"}, "output": ["td", "dt"]}, {"input": {"sequence": "xo"}, "output": ["xo", "ox"]}, {"input": {"sequence": "j"}, "output": ["j"]}, {"input": {"sequence": "f"}, "output": ["f"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tufanggongcheng/MIT_OCW-6.0001-ProblemSet-Solutions", "path": "/ps4/ps4a.py", "msgidx": 3840}}
{"problem_description": "Given a string consisting of lowercase alphabetic characters, how can we generate all possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string. Each permutation is represented as a string.", "refcode": "# import necessary packages\nimport time\n\n# all class and function definitions in the code file, if any\ndef permutations(string, begin, end):\n    if begin == end:\n        return [string]\n\n    permut = []\n    for i in range(begin, end):\n        fixedstr = string[0:begin] + string[i] + string[begin:i] + string[i+1:]\n        permut += permutations(fixedstr, begin + 1, end)\n    return permut\n\n# main function\ndef main_solution(input_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = permutations(input_string, 0, len(input_string))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "rgz"}, "output": ["rgz", "rzg", "grz", "gzr", "zrg", "zgr"]}, {"input": {"input_string": "uto"}, "output": ["uto", "uot", "tuo", "tou", "out", "otu"]}, {"input": {"input_string": "yte"}, "output": ["yte", "yet", "tye", "tey", "eyt", "ety"]}, {"input": {"input_string": "loi"}, "output": ["loi", "lio", "oli", "oil", "ilo", "iol"]}, {"input": {"input_string": "drv"}, "output": ["drv", "dvr", "rdv", "rvd", "vdr", "vrd"]}, {"input": {"input_string": "zhu"}, "output": ["zhu", "zuh", "hzu", "huz", "uzh", "uhz"]}, {"input": {"input_string": "nug"}, "output": ["nug", "ngu", "ung", "ugn", "gnu", "gun"]}, {"input": {"input_string": "qsg"}, "output": ["qsg", "qgs", "sqg", "sgq", "gqs", "gsq"]}, {"input": {"input_string": "yxp"}, "output": ["yxp", "ypx", "xyp", "xpy", "pyx", "pxy"]}, {"input": {"input_string": "odt"}, "output": ["odt", "otd", "dot", "dto", "tod", "tdo"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zeddo123/coding-interview-problem", "path": "/permutations.py", "msgidx": 3909}}
{"problem_description": "Given a list of integers `S`, a subset `s`, and an integer `k`, what are the pairs of subsets of length `k` that share exactly the subset `s`?", "io_requirements": "Input:\n  `S` (list of integers): A list of integers from which subsets are to be formed.\n  `k` (int): An integer representing the length of the subsets to be formed.\n  `s` (list of integers): A list of integers representing the subset that should be shared in the pairs of subsets.\n\nOutput:\n  `return` (list of tuples): A list of tuples, where each tuple contains two lists of integers. Each tuple represents a pair of subsets of length `k` that share the subset `s`.", "refcode": "# import necessary packages\nfrom itertools import permutations, combinations\n\n# all class and function definitions in the code file, if any\ndef subset(l, L):\n    \"\"\"\n    Takes two lists and returns True if the first one is contained in the second one. If the lists could be sorted,\n    it would be more efficient.\n    :param l: `list` instance.\n    :param L: `list` instance.\n    :return: `bool` instance.\n    \"\"\"\n    return all(x in L for x in l)\n\ndef subsets_with_k_elements_that_contain_subset_s(S, k, s):\n    \"\"\"\n    Returns a list with all the sublists of S of length k that contain a given sublist s.\n    :param S: `list` instance.\n    :param k: `int` instance.\n    :param s: `list` instance.\n    :return: `list` instance.\n    \"\"\"\n    s = tuple(s)\n\n    if k < len(s):\n        pass\n    elif not subset(s, S):\n        pass\n    elif k == len(s):\n        yield s\n    else:\n        for x in combinations(set(S) - set(s), k - len(s)):\n            yield s + x\n\ndef pairs_of_disjoint_subsets_with_k_elements(S, k):\n    \"\"\"\n    Returns a list of pairs of sublists with length k that share no elements. This assumes the elements to be\n    ordinal.\n    :param S: `list` instance.\n    :param k: `int` instance.\n    :return: `list` instance.\n    \"\"\"\n    S = set(S)\n\n    if len(S) >= 2*k:\n        for s1 in combinations(S, k):\n            for s2 in combinations(S - set(s1), k):\n                if s1 <= s2:\n                    yield s1, s2\n\ndef pairs_of_subsets_with_k_elements_that_share_exactly_subset_s(S, k, s):\n    \"\"\"\n    Returns a list of pairs of sublists with length k that share a given subset s. This assumes the elements to be\n    ordinal.\n    :param S: `list` instance.\n    :param k: `int` instance.\n    :param s: `list` instance.\n    :return: `list` instance.\n    \"\"\"\n    s = tuple(s)\n    if k >= len(s):\n        for s1, s2 in pairs_of_disjoint_subsets_with_k_elements(set(S) - set(s), k - len(s)):\n            yield s1+s, s2+s\n\ndef finite_bijections(A, B):\n    \"\"\"\n    Gives a list with all finite bijections between lists A and B. A bijection is expressed as a list of pairs, whose\n    first component is in A and its second component is the image of the first through the bijection, in B.\n    :param A: `list` instance.\n    :param B: `list` instance.\n    :return: `list` instance.\n    \"\"\"\n    A = tuple(A)\n    B = tuple(B)\n    if len(A) != len(B):\n        pass\n    else:\n        for perm in permutations(B):\n            yield {A[i]: b for i, b in enumerate(perm)}\n\n# main function\ndef main_solution(S, k, s):\n    \"\"\"\n    Returns a list of pairs of sublists with length k that share a given subset s.\n    :param S: `list` of integers.\n    :param k: `int` representing the length of the subsets.\n    :param s: `list` of integers representing the subset that should be shared.\n    :return: `list` of tuples, where each tuple contains two lists of integers.\n    \"\"\"\n    result = list(pairs_of_subsets_with_k_elements_that_share_exactly_subset_s(S, k, s))\n    return result", "funcname": "main_solution", "ios": [{"input": {"S": [3, 6, 10, 12, 5], "k": 3, "s": [12]}, "output": [[[3, 5, 12], [10, 6, 12]], [[3, 6, 12], [10, 5, 12]], [[5, 6, 12], [10, 3, 12]]]}, {"input": {"S": [17, 5, 14, 15, 4], "k": 3, "s": [4, 5]}, "output": [[[14, 4, 5], [17, 4, 5]], [[14, 4, 5], [15, 4, 5]], [[15, 4, 5], [17, 4, 5]]]}, {"input": {"S": [12, 13, 19, 17, 5], "k": 4, "s": [5, 13, 17]}, "output": [[[12, 5, 13, 17], [19, 5, 13, 17]]]}, {"input": {"S": [18, 19, 12, 6, 4], "k": 4, "s": [4]}, "output": []}, {"input": {"S": [1, 8, 12, 5, 14], "k": 4, "s": [1, 8]}, "output": []}, {"input": {"S": [9, 2, 12, 16, 10], "k": 4, "s": [12, 9]}, "output": []}, {"input": {"S": [6, 5, 4, 14, 16], "k": 3, "s": [16, 4]}, "output": [[[5, 16, 4], [6, 16, 4]], [[5, 16, 4], [14, 16, 4]], [[6, 16, 4], [14, 16, 4]]]}, {"input": {"S": [1, 6, 11, 5, 7, 14], "k": 4, "s": [1]}, "output": []}, {"input": {"S": [18, 19, 9, 1, 16], "k": 4, "s": [19, 16]}, "output": []}, {"input": {"S": [5, 6, 14, 1, 2], "k": 4, "s": [5, 6, 2]}, "output": [[[1, 5, 6, 2], [14, 5, 6, 2]]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bielr/biotrees", "path": "/biotrees/combinatorics.py", "msgidx": 3497}}
{"problem_description": "Given a Sudoku puzzle represented as a string of 81 characters, where each character is either a digit from '1' to '9' or a period ('.') representing an empty cell, what is the solved Sudoku grid as a string of 81 characters? If no solution exists, return \"No solution exists\".", "io_requirements": "Input:\n  `grid` (str): A string representing a Sudoku grid. The string should be of length 81, where each character represents a cell in the Sudoku grid. Empty cells are represented by a period ('.').\n\nOutput:\n  `return` (str): A string representing the solved Sudoku grid. The string will be of length 81, where each character represents a cell in the solved Sudoku grid. If no solution exists, the string will be \"No solution exists\".", "refcode": "# import necessary packages\nimport string\n\n# Constants\nSQUARE_SIZE = 3\nDIMENSION = SQUARE_SIZE * SQUARE_SIZE\nROWS = string.ascii_uppercase[:DIMENSION]\nCOLS = \"\".join([str(n) for n in range(1, DIMENSION + 1)])\n\n# Helper functions\ndef cross(A, B):\n    return [a + b for a in A for b in B]\n\nBOXES = cross(ROWS, COLS)\nDIAGONAL_UNITS = [[\"\".join(n) for n in zip(ROWS, COLS)], [\"\".join(n) for n in zip(ROWS, COLS[::-1])]]\nROW_UNITS = [cross(r, COLS) for r in ROWS]\nCOL_UNITS = [cross(ROWS, c) for c in COLS]\nSQUARE_UNITS = [cross(r, c) for r in [ROWS[n:n + SQUARE_SIZE] for n in range(0, len(ROWS), SQUARE_SIZE)] for c in [COLS[n:n + SQUARE_SIZE] for n in range(0, len(COLS), SQUARE_SIZE)]]\n\nUNITLIST = ROW_UNITS + COL_UNITS + SQUARE_UNITS\nUNITS = dict((box, [u for u in UNITLIST if box in u]) for box in BOXES)\nPEERS = dict((box, set(sum(UNITS[box], [])) - set([box])) for box in BOXES)\n\ndef grid_values(grid):\n    assert len(grid) == len(BOXES)\n    return dict(zip(BOXES, [n if n in COLS else COLS for n in grid]))\n\ndef assign_value(values, box, value):\n    values[box] = value\n    return values\n\ndef naked_twins(values):\n    for unit in UNITLIST:\n        twin_boxes = [box for box in unit if len(values[box]) == 2]\n        while twin_boxes:\n            twin = twin_boxes.pop()\n            matches = [box for box in twin_boxes if values[twin] == values[box]]\n            if matches:\n                twin_boxes.pop(twin_boxes.index(matches[0]))\n                naked_twin = values[twin]\n            else:\n                naked_twin = \"\"\n            for value in naked_twin:\n                peer_boxes = set(unit) - set([twin, matches[0]])\n                values = _eliminate_value(values, peer_boxes, value)\n    return values\n\ndef _eliminate_value(values, boxes, value):\n    for box in boxes:\n        if value in values[box]:\n            _value = values[box].replace(value, '')\n            assign_value(values, box, _value)\n    return values\n\ndef eliminate(values):\n    solved = [box for box in values if len(values[box]) == 1]\n    for solved_box in solved:\n        values = _eliminate_value(values, PEERS[solved_box], values[solved_box])\n    return values\n\ndef only_choice(values):\n    for unit in UNITLIST:\n        for digit in COLS:\n            places = [box for box in unit if digit in values[box]]\n            if len(places) == 1:\n                assign_value(values, places[0], digit)\n    return values\n\ndef reduce_puzzle(values):\n    progressing = True\n    while progressing:\n        before = len([box for box in values if len(values[box]) == 1])\n        values = eliminate(values)\n        values = only_choice(values)\n        values = naked_twins(values)\n        after = len([box for box in values if len(values[box]) == 1])\n        if len([box for box in values if len(values[box]) == 0]):\n            return False\n        progressing = after != before\n    return values\n\ndef search(values):\n    values = reduce_puzzle(values)\n    if not values:\n        return False\n    if all(len(values[box]) == 1 for box in BOXES):\n        return values\n    box, candidates = min((pair for pair in values.items() if len(pair[1]) > 1), key=lambda x: len(x[1]))\n    for candidate in candidates:\n        new_values = values.copy()\n        assign_value(new_values, box, candidate)\n        result = search(new_values)\n        if result:\n            return result\n    return False\n\n# main function\ndef main_solution(grid):\n    # Convert the grid string to a dictionary\n    values = grid_values(grid)\n    # Solve the Sudoku puzzle\n    solution = search(values)\n    # Convert the solution dictionary back to a string\n    if solution:\n        return ''.join(solution[box] for box in BOXES)\n    else:\n        return \"No solution exists\"", "funcname": "main_solution", "ios": [{"input": {"grid": ".9322465841.8974732147921575185557.434.6823726464299.926251.266765859543247346745"}, "output": "No solution exists"}, {"input": {"grid": "28269998912327.2536682549.7225..2294764.9124.895818.156.2.13776759946939.47328.53"}, "output": "No solution exists"}, {"input": {"grid": "6699528.8718.5871.75192.382629744.5245845458338467172.419433179.8.623.5315176.819"}, "output": "No solution exists"}, {"input": {"grid": "15.264558474175665237..84974.2159838..857225.8168.611398.273351513.53377329212969"}, "output": "No solution exists"}, {"input": {"grid": "6722.8314658435611389.434323268676813211496.278617725971448659455428449124.462753"}, "output": "No solution exists"}, {"input": {"grid": "186.94.8928.7.642354837626.439944.2523.891774273185.156955327667151956623998.2894"}, "output": "No solution exists"}, {"input": {"grid": "..648953858342931989197926.93.148.9794755756918.334.6729.944638.77.59189216115298"}, "output": "No solution exists"}, {"input": {"grid": ".114761144..23893674996923115914235594479.199482688311887172.684389391.8681.6.929"}, "output": "No solution exists"}, {"input": {"grid": "578694.744..4598481735.7471689429.13782325615.857913336894125337.776214771.445.68"}, "output": "No solution exists"}, {"input": {"grid": "7364929474.449.231.58786636265536286.17182538648474212198448526868349889778383353"}, "output": "No solution exists"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "barney-s/AIND-Sudoku", "path": "/solution.py", "msgidx": 3306}}
{"problem_description": "You are given a list of scrambling operations that need to be applied to a password string. Each operation can swap positions, swap letters, rotate the string left or right, rotate based on the position of a letter, reverse a segment of the string, or move a letter to a new position. Given a set of such operations and an initial 8-character password, what will be the resulting scrambled password after applying all the operations in sequence?", "io_requirements": "Input:\n  `instructions` (list of strings): A list of strings where each string represents a scrambling operation. Each operation follows the format described in the problem statement.\n  `initial_password` (string): The initial password string that needs to be scrambled. It should be an 8-character string consisting of lowercase letters.\n\nOutput:\n  `return` (string): The scrambled password after applying all the operations in the `instructions` list to the `initial_password`.", "refcode": "# import necessary packages\nimport re\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef swap_position(instruction, word):\n    num1 = int(re.search(r\"^swap\\sposition\\s(\\d)\", instruction).group(1))\n    num2 = int(re.search(r\"(\\d)$\", instruction).group(1))\n    let1, let2 = word[num1], word[num2]\n    word = word[:num1] + let2 + word[num1 + 1:]\n    word = word[:num2] + let1 + word[num2 + 1:]\n    return word\n\ndef swap_letter(instruction, word):\n    let1 = re.search(r\"^swap\\sletter\\s(\\w)\", instruction).group(1)\n    let2 = re.search(r\"(\\w)$\", instruction).group(1)\n    num1, num2 = word.index(let1), word.index(let2)\n    word = word[:num1] + let2 + word[num1 + 1:]\n    word = word[:num2] + let1 + word[num2 + 1:]\n    return word\n\ndef rotate_sideways(instruction, word):\n    num_shift = int(re.search(r\"(\\d)\", instruction).group(1))\n    if \"left\" in instruction:\n        word = word[num_shift:] + word[:num_shift]\n    elif \"right\" in instruction:\n        word = word[-num_shift:] + word[:-num_shift]\n    return word\n\ndef rotate_position(instruction, word):\n    let_shift = re.search(r\"(\\w)$\", instruction).group(1)\n    num_shift = word.index(let_shift)\n    if num_shift >= 4:\n        num_shift += 2\n    else:\n        num_shift += 1\n    if num_shift > len(word):\n        num_shift = num_shift - len(word)\n    return word[-num_shift:] + word[:-num_shift]\n\ndef reverse(instruction, word):\n    num1 = int(re.search(r\"(\\d)\\sthrough\\s(\\d)\", instruction).group(1))\n    num2 = int(re.search(r\"(\\d)\\sthrough\\s(\\d)\", instruction).group(2)) + 1\n    new_order = word[num1:num2][::-1]\n    return word[:num1] + new_order + word[num2:]\n\ndef move(instruction, word):\n    num1 = int(re.search(r\"(\\d)\\sto\\sposition\\s(\\d)\", instruction).group(1))\n    num2 = int(re.search(r\"(\\d)\\sto\\sposition\\s(\\d)\", instruction).group(2))\n    let = word[num1]\n    temp = word[:num1] + word[num1 + 1:]\n    return temp[:num2] + let + temp[num2:]\n\n# main function\ndef main_solution(instructions, initial_password):\n    word = initial_password\n    for instruction in instructions:\n        if \"swap position\" in instruction:\n            word = swap_position(instruction, word)\n        elif \"swap letter\" in instruction:\n            word = swap_letter(instruction, word)\n        elif \"rotate left\" in instruction or \"rotate right\" in instruction:\n            word = rotate_sideways(instruction, word)\n        elif \"rotate based on position\" in instruction:\n            word = rotate_position(instruction, word)\n        elif \"reverse\" in instruction:\n            word = reverse(instruction, word)\n        elif \"move\" in instruction:\n            word = move(instruction, word)\n    return word", "funcname": "main_solution", "ios": [{"input": {"instructions": ["rotate right 6 steps", "rotate based on position of letter f", "swap position 6 with position 0", "swap letter e with letter a", "reverse positions 4 through 4"], "initial_password": "gbaecfhd"}, "output": "cdgbeahf"}, {"input": {"instructions": ["rotate right 1 steps", "rotate left 6 steps", "rotate right 7 steps", "reverse positions 2 through 2", "rotate left 7 steps"], "initial_password": "ahefdgcb"}, "output": "gcbahefd"}, {"input": {"instructions": ["rotate left 3 steps", "move position 7 to position 6", "rotate based on position of letter g", "swap letter g with letter e", "rotate based on position of letter c"], "initial_password": "cadgbefh"}, "output": "aebgfhcd"}, {"input": {"instructions": ["swap position 7 with position 0", "rotate based on position of letter b", "swap position 4 with position 0", "rotate left 3 steps", "swap letter c with letter f"], "initial_password": "febhagcd"}, "output": "dgbhaefc"}, {"input": {"instructions": ["rotate left 5 steps", "swap position 5 with position 1", "reverse positions 3 through 6", "rotate based on position of letter g", "swap letter e with letter f"], "initial_password": "fghcaebd"}, "output": "hdcbgeaf"}, {"input": {"instructions": ["rotate based on position of letter f", "swap letter g with letter f", "swap letter c with letter h", "move position 0 to position 3", "move position 7 to position 1"], "initial_password": "fbdgchea"}, "output": "gebdafhc"}, {"input": {"instructions": ["rotate based on position of letter h", "swap letter c with letter g", "reverse positions 0 through 6", "swap position 5 with position 3", "move position 1 to position 0"], "initial_password": "acfgehbd"}, "output": "bdhfcega"}, {"input": {"instructions": ["rotate based on position of letter h", "swap position 7 with position 7", "rotate right 4 steps", "rotate right 2 steps", "rotate based on position of letter e"], "initial_password": "fhcbgade"}, "output": "efhcbgad"}, {"input": {"instructions": ["swap letter d with letter c", "move position 5 to position 7", "swap position 4 with position 7", "rotate left 6 steps", "rotate left 5 steps"], "initial_password": "fgdcbhae"}, "output": "dhaebfgc"}, {"input": {"instructions": ["rotate based on position of letter h", "swap position 7 with position 0", "move position 0 to position 5", "move position 7 to position 4", "swap letter b with letter f"], "initial_password": "hbcdegfa"}, "output": "hfcdaebg"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lsiepman/AdventOfCode2016", "path": "/Day21.py", "msgidx": 2938}}
{"problem_description": "In the Game of Life, a cellular automaton devised by the British mathematician John Conway, cells live or die based on a set of rules. Given the current state of a grid of cells, what will be the state of the grid in the next generation?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the current state of the Game of Life. Each element in the list is either `0` (dead cell) or `1` (live cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the next state of the Game of Life after applying the rules. Each element in the list is either `0` (dead cell) or `1` (live cell).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Modify board in-place to represent the next state of the Game of Life.\n        \"\"\"\n        board_cp = [row.copy() for row in board]\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                liveCt = self.countLive(board_cp, i, j)\n                if board[i][j] == 0:\n                    if liveCt == 3:\n                        board[i][j] = 1\n                    continue\n                # now board[i][j] == 1\n                if liveCt not in [2, 3]:\n                    board[i][j] = 0\n\n        return board\n\n    def countLive(self, board, row, col):\n        ct = 0\n        for i in [row - 1, row, row + 1]:\n            if i < 0 or i >= len(board):\n                continue\n            for j in [col - 1, col, col + 1]:\n                if j < 0 or j >= len(board[0]):\n                    continue\n                if i == row and j == col:\n                    continue\n                ct += board[i][j]\n        return ct\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.gameOfLife(board)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0]]}, "output": [[1, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0]]}, {"input": {"board": [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]}, "output": [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": {"board": [[0, 0, 0], [1, 0, 1], [1, 1, 0]]}, "output": [[0, 0, 0], [1, 0, 1], [1, 1, 0]]}, {"input": {"board": [[0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 0, 0]]}, "output": [[0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 0, 0]]}, {"input": {"board": [[1, 1, 1, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]]}, "output": [[1, 1, 1, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]]}, {"input": {"board": [[0, 0, 0], [1, 0, 1], [1, 0, 1], [0, 0, 1], [0, 0, 0]]}, "output": [[0, 0, 0], [1, 0, 1], [1, 0, 1], [0, 0, 1], [0, 0, 0]]}, {"input": {"board": [[1, 0, 1], [0, 0, 0], [1, 0, 1]]}, "output": [[1, 0, 1], [0, 0, 0], [1, 0, 1]]}, {"input": {"board": [[0, 1, 0, 0, 0], [1, 0, 0, 1, 0], [0, 1, 0, 1, 0]]}, "output": [[0, 1, 0, 0, 0], [1, 0, 0, 1, 0], [0, 1, 0, 1, 0]]}, {"input": {"board": [[0, 0, 0, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 1, 0]]}, "output": [[0, 0, 0, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 1, 0]]}, {"input": {"board": [[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 1]]}, "output": [[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhiwilliam/geekcoding", "path": "/src/1-500/289/Solution1.py", "msgidx": 3772}}
{"problem_description": "In a game of Blackjack, a player is dealt two cards and the dealer shows one card. Given the sum of the player's first two cards, the dealer's face-up card, and the number of decks used in the game, what is the optimal strategy for the player: to stand or to hit?", "io_requirements": "Input:\n  `first2sum` (int): The sum of the number of the first two cards of the player.\n  `dealer1card` (int): The number of the dealer's first card.\n  `numofdeck` (int): The number of decks used in the game.\n\nOutput:\n  `return` (str): The player's best choice of stand or hit, represented by 'H' for hit and 'S' for stand.", "refcode": "# import necessary packages\nimport numpy as np\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\nclass Player:\n    \"\"\"A player in a BlackJack game.\n    Players would have 2 cards known.\n\"\"\"\n    player_count = 0  # Initialize count of all players.\n    all_players = []  # automatically track all players\n\n    def __init__(self, deck=(), name=None, first2sum=0, dealer1card = 0, hit=True, surrender=False, Joker = False):\n        Player.player_count += 1\n        Player.all_players.append(self)\n\n        # assign player's name:\n        if name is None:\n            self.name = 'Player {:02}'.format(Player.player_count)\n        else:\n            self.name = name\n        if Joker:\n            self.surrender = surrender\n            self.second = first2sum\n            deck = renew_deck(deck, 100)\n            deck = renew_deck(deck, self.second)\n            deck = renew_deck(deck, dealer1card)\n            self.deck = deck\n            self.third = deck[1]\n            if self.third != 100:\n                if self.third + self.second + 10 <= 21:\n                    self.sum = self.second + self.second + 10\n                else:\n                    diff = 21-self.second - self.third\n                    if diff>5:\n                        self.sum =21\n                    else:\n                        self.sum = self.second +self.third +5\n            else:\n                self.sum = 21\n\n        else:\n            self.first2sum = first2sum\n            d1 = deck[deck < first2sum]\n            n1 = d1[d1 >= first2sum-11][0]\n            self.first = n1\n            self.second = self.first2sum - self.first\n            q = 1\n            while self.second == 1:\n                self.first = d1[d1>=first2sum-11][q]\n                self.second = self.first2sum - self.first\n                q += 1\n            deck = renew_deck(deck, self.first)\n            # print(d1)\n            deck = renew_deck(deck, self.second)\n            deck = renew_deck(deck, dealer1card)\n            self.third = 0\n\n            self.surrender = surrender\n            if surrender:\n                hit = False\n\n            if hit:\n                n3 = deck[1]\n                if first2sum + n3 > 21 and n3 == 11:\n                    self.third = 1\n                else:\n                    self.third = n3\n            self.sum = first2sum + self.third\n            self.deck = deck\n\n        # print(self.deck)\n        # print(self.sum)\n        # print(self.first, self.second, self.third)\n\n    def winorloss(self, d: 'Dealer'):\n        \"\"\" The player would win the dealer or not\n\n        :param d: the object of class 'Dealer'\n        :return: if player win the game, return 1\n                 if dealer win the game, return -1\n                 if tie, return 0\n        \"\"\"\n        if self.sum > 21:\n            return -1\n        if (self.sum < 22 and d.sum < 22 and self.sum < d.sum):\n            if self.surrender == True:\n                return -0.5\n            else: return -1\n        if self.sum == d.sum:\n            return 0\n        else:\n            return 1\n\n\nclass Dealer:\n    def __init__(self, deck=(), firstcard=2, hit=True, PlayJocker = False):\n        n2 = deck[0]\n        if firstcard == 11 and n2 == 11:\n            n2 = 1\n        if n2 == 100:\n            n2=10\n\n        k = [firstcard, n2]\n\n        if hit == True:\n            count = 2\n        else:\n            count = 1\n\n        while sum(k) < 17:\n            k.append(deck[count])\n            count +=1\n            if 11 in k and sum(k) > 21:\n                ind = k.index(11)\n                k[ind] = 1\n\n        self.cards = k\n        self.sum = sum(k)\n\ndef make_deck(y, Joker = False):\n    \"\"\"simulation of an ordered cards\n\n    :param y: number of deck\n    :return: an array that store all the cards after shuffling several times\n    \"\"\"\n    deck = np.array([x for x in range(2,15)]*4*y)\n    for i in range(len(deck)):\n        if deck[i] > 11:\n            deck[i] = 10\n    if Joker:\n        deck = np.append(deck,[100]*2*y)\n    np.random.shuffle(deck)\n    return deck\n\ndef renew_deck(deck, num):\n    \"\"\" renew the deck with known card\n\n    :param deck: the initial deck\n    :param num: the card that would be deleted from the deck\n    :return: the renewed deck\n    \"\"\"\n    ind = list(deck).index(num)\n    deck = np.delete(deck, [ind])\n    np.random.shuffle(deck)\n    return deck\n\ndef StandorHit(first2sum, dealer1card,numofdeck)->str:\n    \"\"\"Comparing the expectation of stand and hit and decide which is a better strategy\n\n    :param first2sum: the sum of the number of the first two cards of the player\n    :param dealer1card: number of the dealer's first card\n    :param numofdeck: number of the decks we used in this game\n    :return: player's best choice of stand or hit\n    \"\"\"\n\n    list = []\n    for i in range(1,5):\n        h_results = []\n        s_results = []\n        for match in range(1000):\n            deck = make_deck(numofdeck)\n            player1 = Player(deck, 'Hit', first2sum, dealer1card, hit=True)\n            dealer1 = Dealer(player1.deck, dealer1card)\n            player2 = Player(deck, 'Stand', first2sum, dealer1card, hit=False)\n            dealer2 = Dealer(player2.deck, dealer1card, hit=False)\n            h_results.append(player1.winorloss(dealer1))\n            s_results.append(player2.winorloss(dealer2))\n        h = np.mean(h_results)\n        s = np.mean(s_results)\n        if h>s:\n            list.append('H')\n        else:\n            list.append('S')\n    a = Counter(list)\n    if a['H'] > a['S']:\n        return 'H'\n    else:\n        return 'S'\n\n# main function\ndef main_solution(first2sum, dealer1card, numofdeck):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = StandorHit(first2sum, dealer1card, numofdeck)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"first2sum": 17, "dealer1card": 11, "numofdeck": 4}, "output": "S"}, {"input": {"first2sum": 16, "dealer1card": 3, "numofdeck": 5}, "output": "S"}, {"input": {"first2sum": 8, "dealer1card": 6, "numofdeck": 3}, "output": "H"}, {"input": {"first2sum": 8, "dealer1card": 10, "numofdeck": 1}, "output": "H"}, {"input": {"first2sum": 12, "dealer1card": 4, "numofdeck": 1}, "output": "S"}, {"input": {"first2sum": 13, "dealer1card": 6, "numofdeck": 2}, "output": "S"}, {"input": {"first2sum": 16, "dealer1card": 9, "numofdeck": 3}, "output": "H"}, {"input": {"first2sum": 11, "dealer1card": 4, "numofdeck": 3}, "output": "H"}, {"input": {"first2sum": 15, "dealer1card": 10, "numofdeck": 3}, "output": "H"}, {"input": {"first2sum": 15, "dealer1card": 2, "numofdeck": 5}, "output": "S"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Whitney95/MonteCarloSimulationofBlackJack", "path": "/Final Project.py", "msgidx": 2980}}
{"problem_description": "Given the coordinates of three corners of a triangle and a test point, determine whether the test point lies within the triangle. What is the result of this determination?", "io_requirements": "Input:\n  `p1` (list of int): A list containing two integers representing the x and y coordinates of the first corner of the triangle.\n  `p2` (list of int): A list containing two integers representing the x and y coordinates of the second corner of the triangle.\n  `p3` (list of int): A list containing two integers representing the x and y coordinates of the third corner of the triangle.\n  `test` (list of int): A list containing two integers representing the x and y coordinates of the test point.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the test point lies within the triangle (`True`) or not (`False`).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef within_triangle(p1, p2, p3, test):\n    a = 0.5 * (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n    a1 = 0.5 * (p1[0] * (p2[1] - test[1]) + p2[0] * (test[1] - p1[1]) + test[0] * (p1[1] - p2[1]))\n    a2 = 0.5 * (test[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - test[1]) + p3[0] * (test[1] - p2[1]))\n    a3 = 0.5 * (p1[0] * (test[1] - p3[1]) + test[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - test[1]))\n    return abs(a) == abs(a1) + abs(a2) + abs(a3)\n\n# main function\ndef main_solution(p1, p2, p3, test):\n    # Convert input tuples to lists for JSON serializability\n    p1 = list(p1)\n    p2 = list(p2)\n    p3 = list(p3)\n    test = list(test)\n    \n    # Call the within_triangle function\n    result = within_triangle(p1, p2, p3, test)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"p1": [0, 7], "p2": [6, -10], "p3": [7, 3], "test": [-3, 8]}, "output": false}, {"input": {"p1": [-7, 8], "p2": [-10, -9], "p3": [-5, 9], "test": [10, 5]}, "output": false}, {"input": {"p1": [-2, -8], "p2": [1, 5], "p3": [-9, 10], "test": [6, -9]}, "output": false}, {"input": {"p1": [10, -6], "p2": [7, 1], "p3": [6, -7], "test": [-2, -4]}, "output": false}, {"input": {"p1": [-2, 2], "p2": [-6, 10], "p3": [-9, 10], "test": [-6, -7]}, "output": false}, {"input": {"p1": [4, -9], "p2": [0, 9], "p3": [6, 2], "test": [-8, 2]}, "output": false}, {"input": {"p1": [7, -7], "p2": [-7, 10], "p3": [-3, 8], "test": [5, -2]}, "output": false}, {"input": {"p1": [5, 9], "p2": [3, -9], "p3": [7, -5], "test": [7, -10]}, "output": false}, {"input": {"p1": [9, 5], "p2": [4, -10], "p3": [-2, 1], "test": [3, 8]}, "output": false}, {"input": {"p1": [-9, -3], "p2": [5, 8], "p3": [4, -10], "test": [-3, 5]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/B5J4Bfgg7PoDHBBZQ_12.py", "msgidx": 3884}}
{"problem_description": "Jordan is terrified of spiders and wants to move to the farthest point in his room from a spider he has just spotted. The room is represented as a grid, with 'o' representing space to move and 'x' representing obstacles. Given the coordinates of the spider and Jordan, and the layout of the room, where should Jordan move to maximize the distance from the spider?", "io_requirements": "Input:\n  `spider_row` (int): The row coordinate of the spider.\n  `spider_col` (int): The column coordinate of the spider.\n  `jordan_row` (int): The row coordinate of Jordan.\n  `jordan_col` (int): The column coordinate of Jordan.\n  `grid` (list of strings): A list of strings representing the room grid, where 'o' represents space to move and 'x' represents obstacles.\n\nOutput:\n  `return` (dict): A dictionary containing the final coordinates that Jordan wants to get to, with keys \"JrowFinal\" (int) and \"JcolFinal\" (int).", "refcode": "# import necessary packages\nfrom queue import Queue\n\n# main function\ndef main_solution(spider_row, spider_col, jordan_row, jordan_col, grid):\n    # Convert the grid from a list of strings to a list of lists for easier manipulation\n    grid = [list(row) for row in grid]\n    \n    # BFS initialization\n    Q = Queue()\n    Q.put((spider_row, spider_col, 0))\n    \n    ret = (-1, -1)\n    retDist = -1\n    visited = set()\n    \n    # BFS loop\n    while Q.qsize():\n        cur = Q.get()\n        i = cur[0]\n        j = cur[1]\n        dist = cur[2]\n        \n        visited.add((i, j))\n        \n        if retDist == -1 or dist > retDist:\n            retDist = dist\n            ret = (i, j)\n        \n        # Check all four possible directions\n        if i != len(grid)-1 and grid[i+1][j] != 'x' and ((i+1, j) not in visited):\n            Q.put((i+1, j, dist+1))\n        if j != len(grid[i])-1 and grid[i][j+1] != 'x' and ((i, j+1) not in visited):\n            Q.put((i, j+1, dist+1))\n        if i != 0 and grid[i-1][j] != 'x' and ((i-1, j) not in visited):\n            Q.put((i-1, j, dist+1))\n        if j != 0 and grid[i][j-1] != 'x' and ((i, j-1) not in visited):\n            Q.put((i, j-1, dist+1))\n    \n    # Return the coordinates as a tuple of integers\n    return {\"JrowFinal\": ret[0], \"JcolFinal\": ret[1]}", "funcname": "main_solution", "ios": [{"input": {"spider_row": 1, "spider_col": 0, "jordan_row": 1, "jordan_col": 4, "grid": ["oxooo", "oxooo", "oxxoo", "ooxoo", "ooooo"]}, "output": {"JrowFinal": 0, "JcolFinal": 4}}, {"input": {"spider_row": 3, "spider_col": 1, "jordan_row": 1, "jordan_col": 4, "grid": ["oxoox", "ooxox", "oooox", "xxooo", "xoooo"]}, "output": {"JrowFinal": 0, "JcolFinal": 2}}, {"input": {"spider_row": 1, "spider_col": 1, "jordan_row": 2, "jordan_col": 1, "grid": ["oxoxo", "ooooo", "ooooo", "oooox", "xoxxx"]}, "output": {"JrowFinal": 3, "JcolFinal": 3}}, {"input": {"spider_row": 0, "spider_col": 0, "jordan_row": 0, "jordan_col": 3, "grid": ["oxooo", "xoooo", "ooooo", "oxoxo", "xoxoo"]}, "output": {"JrowFinal": 0, "JcolFinal": 0}}, {"input": {"spider_row": 2, "spider_col": 2, "jordan_row": 0, "jordan_col": 3, "grid": ["oxooo", "oxxoo", "ooooo", "ooooo", "ooooo"]}, "output": {"JrowFinal": 4, "JcolFinal": 4}}, {"input": {"spider_row": 4, "spider_col": 4, "jordan_row": 1, "jordan_col": 4, "grid": ["oxxoo", "ooooo", "oxooo", "oooox", "xooxo"]}, "output": {"JrowFinal": 4, "JcolFinal": 4}}, {"input": {"spider_row": 2, "spider_col": 1, "jordan_row": 3, "jordan_col": 2, "grid": ["oxooo", "xoooo", "ooooo", "ooooo", "oxooo"]}, "output": {"JrowFinal": 4, "JcolFinal": 4}}, {"input": {"spider_row": 0, "spider_col": 0, "jordan_row": 1, "jordan_col": 3, "grid": ["ooxoo", "ooooo", "oooxo", "xoooo", "ooooo"]}, "output": {"JrowFinal": 4, "JcolFinal": 4}}, {"input": {"spider_row": 4, "spider_col": 4, "jordan_row": 1, "jordan_col": 1, "grid": ["oooxx", "ooooo", "oxooo", "oooox", "oooox"]}, "output": {"JrowFinal": 0, "JcolFinal": 0}}, {"input": {"spider_row": 1, "spider_col": 1, "jordan_row": 0, "jordan_col": 3, "grid": ["ooxox", "ooxoo", "xoooo", "ooooo", "ooooo"]}, "output": {"JrowFinal": 4, "JcolFinal": 4}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "grawlixes/acm-contest-sep-2018", "path": "/spiders.py", "msgidx": 3268}}
{"problem_description": "In the vast expanse of the asteroid belt, the Ceres monitoring station is tasked with tracking all asteroids in a given region. The station's map of the region is represented by a grid where each position is either empty (.) or contains an asteroid (#). The coordinates of each asteroid are given by their distance from the left edge (X) and the top edge (Y). The station needs to determine the optimal location for a new monitoring station that can detect the maximum number of other asteroids without any obstructions. Given the map of the region, how many other asteroids can be detected from the best location for the new monitoring station?", "io_requirements": "Input:\n  `astr_map` (list of strings): A list where each string represents a row in the asteroid map. Each character in the string can be either '.' (empty space) or '#' (asteroid).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `max_asteroids` (int): The maximum number of other asteroids that can be detected from the best location.\n    - `best_location` (tuple of int): The coordinates (x, y) of the best location for the monitoring station.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef detect(location, astr_map):\n    astroids = []\n    astr_x = location[0]\n    astr_y = location[1]\n    used = set()\n    for x in range(len(astr_map)):\n        for y in range(len(astr_map[x])):\n            if astr_map[x][y] == '#' and (x != astr_x or y != astr_y):\n                theta = math.atan2(x - astr_x, y - astr_y)\n                if theta not in used:\n                    used.add(theta)\n                    astroids.append((x, y))\n    return len(astroids)\n\n# main function\ndef main_solution(astr_map):\n    # Convert the input list of strings to a list of lists for easier manipulation\n    astr_map = [list(row) for row in astr_map]\n    \n    max_astr = 0\n    best_location = ()\n    for x in range(len(astr_map)):\n        for y in range(len(astr_map[x])):\n            if astr_map[x][y] == '#':\n                astroids_num = detect((x, y), astr_map)\n                if astroids_num > max_astr:\n                    max_astr = astroids_num\n                    best_location = (y, x)\n    \n    # Return the result as a dictionary for JSON serialization\n    return {\"max_asteroids\": max_astr, \"best_location\": best_location}", "funcname": "main_solution", "ios": [{"input": {"astr_map": ["...#...##", "#.##.....", ".###.....", "##...##.#", "...#.#...", "#.#...#.#", "#..####..", ".#...#...", "#....####"]}, "output": {"max_asteroids": 29, "best_location": [1, 7]}}, {"input": {"astr_map": ["..#.###.#", "...#..##.", ".#..####.", "####.###.", ".###.####", "#.##.#.##", "##.#...#.", "#....##.#", "..##.#.##"]}, "output": {"max_asteroids": 36, "best_location": [5, 7]}}, {"input": {"astr_map": [".###.##.", "##..#...", "###.##.#", "..##.#.#", "##..#..#", "###..##."]}, "output": {"max_asteroids": 23, "best_location": [5, 3]}}, {"input": {"astr_map": ["###...#.##", "..##.####.", ".####.###.", "#....#####", "...##.#.#.", ".##..#..##", ".#...##...", "#....#.#.#"]}, "output": {"max_asteroids": 33, "best_location": [1, 6]}}, {"input": {"astr_map": [".##..#", "..####", "######", "...###", "#..#.#", "....##", "..#...", ".##.#.", "###.##"]}, "output": {"max_asteroids": 26, "best_location": [3, 3]}}, {"input": {"astr_map": ["#..#.#...#", "#.#..###..", "###......#", "#.###.####", "###....#..", "..#...##.#", "###....##.", ".#.#####.#"]}, "output": {"max_asteroids": 34, "best_location": [2, 2]}}, {"input": {"astr_map": ["#...###.#", ".##......", ".#.#.#.#.", ".###.#.##", "###..#.##"]}, "output": {"max_asteroids": 19, "best_location": [2, 1]}}, {"input": {"astr_map": ["##.###", "..#.#.", "###.##", "#..##.", "....#.", "#.#.##", "##.#.#"]}, "output": {"max_asteroids": 21, "best_location": [3, 3]}}, {"input": {"astr_map": ["##.##.", "#.####", "##..##", ".####.", ".#..#.", "##.###", "..##.#", "##.#.#"]}, "output": {"max_asteroids": 25, "best_location": [2, 3]}}, {"input": {"astr_map": [".######.", "....#...", "#.#.##.#", "#.###.#.", "#.##...#", "#...##..", "##.####.", "......#.", "....##.."]}, "output": {"max_asteroids": 28, "best_location": [5, 5]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "leila100/coding-exercises", "path": "/AdventOfCode/day10/star1.py", "msgidx": 3769}}
{"problem_description": "Given the property of truncatable primes, where a prime number remains prime when digits are removed from either the left or the right, what is the sum of all such truncatable primes up to a specified maximum number of digits?", "io_requirements": "Input:\n  `max_digits` (int): The maximum number of digits to consider for generating truncatable primes. This should be a positive integer.\n\nOutput:\n  `return` (int): The sum of all truncatable primes up to the specified maximum number of digits.", "refcode": "# import necessary packages\nfrom itertools import count\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef generate_truncatable_primes(max_digits):\n    right_truncatable_primes_by_num_digits = {\n        1: set([2, 3, 5, 7])\n    }\n    left_truncatable_primes_by_num_digits = {\n        1: set([2, 3, 5, 7])\n    }\n    truncatable_primes = set()\n\n    for n in count(2):\n        num_digits = len(str(n))\n\n        if num_digits > max_digits:\n            break\n\n        if num_digits > 2 and not right_truncatable_primes_by_num_digits.get(num_digits - 1) and not left_truncatable_primes_by_num_digits.get(num_digits - 1):\n            break\n\n        if not is_prime(n):\n            continue\n\n        left_truncatable_primes = left_truncatable_primes_by_num_digits.setdefault(num_digits, set())\n        right_truncatable_primes = right_truncatable_primes_by_num_digits.setdefault(num_digits, set())\n\n        if num_digits > 1:\n            if int(str(n)[1:]) in left_truncatable_primes_by_num_digits[num_digits - 1]:\n                left_truncatable_primes.add(n)\n\n            if int(str(n)[:-1]) in right_truncatable_primes_by_num_digits[num_digits - 1]:\n                right_truncatable_primes.add(n)\n\n            if n in left_truncatable_primes and n in right_truncatable_primes:\n                truncatable_primes.add(n)\n\n    return truncatable_primes\n\n# main function\ndef main_solution(max_digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    truncatable_primes = generate_truncatable_primes(max_digits)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(truncatable_primes)", "funcname": "main_solution", "ios": [{"input": {"max_digits": 2}, "output": 186}, {"input": {"max_digits": 4}, "output": 8920}, {"input": {"max_digits": 5}, "output": 8920}, {"input": {"max_digits": 3}, "output": 1986}, {"input": {"max_digits": 6}, "output": 748317}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lorenyu/project-euler", "path": "/problem-037.py", "msgidx": 3471}}
{"problem_description": "Given a string of digits from '2' to '9' representing the keys on a telephone keypad, what are all the possible letter combinations that these digits could represent?", "io_requirements": "Input:\n  `digits` (str): A string containing digits from '2' to '9' which represent the keys on a telephone keypad.\n\nOutput:\n  `return` (list of str): A list of all possible letter combinations that the digits could represent, based on the telephone keypad mapping.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nletterMap = {\n    0: \"\",\n    1: \"\",\n    2: \"abc\",\n    3: \"def\",\n    4: \"ghi\",\n    5: \"jkl\",\n    6: \"mno\",\n    7: \"pqrs\",\n    8: \"tuv\",\n    9: \"wxyz\"\n}\n\nres = []\n\ndef findCombination(digits, ind, s):\n    if ind == len(digits):\n        res.append(s)\n        return\n    num = digits[ind]\n    letter = letterMap[int(num)]\n    for x in range(len(letter)):\n        findCombination(digits, ind + 1, s + letter[x])\n\n# main function\ndef main_solution(digits):\n    global res\n    res = []\n    if digits == \"\":\n        return res\n    findCombination(digits, 0, \"\")\n    return res", "funcname": "main_solution", "ios": [{"input": {"digits": "7"}, "output": ["p", "q", "r", "s"]}, {"input": {"digits": "54"}, "output": ["jg", "jh", "ji", "kg", "kh", "ki", "lg", "lh", "li"]}, {"input": {"digits": "5"}, "output": ["j", "k", "l"]}, {"input": {"digits": "8"}, "output": ["t", "u", "v"]}, {"input": {"digits": "2"}, "output": ["a", "b", "c"]}, {"input": {"digits": "82"}, "output": ["ta", "tb", "tc", "ua", "ub", "uc", "va", "vb", "vc"]}, {"input": {"digits": "75"}, "output": ["pj", "pk", "pl", "qj", "qk", "ql", "rj", "rk", "rl", "sj", "sk", "sl"]}, {"input": {"digits": "73"}, "output": ["pd", "pe", "pf", "qd", "qe", "qf", "rd", "re", "rf", "sd", "se", "sf"]}, {"input": {"digits": "74"}, "output": ["pg", "ph", "pi", "qg", "qh", "qi", "rg", "rh", "ri", "sg", "sh", "si"]}, {"input": {"digits": "53"}, "output": ["jd", "je", "jf", "kd", "ke", "kf", "ld", "le", "lf"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "SocratesMing/LeetCode", "path": "/Python/DFS/No17_\u7535\u8bdd\u7ec4\u5408.py", "msgidx": 3539}}
{"problem_description": "In a unique calendar system, each year has 13 months, with even months having 15 days and odd months having 13 days. Festivals occur only in years where the year number modulo 4 equals 1. Given the current date and the festival date, how many days are there until the next festival?", "io_requirements": "Input:\n  `current_date` (str): A string representing the current date in the format \"yyyy mm dd\".\n  `festival_date` (str): A string representing the festival date in the format \"mm dd\".\n\nOutput:\n  `return` (int): An integer representing the number of days until the next festival.", "refcode": "# import necessary packages\nimport datetime\n\n# all class and function definitions in the code file, if any\ndef is_festival_year(year):\n    return year % 4 == 1\n\ndef days_in_month(month, year):\n    if month % 2 == 0:\n        return 15\n    else:\n        return 13\n\ndef days_until_next_festival(current_date, festival_date):\n    current_year, current_month, current_day = map(int, current_date.split())\n    festival_month, festival_day = map(int, festival_date.split())\n    \n    days_count = 0\n    \n    while True:\n        if current_month == festival_month and current_day == festival_day and is_festival_year(current_year):\n            break\n        \n        days_count += 1\n        current_day += 1\n        \n        if current_day > days_in_month(current_month, current_year):\n            current_day = 1\n            current_month += 1\n        \n        if current_month > 13:\n            current_month = 1\n            current_year += 1\n    \n    return days_count\n\n# main function\ndef main_solution(current_date, festival_date):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    days_until_festival = days_until_next_festival(current_date, festival_date)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return days_until_festival", "funcname": "main_solution", "ios": [{"input": {"current_date": "2065 12 12", "festival_date": "3 7"}, "output": 594}, {"input": {"current_date": "2031 4 14", "festival_date": "8 4"}, "output": 408}, {"input": {"current_date": "2015 8 11", "festival_date": "5 8"}, "output": 318}, {"input": {"current_date": "2027 9 2", "festival_date": "10 4"}, "output": 377}, {"input": {"current_date": "2050 11 8", "festival_date": "8 13"}, "output": 505}, {"input": {"current_date": "2000 3 4", "festival_date": "10 3"}, "output": 277}, {"input": {"current_date": "2057 7 4", "festival_date": "7 7"}, "output": 3}, {"input": {"current_date": "1928 13 11", "festival_date": "4 4"}, "output": 47}, {"input": {"current_date": "1973 2 8", "festival_date": "5 11"}, "output": 46}, {"input": {"current_date": "2085 7 3", "festival_date": "10 12"}, "output": 50}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hiroshi415/pythonweek2", "path": "/Database/HW.py", "msgidx": 3814}}
{"problem_description": "Given a chessboard of size `n` x `n`, where `n` is a positive integer, what are all the possible ways to place `n` queens on the board such that no two queens threaten each other? Each solution should be represented as a list of strings, where each string represents a row on the chessboard, with 'Q' indicating the position of a queen and '_' indicating an empty space.", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (list of lists of strings): A list of all possible solutions where each solution is represented as a list of strings. Each string represents a row on the chessboard, with 'Q' indicating the position of a queen and '_' indicating an empty space.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef place_queen(diag1, diag2, cols, row, col):\n    diag1.add(row + col)\n    diag2.add(row - col)\n    cols[col] = row\n\ndef remove_queen(diag1, diag2, cols, row, col):\n    diag1.remove(row + col)\n    diag2.remove(row - col)\n    del cols[col]\n\ndef is_under_attack(diag1, diag2, cols, row, col):\n    return row + col in diag1 or row - col in diag2 or col in cols\n\ndef backtrack(diag1, diag2, cols, n, row, res, pos):\n    for col in range(n):\n        if not is_under_attack(diag1, diag2, cols, row, col):\n            place_queen(diag1, diag2, cols, row, col)\n            if row == n - 1:\n                res.append([j * '_ ' + 'Q ' + (n - 1 - j) * '_ ' for j in pos + [col]])\n            else:\n                backtrack(diag1, diag2, cols, n, row + 1, res, pos + [col])\n            remove_queen(diag1, diag2, cols, row, col)\n\ndef solution(n):\n    diag_set1 = set()\n    diag_set2 = set()\n    col_map = {}\n    res_list = []\n    backtrack(diag_set1, diag_set2, col_map, n, 0, res_list, [])\n    return res_list\n\n# main function\ndef main_solution(n):\n    # Convert input to JSON serializable\n    n = int(n)\n    \n    # Call the solution function\n    result = solution(n)\n    \n    # Convert output to JSON serializable\n    result = [[''.join(row.split()) for row in board] for board in result]\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": [["_Q__", "___Q", "Q___", "__Q_"], ["__Q_", "Q___", "___Q", "_Q__"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Hybrid2232000/Test", "path": "/q6.py", "msgidx": 3600}}
{"problem_description": "In a polymerization process, a polymer template undergoes a series of pair insertion steps based on given rules. Each rule specifies that when two specific elements are adjacent, a third element should be inserted between them. After a certain number of steps, the polymer grows significantly. Given the initial polymer template, a list of pair insertion rules, and the number of steps, what is the difference between the quantity of the most common element and the least common element in the resulting polymer?", "io_requirements": "Input:\n  `initial_compound` (str): The starting polymer template as a string.\n  `replacements` (list of str): A list of strings where each string represents a pair insertion rule in the format \"AB -> C\".\n  `steps` (int): The number of steps to run the polymerization process.\n\nOutput:\n  `return` (int): The difference between the quantity of the most common element and the least common element after the specified number of steps.", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\nclass Polymerization:\n    def __init__(self, replacements):\n        self.insertions = dict()\n        for r in replacements:\n            base, insert = r.split(' -> ')\n            self.insertions[base] = insert\n\n    def fast_steps(self, initial_compound, steps):\n        fast_map = Counter()\n        for pos, left in enumerate(initial_compound):\n            if pos + 1 == len(initial_compound):\n                fast_map[f'{left}*'] += 1\n            else:\n                right = initial_compound[pos + 1]\n                fast_map[f'{left}{right}'] += 1\n        for _ in range(steps):\n            next_step = Counter()\n            for n in fast_map:\n                if n not in self.insertions:\n                    next_step[n] += fast_map[n]\n                else:\n                    new = self.insertions[n]\n                    left, right = n\n                    next_step[f'{left}{new}'] += fast_map[n]\n                    next_step[f'{new}{right}'] += fast_map[n]\n            fast_map = next_step\n        data = Counter()\n        for n in fast_map:\n            left, _ = n\n            data[left] += fast_map[n]\n        frequency = data.most_common()\n        return frequency[0][1] - frequency[-1][1]\n\n# main function\ndef main_solution(initial_compound, replacements, steps):\n    # Convert replacements list to a JSON serializable format\n    replacements_dict = {r.split(' -> ')[0]: r.split(' -> ')[1] for r in replacements}\n    \n    # Create Polymerization object\n    polymerization = Polymerization(replacements)\n    \n    # Run the fast_steps method\n    result = polymerization.fast_steps(initial_compound, steps)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"initial_compound": "NHBBHCBCBH", "replacements": ["H -> C", "B -> H", "N -> H", "C -> B"], "steps": 26}, "output": 3}, {"input": {"initial_compound": "BBCC", "replacements": ["H -> N", "C -> N", "B -> H", "N -> N"], "steps": 36}, "output": 0}, {"input": {"initial_compound": "CCBBBBNHHC", "replacements": ["C -> N", "B -> N", "H -> H", "N -> B"], "steps": 16}, "output": 3}, {"input": {"initial_compound": "BHBBCHNCNB", "replacements": ["C -> N", "B -> H", "H -> C", "N -> B"], "steps": 35}, "output": 2}, {"input": {"initial_compound": "CCBC", "replacements": ["C -> C", "H -> H", "N -> N", "B -> C"], "steps": 28}, "output": 2}, {"input": {"initial_compound": "HBCHB", "replacements": ["C -> C", "N -> H", "B -> B", "H -> N"], "steps": 12}, "output": 1}, {"input": {"initial_compound": "HCHCNNC", "replacements": ["N -> B", "B -> B", "H -> N", "C -> B"], "steps": 35}, "output": 1}, {"input": {"initial_compound": "BNBHB", "replacements": ["N -> H", "B -> B", "H -> H", "C -> H"], "steps": 21}, "output": 2}, {"input": {"initial_compound": "CCNCBHHNB", "replacements": ["H -> C", "C -> B", "B -> B", "N -> C"], "steps": 28}, "output": 1}, {"input": {"initial_compound": "NBCN", "replacements": ["C -> H", "H -> N", "N -> B", "B -> N"], "steps": 34}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jvano74/advent_of_code", "path": "/2021/day_14_test.py", "msgidx": 3638}}
{"problem_description": "Given a string consisting of uppercase and lowercase letters, what are all the unique permutations of the string sorted in dictionary order?", "io_requirements": "Input:\n  `input_string` (str): A string of characters, where each character is either an uppercase or lowercase letter. The length of the string is between 1 and 9 characters.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a unique permutation of the input string, sorted in dictionary order.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the characters\n    permutations = list(set(itertools.permutations(char_list)))\n    \n    # Convert each permutation tuple back to a string\n    result = [''.join(perm) for perm in permutations]\n    \n    # Sort the result list to ensure dictionary order\n    result.sort()\n    \n    # Return the sorted list of permutations\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "bYR"}, "output": ["RYb", "RbY", "YRb", "YbR", "bRY", "bYR"]}, {"input": {"input_string": "VO"}, "output": ["OV", "VO"]}, {"input": {"input_string": "L"}, "output": ["L"]}, {"input": {"input_string": "Jz"}, "output": ["Jz", "zJ"]}, {"input": {"input_string": "bk"}, "output": ["bk", "kb"]}, {"input": {"input_string": "b"}, "output": ["b"]}, {"input": {"input_string": "TJ"}, "output": ["JT", "TJ"]}, {"input": {"input_string": "uco"}, "output": ["cou", "cuo", "ocu", "ouc", "uco", "uoc"]}, {"input": {"input_string": "oSu"}, "output": ["Sou", "Suo", "oSu", "ouS", "uSo", "uoS"]}, {"input": {"input_string": "Rt"}, "output": ["Rt", "tR"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "foxzyxu/offer", "path": "/27.\u5b57\u7b26\u4e32\u7684\u6392\u5217.py", "msgidx": 4232}}
{"problem_description": "Given a seed set of integers, what is the set string of the next optimum special sum set generated from the seed, following the rule that the next set is formed by adding the \"middle\" element of the seed to each element of the seed and then sorting the resulting set?", "io_requirements": "Input:\n  `seed` (list of integers): A list of integers representing the seed set from which the next optimum special sum set is to be generated.\n\nOutput:\n  `return` (string): A string representing the set of integers if the generated set is a special sum set. If the generated set is not a special sum set, it returns the string \"Not a special sum set\".", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef subsets(s):\n    res = []\n    tmp = [s]\n    while(0 < len(tmp)):\n        ts = tmp.pop()\n        if(not ts in res):\n            res.append(ts)\n        if(0 < len(ts)):\n            for i in range(len(ts)):\n                tmp.append(ts[:i]+ts[i+1:])\n    \n    return res\n\ndef sumup(s):\n    res = 0\n    if(0 < len(s)):\n        res = sum(s)\n    return res\n\ndef is_disjoint(s1, s2):\n    if(len(s1) > len(s2)):\n        return is_disjoint(s2, s1)\n    res = True\n    i = 0\n    while(res and (i<len(s1))):\n        res = not(s1[i] in s2)\n        i = i + 1\n    return res\n\ndef is_sss(s):\n    res = True\n    if(1 < len(s)):\n        ss = subsets(s)\n        i = 0\n        while(i < len(ss) and res):\n            s1 = ss[i]\n            j = i + 1\n            while(j < len(ss) and res):\n                s2 = ss[j]\n                if(0<len(s1)*len(s2))and(is_disjoint(s1, s2)):\n                    res = (sum(s1)!=sum(s2))and((sum(s1)-sum(s2))*(len(s1)-len(s2))>=0)and res\n                j = j + 1\n            i = i + 1\n    return res\n\ndef gen_from_seed(seed):\n    res = []\n    mid = seed[len(seed)//2]\n    res.append(mid)\n    for e in seed:\n        res.append(mid+e)\n    res.sort()\n    return res\n\n# main function\ndef main_solution(seed):\n    # Convert seed from list to string\n    seed_str = ''.join(map(str, seed))\n    \n    # Generate the next set from the seed\n    next_set = gen_from_seed(seed)\n    \n    # Check if the generated set is a special sum set\n    if is_sss(next_set):\n        # Convert the set to a string\n        set_string = ''.join(map(str, next_set))\n        return set_string\n    else:\n        return \"Not a special sum set\"", "funcname": "main_solution", "ios": [{"input": {"seed": [4, 4, 17]}, "output": "Not a special sum set"}, {"input": {"seed": [12, 13]}, "output": "132526"}, {"input": {"seed": [1, 9, 11, 14]}, "output": "Not a special sum set"}, {"input": {"seed": [8, 9]}, "output": "91718"}, {"input": {"seed": [1, 10, 15, 18, 20]}, "output": "Not a special sum set"}, {"input": {"seed": [1, 9, 13, 19]}, "output": "Not a special sum set"}, {"input": {"seed": [16]}, "output": "1632"}, {"input": {"seed": [1, 13]}, "output": "131426"}, {"input": {"seed": [9, 11, 17]}, "output": "11202228"}, {"input": {"seed": [7, 7, 11, 19]}, "output": "Not a special sum set"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gcd0318/pe", "path": "/l5/pe103.py", "msgidx": 3654}}
{"problem_description": "In a hypothetical scenario, a pair of rabbits produces a certain number of pairs each month. These rabbits become adults after one month and can start reproducing. Given the number of months (`n`) and the number of pairs produced by each pair of adult rabbits each month (`k`), how many rabbits will there be after `n` months?", "io_requirements": "Input:\n  `n` (int): The number of months to simulate the rabbit population growth.\n  `k` (int): The number of pairs of rabbits produced by each pair of adult rabbits each month.\n\nOutput:\n  `return` (int): The total number of rabbits after `n` months given the reproduction rate `k`.", "refcode": "# import necessary packages\nfrom functools import lru_cache\n\n# all class and function definitions in the code file, if any\n@lru_cache(40)\ndef rabbitRecurion(n, k):\n    '''\n    Calculates the number of rabbits after n months when a pair of adult rabbits produce k pairs.\n    They become adults after 1 month.\n    Recursion equation F(n)=F(n-1)+k*F(n-2)\n    '''\n    if n < 3:\n        return 1\n    return rabbitRecurion(n-1, k) + k * rabbitRecurion(n-2, k)\n\n# main function\ndef main_solution(n, k):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = rabbitRecurion(n, k)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 15, "k": 3}, "output": 75316}, {"input": {"n": 5, "k": 3}, "output": 19}, {"input": {"n": 19, "k": 5}, "output": 64457461}, {"input": {"n": 19, "k": 2}, "output": 174763}, {"input": {"n": 14, "k": 1}, "output": 377}, {"input": {"n": 2, "k": 5}, "output": 1}, {"input": {"n": 3, "k": 2}, "output": 3}, {"input": {"n": 7, "k": 2}, "output": 43}, {"input": {"n": 17, "k": 1}, "output": 1597}, {"input": {"n": 5, "k": 2}, "output": 11}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "SebastienBah/RosalindProbs", "path": "/DyingRabbits/dyingRabbits.py", "msgidx": 4188}}
{"problem_description": "Given a grid of black and white squares, determine if it qualifies as a valid American-style crossword puzzle grid. The grid must satisfy the following conditions:\n1. Every white square must be part of an \"across\" word and a \"down\" word.\n2. No word can be fewer than three letters long.\n3. Every white square must be reachable from every other white square.\n4. The grid is rotationally symmetric.\n\nWhat is the result of checking if the provided grid qualifies as a crossword grid?", "io_requirements": "Input:\n  `matrix` (List[List[str]]): A 2D list representing the crossword grid. Each element is either 'B' (black) or 'W' (white). The size of the matrix is N x N, where N is a positive integer.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the given matrix qualifies as a crossword grid according to the rules specified.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef components(m: List[List[str]]) -> int:\n    n = len(m)\n    count = 0\n    visited = set()\n\n    def traverse(i: int, j: int):\n        nonlocal visited\n        nonlocal n\n        visited.add((i, j))\n        neighbors = [(i + 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]\n        for i2, j2 in neighbors:\n            if 0 <= i2 < n and 0 <= j2 < n and (i2, j2) not in visited and m[i2][j2] == 'W':\n                traverse(i2, j2)\n\n    for i in range(n):\n        for j in range(n):\n            if m[i][j] == 'W' and (i, j) not in visited:\n                count += 1\n                traverse(i, j)\n\n    return count\n\ndef is_180_degrees_symmetric(m: List[List[str]]) -> bool:\n    n = len(m)\n    for i in range(n):\n        for j in range(n):\n            if m[i][j] != m[n - i - 1][n - j - 1]:\n                return False\n    return True\n\ndef check(m: List[List[str]]) -> bool:\n    n = len(m)\n\n    # rule #1 and #2 (horizontally and vertically)\n    for i in range(n):\n        ln = 0\n        for j in range(n):\n            if m[i][j] == 'W':\n                ln += 1\n            if m[i][j] != 'W' or j == n - 1:\n                if ln != 0 and ln < 3:\n                    return False\n                ln = 0\n\n    for j in range(n):\n        ln = 0\n        for i in range(n):\n            if m[i][j] == 'W':\n                ln += 1\n            if m[i][j] != 'W' or i == n - 1:\n                if ln != 0 and ln < 3:\n                    return False\n                ln = 0\n\n    # rule #3\n    components_count = components(m)\n    if components_count != 1:\n        return False\n\n    # rule #4\n    if not is_180_degrees_symmetric(m):\n        return False\n\n    return True\n\n# main function\ndef main_solution(matrix: List[List[str]]) -> bool:\n    # all input arguments of the main_solution function should be json serializable\n    # return, the returned value must be json serializable\n    return check(matrix)", "funcname": "main_solution", "ios": [{"input": {"matrix": [["W", "W", "B", "W"], ["B", "W", "W", "W"], ["W", "B", "B", "W"], ["W", "B", "W", "B"]]}, "output": false}, {"input": {"matrix": [["W", "B", "W"], ["B", "B", "W"], ["B", "B", "W"]]}, "output": false}, {"input": {"matrix": [["B", "B", "W", "B"], ["W", "W", "W", "B"], ["B", "W", "W", "W"], ["B", "W", "B", "W"]]}, "output": false}, {"input": {"matrix": [["B", "W", "W", "W"], ["W", "B", "W", "B"], ["W", "W", "B", "W"], ["B", "W", "B", "W"]]}, "output": false}, {"input": {"matrix": [["W", "W", "B", "B"], ["B", "W", "W", "B"], ["B", "B", "W", "B"], ["W", "W", "W", "B"]]}, "output": false}, {"input": {"matrix": [["B", "B", "W", "W"], ["B", "W", "W", "B"], ["W", "W", "W", "W"], ["B", "W", "B", "B"]]}, "output": false}, {"input": {"matrix": [["B", "W", "W", "B"], ["W", "B", "B", "B"], ["W", "B", "W", "B"], ["B", "B", "B", "B"]]}, "output": false}, {"input": {"matrix": [["W", "B", "W"], ["W", "W", "B"], ["B", "W", "B"]]}, "output": false}, {"input": {"matrix": [["W", "B", "W", "W"], ["B", "B", "B", "W"], ["B", "W", "B", "B"], ["W", "W", "B", "W"]]}, "output": false}, {"input": {"matrix": [["B", "B", "W", "W"], ["B", "W", "B", "W"], ["W", "B", "W", "W"], ["B", "B", "B", "W"]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gubenkoved/daily-coding-problem", "path": "/python/dcp_352_check_if_matrix_quilify_for_crossword_grid.py", "msgidx": 3729}}
{"problem_description": "Given a partially filled Sudoku puzzle, can you determine the complete solution for the puzzle? The Sudoku puzzle is represented as a string of 81 characters, where each character is a digit (0-9), and '0' represents an empty cell. The string is read row by row from top to bottom, and each row is read from left to right. What is the complete solution for the given Sudoku puzzle?", "io_requirements": "Input:\n  `sudoku_str` (str): A string of length 81 representing the Sudoku puzzle. Each character is a digit (0-9), where '0' represents an empty cell. The string is read row by row from top to bottom, and each row is read from left to right.\n\nOutput:\n  `return` (str): A string of length 81 representing the solved Sudoku puzzle. Each character is a digit (1-9). If no solution is found, the string \"No solution\" is returned.", "refcode": "# import necessary packages\nfrom collections import deque\nimport copy\n\n# Constants\nROW = \"ABCDEFGHI\"\nCOL = \"123456789\"\n\n# Initialize the three maps\ndef init_map(sudoku):\n    row_map = {i: {k: False for k in range(1, 10)} for i in ROW}\n    col_map = {j: {k: False for k in range(1, 10)} for j in COL}\n    cell_map = {i: {k: False for k in range(1, 10)} for i in range(9)}\n    \n    for i in ROW:\n        for j in COL:\n            value = sudoku[i + j]\n            if value != 0:\n                row_map[i][value] = True\n                col_map[j][value] = True\n                row_index = (ord(i) - ord('A')) // 3\n                col_index = (ord(j) - ord('1')) // 3\n                cell_map[row_index * 3 + col_index][value] = True\n    return row_map, col_map, cell_map\n\n# Count the domain of each cell based on three maps information\ndef count(row_map, col_map, cell_map, cell):\n    count = 0\n    start_row, start_col = cell\n    row_index = (ord(start_row) - ord('A')) // 3\n    col_index = (ord(start_col) - ord('1')) // 3\n    cell_key = row_index * 3 + col_index\n    for x in range(1, 10):\n        if not row_map[start_row][x] and not col_map[start_col][x] and not cell_map[cell_key][x]:\n            count += 1\n    return count\n\n# Get the next cell for dfs call\ndef next2(sudoku, row_map, col_map, cell_map):\n    min_count = 10\n    min_cell = \"\"\n    for i in ROW:\n        for j in COL:\n            if sudoku[i + j] == 0:\n                this_count = count(row_map, col_map, cell_map, i + j)\n                if this_count < min_count:\n                    min_count = this_count\n                    min_cell = i + j\n    return min_cell\n\n# The dfs function for solution2\ndef dfs2(sudoku, row_map, col_map, cell_map, start):\n    if start == \"\":\n        return True\n    start_row, start_col = start\n    row_index = (ord(start_row) - ord('A')) // 3\n    col_index = (ord(start_col) - ord('1')) // 3\n    cell_key = row_index * 3 + col_index\n    if sudoku[start] == 0:\n        for x in range(1, 10):\n            if not row_map[start_row][x] and not col_map[start_col][x] and not cell_map[cell_key][x]:\n                sudoku[start] = x\n                row_map[start_row][x] = True\n                col_map[start_col][x] = True\n                cell_map[cell_key][x] = True\n                next_cell = next2(sudoku, row_map, col_map, cell_map)\n                if dfs2(sudoku, row_map, col_map, cell_map, next_cell):\n                    return True\n                sudoku[start] = 0\n                row_map[start_row][x] = False\n                col_map[start_col][x] = False\n                cell_map[cell_key][x] = False\n    return False\n\n# Main function\ndef main_solution(sudoku_str):\n    sudoku = {ROW[i] + COL[j]: int(sudoku_str[9 * i + j]) for i in range(9) for j in range(9)}\n    row_map, col_map, cell_map = init_map(sudoku)\n    start = next2(sudoku, row_map, col_map, cell_map)\n    if dfs2(sudoku, row_map, col_map, cell_map, start):\n        result = ''.join(str(sudoku[i + j]) for i in ROW for j in COL)\n        return result\n    else:\n        return \"No solution\"", "funcname": "main_solution", "ios": [{"input": {"sudoku_str": "086563246574025541864963249258370309175251005837157307290527370890371282176686027"}, "output": "No solution"}, {"input": {"sudoku_str": "303030938870096622863466519217384985114439910122571530189283500031569160463034660"}, "output": "No solution"}, {"input": {"sudoku_str": "360862167460328631872107262260386583910963883304598190178763508240215513152674070"}, "output": "No solution"}, {"input": {"sudoku_str": "396772461280420736581909820604214628715177958111330125659135396945763403655475107"}, "output": "No solution"}, {"input": {"sudoku_str": "910544117591714685400669816198162218661849078739076305316568279129447640821180189"}, "output": "No solution"}, {"input": {"sudoku_str": "465839393452191751610835328869573884551818652865715141712497408333752189589201014"}, "output": "No solution"}, {"input": {"sudoku_str": "668724518971208992629283179356913488228709057482358216422206449369655961861682374"}, "output": "No solution"}, {"input": {"sudoku_str": "756442198703034991366576843826756345663281067293676169871792087497942571609052552"}, "output": "No solution"}, {"input": {"sudoku_str": "650702760277650856642702555743087919416776454147532861277400151517352299161459868"}, "output": "No solution"}, {"input": {"sudoku_str": "993839836509493642023110752627671916709322481553693968020202342416112264528142335"}, "output": "No solution"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Staniel/Sudoku", "path": "/hw4_ly2328.py", "msgidx": 3764}}
{"problem_description": "A robot is located on a 4\u00d74 grid and can move either up, down, left, or right. The robot cannot visit the same location twice. Given the starting coordinates `(start_x, start_y)` and the ending coordinates `(end_x, end_y)`, how many unique paths can the robot take to reach the destination?", "io_requirements": "Input:\n  `start_x` (int): The x-coordinate of the starting position of the robot. It should be between 0 and 3.\n  `start_y` (int): The y-coordinate of the starting position of the robot. It should be between 0 and 3.\n  `end_x` (int): The x-coordinate of the ending position of the robot. It should be between 0 and 3.\n  `end_y` (int): The y-coordinate of the ending position of the robot. It should be between 0 and 3.\n\nOutput:\n  `return` (int): The number of unique ways the robot can reach the destination from the starting position without visiting the same location twice. The number should be an integer \u2265 0.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef count_paths(grid, current_x, current_y, end_x, end_y):\n    if current_x < 0 or current_x > 3 or current_y < 0 or current_y > 3:\n        return 0\n\n    if grid[current_x][current_y]:\n        return 0\n\n    if current_x == end_x and current_y == end_y:\n        return 1\n\n    grid[current_x][current_y] = True\n\n    result = 0\n\n    result += count_paths(grid, current_x+1, current_y,   end_x, end_y)\n    result += count_paths(grid, current_x,   current_y+1, end_x, end_y)\n    result += count_paths(grid, current_x-1, current_y,   end_x, end_y)\n    result += count_paths(grid, current_x,   current_y-1, end_x, end_y)\n\n    grid[current_x][current_y] = False\n\n    return result\n\n# main function\ndef main_solution(start_x, start_y, end_x, end_y):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    four_by_four_grid = [\n        [False, False, False, False],\n        [False, False, False, False],\n        [False, False, False, False],\n        [False, False, False, False]\n    ]\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count_paths(four_by_four_grid, start_x, start_y, end_x, end_y)", "funcname": "main_solution", "ios": [{"input": {"start_x": 0, "start_y": 0, "end_x": 3, "end_y": 0}, "output": 178}, {"input": {"start_x": 3, "start_y": 2, "end_x": 3, "end_y": 1}, "output": 125}, {"input": {"start_x": 1, "start_y": 2, "end_x": 2, "end_y": 3}, "output": 105}, {"input": {"start_x": 0, "start_y": 1, "end_x": 2, "end_y": 2}, "output": 106}, {"input": {"start_x": 0, "start_y": 0, "end_x": 3, "end_y": 2}, "output": 146}, {"input": {"start_x": 3, "start_y": 0, "end_x": 0, "end_y": 2}, "output": 146}, {"input": {"start_x": 2, "start_y": 2, "end_x": 2, "end_y": 2}, "output": 1}, {"input": {"start_x": 3, "start_y": 2, "end_x": 2, "end_y": 0}, "output": 117}, {"input": {"start_x": 0, "start_y": 0, "end_x": 1, "end_y": 2}, "output": 132}, {"input": {"start_x": 3, "start_y": 0, "end_x": 2, "end_y": 2}, "output": 132}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Balu-Varanasi/simple-python-programs", "path": "/robot-problem/robot_problem.py", "msgidx": 3922}}
{"problem_description": "Given a sequence of integers, determine if this sequence could represent the post-order traversal of a Binary Search Tree (BST). What is the result of this verification?", "io_requirements": "Input:\n  `nums` (list of int): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input list is a valid post-order traversal of a BST (`True`) or not (`False`).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, nums):\n        \"\"\"\n        :param nums:  List[int]\n        :return: bool\n        \"\"\"\n        if not nums:\n            return True\n        n = len(nums)\n        if n == 1:\n            return True\n        root_val = nums[-1]\n        index = 0\n        while index < n-1 and nums[index] < root_val:\n            index += 1\n        mid = index\n        while index < n-1 and nums[index] > root_val:\n            index += 1\n        if index != n-1:\n            return False\n        left = nums[:mid]\n        right = nums[mid:-1]\n        return self.VerifySquenceOfBST(left) and self.VerifySquenceOfBST(right)\n\n# main function\ndef main_solution(nums):\n    # Convert input to the required format\n    nums = list(nums)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(nums)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"nums": [35, 23, 11, 39, 12, 4, 46, 29, 81]}, "output": false}, {"input": {"nums": [94, 80, 23, 36, 37, 58]}, "output": false}, {"input": {"nums": [44]}, "output": true}, {"input": {"nums": [56, 9]}, "output": true}, {"input": {"nums": [70, 25, 51, 7]}, "output": false}, {"input": {"nums": [56, 2, 49, 70, 77, 51, 76, 93, 80]}, "output": false}, {"input": {"nums": [60]}, "output": true}, {"input": {"nums": [67, 16, 96, 2, 54, 46, 81]}, "output": false}, {"input": {"nums": [7, 2, 66, 85, 98, 24, 53, 10, 8, 16]}, "output": false}, {"input": {"nums": [35, 40]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ganlanshu/leetcode", "path": "/VerifySquenceOfBST.py", "msgidx": 3599}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate combinations for. Must be a non-negative integer.\n\nOutput:\n  `return` (list of str): A list of strings, where each string represents a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(n):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  if n <= 0:\n    return []\n  cache = defaultdict(list)\n  cache[1].append('()')\n  for i in range(2, n+1):\n    dup = {}\n    for e in cache[i-1]:\n      dup['(%s)' % e] = 1\n    for x in range(1, i):\n      y = i - x\n      cx = cache[x]\n      cy = cache[y]\n      for ex in cx:\n        for ey in cy:\n          dup['%s%s' % (ex, ey)] = 1\n    cache[i] = list(dup.keys())\n  return cache[n]", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 0}, "output": []}, {"input": {"n": 3}, "output": ["((()))", "(()())", "()(())", "()()()", "(())()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "haoccheng/pegasus", "path": "/leetcode/generate_parentheses.py", "msgidx": 4361}}
{"problem_description": "Given a number for which we need to calculate the factorial, a number of disks for the Tower of Hanoi problem, and two lists `A` and `B`, what are the results of the factorial calculation, the number of moves required to solve the Tower of Hanoi problem, and the state of the lists `A` and `B` after performing a specific move operation?", "io_requirements": "Input:\n  `n_factorial` (int): The number for which the factorial needs to be calculated.\n  `n_hanoi` (int): The number of disks in the Tower of Hanoi problem.\n  `A` (list of int): The initial list for the move operation.\n  `B` (list of int): The initial list for the move operation.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `factorial_result` (int): The result of the factorial calculation.\n    - `hanoi_result` (int): The number of moves required to solve the Tower of Hanoi problem.\n    - `A_after_move` (list of int): The list `A` after the move operation.\n    - `B_after_move` (list of int): The list `B` after the move operation.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nfact = lambda x: 1 if x == 0 else x * fact(x - 1)\nT = lambda n, A, B, C: 1 if n == 1 else T(1, A, C, B) + T(n - 1, A, B, C) + T(n - 1, C, B, A)\nswap = lambda x, y: (y, x)\n\ndef move(A, B, nA, nB): \n    A[nA], B[nB] = swap(A[nA], B[nB])\n\n# main function\ndef main_solution(n_factorial, n_hanoi, A, B):\n    # Calculate factorial\n    factorial_result = fact(n_factorial)\n    \n    # Calculate Tower of Hanoi moves\n    hanoi_result = T(n_hanoi, None, None, None)\n    \n    # Perform the move operation\n    move(A, B, len(A) - 1, 0)\n    \n    # Return results\n    return {\n        \"factorial_result\": factorial_result,\n        \"hanoi_result\": hanoi_result,\n        \"A_after_move\": A,\n        \"B_after_move\": B\n    }", "funcname": "main_solution", "ios": [{"input": {"n_factorial": 10, "n_hanoi": 1, "A": [3, 7, 1, 8, 6, 0], "B": [4, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 3628800, "hanoi_result": 1, "A_after_move": [3, 7, 1, 8, 6, 0], "B_after_move": [4, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 1, "n_hanoi": 5, "A": [4, 8, 6, 3, 5, 0], "B": [9, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 1, "hanoi_result": 31, "A_after_move": [4, 8, 6, 3, 5, 0], "B_after_move": [9, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 6, "n_hanoi": 3, "A": [5, 2, 8, 6, 4, 0], "B": [9, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 720, "hanoi_result": 7, "A_after_move": [5, 2, 8, 6, 4, 0], "B_after_move": [9, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 10, "n_hanoi": 1, "A": [5, 9, 7, 8, 6, 0], "B": [3, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 3628800, "hanoi_result": 1, "A_after_move": [5, 9, 7, 8, 6, 0], "B_after_move": [3, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 7, "n_hanoi": 1, "A": [8, 1, 5, 9, 4, 0], "B": [6, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 5040, "hanoi_result": 1, "A_after_move": [8, 1, 5, 9, 4, 0], "B_after_move": [6, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 2, "n_hanoi": 2, "A": [8, 3, 2, 5, 6, 0], "B": [1, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 2, "hanoi_result": 3, "A_after_move": [8, 3, 2, 5, 6, 0], "B_after_move": [1, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 1, "n_hanoi": 5, "A": [3, 4, 8, 2, 5, 0], "B": [7, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 1, "hanoi_result": 31, "A_after_move": [3, 4, 8, 2, 5, 0], "B_after_move": [7, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 6, "n_hanoi": 4, "A": [5, 4, 8, 9, 6, 0], "B": [2, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 720, "hanoi_result": 15, "A_after_move": [5, 4, 8, 9, 6, 0], "B_after_move": [2, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 2, "n_hanoi": 5, "A": [3, 9, 2, 6, 8, 0], "B": [1, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 2, "hanoi_result": 31, "A_after_move": [3, 9, 2, 6, 8, 0], "B_after_move": [1, 0, 0, 0, 0, 0]}}, {"input": {"n_factorial": 10, "n_hanoi": 5, "A": [9, 5, 2, 6, 4, 0], "B": [1, 0, 0, 0, 0, 0]}, "output": {"factorial_result": 3628800, "hanoi_result": 31, "A_after_move": [9, 5, 2, 6, 4, 0], "B_after_move": [1, 0, 0, 0, 0, 0]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ShrohanMohapatra/ExplorePLT", "path": "/lambdaTutorial2.py", "msgidx": 3945}}
{"problem_description": "Given a binary tree, determine whether it is height-balanced. A binary tree is considered height-balanced if the difference in height between the left and right subtrees of every node is no more than one. What is the result of checking if the provided binary tree is balanced?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the binary tree structure. Each node is represented as a dictionary with keys:\n    - `value` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as a dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as a dictionary or None if there is no right child.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is balanced. Returns `True` if the tree is balanced, otherwise `False`.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.right = right\n        self.left = left\n\n    def __str__(self):\n        return str(self.value)\n\ndef height(root):\n    if root is None:\n        return 0\n    return max(height(root.left), height(root.right)) + 1\n\ndef solution(root):\n    if root is None:\n        return True\n    lh = height(root.left)\n    rh = height(root.right)\n    if (abs(lh - rh) <= 1) and solution(root.left) is True and solution(root.right) is True:\n        return True\n    return False\n\n# main function\ndef main_solution(tree_structure):\n    # Convert JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        return Node(data['value'], build_tree(data['left']), build_tree(data['right']))\n\n    root = build_tree(tree_structure)\n    \n    # Call the solution function\n    is_balanced = solution(root)\n    \n    # Convert the output to JSON serializable\n    return is_balanced", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"value": -47, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": -23, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": -42, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 8, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 93, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 38, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": -53, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": -50, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": -75, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 87, "left": null, "right": null}}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KorsakovPV/yandex_contest", "path": "/15_Yandex_Contest/B/B.py", "msgidx": 3949}}
{"problem_description": "Given a Sudoku grid represented as a string, determine whether the grid is a valid Sudoku solution. The grid is a square matrix of size N (either 4 or 9), and each row, column, and sub-grid (of size sqrt(N) x sqrt(N)) must contain all the digits from 1 to N exactly once. What is the validity of the provided Sudoku grid?", "io_requirements": "Input:\n  `grid_str` (str): A string representing the Sudoku grid in the format \"N;x1,x2,...,xN^2\" where N is the size of the grid (either 4 or 9) and x1, x2, ..., xN^2 are the values in the grid in row-major order, comma-delimited.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the given Sudoku grid is a valid solution (True) or not (False).", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(grid_str):\n    # Convert the input string to a grid\n    grid = create_grid(grid_str)\n    \n    # Determine the size of the grid\n    n = len(grid)\n    \n    # Check if the grid is a valid sudoku solution\n    result = check_sudoku(grid, n)\n    \n    # Return the result as a boolean\n    return result\n\n# Function to create a grid from a string\ndef create_grid(test):\n    test = test.rstrip().split(';')\n    test[1] = test[1].split(',')\n    grid = []\n    for i in range(int(test[0])):\n        slist = []\n        for j in range(int(test[0])):\n            slist.append(int(test[1][j + int(test[0]) * i]))\n        grid.append(slist)\n    return grid\n\n# Function to check if a grid is a valid sudoku solution\ndef check_sudoku(grid, n):\n    try:\n        rcount = 0\n        for lst in grid:\n            if len(lst) != n:\n                raise\n            rcount += 1\n            for item in lst:\n                if type(item) != int:\n                    raise\n                if item < 0 or item > n:\n                    raise\n        if rcount != n:\n            return None\n    except:\n        return None\n    \n    # Check row validity\n    for lst in grid:\n        rdigits = [int(i) for i in range(1, n + 1)]\n        for digit in lst:\n            if digit in rdigits:\n                rdigits.remove(digit)\n            elif digit == 0:\n                pass\n            else:\n                return False\n    \n    # Check column validity\n    for col in range(n):\n        cdigits = [int(i) for i in range(1, n + 1)]\n        for i in range(n):\n            if grid[i][col] in cdigits:\n                cdigits.remove(grid[i][col])\n            elif grid[i][col] == 0:\n                pass\n            else:\n                return False\n    \n    # Check grid validity\n    box = int(math.sqrt(n))\n    for g in range(n):\n        gdigits = [int(i) for i in range(1, n + 1)]\n        for i in range((g % box) * box, (g % box) * box + box):\n            for j in range((g // box) * box, (g // box) * box + box):\n                if grid[j][i] in gdigits:\n                    gdigits.remove(grid[j][i])\n                elif grid[j][i] == 0:\n                    pass\n                else:\n                    return False\n    \n    return True", "funcname": "main_solution", "ios": [{"input": {"grid_str": "4;4,1,3,2,4,1,3,2,4,3,1,2,3,2,4,1"}, "output": false}, {"input": {"grid_str": "4;3,1,2,4,1,3,2,4,4,2,1,3,4,1,2,3"}, "output": false}, {"input": {"grid_str": "4;4,2,3,1,3,1,4,2,4,1,3,2,2,1,4,3"}, "output": false}, {"input": {"grid_str": "4;4,2,3,1,4,3,2,1,3,1,4,2,4,3,2,1"}, "output": false}, {"input": {"grid_str": "4;2,3,4,1,4,2,3,1,2,3,4,1,3,4,2,1"}, "output": false}, {"input": {"grid_str": "4;3,4,1,2,2,4,1,3,4,1,3,2,2,4,1,3"}, "output": false}, {"input": {"grid_str": "4;3,1,4,2,1,3,4,2,4,2,3,1,3,1,2,4"}, "output": false}, {"input": {"grid_str": "4;3,2,1,4,2,3,4,1,1,3,4,2,1,2,4,3"}, "output": false}, {"input": {"grid_str": "4;4,2,3,1,1,4,2,3,2,1,4,3,2,4,3,1"}, "output": false}, {"input": {"grid_str": "4;2,4,3,1,3,4,2,1,4,2,3,1,3,2,4,1"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mgorgei/codeeval", "path": "/Medium/c78 Sudoku.py", "msgidx": 4000}}
{"problem_description": "In a criminal investigation, four suspects (A, B, C, and D) are interrogated. Each suspect makes a statement about who they think the thief is. Based on the statements made by A, B, C, and D, which suspect is identified as the thief?", "io_requirements": "Input:\n  `statements` (dict): A dictionary representing the statements made by each suspect. The keys are the suspect names ('A', 'B', 'C', 'D') and the values are their corresponding statements. Each statement is a string that can be evaluated to a boolean expression.\n\nOutput:\n  `return` (str): A string representing the name of the thief ('1', '2', '3', or '4'). If no thief is identified, it returns `None`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n\n# main function\ndef main_solution(statements):\n    # Convert the statements dictionary to boolean expressions\n    for i in range(1, 5):\n        x = i\n        exp1 = 1 if x != 1 else 0\n        exp2 = 1 if x == 3 else 0\n        exp3 = 1 if x == 4 else 0\n        exp4 = 1 if x != 4 else 0\n        sum_ = exp1 + exp2 + exp3 + exp4\n        if sum_ == 3:\n            return str(i)\n    return None", "funcname": "main_solution", "ios": [{"input": {"statements": {"A": "C is the thief.", "B": "The thief is D.", "C": "The thief is D.", "D": "The thief is D."}}, "output": "3"}, {"input": {"statements": {"A": "The thief is D.", "B": "C is lying.", "C": "The thief is D.", "D": "The thief is D."}}, "output": "3"}, {"input": {"statements": {"A": "C is the thief.", "B": "C is the thief.", "C": "The thief is D.", "D": "C is lying."}}, "output": "3"}, {"input": {"statements": {"A": "C is the thief.", "B": "I am not the thief.", "C": "I am not the thief.", "D": "The thief is D."}}, "output": "3"}, {"input": {"statements": {"A": "C is the thief.", "B": "The thief is D.", "C": "C is the thief.", "D": "The thief is D."}}, "output": "3"}, {"input": {"statements": {"A": "I am not the thief.", "B": "C is the thief.", "C": "C is the thief.", "D": "C is lying."}}, "output": "3"}, {"input": {"statements": {"A": "C is the thief.", "B": "The thief is D.", "C": "I am not the thief.", "D": "C is lying."}}, "output": "3"}, {"input": {"statements": {"A": "I am not the thief.", "B": "I am not the thief.", "C": "The thief is D.", "D": "The thief is D."}}, "output": "3"}, {"input": {"statements": {"A": "C is lying.", "B": "C is lying.", "C": "C is the thief.", "D": "C is lying."}}, "output": "3"}, {"input": {"statements": {"A": "C is lying.", "B": "C is lying.", "C": "I am not the thief.", "D": "The thief is D."}}, "output": "3"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chenchuangc/algorithm", "path": "/03.mythink_/09.code_python02/01.base_sumarise_/01.data_module_design_/01.who_is_thief.py", "msgidx": 4175}}
{"problem_description": "Given the concept of circular primes, where a prime number remains prime under all rotations of its digits, how many such circular primes exist below a certain limit? Specifically, what is the count of circular primes below one million?", "io_requirements": "Input:\n  `N` (int): The upper limit (exclusive) up to which to search for circular primes.\n\nOutput:\n  `return` (int): The count of circular primes below the given limit `N`.", "refcode": "# import necessary packages\nfrom math import sqrt, ceil\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(ceil(sqrt(n))) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef check_values(xs):\n    for i in xs:\n        if not is_prime(i):\n            return False\n    return True\n\ndef rotations(n):\n    aux = str(n)\n    res = []\n    for i in range(len(aux)):\n        res.append(int(aux[i:] + aux[:i]))\n    return tuple(res)\n\n# main function\ndef main_solution(N):\n    count = 1  # Para contar el 2\n    gen = (n for n in range(3, N, 2) if is_prime(n))\n    for num in gen:\n        values = rotations(num)\n        if check_values(values):\n            count += 1\n    return count", "funcname": "main_solution", "ios": [{"input": {"N": 10000}, "output": 33}, {"input": {"N": 100000}, "output": 43}, {"input": {"N": 1000000}, "output": 55}, {"input": {"N": 100}, "output": 13}, {"input": {"N": 1000}, "output": 25}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "floppp/programming_challenges", "path": "/project_euler/001-050/35.py", "msgidx": 4084}}
{"problem_description": "In a dice game, you are given a set of dice rolls and need to determine the optimal strategy to achieve a large straight (either 1-2-3-4-5 or 2-3-4-5-6). Given the initial roll of 1, 2, 4, 5, and an unknown die, what strategy should be used to maximize the chances of achieving a large straight, and what is the outcome of that strategy?", "io_requirements": "Input:\n  `strategy` (str): A string representing the strategy to be used. Possible values are \"strategy1\", \"strategy2\", and \"strategy3\".\n\nOutput:\n  `return` (dict): A dictionary containing the result of the strategy execution. The dictionary has the following structure:\n    - `result` (bool or int): The outcome of the strategy. If the strategy is successful, it returns `True` (for strategy1) or an integer representing the roll path (for strategy2 and strategy3). If the strategy fails, it returns `False` (for strategy1) or `0` (for strategy2 and strategy3).\n    - `error` (str): If the input strategy is invalid, this key will be present with the value \"Invalid strategy\".", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(strategy):\n    # Convert the strategy input to the corresponding function\n    strategies = {\n        \"strategy1\": strategy1,\n        \"strategy2\": strategy2,\n        \"strategy3\": strategy3\n    }\n    \n    if strategy not in strategies:\n        return {\"error\": \"Invalid strategy\"}\n    \n    # Execute the selected strategy\n    result = strategies[strategy]()\n    \n    # Convert the result to a JSON serializable output\n    if isinstance(result, np.bool_):\n        result = bool(result)\n    elif isinstance(result, np.int64):\n        result = int(result)\n    \n    return {\"result\": result}\n\n# Strategy 1: Reroll the X only\ndef strategy1():\n    r = np.array([1, 2, 4, 5])\n    s = np.random.choice(6, 1) + 1\n    a = np.r_[r, s]\n    a = np.sort(a)\n    if np.all(a == np.array([1, 2, 3, 4, 5])):\n        return True\n    s = np.random.choice(6, 1) + 1\n    a = np.r_[r, s]\n    a = np.sort(a)\n    if np.all(a == np.array([1, 2, 3, 4, 5])):\n        return True\n    return False\n\n# Strategy 2: Reroll the 1,X\n# Roll 1 die if you have a 3 otherwise roll 2\ndef strategy2():\n    r = np.array([2, 4, 5])\n    s = np.random.choice(6, 2) + 1\n    a = np.r_[r, s]\n    a = np.sort(a)\n    if np.all(a == np.array([1, 2, 3, 4, 5])):\n        return 1\n    elif np.all(a == np.array([2, 3, 4, 5, 6])):\n        return 1\n    if 3 in s:\n        r = np.array([2, 3, 4, 5])\n        s = np.random.choice(6, 1) + 1\n        rollpath = 2\n    else:\n        r = np.array([2, 4, 5])\n        s = np.random.choice(6, 2) + 1\n        rollpath = 5\n    a = np.r_[r, s]\n    a = np.sort(a)\n    if np.all(a == np.array([1, 2, 3, 4, 5])):\n        return rollpath\n    elif np.all(a == np.array([2, 3, 4, 5, 6])):\n        return rollpath\n    return 0\n\n# Strategy 3: Reroll the 1,X\n# Reroll 1 die if you have a 3, 1, or 6\n# The priority is to keep the 3 (double ended straight)\ndef strategy3():\n    r = np.array([2, 4, 5])\n    s = np.random.choice(6, 2) + 1\n    a = np.r_[r, s]\n    a = np.sort(a)\n    if np.all(a == np.array([1, 2, 3, 4, 5])):\n        return 1\n    elif np.all(a == np.array([2, 3, 4, 5, 6])):\n        return 1\n    if 3 in s:\n        r = np.array([2, 3, 4, 5])\n        s = np.random.choice(6, 1) + 1\n        rollpath = 2\n    elif 1 in s:\n        r = np.array([1, 2, 4, 5])\n        s = np.random.choice(6, 1) + 1\n        rollpath = 3\n    elif 6 in s:\n        r = np.array([2, 4, 5, 6])\n        s = np.random.choice(6, 1) + 1\n        rollpath = 4\n    else:\n        r = np.array([2, 4, 5])\n        s = np.random.choice(6, 2) + 1\n        rollpath = 5\n    a = np.r_[r, s]\n    a = np.sort(a)\n    if np.all(a == np.array([1, 2, 3, 4, 5])):\n        return rollpath\n    elif np.all(a == np.array([2, 3, 4, 5, 6])):\n        return rollpath\n    return 0", "funcname": "main_solution", "ios": [{"input": {"strategy": "strategy2"}, "output": {"result": 2}}, {"input": {"strategy": "strategy1"}, "output": {"result": false}}, {"input": {"strategy": "strategy3"}, "output": {"result": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rgc-retired/math_puzzles", "path": "/riddler/nancy/yahtzee.py", "msgidx": 3488}}
{"problem_description": "Given a set of distinct elements, how can we generate all possible subsets of this set using either a recursive approach or a combinatorial approach?", "io_requirements": "Input:\n  `set_elements` (list of strings): A list of elements representing the set for which subsets need to be generated.\n  `method` (string): A string indicating the method to use for generating subsets. Valid values are \"recursion\" or \"combinatorics\".\n\nOutput:\n  `return` (string): A JSON-formatted string representing the list of all subsets of the input set. Each subset is also represented as a list.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef list_sub_set(a_set, n):\n    set_len = n + 1\n    if set_len == 0:\n        return [[]]\n    result = []\n    for subset in list_sub_set(a_set, n-1):\n        result.append(subset)\n        result.append(subset + list(a_set[n]))\n    return result\n\ndef list_sub_set_2(a_set):\n    set_length = len(a_set)\n    max = 1 << set_length\n    result = []\n    for i in range(max):\n        result.append(get_sub_set(a_set, set_length, i))\n    return result\n\ndef get_sub_set(a_set, set_length, number):\n    sub_set = []\n    index = set_length-1\n    while number > 0:\n        if (number & 1) == 1:\n            sub_set.append(a_set[index])\n        index -= 1\n        number >>= 1\n    return sub_set\n\n# main function\ndef main_solution(set_elements, method):\n  # Convert JSON serializable input to original input variables\n  a_set = set_elements\n  if method == \"recursion\":\n      result = list_sub_set(a_set, len(a_set)-1)\n  elif method == \"combinatorics\":\n      result = list_sub_set_2(a_set)\n  else:\n      raise ValueError(\"Invalid method. Choose 'recursion' or 'combinatorics'.\")\n  \n  # Convert result to JSON serializable output\n  result = json.dumps(result)\n  \n  return result", "funcname": "main_solution", "ios": [{"input": {"set_elements": ["u"], "method": "recursion"}, "output": "[[], [\"u\"]]"}, {"input": {"set_elements": ["y"], "method": "recursion"}, "output": "[[], [\"y\"]]"}, {"input": {"set_elements": ["j", "u"], "method": "recursion"}, "output": "[[], [\"u\"], [\"j\"], [\"j\", \"u\"]]"}, {"input": {"set_elements": ["e"], "method": "recursion"}, "output": "[[], [\"e\"]]"}, {"input": {"set_elements": ["u", "l"], "method": "recursion"}, "output": "[[], [\"l\"], [\"u\"], [\"u\", \"l\"]]"}, {"input": {"set_elements": ["s"], "method": "recursion"}, "output": "[[], [\"s\"]]"}, {"input": {"set_elements": ["v", "e", "r"], "method": "recursion"}, "output": "[[], [\"r\"], [\"e\"], [\"e\", \"r\"], [\"v\"], [\"v\", \"r\"], [\"v\", \"e\"], [\"v\", \"e\", \"r\"]]"}, {"input": {"set_elements": ["r"], "method": "recursion"}, "output": "[[], [\"r\"]]"}, {"input": {"set_elements": ["l", "r", "r"], "method": "recursion"}, "output": "[[], [\"r\"], [\"r\"], [\"r\", \"r\"], [\"l\"], [\"l\", \"r\"], [\"l\", \"r\"], [\"l\", \"r\", \"r\"]]"}, {"input": {"set_elements": ["x", "a", "n"], "method": "recursion"}, "output": "[[], [\"n\"], [\"a\"], [\"a\", \"n\"], [\"x\"], [\"x\", \"n\"], [\"x\", \"a\"], [\"x\", \"a\", \"n\"]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lelong03/python_algorithm", "path": "/recursion/list_sub_sets.py", "msgidx": 3629}}
{"problem_description": "Given a board represented by a list of positive integers with one '0', and a starting position on the board, determine if it is possible to reach the '0' by jumping according to the values on the board. The jumps are determined by the integer values at the current position. Is it possible to reach the '0' from the given starting position?", "io_requirements": "Input:\n  `start` (int): The starting index on the board.\n  `board` (list of int): A list of positive integers with one '0', representing the board.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"solvable\" whose value is a boolean indicating whether it is possible to reach the '0' from the starting index.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_solvable(start, board):\n    \"\"\"\n    A function that receives a board and a starting location on the board.\n    The board is a list of positive integers with one '0'.\n    The location is an integer representing the starting index.\n    Returns True if you can get from the starting position to the '0' by the jumps\n    given by the numbers on the board, False if you can't.\n    \"\"\"\n    solvable = a_path_is_possible(start, board)\n    for corridor in range(len(board)):\n        if board[corridor] < 0:\n            board[corridor] = -board[corridor]\n    return solvable\n\ndef a_path_is_possible(start, board):\n    \"\"\"\n    A recursive function to solve 'is_solvable'. It goes through the board\n    and checks any possible way to reach the '0'.\n    \"\"\"\n    if start < 0 or start >= len(board):\n        return False\n    if board[start] < 0:\n        return False\n    if board[start] == 0:\n        return True\n    board[start] = -board[start]\n    return a_path_is_possible(start + board[start], board) or \\\n           a_path_is_possible(start - board[start], board)\n\n# main function\ndef main_solution(start, board):\n    # Convert the board list to a JSON serializable format\n    board_serializable = board[:]\n    # Call the is_solvable function\n    result = is_solvable(start, board_serializable)\n    # Convert the result to a JSON serializable format\n    return {\"solvable\": result}", "funcname": "main_solution", "ios": [{"input": {"start": 5, "board": [4, 3, 1, 0, 5, 1]}, "output": {"solvable": false}}, {"input": {"start": 3, "board": [1, 4, 0, 1, 5, 2, 2, 4, 3]}, "output": {"solvable": true}}, {"input": {"start": 2, "board": [3, 5, 0, 1, 3, 3]}, "output": {"solvable": true}}, {"input": {"start": 0, "board": [2, 0, 1, 4, 3, 2, 2, 2, 2]}, "output": {"solvable": true}}, {"input": {"start": 7, "board": [1, 5, 3, 5, 1, 4, 0, 4, 3]}, "output": {"solvable": true}}, {"input": {"start": 1, "board": [3, 4, 0, 1, 5, 2, 1, 5, 3]}, "output": {"solvable": true}}, {"input": {"start": 0, "board": [0, 4, 5, 4, 3, 4, 1, 2]}, "output": {"solvable": true}}, {"input": {"start": 4, "board": [0, 1, 4, 2, 1]}, "output": {"solvable": true}}, {"input": {"start": 4, "board": [4, 1, 2, 0, 4, 1, 4, 3, 5]}, "output": {"solvable": true}}, {"input": {"start": 2, "board": [5, 1, 0, 4, 2, 5, 3, 4, 1]}, "output": {"solvable": true}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "adirz/sample-projects", "path": "/samle projects/school projects/intro to CS/ex5/GetToTheZero.py", "msgidx": 4006}}
{"problem_description": "Given a set of academic papers and a list of authors, determine the Erdos number for each author. The Erdos number is a measure of the collaborative distance between an author and Paul Erdos, a prolific mathematician. If an author has co-authored a paper with Erdos, their Erdos number is 1. If an author has co-authored a paper with someone who has an Erdos number of 1, their Erdos number is 2, and so on. What are the Erdos numbers for the given list of authors based on the provided papers?", "io_requirements": "Input:\n  `papers` (int): The number of papers to process.\n  `names` (int): The number of names to query for Erdos numbers.\n  `authorList` (list of lists of strings): A list where each element is a list of author names for a paper.\n  `namesList` (list of strings): A list of names to query for their Erdos numbers.\n\nOutput:\n  `return` (dict): A dictionary where the keys are the names from `namesList` and the values are their corresponding Erdos numbers. If a name does not have an Erdos number, the value is \"infinity\".", "refcode": "# import necessary packages\nfrom collections import defaultdict, deque\n\n# all class and function definitions in the code file, if any\nclass Tree(object):\n    def __init__(self, name, children=[]):\n        self.name = name\n        self.children = list(children)\n\n    def add(self, child):\n        self.children.append(child)\n\ndef addChildren(authorLine, erdosTree):\n    if 'Erdos, P.' in authorLine: #Erdos present in author list\n        for i in authorLine:\n            if (i != 'Erdos, P.'): \n                erdosTree.add(Tree(i))\n    else: #handle authors removed from Erdos\n        #search for match\n        for i in range(len(erdosTree.children)): #iterator \n            for authorName in authorLine:\n                if authorName == erdosTree.children[i].name:\n                    filterLine = filter(lambda x: x!=authorName, authorLine)\n                    for childName in filterLine:\n                        erdosTree.children[i].add(Tree(childName)) \n\ndef treeToMap(erdosTree):\n    authNumberDict = defaultdict(int)\n    for i in range(len(erdosTree.children)):\n        authNumberDict[erdosTree.children[i].name] = 1\n        if erdosTree.children[i].children:\n            for j in range(len(erdosTree.children[i].children)):\n                authNumberDict[erdosTree.children[i].children[j].name] = 2\n    return authNumberDict\n\n# main function\ndef main_solution(papers, names, authorList, namesList):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    erdosTree = Tree(\"Erdos, P.\")\n\n    for line in authorList:\n        addChildren(line, erdosTree)\n\n    authNumberDict = treeToMap(erdosTree)\n\n    result = {}\n    for name in namesList:\n        if name in authNumberDict:\n            result[name] = authNumberDict[name]\n        else:\n            result[name] = \"infinity\"\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"papers": 1, "names": 1, "authorList": [["Author1", "Erdos, P.", "Author0"]], "namesList": ["Author0"]}, "output": {"Author0": 1}}, {"input": {"papers": 1, "names": 1, "authorList": [["Author0", "Erdos, P.", "Author2", "Author1"]], "namesList": ["Author0"]}, "output": {"Author0": 1}}, {"input": {"papers": 1, "names": 2, "authorList": [["Author0", "Erdos, P."]], "namesList": ["Author0", "Author1"]}, "output": {"Author0": 1, "Author1": "infinity"}}, {"input": {"papers": 1, "names": 1, "authorList": [["Erdos, P.", "Author0"]], "namesList": ["Author0"]}, "output": {"Author0": 1}}, {"input": {"papers": 1, "names": 1, "authorList": [["Author0", "Erdos, P.", "Author1"]], "namesList": ["Author0"]}, "output": {"Author0": 1}}, {"input": {"papers": 1, "names": 1, "authorList": [["Erdos, P.", "Author2", "Author0", "Author1"]], "namesList": ["Author0"]}, "output": {"Author0": 1}}, {"input": {"papers": 1, "names": 1, "authorList": [["Author1", "Author2", "Author0", "Erdos, P."]], "namesList": ["Author0"]}, "output": {"Author0": 1}}, {"input": {"papers": 1, "names": 2, "authorList": [["Erdos, P.", "Author0"]], "namesList": ["Author0", "Author1"]}, "output": {"Author0": 1, "Author1": "infinity"}}, {"input": {"papers": 1, "names": 1, "authorList": [["Author0", "Erdos, P."]], "namesList": ["Author0"]}, "output": {"Author0": 1}}, {"input": {"papers": 1, "names": 1, "authorList": [["Author1", "Author0", "Erdos, P."]], "namesList": ["Author0"]}, "output": {"Author0": 1}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nyucusp/gx5003-fall2013", "path": "/rad416/Assignment3/problem3.py", "msgidx": 3387}}
{"problem_description": "Given a list of words, how can we identify which words can be split into two smaller words, where the first smaller word contains the letters from the even positions of the original word, and the second smaller word contains the letters from the odd positions of the original word?", "io_requirements": "Input:\n  `words` (list of str): A list of words to analyze for alternades. Each word should be a string consisting of alphanumeric characters.\n\nOutput:\n  `return` (dict): A dictionary where the keys are the words that have alternades and the values are lists of their alternades. Each alternade is a string.", "refcode": "# import necessary packages\nimport re\nfrom collections import defaultdict\n\n# main function\ndef main_solution(words):\n    \"\"\"\n    Finds alternades in a list of words. An alternade is a word that can be split into two smaller words,\n    where the first smaller word contains the letters from the even positions of the original word,\n    and the second smaller word contains the letters from the odd positions of the original word.\n\n    Args:\n    words (list of str): A list of words to analyze for alternades.\n\n    Returns:\n    dict: A dictionary where the keys are the words that have alternades and the values are lists of their alternades.\n    \"\"\"\n    foundalternades = defaultdict(list)\n\n    for word in words:\n        wordlist, smallerwordeven, smallerwordodd = words[:], '', ''\n        wordlist.remove(word)\n\n        if len(word) > 1:\n            for i, letters in enumerate(word):\n                if i % 2 == 0:\n                    smallerwordeven += letters\n                    if smallerwordeven in wordlist and smallerwordeven not in foundalternades[word]:\n                        foundalternades[word].append(smallerwordeven)\n                else:\n                    smallerwordodd += letters\n                    if smallerwordodd in wordlist and smallerwordodd not in foundalternades[word]:\n                        foundalternades[word].append(smallerwordodd)\n\n    return {word: alternades for word, alternades in foundalternades.items() if alternades}", "funcname": "main_solution", "ios": [{"input": {"words": ["UxKNE", "Woudt", "oeCCmiV", "YVUWq", "xUUmecU", "cPABsME", "BFFmnp", "OuXA", "QHk"]}, "output": {}}, {"input": {"words": ["sKeXJY", "ccv", "JPas", "mulA", "rSufeN", "lNcgb", "ozArpdj"]}, "output": {}}, {"input": {"words": ["gMj", "lXY", "PXNdgEh", "DoTRqE", "EgaN"]}, "output": {}}, {"input": {"words": ["oQE", "soARXo", "CymRel", "uhXhj", "iRbMK", "lGJzGZH", "wjaCje", "tDeo", "RkDuct", "kRDd"]}, "output": {}}, {"input": {"words": ["HmTi", "vAKMm", "nKQGVx", "RqoS", "PkdY"]}, "output": {}}, {"input": {"words": ["ZYww", "GCKO", "xQXkkqg", "YXje", "silC", "zii"]}, "output": {}}, {"input": {"words": ["Zzg", "IKm", "GARlvtD", "UcqK", "DTsCirv", "UqrwWSj", "oYAH", "bnWACV", "gylkG"]}, "output": {}}, {"input": {"words": ["pRqAqx", "dIvoDFk", "hkjR", "lIVIJW", "Cngz", "qwLZzhL", "ZubyJHk", "tznKpq", "YPPQoa"]}, "output": {}}, {"input": {"words": ["vWuKdcW", "jZDwZe", "AgQ", "PIyv", "KvbOVi", "YJfLpjw", "dSZUwm", "WmL"]}, "output": {}}, {"input": {"words": ["tiqJl", "UvM", "tZSWn", "qqtTEz", "RpdiAz", "mqg"]}, "output": {}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Prashantbangar03/coriolis_assingment", "path": "/46.alternate_word.py", "msgidx": 4282}}
{"problem_description": "Given the concept of strobogrammatic numbers, which are numbers that look the same when rotated 180 degrees (or viewed upside down), what are all the strobogrammatic numbers of a specified length `n`?", "io_requirements": "Input:\n  `n` (int): The length of the strobogrammatic numbers to be found. Must be a positive integer.\n\nOutput:\n  `return` (List[str]): A list of strings representing all strobogrammatic numbers of length `n`. Each string in the list is a strobogrammatic number.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def findStrobogrammatic(self, n: int) -> List[str]:\n        record = {1: ['0', '1', '8'], 2: ['11', '69', '88', '96']}\n        pair = ['00', '11', '88', '69', '96']\n        if n <= 2:\n            return record[n]\n        cnt = 3\n        while cnt <= n:\n            tmp = []\n            if (cnt - 1) % 2 == 0:\n                for item in record[cnt - 1]:\n                    for num in record[1]:\n                        tmp.append(item[:len(item)//2] + num + item[len(item)//2:])\n            else:\n                for item in record[cnt - 2]:\n                    for num in pair:\n                        tmp.append(item[:len(item)//2] + num + item[len(item)//2:])\n            record[cnt] = tmp\n            cnt += 1\n        return record[n]\n\n# main function\ndef main_solution(n: int) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable\n    solution = Solution()\n    result = solution.findStrobogrammatic(n)\n    # return, the returned value must be json serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": ["101", "111", "181", "609", "619", "689", "808", "818", "888", "906", "916", "986"]}, {"input": {"n": 2}, "output": ["11", "69", "88", "96"]}, {"input": {"n": 1}, "output": ["0", "1", "8"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhangwang0537/LeetCode-Notebook", "path": "/source/Clarification/Math/247.\u4e2d\u5fc3\u5bf9\u79f0\u6570\u2161.py", "msgidx": 3883}}
{"problem_description": "In a block world simulation, a robot arm is tasked with manipulating blocks on a flat table according to a set of commands. The blocks are initially arranged in a line from 0 to n-1. The robot can execute commands to move blocks from one stack to another, either individually or in piles, while adhering to specific rules. Given a number of blocks and a series of commands, what will be the final arrangement of the blocks on the table?", "io_requirements": "Input:\n  `size` (int): The number of blocks on the table, ranging from 0 to n-1.\n  `commands` (list of lists): A list of commands, where each command is a list containing three elements:\n    - `cmd[0]` (str): The command type, which can be one of `\"move_onto\"`, `\"move_over\"`, `\"pile_onto\"`, or `\"pile_over\"`.\n    - `cmd[1]` (int): The block number `a` involved in the command.\n    - `cmd[2]` (int): The block number `b` involved in the command.\n\nOutput:\n  `return` (str): A string representing the final state of the blocks after executing all commands. Each line represents a stack of blocks, formatted as `\"stack_number: block1 block2 ...\"`.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\nclass Blocks():\n    def __init__(self, size, commands):\n        self.stacks = [[block] for block in range(size)]\n        self.size = size\n        self.commands = commands\n\n    def __find_stack(self, block):\n        for stack in range(self.size):\n            if block in self.stacks[stack]:\n                return stack\n\n    def __reset_stack(self, stack, block):\n        for b in self.stacks[stack]:\n            if b != block:\n                self.stacks[b] = [b]\n\n    def __move_block(self, stack_from, stack_to, block):\n        blocks = self.stacks[stack_from]\n        position = blocks.index(block) \n        self.stacks[stack_from] = blocks[:position]\n        self.stacks[stack_to].extend(blocks[position:])\n\n    def __command(self, a, b, reset_a=False, reset_b=False):\n        stack_a, stack_b = self.__find_stack(a), self.__find_stack(b)\n\n        if a == b or stack_a == stack_b:\n            return\n\n        if reset_a:\n            self.__reset_stack(stack_a, a)\n        if reset_b:\n            self.__reset_stack(stack_b, b)\n\n        self.__move_block(stack_a, stack_b, a)\n\n    def execute(self):\n        for command, a, b in self.commands:\n            if a != b:\n                getattr(self, command)(a, b) \n\n    def move_onto(self, a, b):\n        self.__command(a, b, reset_a=True, reset_b=True)\n\n    def move_over(self, a, b):\n        self.__command(a, b, reset_a=True)\n    \n    def pile_over(self, a, b):\n        self.__command(a, b, reset_b=True)\n    \n    def pile_onto(self, a, b):\n        self.__command(a, b)\n\n# main function\ndef main_solution(size, commands):\n    # Convert commands list to a list of tuples\n    commands = [(cmd[0], int(cmd[1]), int(cmd[2])) for cmd in commands]\n    \n    # Initialize the Blocks instance\n    blocks = Blocks(size, commands)\n    \n    # Execute the commands\n    blocks.execute()\n    \n    # Prepare the output\n    output = []\n    for stack in range(blocks.size):\n        output.append(f\"{stack}: {' '.join(map(str, blocks.stacks[stack]))}\")\n    \n    return \"\\n\".join(output)", "funcname": "main_solution", "ios": [{"input": {"size": 8, "commands": [["pile_over", "2", "6"]]}, "output": "0: 0\n1: 1\n2: \n3: 3\n4: 4\n5: 5\n6: 6 2\n7: 7"}, {"input": {"size": 3, "commands": [["move_onto", "2", "1"]]}, "output": "0: 0\n1: 1 2\n2: "}, {"input": {"size": 3, "commands": [["pile_over", "0", "1"]]}, "output": "0: \n1: 1 0\n2: 2"}, {"input": {"size": 7, "commands": [["move_onto", "4", "0"]]}, "output": "0: 0 4\n1: 1\n2: 2\n3: 3\n4: \n5: 5\n6: 6"}, {"input": {"size": 8, "commands": [["move_over", "7", "1"], ["pile_over", "4", "2"]]}, "output": "0: 0\n1: 1 7\n2: 2 4\n3: 3\n4: \n5: 5\n6: 6\n7: "}, {"input": {"size": 8, "commands": [["pile_onto", "4", "6"]]}, "output": "0: 0\n1: 1\n2: 2\n3: 3\n4: \n5: 5\n6: 6 4\n7: 7"}, {"input": {"size": 7, "commands": [["pile_over", "2", "0"]]}, "output": "0: 0 2\n1: 1\n2: \n3: 3\n4: 4\n5: 5\n6: 6"}, {"input": {"size": 2, "commands": [["pile_onto", "0", "1"], ["move_over", "1", "0"]]}, "output": "0: \n1: 1 0"}, {"input": {"size": 3, "commands": [["pile_over", "2", "1"]]}, "output": "0: 0\n1: 1 2\n2: "}, {"input": {"size": 10, "commands": [["pile_over", "6", "5"]]}, "output": "0: 0\n1: 1\n2: 2\n3: 3\n4: 4\n5: 5 6\n6: \n7: 7\n8: 8\n9: 9"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chinnurtb/problem_sets", "path": "/uva/blocks_problem.py", "msgidx": 3668}}
{"problem_description": "A monkey is exploring a planar grid starting from the origin (0, 0). The monkey can move one space at a time in any of the four cardinal directions (left, right, up, down). The monkey can only access points where the sum of the digits of the absolute value of the x-coordinate plus the sum of the digits of the absolute value of the y-coordinate is less than or equal to a certain boundary value. Given a boundary value, how many unique points can the monkey access starting from (0, 0)?", "io_requirements": "Input:\n  `boundary` (int): The maximum sum of the digits of the absolute values of the coordinates that the monkey can access.\n\nOutput:\n  `return` (int): The total number of accessible tiles the monkey can visit starting from (0, 0).", "refcode": "# import necessary packages\nimport itertools\nfrom functools import update_wrapper\n\n# all class and function definitions in the code file, if any\ndef decorator(d):\n    \"Make function d a decorator that wraps function fn\"\n    return lambda fn: update_wrapper(d(fn), fn)\n\ndecorator = decorator(decorator)\n\n@decorator\ndef memo(fn):\n    \"Decorator to memoize (cache) results of a function\"\n    cache = {}\n    def _f(*args, **kwargs):\n        key = (args, tuple(kwargs.items()))\n        try:  # check if we have it in cache\n            return cache[key]\n        except KeyError:  # No, we don't\n            cache[key] = result = fn(*args, **kwargs)\n            return result\n        except TypeError:  # Actually, the args cannot even be a key of dict (like lists)\n            return fn(*args, **kwargs)\n    return _f\n\n@memo\ndef sum_digits(number):\n    mod = number % 10\n    div = number // 10\n    if div == 0:\n        return mod\n    else:\n        return mod + sum_digits(div)\n\nclass Walker(object):\n    def __init__(self, boundary):\n        self.visited_tiles = set()\n        self.boundary = boundary\n\n    def look_around(self, point):\n        'checks which of the neighboring tiles are accessible and not yet covered'\n        for ds in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x, y = tuple(i + j for i, j in zip(point, ds))\n\n            sumx = sum_digits(abs(x))\n            sumy = sum_digits(abs(y))\n\n            if sumx + sumy <= self.boundary \\\n               and (x, y) not in self.visited_tiles and \\\n               x >= 0 and y >= 0:\n                yield (x, y)\n\n    def stack_walk(self, starting_point):\n        '''non-recursive version of walk'''\n        self.visited_tiles = set()  # empty set, free some memory\n        visited_tiles = set()  # local version\n        boundary = self.boundary  # minimize self calls\n        stack = [starting_point]\n        visited_tiles.add(starting_point)\n        iteration = 0\n        while stack:  # test if empty\n            iteration += 1\n            point = stack.pop()\n            x, y = point\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                newx = x + dx\n                newy = y + dy\n                sumx = sum_digits(abs(newx))\n                sumy = sum_digits(abs(newy))\n                # check boundary condition\n                if sumx + sumy > boundary:\n                    continue\n                # check if already covered\n                if (newx, newy) in visited_tiles:\n                    continue\n                visited_tiles.add((newx, newy))\n                stack.append((newx, newy))\n        return visited_tiles\n\n# main function\ndef main_solution(boundary):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    walker = Walker(boundary)\n    visited_tiles = walker.stack_walk((0, 0))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(visited_tiles)", "funcname": "main_solution", "ios": [{"input": {"boundary": 18}, "output": 47905}, {"input": {"boundary": 15}, "output": 9021}, {"input": {"boundary": 17}, "output": 14785}, {"input": {"boundary": 16}, "output": 11705}, {"input": {"boundary": 13}, "output": 4805}, {"input": {"boundary": 11}, "output": 2025}, {"input": {"boundary": 19}, "output": 102485}, {"input": {"boundary": 12}, "output": 3245}, {"input": {"boundary": 10}, "output": 1121}, {"input": {"boundary": 20}, "output": 181533}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mverzett/challenges", "path": "/monkey_grid/walker.py", "msgidx": 3914}}
{"problem_description": "Given the mathematical concept of pandigital numbers, which are numbers that contain each digit from 1 to a certain number exactly once, what is the largest prime pandigital number that can be formed using the digits from 1 to 7?", "io_requirements": "Input:\n  No input arguments are required.\n\nOutput:\n  `return` (int): The largest prime number that is also a pandigital number using digits from 1 to 7.", "refcode": "# import necessary packages\nfrom math import sqrt\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef prime(number):\n    if number == 1:\n        return False\n    upper_bound = int(sqrt(number)) + 1\n    for x in range(2, upper_bound):\n        if x == number:\n            next\n        if number % x == 0:\n            return False\n    return True\n\ndef largest_prime_pandigital():\n    largest_prime_pandigital = 1\n    permutations_list = list(permutations('1234567'))\n\n    for p in permutations_list:\n        number = int(''.join(map(str, p)))\n        if prime(number):\n            largest_prime_pandigital = number\n\n    return largest_prime_pandigital\n\n# main function\ndef main_solution():\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = largest_prime_pandigital()\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {}, "output": 7652413}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "FrankKair/polyglot-euler", "path": "/src/041/p041.py", "msgidx": 4201}}
{"problem_description": "In a game of Tic-Tac-Toe with a custom board size and win condition, given the current state of the board, what is the best move for the current player and what is the utility value of the current state? The board dimensions are defined by `m` rows and `n` columns, and a player wins by getting `k` consecutive symbols in a row, column, or diagonal. The current state of the board is represented by `current_state`, where each cell can be either empty ('_'), 'X', or 'o'.", "io_requirements": "Input:\n  `m` (int): The number of rows in the game board.\n  `n` (int): The number of columns in the game board.\n  `k` (int): The number of consecutive symbols required to win the game.\n  `current_state` (list of lists of str): The current state of the game board represented as a 2D list of strings. Each string can be either '_' (empty), 'X', or 'o'.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `utility` (int): The utility value of the current state. It can be 1 (Max wins), -1 (Min wins), or 0 (tie).\n    - `best_move` (tuple of int): The best move recommended for the current player, represented as a tuple of row and column indices.", "refcode": "# import necessary packages\nimport numpy as np\nimport math\nimport time\n\n# all class and function definitions in the code file, if any\nclass Game:\n\n    def __init__(self, m, n, k):\n        self.m = m\n        self.n = n\n        self.k = k\n        self.utility = 0\n        self.initialize_game()\n        self.turn = 'X'\n        self.visited_states = 0\n\n    def initialize_game(self):\n        self.current_state = np.full((self.m, self.n), \"_\", dtype=object)\n\n    def is_valid(self, coord):\n        x, y = coord[0], coord[1]\n        if self.current_state[x][y] != '_':\n            return False\n        if (x >= self.m) or (x < 0) or (y >= self.n) or (y < 0):\n            return False\n        return True\n\n    def is_terminal(self):\n        Max_win = 'X' * self.k\n        Min_win = 'o' * self.k\n        for j in range(2):\n            board = self.current_state\n            if j == 1:\n                board = self.current_state.T\n            for i in range(board.shape[0]):\n                l = board[i].tolist()\n                final = \"\".join(l)\n                if Max_win in final:\n                    self.utility = 1\n                    return True\n                elif Min_win in final:\n                    self.utility = -1\n                    return True\n        a = self.current_state\n        diags = [a[::-1, :].diagonal(i) for i in range(-a.shape[0] + 1, a.shape[1])]\n        for j in range(2):\n            if j == 1:\n                diags = [a[::, :].diagonal(i) for i in range(-a.shape[0] + 1, a.shape[1])]\n            for i, elem in enumerate(diags):\n                final = \"\".join(diags[i])\n                if Max_win in final:\n                    self.utility = 1\n                    return True\n                elif Min_win in final:\n                    self.utility = -1\n                    return True\n        tie = True\n        for i in range(self.m):\n            for j in range(self.n):\n                if self.current_state[i][j] == '_':\n                    tie = False\n        if tie:\n            self.utility = 0\n            return True\n        return False\n\n    def MAX_VALUE(self, alpha, beta):\n        end = self.is_terminal()\n        if end:\n            return self.utility, 0, 0\n        v = -float('inf')\n        best_x = None\n        best_y = None\n        visited_states = 0\n        for j in range(self.m):\n            for i in range(self.n):\n                if self.current_state[j][i] == '_':\n                    visited_states += 1\n                    self.current_state[j][i] = 'X'\n                    minv, minx, miny = self.MIN_VALUE(alpha, beta)\n                    if v < minv:\n                        v = minv\n                        best_x = j\n                        best_y = i\n                    self.current_state[j][i] = '_'\n                    if v >= beta:\n                        return (v, best_x, best_y)\n                    if v > alpha:\n                        alpha = v\n        self.visited_states = self.visited_states + visited_states\n        return v, best_x, best_y\n\n    def MIN_VALUE(self,alpha, beta):\n        end = self.is_terminal()\n        if end:\n            return self.utility, 0, 0\n        v = float('inf')\n        best_x = None\n        best_y = None\n        visited_states = 0\n        for j in range(self.m):\n            for i in range(self.n):\n                if self.current_state[j][i] == '_':\n                    visited_states += 1\n                    self.current_state[j][i] = 'o'\n                    maxv, maxx, maxy = self.MAX_VALUE(alpha, beta)\n                    if v > maxv:\n                        v = maxv\n                        best_x = j\n                        best_y = i\n                    self.current_state[j][i] = '_'\n                    if v <= alpha:\n                        return (v, best_x, best_y)\n                    if v < beta:\n                        beta = v\n        self.visited_states = self.visited_states + visited_states\n        return v, best_x, best_y\n\n# main function\ndef main_solution(m, n, k, current_state):\n    # Convert the JSON serializable input to the original input variables\n    current_state = np.array(current_state, dtype=object)\n    \n    # Initialize the game\n    game = Game(m, n, k)\n    game.current_state = current_state\n    \n    # Determine the best move for the current state\n    if game.turn == 'X':\n        v, v_x, v_y = game.MAX_VALUE(-float('inf'), float('inf'))\n    else:\n        v, v_x, v_y = game.MIN_VALUE(-float('inf'), float('inf'))\n    \n    # Convert the output to JSON serializable format\n    return {\n        \"utility\": v,\n        \"best_move\": (v_x, v_y)\n    }", "funcname": "main_solution", "ios": [{"input": {"m": 3, "n": 3, "k": 3, "current_state": [["_", "_", "_"], ["_", "_", "_"], ["o", "_", "o"]]}, "output": {"utility": -1, "best_move": [0, 0]}}, {"input": {"m": 3, "n": 4, "k": 3, "current_state": [["o", "X", "_", "X"], ["_", "_", "_", "_"], ["X", "_", "X", "o"]]}, "output": {"utility": 1, "best_move": [0, 2]}}, {"input": {"m": 3, "n": 4, "k": 3, "current_state": [["_", "o", "o", "_"], ["X", "o", "_", "_"], ["X", "_", "o", "o"]]}, "output": {"utility": 1, "best_move": [0, 0]}}, {"input": {"m": 3, "n": 4, "k": 3, "current_state": [["X", "_", "_", "_"], ["X", "_", "o", "X"], ["X", "o", "o", "X"]]}, "output": {"utility": 1, "best_move": [0, 0]}}, {"input": {"m": 3, "n": 4, "k": 3, "current_state": [["o", "_", "_", "o"], ["o", "_", "_", "o"], ["_", "X", "X", "_"]]}, "output": {"utility": 1, "best_move": [2, 0]}}, {"input": {"m": 3, "n": 4, "k": 3, "current_state": [["X", "_", "_", "o"], ["_", "_", "X", "_"], ["_", "X", "X", "_"]]}, "output": {"utility": 1, "best_move": [0, 1]}}, {"input": {"m": 3, "n": 4, "k": 3, "current_state": [["o", "_", "_", "_"], ["o", "X", "_", "o"], ["X", "_", "o", "X"]]}, "output": {"utility": 1, "best_move": [0, 1]}}, {"input": {"m": 3, "n": 3, "k": 3, "current_state": [["_", "o", "_"], ["o", "_", "_"], ["_", "_", "X"]]}, "output": {"utility": 1, "best_move": [0, 2]}}, {"input": {"m": 3, "n": 4, "k": 3, "current_state": [["_", "o", "o", "X"], ["_", "X", "X", "X"], ["_", "_", "_", "o"]]}, "output": {"utility": 1, "best_move": [0, 0]}}, {"input": {"m": 3, "n": 3, "k": 3, "current_state": [["_", "_", "o"], ["_", "o", "o"], ["X", "o", "X"]]}, "output": {"utility": -1, "best_move": [0, 0]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "candmt/Adversarial_Search_mnk_Games", "path": "/mnk_game.py", "msgidx": 3791}}
{"problem_description": "Given a logical function F defined as (w \u2227 y) \u2228 ((x \u2192 w) \u2261 (y \u2192 z)), determine the output of the function for specific boolean values of x, y, z, and w. What is the result of the function F when x, y, z, and w are given specific boolean values?", "io_requirements": "Input:\n  `x` (int): An integer (0 or 1) representing the boolean value of x.\n  `y` (int): An integer (0 or 1) representing the boolean value of y.\n  `z` (int): An integer (0 or 1) representing the boolean value of z.\n  `w` (int): An integer (0 or 1) representing the boolean value of w.\n\nOutput:\n  `return` (int): An integer (0 or 1) representing the boolean result of the logical function F.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n\n# main function\ndef main_solution(x, y, z, w):\n    # Convert inputs to boolean values\n    x = bool(x)\n    y = bool(y)\n    z = bool(z)\n    w = bool(w)\n    \n    # Calculate the logical function F\n    F = (w and y) or ((not x or w) == (not y or z))\n    \n    # Return the result as an integer (0 or 1)\n    return int(F)", "funcname": "main_solution", "ios": [{"input": {"x": 0, "y": 1, "z": 1, "w": 0}, "output": 1}, {"input": {"x": 0, "y": 0, "z": 1, "w": 0}, "output": 1}, {"input": {"x": 0, "y": 0, "z": 0, "w": 1}, "output": 1}, {"input": {"x": 0, "y": 0, "z": 0, "w": 0}, "output": 1}, {"input": {"x": 0, "y": 1, "z": 1, "w": 1}, "output": 1}, {"input": {"x": 0, "y": 1, "z": 0, "w": 1}, "output": 1}, {"input": {"x": 1, "y": 1, "z": 0, "w": 0}, "output": 1}, {"input": {"x": 1, "y": 1, "z": 0, "w": 1}, "output": 1}, {"input": {"x": 1, "y": 1, "z": 1, "w": 0}, "output": 0}, {"input": {"x": 0, "y": 1, "z": 0, "w": 0}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "htmlprogrammist/kege-2021", "path": "/tasks_2/homework/task_2_4.py", "msgidx": 4185}}
{"problem_description": "In a building with a certain number of floors, you have a limited number of balls to determine the highest floor from which a ball can be dropped without breaking. Given the number of balls, the total number of floors, and the specific floor number at which the ball will break, what is the highest floor from which the ball can be safely dropped?", "io_requirements": "Input:\n  `n_balls` (int): The number of balls available for the simulation.\n  `n_floors` (int): The number of floors in the building.\n  `hardness` (int): The floor number at which the ball will break.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"hardness\" whose value is an integer representing the highest floor number at which the ball does not break.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef min_radix(digits, largest):\n    # Calculate radix that can represent the largest number with given digits.\n    # radix ^ digits > largest\n    radix = math.ceil(largest**(1/digits))\n    return radix\n\ndef encode(base, number):\n    \"\"\"Result is least significant digit first.\n    That way, it is easier to access via index.\n    \"\"\"\n    result = []\n    while True:\n        result.append(number % base)\n        number = number // base\n        if number == 0:\n            break\n    return tuple(result)\n\ndef decode(base, digits):\n    \"\"\"Least significant digit first\n    >>> decode(3, (0, 1, 1))\n    12\n    \"\"\"\n    result = 0\n    for position, digit in enumerate(digits):\n        significance = base**position\n        result += significance*digit\n    return result\n\n# main function\ndef main_solution(n_balls, n_floors, hardness):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  radix = min_radix(n_balls, n_floors)\n  floor = [0] * n_balls\n\n  for index in reversed(range(n_balls)):\n      for digit in range(1, radix):\n          prev_floor = floor.copy()\n\n          floor[index] = digit\n          floor_number = decode(radix, floor)\n\n          max_floor_exceeded = floor_number > n_floors\n          if max_floor_exceeded:\n              floor = prev_floor\n              break\n\n          ball_broke = hardness < floor_number\n          if ball_broke:\n              floor = prev_floor\n              break\n\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return {\"hardness\": decode(radix, floor)}", "funcname": "main_solution", "ios": [{"input": {"n_balls": 2, "n_floors": 86, "hardness": 64}, "output": {"hardness": 64}}, {"input": {"n_balls": 3, "n_floors": 94, "hardness": 79}, "output": {"hardness": 79}}, {"input": {"n_balls": 9, "n_floors": 72, "hardness": 11}, "output": {"hardness": 11}}, {"input": {"n_balls": 7, "n_floors": 29, "hardness": 22}, "output": {"hardness": 22}}, {"input": {"n_balls": 7, "n_floors": 14, "hardness": 8}, "output": {"hardness": 8}}, {"input": {"n_balls": 2, "n_floors": 10, "hardness": 1}, "output": {"hardness": 1}}, {"input": {"n_balls": 2, "n_floors": 87, "hardness": 38}, "output": {"hardness": 38}}, {"input": {"n_balls": 3, "n_floors": 99, "hardness": 20}, "output": {"hardness": 20}}, {"input": {"n_balls": 7, "n_floors": 36, "hardness": 2}, "output": {"hardness": 2}}, {"input": {"n_balls": 8, "n_floors": 82, "hardness": 73}, "output": {"hardness": 73}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Susensio/aim.101p", "path": "/puzzle-4-please-do-break-the-crystal/sandbox4.py", "msgidx": 4097}}
{"problem_description": "Given a string of characters, what are all the possible unique permutations of the string, sorted in lexicographical order?", "io_requirements": "Input:\n  `input_string` (str): A string of characters for which all possible unique permutations need to be generated. The string may contain duplicate characters.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string, sorted lexicographically. Each permutation is represented as a string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution_38(object):\n    def __init__(self):\n        self.result = []\n\n    def permutation(self, strings):\n        if not strings:\n            return []\n        str_ls = list(strings)\n\n        self.permute(str_ls, 0)\n\n        # \u7531\u4e8e\u8f93\u5165\u5b57\u7b26\u4e2d\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u7684\u5b57\u7b26\uff0c\u6240\u4ee5\u6700\u7ec8\u6392\u5e8f\u4e2d\u6709\u91cd\u590d\u7684\u5e8f\u5217\uff0c\u6545\u6700\u7ec8\u7ed3\u679c\u5e94\u8be5\u53bb\u91cd\u3001\u6392\u5e8f\n        res = list(set(self.result))\n        res.sort()\n        return res\n\n    def permute(self, string, begin):\n        # \u6700\u540e\u4e00\u4e2a\u5b57\u7b26\n        if begin == len(string):\n            self.result.append(''.join(string))\n        else:\n            for i in range(begin, len(string)):\n                # \u5c06\u9996\u5b57\u7b26\u4e0e\u4f59\u4e0b\u5b57\u7b26\u8fdb\u884c\u4ea4\u6362\n                string[i], string[begin] = string[begin], string[i]\n                # \u56fa\u5b9a\u9996\u4f4d\uff0c\u9012\u5f52\u4f59\u4e0b\u90e8\u5206\n                self.permute(string, begin+1)\n                # \u5c06\u4ea4\u6362\u7684\u5b57\u7b26\u6362\u56de\u6765\n                string[begin], string[i] = string[i], string[begin]\n\n# main function\ndef main_solution(input_string):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution_38()\n  result = solution.permutation(input_string)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "mtl"}, "output": ["lmt", "ltm", "mlt", "mtl", "tlm", "tml"]}, {"input": {"input_string": "jkg"}, "output": ["gjk", "gkj", "jgk", "jkg", "kgj", "kjg"]}, {"input": {"input_string": "kfoo"}, "output": ["fkoo", "foko", "fook", "kfoo", "kofo", "koof", "ofko", "ofok", "okfo", "okof", "oofk", "ookf"]}, {"input": {"input_string": "dax"}, "output": ["adx", "axd", "dax", "dxa", "xad", "xda"]}, {"input": {"input_string": "lpt"}, "output": ["lpt", "ltp", "plt", "ptl", "tlp", "tpl"]}, {"input": {"input_string": "sccj"}, "output": ["ccjs", "ccsj", "cjcs", "cjsc", "cscj", "csjc", "jccs", "jcsc", "jscc", "sccj", "scjc", "sjcc"]}, {"input": {"input_string": "ynq"}, "output": ["nqy", "nyq", "qny", "qyn", "ynq", "yqn"]}, {"input": {"input_string": "bfm"}, "output": ["bfm", "bmf", "fbm", "fmb", "mbf", "mfb"]}, {"input": {"input_string": "zyii"}, "output": ["iiyz", "iizy", "iyiz", "iyzi", "iziy", "izyi", "yiiz", "yizi", "yzii", "ziiy", "ziyi", "zyii"]}, {"input": {"input_string": "xst"}, "output": ["stx", "sxt", "tsx", "txs", "xst", "xts"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "TechInTech/algorithmsAnddataStructure", "path": "/stringOperation/interview38.py", "msgidx": 4247}}
{"problem_description": "Given a string composed of lowercase alphabetic characters, what are all the unique permutations of this string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should be composed of lowercase alphabetic characters and should not exceed a reasonable length (e.g., less than 10 characters).\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string. The list will contain all possible permutations of the input string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef perm_gen_lex(a):\n    \"\"\"creates a list of all the permutations of a given string\"\"\"\n    new = []\n    new_str = ''\n    for i in range(len(a)):  # gets the index of each letter in the word\n        new_str = a[:i] + a[i + 1:]  # gets rid of indexed letter in the word\n        Nlist = perm_gen_lex(new_str)  # perm gens this new word\n        if len(a) == 1 and len(new_str) == 0:  # when there is only a one letter word it adds space so that the for loop will detect it\n            Nlist.append(\" \")\n        for j in range(len(Nlist)):\n            new.append(a[i] + Nlist[j])  # creates list of words\n    for i in range(len(new)):  # removes spaces added\n        new[i] = new[i].strip()\n    return new\n\n# main function\ndef main_solution(input_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    permutations = perm_gen_lex(input_string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "d"}, "output": ["d"]}, {"input": {"input_string": "xkw"}, "output": ["xkw", "xwk", "kxw", "kwx", "wxk", "wkx"]}, {"input": {"input_string": "zbi"}, "output": ["zbi", "zib", "bzi", "biz", "izb", "ibz"]}, {"input": {"input_string": "rz"}, "output": ["rz", "zr"]}, {"input": {"input_string": "qqv"}, "output": ["qqv", "qvq", "qqv", "qvq", "vqq", "vqq"]}, {"input": {"input_string": "bo"}, "output": ["bo", "ob"]}, {"input": {"input_string": "xr"}, "output": ["xr", "rx"]}, {"input": {"input_string": "hjp"}, "output": ["hjp", "hpj", "jhp", "jph", "phj", "pjh"]}, {"input": {"input_string": "be"}, "output": ["be", "eb"]}, {"input": {"input_string": "ds"}, "output": ["ds", "sd"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cpe202spring2019/lab1-bretthickman", "path": "/perm_lex.py", "msgidx": 3923}}
{"problem_description": "Given a number `n`, what are all the possible ways to arrange the numbers from 1 to `n` in a sequence? Each arrangement should be represented as a space-separated string of integers.", "io_requirements": "Input:\n  `n` (int): An integer representing the number of elements to permute. It should be a positive integer.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a permutation of the numbers from 1 to `n`. Each permutation is formatted as a space-separated string of integers.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(n):\n    # Convert the input to a list of integers from 1 to n\n    arrange = list(range(1, n + 1))\n    \n    # Generate all permutations of the list\n    permutations = list(itertools.permutations(arrange))\n    \n    # Convert each permutation tuple to a space-separated string\n    result = [' '.join(map(str, perm)) for perm in permutations]\n    \n    # Return the list of permutations as strings\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["1"]}, {"input": {"n": 2}, "output": ["1 2", "2 1"]}, {"input": {"n": 3}, "output": ["1 2 3", "1 3 2", "2 1 3", "2 3 1", "3 1 2", "3 2 1"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cyberskeleton/sandbox", "path": "/2019-12-01hw1.py", "msgidx": 4462}}
{"problem_description": "Given an encoded integer, which represents a sequence of strictly positive integers, how can you decode it back to the original sequence of integers?", "io_requirements": "Input:\n  `encoded_integer` (int): A strictly positive integer that represents the encoded sequence of integers.\n\nOutput:\n  `return` (list of int): A list of strictly positive integers that were decoded from the input `encoded_integer`. If the input does not encode a valid sequence, `None` is returned.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(encoded_integer):\n    # Convert the encoded integer to its binary representation\n    binary_string = bin(encoded_integer)[2:]\n    \n    # Define the pattern to match the encoded segments\n    pattern = \"(00|11)*\"\n    re.compile(pattern)\n    \n    # Find all matches of the pattern in the binary string\n    iter = re.finditer(pattern, binary_string)\n    indices = [m.start() for m in iter]\n    \n    # Check if the indices are valid for decoding\n    if len(indices) % 2 != 0:\n        return None\n    \n    # Extract the encoded segments\n    list_of_num = []\n    for i in range(0, len(indices), 2):\n        sub = binary_string[indices[i]:indices[i+1]]\n        list_of_num.append(sub)\n    \n    # Decode each segment\n    decoded_list = []\n    for num in list_of_num:\n        length_num = len(num)\n        sub = \"\"\n        for k in range(0, length_num, 2):\n            sub += num[k]\n        decoded_list.append(int(sub, 2))\n    \n    return decoded_list", "funcname": "main_solution", "ios": [{"input": {"encoded_integer": 1020}, "output": [30]}, {"input": {"encoded_integer": 3678739282603408947}, "output": [41, 70, 33, 94, 5]}, {"input": {"encoded_integer": 780}, "output": [18]}, {"input": {"encoded_integer": 36023508947841219}, "output": [63, 82, 42, 73]}, {"input": {"encoded_integer": 1150530681200082684}, "output": [15, 98, 100, 55, 14]}, {"input": {"encoded_integer": 837627644991}, "output": [36, 94, 39]}, {"input": {"encoded_integer": 415741479987}, "output": [4, 20, 14, 37]}, {"input": {"encoded_integer": 106982400}, "output": [81, 32]}, {"input": {"encoded_integer": 2138340568609596}, "output": [26, 45, 32, 86]}, {"input": {"encoded_integer": 35098474739916}, "output": [15, 64, 54, 10]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "khaamosh/COMP-9021", "path": "/Quiz 5/quiz_5.py", "msgidx": 4209}}
{"problem_description": "In a game scenario, a player needs to make a move. Given the player's ID and the type of move they wish to make, determine if the move is valid. What is the validity status of the move?", "io_requirements": "Input:\n  `player_id` (str): A string representing the ID of the player making the move.\n  `move_type` (str): A string representing the type of move being made (e.g., \"forfeit\", \"normal\").\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"is_valid\"` whose value is a boolean indicating whether the move is valid.", "refcode": "# import necessary packages\nimport copy\nimport weakref\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass GameMove:\n    def __str__(self):\n        return \"Base GameMove object\"\n    def get_player(self):\n        return None\n    def get_move(self):\n        return None\n    def is_forfeit(self):\n        return False\n\nclass GameState:\n    def __init__(self):\n        self.controller = None\n    \n    def setController(self, controller, proxy=True):\n        if proxy:\n            self.controller = weakref.proxy(controller)\n        else:\n            self.controller = controller\n    \n    def __str__(self):\n        return \"Base game state object\"\n    \n    def repeats(self):\n        return False\n    \n    def repeated_rep(self):\n        pass\n    \n    def copy_into(self, other):\n        other.controller = self.controller\n    \n    def make_copy(self):\n        pass\n    \n    def clear(self):\n        pass\n    \n    def is_win(self, player):\n        pass\n    \n    def get_players(self):\n        pass\n    \n    def get_next_player(self):\n        pass\n    \n    def get_player_state(self, player):\n        return None\n    \n    def is_valid_move(self, move):\n        return False\n    \n    def move(self, move, clearRepeats=False):\n        pass\n    \n    def handle_cycle(self):\n        pass\n    \n    def expansions_count(self):\n        if self.controller == None:\n            return None\n        else:\n            return self.controller.expansions_count()\n    \n    def successor_moves(self):\n        if self.controller == None or self.controller.successor_generated():\n            return []\n        else:\n            return None\n    \n    def move_copy(self, move):\n        if not self.is_valid_move(move):\n            return None\n        r = self.make_copy()\n        player = r.move(move)\n        return (player, r)\n    \n    def successors(self):\n        moves = self.successor_moves()\n        if moves == None:\n            return None\n        s = map(self.move_copy, moves)\n        s = zip([x[0] for x in s], [x[1] for x in s], moves)\n        return s\n\n# main function\ndef main_solution(player_id, move_type):\n    # Create a GameState object\n    game_state = GameState()\n    \n    # Create a GameMove object\n    game_move = GameMove()\n    \n    # Set the player for the move\n    game_move.player_id = player_id\n    game_move.move_type = move_type\n    \n    # Check if the move is valid\n    is_valid = game_state.is_valid_move(game_move)\n    \n    # Return the result as a dictionary\n    return {\"is_valid\": is_valid}", "funcname": "main_solution", "ios": [{"input": {"player_id": "player_55", "move_type": "normal"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_61", "move_type": "forfeit"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_82", "move_type": "forfeit"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_42", "move_type": "forfeit"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_25", "move_type": "forfeit"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_97", "move_type": "normal"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_43", "move_type": "forfeit"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_90", "move_type": "forfeit"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_96", "move_type": "forfeit"}, "output": {"is_valid": false}}, {"input": {"player_id": "player_1", "move_type": "normal"}, "output": {"is_valid": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nazlitemur/oware", "path": "/game_state.py", "msgidx": 3961}}
{"problem_description": "Given a range of tens and unit digits, what is the denominator of the product of all fractions that can be incorrectly simplified by canceling out a common digit in the numerator and denominator, where the numerator and denominator are two-digit numbers formed by the tens and unit digits within the specified ranges?", "io_requirements": "Input:\n  `tens_range` (list of int): A list containing two integers representing the range of tens digits to be considered. The first integer is the start of the range (inclusive), and the second integer is the end of the range (inclusive).\n  `unit_range` (list of int): A list containing two integers representing the range of unit digits to be considered. The first integer is the start of the range (inclusive), and the second integer is the end of the range (inclusive).\n\nOutput:\n  `return` (int): The denominator of the product of all matching fractions found within the specified ranges, given in its lowest common terms.", "refcode": "# import necessary packages\nfrom fractions import Fraction\n\n# main function\ndef main_solution(tens_range, unit_range):\n    result = Fraction(1, 1)\n\n    def get_digit(num, pos):\n        return int(str(num)[pos])\n\n    def test_match(num, deno):\n        nonlocal result\n        new_fraction = Fraction(get_digit(num, 0), get_digit(deno, 1))\n        if new_fraction == Fraction(num, deno):\n            result *= new_fraction\n\n    def find_matching_fractions(tens_range, unit_range):\n        for tens in range(tens_range[0], tens_range[1] + 1):\n            for unit in range(unit_range[0], unit_range[1] + 1):\n                if unit == tens:\n                    continue\n                numerator = tens * 10 + unit\n                for i in range(1, 10):\n                    denominator = unit * 10 + i\n                    test_match(numerator, denominator)\n\n    find_matching_fractions(tens_range, unit_range)\n    return result.denominator", "funcname": "main_solution", "ios": [{"input": {"tens_range": [8, 8], "unit_range": [2, 3]}, "output": 1}, {"input": {"tens_range": [6, 5], "unit_range": [3, 1]}, "output": 1}, {"input": {"tens_range": [5, 6], "unit_range": [2, 9]}, "output": 1}, {"input": {"tens_range": [5, 5], "unit_range": [7, 5]}, "output": 1}, {"input": {"tens_range": [4, 4], "unit_range": [5, 3]}, "output": 1}, {"input": {"tens_range": [4, 1], "unit_range": [9, 9]}, "output": 1}, {"input": {"tens_range": [6, 3], "unit_range": [8, 8]}, "output": 1}, {"input": {"tens_range": [8, 2], "unit_range": [8, 4]}, "output": 1}, {"input": {"tens_range": [8, 1], "unit_range": [9, 8]}, "output": 1}, {"input": {"tens_range": [8, 3], "unit_range": [6, 3]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MrDeshaies/NOT-projecteuler.net", "path": "/euler_033.py", "msgidx": 4264}}
{"problem_description": "A bug is moving on the surface of a 10x10x10 cube. The bug starts at a point and moves to a series of other points on the cube's surface. The bug moves in arcs when it stays on the same face and takes the shortest path when moving between different faces. Given the number of points and their coordinates, what is the total distance the bug travels, rounded to two decimal places?", "io_requirements": "Input:\n  `N` (int): The number of points.\n  `coordinates` (list of floats): A list of coordinates where each point is represented by 3 consecutive floats (x, y, z).\n\nOutput:\n  `return` (float): The total distance traveled by the bug, rounded to 2 decimal places.", "refcode": "# import necessary packages\nfrom math import pi, sqrt\n\n# all class and function definitions in the code file, if any\ndef calculateArc(x0, y0, z0, x1, y1, z1):\n    ''' An arc that has an angle of 60\u00ba at the center.\n    Hence the radious is the same as the arc distance\n    ############################################### '''\n    r = sqrt((x1-x0)**2 + (y1-y0)**2+ (z1-z0)**2)\n\n    return pi/3*r\n\n\ndef findFace(x, y, z):\n    ''' returns a code of the face\n    \"x0\"\n    \"x10\", \"y0\",...\n    ############################################### '''\n    if x == 0:\n        return 'x0'\n    elif x == 10:\n        return 'x10'\n    elif y == 0:\n        return 'y0'\n    elif y == 10:\n        return 'y10'\n    elif z == 0:\n        return 'z0'\n    elif z == 10:\n        return 'z10'\n\n\ndef calculateDistance(x0, y0, z0, x1, y1, z1):\n    ''' When the bug needs to move in the same face it does an arc.\n    When it needs to go to a different face, it goes the shortest path.\n    \n    ############################################### '''\n    face0 = findFace(x0, y0, z0)\n    face1 = findFace(x1, y1, z1)\n    \n    if face0 == face1:\n        # in the same face!\n        return calculateArc(x0, y0, z0, x1, y1, z1)\n\n    # else: points are in different faces!\n\n    # are in opposite faces???\n    if (face0 == 'x0' and face1=='x10') or (face0 == 'x10' and face1=='x0'):\n        # in opposite faces of the x plane, goes trhoguh the z up plane\n        return sqrt((y1-y0)**2 + (10 - z1 + 10 - z0 + 10)**2)\n\n    if (face0 == 'y0' and face1=='y10') or (face0 == 'y10' and face1=='y0'):\n        # in opposite faces of the y plane, goes trhoguh the z up plane\n        return sqrt((x1-x0)**2 + (10 - z1 + 10 - z0 + 10)**2)\n\n    # else: points are in adjacent faces!\n    if (face0 == 'x0' and face1=='y0') or (face1 == 'x0' and face0=='y0'):\n        # ya q un x y un y son cero tncs si vale\n        return sqrt((x1 + x0 + y1 + y0)**2 + (z1 - z0)**2)\n\n    if (face0 == 'x0' and face1=='y10') or (face1 == 'x0' and face0=='y10'):\n        # ya q 1 y is 10 and 1 x is cero\n        return sqrt((x1 + x0 + abs(y1 - y0))**2 + (z1 - z0)**2)\n\n    if (face0 == 'x0' and face1=='z10') or (face1 == 'x0' and face0=='z10'):\n        return sqrt((x1 + x0 + abs(z1 - z0))**2 + (y1 - y0)**2)\n\n    if (face0 == 'x10' and face1=='y0') or (face1 == 'x10' and face0=='y0'):\n        return sqrt((y1 + y0 + abs(x1 - x0))**2 + (z1 - z0)**2)\n        \n    if (face0 == 'x10' and face1=='y10') or (face1 == 'x10' and face0=='y10'):\n        return sqrt((abs(y1 - y0) + abs(x1 - x0))**2 + (z1 - z0)**2)\n        \n    if (face0 == 'x10' and face1=='z10') or (face1 == 'x10' and face0=='z10'):\n        return sqrt((abs(x1 - x0) + abs(z1 - z0))**2 + (y1 - y0)**2)\n\n# main function\ndef main_solution(N, coordinates):\n    '''\n    N: int, number of points\n    coordinates: list of floats, each point is represented by 3 consecutive floats (x, y, z)\n    '''\n    dist = 0\n    x0, y0, z0 = coordinates[0:3]\n    for i in range(1, N):\n        x, y, z = coordinates[i*3:(i + 1)*3]\n        dist += round(calculateDistance(x0, y0, z0, x, y, z), 2)\n        x0, y0, z0 = x, y, z\n    \n    return dist", "funcname": "main_solution", "ios": [{"input": {"N": 2, "coordinates": [8.613678990361667, 1.3276398376123333, 7.583206608668334, 0.49841753435363456, 9.5461381344143, 6.504798401121539]}, "output": 12.15}, {"input": {"N": 4, "coordinates": [1.8235090752437666, 6.746427002751007, 1.0122269416268814, 4.9969312567886695, 2.1272575210064506, 2.4613865082198636, 7.409706890202321, 9.403422255787868, 1.0643116296749622, 7.614734834653346, 7.836420769357913, 5.994530670221357]}, "output": 19.64}, {"input": {"N": 5, "coordinates": [1.3659382573157253, 5.838163292142504, 0.6610910022887218, 0.5533963104444706, 0.2199365553062005, 9.862635788061361, 7.791983160180846, 6.801262995388726, 8.562062078153328, 0.9473020832440016, 0.6268899330551492, 0.8273783167669024, 1.3362111568148027, 7.505054717905853, 7.176061789914357]}, "output": 44.07}, {"input": {"N": 6, "coordinates": [5.313635144585951, 0.34369464868676425, 0.4508547476804414, 6.176110643355023, 8.458671684674506, 3.4719495574458383, 0.530293067588683, 8.132825629403301, 8.241136754508119, 4.109450525905787, 9.057528540734728, 6.2006635430426895, 1.9561955345841908, 3.6311006984922054, 3.792318518436004, 3.7854786266472926, 1.0971063609324605, 8.061143903574473]}, "output": 33.43}, {"input": {"N": 4, "coordinates": [8.363256356901523, 7.577228184060692, 1.0871466564237353, 9.344272085924395, 4.773876732271639, 3.7800004194244563, 3.9985021652274124, 6.933599626072283, 9.289609145282945, 6.205684381673644, 2.1324688151137448, 5.643094424667886]}, "output": 19.27}, {"input": {"N": 4, "coordinates": [0.31211119108851215, 4.330259672526061, 9.068946867201008, 3.1054603735874475, 3.3567020892291466, 9.7243988168442, 9.3616233297686, 6.380963237757146, 4.421060886503369, 6.418334186769467, 9.684097701298121, 2.1697300031438216]}, "output": 17.52}, {"input": {"N": 2, "coordinates": [5.298728054525026, 6.4967815027241205, 8.020959391745905, 1.226514869132973, 7.893099302508995, 8.074347318346437]}, "output": 4.51}, {"input": {"N": 3, "coordinates": [9.120303317590448, 4.695844853422836, 4.968845932521548, 7.0544991467740195, 6.178320930070866, 1.7682990231473228, 8.146559005994744, 5.828414898876152, 3.2692856286248917]}, "output": 6.26}, {"input": {"N": 4, "coordinates": [8.230503988001562, 6.372379839126029, 4.800775630916726, 0.44622749483753776, 1.7203661925397973, 7.359299585282336, 5.076302688255286, 4.109793163935067, 4.135294073153779, 2.8036788962008274, 4.052569617308585, 3.0517722162875662]}, "output": 18.93}, {"input": {"N": 5, "coordinates": [6.757026749365227, 6.654117459633038, 5.065786405165532, 3.18163039174274, 5.878308522425916, 3.180938440163843, 7.071983075721343, 1.7370571748401753, 0.17837014818212538, 4.612934092523241, 1.8256317748951023, 1.8017732172890566, 0.5275258689313289, 1.1029903332319102, 2.954247972984585]}, "output": 18.64}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ztjona/codevita_sample_questions", "path": "/(A) On A Cube/walkingOnCube_v0.py", "msgidx": 3358}}
{"problem_description": "In a group of people, each person's age is 2 years more than the person directly before them. The first person is known to be 10 years old. What is the age of the person at a given position in the sequence?", "io_requirements": "Input:\n  `index` (int): The position of the person in the sequence (e.g., 1 for the first person, 2 for the second person, etc.).\n\nOutput:\n  `return` (int): The age of the person at the specified position in the sequence.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef CalcAge(index):\n    if index <= 1:\n        return 10\n    return CalcAge(index - 1) + 2\n\n# main function\ndef main_solution(index):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    age = CalcAge(index)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return age", "funcname": "main_solution", "ios": [{"input": {"index": 8}, "output": 24}, {"input": {"index": 1}, "output": 10}, {"input": {"index": 4}, "output": 16}, {"input": {"index": 2}, "output": 12}, {"input": {"index": 7}, "output": 22}, {"input": {"index": 9}, "output": 26}, {"input": {"index": 6}, "output": 20}, {"input": {"index": 5}, "output": 18}, {"input": {"index": 10}, "output": 28}, {"input": {"index": 3}, "output": 14}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "YellowTulipShow/PythonScripts", "path": "/case/practice_questions/collect.023.py", "msgidx": 4268}}
{"problem_description": "Given a binary string with wildcards represented by '?', how can you generate all possible binary strings by replacing each wildcard with either '0' or '1'?", "io_requirements": "Input:\n  `input_string` (str): A string containing '0', '1', and '?' characters. The '?' characters represent wildcards that can be either '0' or '1'.\n\nOutput:\n  `return` (list of str): A list of all possible binary strings that can be formed by replacing each '?' in the input string with either '0' or '1'.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n  # Convert the input string to a list for easier manipulation\n  input_list = list(input_string)\n  \n  # Find all positions of '?' in the input string\n  wildcard_positions = [i for i, char in enumerate(input_list) if char == '?']\n  \n  # Generate all possible combinations of '0' and '1' for the wildcards\n  combinations = list(itertools.product(['0', '1'], repeat=len(wildcard_positions)))\n  \n  # List to store all possible binary strings\n  binary_strings = []\n  \n  # Replace '?' with each combination of '0' and '1'\n  for combination in combinations:\n    for pos, value in zip(wildcard_positions, combination):\n      input_list[pos] = value\n    binary_strings.append(''.join(input_list))\n  \n  # Return the list of all possible binary strings\n  return binary_strings", "funcname": "main_solution", "ios": [{"input": {"input_string": "0?0110?0"}, "output": ["00011000", "00011010", "01011000", "01011010"]}, {"input": {"input_string": "100?00?"}, "output": ["1000000", "1000001", "1001000", "1001001"]}, {"input": {"input_string": "0?000"}, "output": ["00000", "01000"]}, {"input": {"input_string": "111001?00"}, "output": ["111001000", "111001100"]}, {"input": {"input_string": "1001110"}, "output": ["1001110"]}, {"input": {"input_string": "?101??"}, "output": ["010100", "010101", "010110", "010111", "110100", "110101", "110110", "110111"]}, {"input": {"input_string": "?00100?"}, "output": ["0001000", "0001001", "1001000", "1001001"]}, {"input": {"input_string": "??000"}, "output": ["00000", "01000", "10000", "11000"]}, {"input": {"input_string": "10100?0?"}, "output": ["10100000", "10100001", "10100100", "10100101"]}, {"input": {"input_string": "11?11?010"}, "output": ["110110010", "110111010", "111110010", "111111010"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "at1as/interview_prep", "path": "/other_problems/binary_wildcard.py", "msgidx": 4246}}
{"problem_description": "In a multi-story apartment building, five notable individuals\u2014Hopper, Kay, Liskov, Perlis, and Ritchie\u2014each reside on a different floor. Given the constraints that Hopper does not live on the top floor, Kay does not live on the bottom floor, Liskov does not live on either the top or the bottom floor, Perlis lives on a higher floor than Kay, Ritchie does not live on a floor adjacent to Liskov's, and Liskov does not live on a floor adjacent to Kay's, on which floors do Hopper, Kay, Liskov, Perlis, and Ritchie live?", "io_requirements": "Input:\n  `top_floor` (int): The highest floor number in the building.\n  `bottom_floor` (int): The lowest floor number in the building.\n\nOutput:\n  `return` (dict): A dictionary with keys \"Hopper\", \"Kay\", \"Liskov\", \"Perlis\", and \"Ritchie\", each containing the floor number where the respective person lives.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(top_floor, bottom_floor):\n    # Convert JSON serializable inputs to original input variables\n    floors = [bottom_floor, bottom_floor + 1, bottom_floor + 2, bottom_floor + 3, top_floor]\n    \n    for hopper, kay, liskov, perlis, ritchie in list(itertools.permutations(floors)):\n        if hopper == top_floor:\n            continue\n        if kay == bottom_floor:\n            continue\n        if liskov == bottom_floor or liskov == top_floor:\n            continue\n        if not lives_higher(perlis, kay):\n            continue\n        if live_adjacent(ritchie, liskov):\n            continue\n        if live_adjacent(liskov, kay):\n            continue\n\n        # Convert output to JSON serializable format\n        return {\n            \"Hopper\": hopper,\n            \"Kay\": kay,\n            \"Liskov\": liskov,\n            \"Perlis\": perlis,\n            \"Ritchie\": ritchie\n        }\n\n# code to represent the relationships\ndef lives_higher(person1, person2):\n    \"\"\" returns True if person1 lives in a higher floor than person2\"\"\"\n    return person1 > person2\n\ndef lives_lower(person1, person2):\n    \"\"\" returns True if person1 lives in a lower floor than person2\"\"\"\n    return person1 < person2\n\ndef live_adjacent(person1, person2):\n    \"\"\" returns True if person1 and person2 live in adjacent floors\"\"\"\n    return abs(person1 - person2) == 1", "funcname": "main_solution", "ios": [{"input": {"top_floor": 9, "bottom_floor": 4}, "output": {"Hopper": 4, "Kay": 5, "Liskov": 7, "Perlis": 6, "Ritchie": 9}}, {"input": {"top_floor": 7, "bottom_floor": 3}, "output": {"Hopper": 5, "Kay": 4, "Liskov": 6, "Perlis": 7, "Ritchie": 3}}, {"input": {"top_floor": 8, "bottom_floor": 4}, "output": {"Hopper": 6, "Kay": 5, "Liskov": 7, "Perlis": 8, "Ritchie": 4}}, {"input": {"top_floor": 8, "bottom_floor": 1}, "output": {"Hopper": 1, "Kay": 2, "Liskov": 4, "Perlis": 3, "Ritchie": 8}}, {"input": {"top_floor": 7, "bottom_floor": 2}, "output": {"Hopper": 2, "Kay": 3, "Liskov": 5, "Perlis": 4, "Ritchie": 7}}, {"input": {"top_floor": 10, "bottom_floor": 4}, "output": {"Hopper": 4, "Kay": 5, "Liskov": 7, "Perlis": 6, "Ritchie": 10}}, {"input": {"top_floor": 5, "bottom_floor": 1}, "output": {"Hopper": 3, "Kay": 2, "Liskov": 4, "Perlis": 5, "Ritchie": 1}}, {"input": {"top_floor": 8, "bottom_floor": 3}, "output": {"Hopper": 3, "Kay": 4, "Liskov": 6, "Perlis": 5, "Ritchie": 8}}, {"input": {"top_floor": 9, "bottom_floor": 2}, "output": {"Hopper": 2, "Kay": 3, "Liskov": 5, "Perlis": 4, "Ritchie": 9}}, {"input": {"top_floor": 6, "bottom_floor": 2}, "output": {"Hopper": 4, "Kay": 3, "Liskov": 5, "Perlis": 6, "Ritchie": 2}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ajdt/udacity_cs212", "path": "/unit2/floor_puzzle.py", "msgidx": 4176}}
{"problem_description": "Given a list of unique integers, how many permutations of these integers satisfy the equation `number[0] + 2 * number[1] / number[2] + number[3] + 12 * number[4] == 43` when evaluated using multiprocessing?", "io_requirements": "Input:\n  `number_list` (list of int): A list of integers to be permuted.\n  `process_count` (int): The number of processes to use for multiprocessing.\n\nOutput:\n  `return` (list of tuple): A list of tuples representing the valid permutations that satisfy the equation.", "refcode": "# import necessary packages\nfrom multiprocessing import Process, Queue\nimport itertools\n\n# main function\ndef main_solution(number_list, process_count):\n    \"\"\"\n    Given a list of numbers and the number of processes, calculate the number of permutations \n    and solve for all possible solutions using multiprocessing.\n\n    Input:\n        number_list (list of int): A list of integers to be permuted.\n        process_count (int): The number of processes to use for multiprocessing.\n\n    Output:\n        return (list of tuple): A list of tuples representing the valid permutations that satisfy the equation.\n    \"\"\"\n    # Convert number_list to a sorted list of strings for permutation\n    permutation_number_as_list = sorted(map(str, number_list))\n\n    # Generate all permutations of the number list\n    all_permutations = list(itertools.permutations(permutation_number_as_list))\n\n    # Divide the permutation list into chunks for multiprocessing\n    divided_permutations = dividePermutationList(all_permutations, process_count)\n\n    # Create a queue to collect results from processes\n    perm_solution_queue = Queue()\n\n    # Create and start processes\n    processes = []\n    for perm_chunk in divided_permutations:\n        process = solutionsWithPermutations(perm_solution_queue, perm_chunk)\n        process.start()\n        processes.append(process)\n\n    # Collect results from processes\n    results = []\n    for process in processes:\n        process.join()\n        while not perm_solution_queue.empty():\n            results.append(perm_solution_queue.get())\n\n    # Convert results to JSON serializable format\n    json_serializable_results = [tuple(map(int, item)) for item in results]\n\n    return json_serializable_results\n\n# Helper functions from the original code file\ndef dividePermutationList(permutation_list, process_count):\n    \"\"\"\n    Given a list of permutations as tuples and a number of processes, divide the \n    permutation list into even (as even as possible) chunks of sub-lists in one list\n\n    Input:  \n        permutation_list [(<int>)] <- list of tuples of integers\n        process_count <int>\n    Output: \n        list of sub-lists [sub-list [<int>]]\n    \"\"\"\n    step = max(1, len(permutation_list) // process_count)\n    process_count = min(process_count, len(permutation_list))\n    output_list = []\n    for number in range(process_count):\n        f_index = number * step\n        l_index = (number + 1) * step if number < process_count - 1 else len(permutation_list)\n        output_list.append(permutation_list[f_index:l_index])\n    return output_list\n\nclass solutionsWithPermutations(Process):\n    def __init__(self, perm_solution_queue, perm_list_as_tuples):\n        Process.__init__(self)\n        self.perm_solution_queue = perm_solution_queue\n        self.perm_set_of_tuples_string = set(perm_list_as_tuples)\n        self.solution_set = set()\n\n    def run(self):\n        perm_set_tuples_int = set()\n        for string_tuple in self.perm_set_of_tuples_string:\n            perm_set_tuples_int.add(tuple(int(d) for d in string_tuple))\n\n        for number in perm_set_tuples_int:\n            if (number[0] + 2 * number[1] / number[2] + number[3] + 12 * number[4] == 43 and (number not in self.solution_set)):\n                self.solution_set.add(number)\n\n        for tup in self.solution_set:\n            self.perm_solution_queue.put(tup)", "funcname": "main_solution", "ios": [{"input": {"number_list": [6, 5, 3, 4, 2], "process_count": 5}, "output": []}, {"input": {"number_list": [7, 8, 6, 2, 3], "process_count": 1}, "output": [[8, 6, 3, 7, 2], [7, 6, 3, 8, 2]]}, {"input": {"number_list": [9, 2, 5, 1, 8], "process_count": 3}, "output": []}, {"input": {"number_list": [3, 2, 5, 9, 7], "process_count": 1}, "output": []}, {"input": {"number_list": [8, 6, 9, 1, 5], "process_count": 1}, "output": []}, {"input": {"number_list": [3, 4, 5, 2, 9], "process_count": 2}, "output": []}, {"input": {"number_list": [7, 5, 4, 9, 3], "process_count": 2}, "output": []}, {"input": {"number_list": [8, 4, 2, 1, 3], "process_count": 1}, "output": [[8, 4, 1, 3, 2], [1, 8, 4, 2, 3], [2, 8, 4, 1, 3], [3, 4, 1, 8, 2]]}, {"input": {"number_list": [4, 5, 6, 9, 2], "process_count": 3}, "output": []}, {"input": {"number_list": [8, 2, 5, 3, 1], "process_count": 1}, "output": [[8, 3, 1, 5, 2], [5, 3, 1, 8, 2]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "IronMan61693/MultiprocessingPermutationPython", "path": "/processing_permutations_brute.py", "msgidx": 3875}}
{"problem_description": "A ship is navigating through a series of instructions given in a specific format. Each instruction specifies a direction (North, South, East, West) or a turn (Left, Right) or a forward movement. Given a set of navigation instructions, what is the Manhattan distance from the starting point to the final position of the ship after following all the instructions?", "io_requirements": "Input:\n  `data` (str): A string containing navigation instructions. Each line represents a single instruction where the first character is the action (N, S, E, W for movement, F for forward, L for left turn, R for right turn) and the rest of the line is the amount (integer) to move or turn.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"manhattan_distance\"` whose value is an integer representing the Manhattan distance from the starting point to the final position after following the navigation instructions.", "refcode": "# import necessary packages\nimport math\nimport cmath\n\n# all class and function definitions in the code file, if any\ncompass = {'N': 0+1j, 'S': 0-1j, 'E': 1+0j, 'W': -1+0j}\n\ndef turn(bearing, degrees):\n    r, phi = cmath.polar(bearing)\n    rads = math.radians(degrees)\n    return cmath.rect(r, phi+rads)\n\n# main function\ndef main_solution(data):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    position = 0+0j\n    waypoint = 10+1j # Relative to ship\n\n    for line in data.splitlines():\n        move, amount = line[0], int(line[1:])\n\n        if move in compass:\n            waypoint += compass[move] * amount\n        elif move == 'F':\n            position += waypoint * amount\n        elif move == 'L':\n            waypoint = turn(waypoint, amount)\n        elif move == 'R':\n            waypoint = turn(waypoint, -amount)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"manhattan_distance\": abs(position.real) + abs(position.imag)}", "funcname": "main_solution", "ios": [{"input": {"data": "E8\nN44\nW57\nN40\nW58\nF59\nW76\nE12\nN55\nS27"}, "output": {"manhattan_distance": 10738.0}}, {"input": {"data": "W19\nE12\nW92\nE80\nW82\nW50\nN22\nN63\nE48\nF68"}, "output": {"manhattan_distance": 12172.0}}, {"input": {"data": "N13\nN33\nR5\nL55\nN44\nS9\nR82\nS48\nR25\nW7"}, "output": {"manhattan_distance": 0.0}}, {"input": {"data": "L62\nR87\nR31\nS36\nN13\nR60\nS90\nE85\nE55\nW45"}, "output": {"manhattan_distance": 0.0}}, {"input": {"data": "R46\nS53\nS64\nR66\nR91\nL67\nW54\nR76\nN50\nR44"}, "output": {"manhattan_distance": 0.0}}, {"input": {"data": "E90\nR7\nE5\nW1\nR82\nW54\nE100\nW64\nL9\nF39"}, "output": {"manhattan_distance": 4160.866660314542}}, {"input": {"data": "F47\nR69\nN44\nL71\nL43\nL60\nL88\nF37\nL14\nE72"}, "output": {"manhattan_distance": 2028.8200718187336}}, {"input": {"data": "W9\nF44\nS24\nR10\nF18\nW13\nS30\nF7\nS90\nL51"}, "output": {"manhattan_distance": 858.8331707568726}}, {"input": {"data": "R60\nF59\nF83\nE38\nN21\nN63\nW26\nL9\nL69\nW100"}, "output": {"manhattan_distance": 1991.7316807112932}}, {"input": {"data": "W2\nF16\nE74\nR41\nL91\nR15\nW17\nF89\nW70\nL1"}, "output": {"manhattan_distance": 8816.988680817474}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "orions-stardom/aoc-2020", "path": "/2020/day_12.py", "msgidx": 3807}}
{"problem_description": "Given a family tree represented as a set of parent-child relationships, how many descendants does each family member have, and what is the sorted order of family members based on their number of descendants?", "io_requirements": "Input:\n  `tree_data` (str): A JSON string representing a dictionary where each key is a child and each value is its parent. The dictionary represents the tree structure.\n\nOutput:\n  `return` (dict): A dictionary where each key is an element from the tree and each value is the number of descendants that element has. The dictionary is sorted by keys.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef f(v, res, tree):\n    # \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0434\u0435\u0442\u0435\u0439\n    childs = [x for x in tree.keys() if tree[x] == v]\n    # \u043a\u043e\u043b-\u0432\u043e \u043f\u043e\u0442\u043e\u043c\u043a\u043e\u0432\n    descendantsCount = 0\n    for x in childs:\n        descendantsCount += 1 + f(x, res, tree)\n    res[v] = descendantsCount\n    return descendantsCount\n\ndef gen_res(tree):\n    result = {}\n    # \u041d\u0430\u0439\u0434\u0435\u043c \u0440\u043e\u0434\u043e\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0438\u043a\u0430\n    for x in tree.values():\n        if not x in tree:\n            gParent = x\n    # \u041d\u0430\u0439\u0434\u0435\u043c \u0432\u0441\u0435\u0445 \u0438\u0445 \u043f\u0440\u0435\u0434\u043a\u043e\u0432\n    f(gParent, result, tree)\n    return result\n\n# main function\ndef main_solution(tree_data):\n    # Convert JSON serializable input to the original input format\n    tree = json.loads(tree_data)\n    \n    # Generate the result\n    result = gen_res(tree)\n    \n    # Convert the result to JSON serializable output\n    sorted_result = {k: result[k] for k in sorted(result)}\n    \n    return sorted_result", "funcname": "main_solution", "ios": [{"input": {"tree_data": "{\"1\": \"0\", \"2\": \"1\", \"3\": \"0\", \"4\": \"1\", \"5\": \"0\", \"6\": \"4\", \"7\": \"4\"}"}, "output": {"0": 7, "1": 4, "2": 0, "3": 0, "4": 2, "5": 0, "6": 0, "7": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"1\", \"3\": \"0\", \"4\": \"3\", \"5\": \"3\", \"6\": \"1\", \"7\": \"0\", \"8\": \"0\"}"}, "output": {"0": 8, "1": 2, "2": 0, "3": 2, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"0\", \"3\": \"0\", \"4\": \"2\", \"5\": \"0\", \"6\": \"2\", \"7\": \"1\", \"8\": \"7\"}"}, "output": {"0": 8, "1": 2, "2": 2, "3": 0, "4": 0, "5": 0, "6": 0, "7": 1, "8": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"0\", \"3\": \"1\", \"4\": \"3\", \"5\": \"0\", \"6\": \"5\"}"}, "output": {"0": 6, "1": 2, "2": 0, "3": 1, "4": 0, "5": 1, "6": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"1\", \"3\": \"1\", \"4\": \"0\"}"}, "output": {"0": 4, "1": 2, "2": 0, "3": 0, "4": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"1\", \"3\": \"0\", \"4\": \"0\", \"5\": \"0\", \"6\": \"4\"}"}, "output": {"0": 6, "1": 1, "2": 0, "3": 0, "4": 1, "5": 0, "6": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"0\", \"3\": \"2\", \"4\": \"2\", \"5\": \"3\", \"6\": \"0\", \"7\": \"5\"}"}, "output": {"0": 7, "1": 0, "2": 4, "3": 2, "4": 0, "5": 1, "6": 0, "7": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"0\", \"3\": \"2\", \"4\": \"2\", \"5\": \"3\"}"}, "output": {"0": 5, "1": 0, "2": 3, "3": 1, "4": 0, "5": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"1\", \"3\": \"1\", \"4\": \"1\", \"5\": \"1\", \"6\": \"3\", \"7\": \"3\", \"8\": \"2\"}"}, "output": {"0": 8, "1": 7, "2": 1, "3": 2, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0}}, {"input": {"tree_data": "{\"1\": \"0\", \"2\": \"0\", \"3\": \"0\", \"4\": \"2\", \"5\": \"3\"}"}, "output": {"0": 5, "1": 0, "2": 1, "3": 1, "4": 0, "5": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dupeljan/pyhton4th", "path": "/2/ind.py", "msgidx": 4653}}
{"problem_description": "In a memory management system, a list of memory banks is redistributed periodically to ensure even distribution. Each bank can hold a certain number of blocks, and the redistribution process involves taking all blocks from the fullest bank and distributing them one by one to subsequent banks. How many redistributions are required before a configuration of the memory banks repeats?", "io_requirements": "Input:\n  `list_of_banks` (str): A string representing a list of integers separated by spaces. For example, \"0 2 7 0\".\n\nOutput:\n  `return` (int): The number of redistributions required before a configuration repeats.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef redistributer(arr, pos, total):\n    if pos >= len(arr):\n        pos = 0\n    if total <= 0:\n        return arr\n    else:\n        arr[pos] += 1\n        return redistributer(arr, pos+1, total-1)\n\ndef arr_to_string(arr):\n    return \" \".join(str(x) for x in arr)\n\n# main function\ndef main_solution(list_of_banks):\n    # Convert the input list to a list of integers\n    list_of_banks = [int(x) for x in list_of_banks.split()]\n    \n    # Putting stuff in\n    memory = defaultdict(int)\n    memory[arr_to_string(list_of_banks)] += 1\n    time = 0\n    \n    # Checking max\n    while memory[arr_to_string(list_of_banks)] <= 1:\n        max_value = max(list_of_banks)\n        list_of_banks[list_of_banks.index(max(list_of_banks))] = 0\n        list_of_banks = redistributer(list_of_banks, list_of_banks.index(max(list_of_banks)) + 1, max_value)\n        memory[arr_to_string(list_of_banks)] += 1\n        time += 1\n    \n    # Return the number of redistributions as an integer\n    return time", "funcname": "main_solution", "ios": [{"input": {"list_of_banks": "3 1 7 9 4"}, "output": 7}, {"input": {"list_of_banks": "2 0 3 2"}, "output": 5}, {"input": {"list_of_banks": "3 7 7 2"}, "output": 6}, {"input": {"list_of_banks": "6 7 10 10"}, "output": 11}, {"input": {"list_of_banks": "8 8 0 0 8"}, "output": 8}, {"input": {"list_of_banks": "2 7 7 7 8"}, "output": 26}, {"input": {"list_of_banks": "8 8 5 3 5"}, "output": 10}, {"input": {"list_of_banks": "2 8 5"}, "output": 3}, {"input": {"list_of_banks": "3 9 1"}, "output": 4}, {"input": {"list_of_banks": "4 5 9 6 7"}, "output": 16}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ndo3/Advent_Of_Code_2017", "path": "/day6.py", "msgidx": 4455}}
{"problem_description": "You are tasked with determining the number of lit pixels on a screen after following a series of instructions. The screen is 50 pixels wide and 6 pixels tall, and it starts with all pixels off. The instructions provided can turn on rectangular sections of the screen, rotate rows to the right, or rotate columns down. How many pixels are lit after executing all the given instructions?", "io_requirements": "Input:\n  `instructions` (list of strings): A list of instructions where each string represents a single instruction for the screen. Each instruction can be one of the following formats:\n  - \"rect AxB\" where A and B are integers representing the width and height of the rectangle to be turned on.\n  - \"rotate row y=A by B\" where A and B are integers representing the row index and the number of pixels to shift right.\n  - \"rotate column x=A by B\" where A and B are integers representing the column index and the number of pixels to shift down.\n\nOutput:\n  `return` (int): The number of pixels that are lit on the screen after processing all the instructions.", "refcode": "# import necessary packages\nimport numpy as np\nimport re\n\n# main function\ndef main_solution(instructions):\n    # Initialize the screen array\n    array = np.zeros((6, 50), dtype=bool)\n\n    # Process each instruction\n    for line in instructions:\n        split_line = re.split(r\"[ =]\", line)\n\n        if split_line[0] == \"rect\":\n            width, height = map(int, split_line[1].split('x'))\n            array[:height, :width] = True\n\n        elif split_line[0] == \"rotate\":\n            if split_line[1] == \"row\":\n                rotate_loc = int(split_line[3])\n                rotate_by = int(split_line[5])\n                array[rotate_loc] = np.roll(array[rotate_loc], rotate_by)\n            else:\n                rotate_loc = int(split_line[3])\n                rotate_by = int(split_line[5])\n                array[:, rotate_loc] = np.roll(array[:, rotate_loc], rotate_by)\n\n    # Convert the array to a JSON serializable format\n    lit_pixels = int(np.sum(array))\n    return lit_pixels", "funcname": "main_solution", "ios": [{"input": {"instructions": ["rotate row y=0 by 4"]}, "output": 0}, {"input": {"instructions": ["rotate column x=14 by 5", "rotate column x=2 by 5", "rotate row y=3 by 14", "rotate row y=2 by 31", "rect 43x1", "rotate row y=0 by 18"]}, "output": 43}, {"input": {"instructions": ["rotate column x=14 by 2", "rect 22x1", "rotate column x=28 by 3", "rect 32x2", "rect 42x6"]}, "output": 252}, {"input": {"instructions": ["rotate row y=0 by 32", "rotate column x=30 by 1", "rotate row y=2 by 5"]}, "output": 0}, {"input": {"instructions": ["rect 22x2", "rect 30x1"]}, "output": 52}, {"input": {"instructions": ["rotate column x=38 by 4", "rotate row y=0 by 35", "rotate row y=0 by 45", "rotate column x=26 by 5", "rotate column x=12 by 2", "rotate column x=3 by 1", "rect 5x3"]}, "output": 15}, {"input": {"instructions": ["rotate column x=15 by 3", "rect 28x1", "rotate row y=1 by 13", "rect 25x4", "rect 29x5"]}, "output": 145}, {"input": {"instructions": ["rotate row y=4 by 19", "rotate row y=3 by 12", "rotate column x=19 by 2", "rect 23x1"]}, "output": 23}, {"input": {"instructions": ["rect 29x6", "rect 5x4", "rect 50x5", "rotate row y=1 by 8", "rotate column x=20 by 4"]}, "output": 279}, {"input": {"instructions": ["rotate row y=0 by 26", "rect 49x5", "rect 9x1", "rect 37x1", "rotate row y=0 by 37", "rect 1x3"]}, "output": 245}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lsiepman/AdventOfCode2016", "path": "/Day08.py", "msgidx": 4325}}
{"problem_description": "Given a fractal grid of a certain size and complexity, how can we determine the sequence of least common tiles within a specified search limit? Specifically, what is the resulting sequence of tiles or indication if the search limit is exceeded?", "io_requirements": "Input:\n  `size` (int): The size of the fractal grid.\n  `complexity` (int): The complexity level of the fractal generation.\n  `searchLim` (int): The search limit for finding the least common tile.\n\nOutput:\n  `return` (str): A string representing the result of the fractal processing. It can be a sequence of numbers separated by spaces or \"IMPOSSIBLE\" if the search limit is exceeded.", "refcode": "# import necessary packages\nimport numpy as np\nfrom collections import Counter\nimport itertools\n\n# all class and function definitions in the code file, if any\nclass Fractals:\n    def process(self, size, complexity, searchLim):\n        startingTiles = self.generateStartingComboPower2(size)\n        finalTiles = []\n        for tile in startingTiles:\n            finalTile = self.getNextGeneration(tile, complexity, tile, size)\n            finalTiles.append(finalTile)\n\n        if searchLim == size:\n            obviousResult = \" \".join(str(tile[0]) for tile in finalTiles)\n            return obviousResult\n        else:\n            return self.searchGold(finalTiles, size, searchLim)\n\n    def searchGold(self, finalTiles, size, searchLim):\n        result = []\n        steps = 0\n\n        while len(finalTiles) > 1 and steps < searchLim:\n            collapsed = [item for sublist in finalTiles for item in sublist]\n            counts = Counter(collapsed)\n            leastCommonTile, freq = counts.most_common()[-1]\n\n            checkZero = 1\n            while checkZero < max(collapsed):\n                if counts[checkZero] == 0:\n                    leastCommonTile = checkZero\n                    break\n                checkZero += 1\n\n            result.append(leastCommonTile)\n            newTiles = [tile for tile in finalTiles if leastCommonTile in tile]\n            finalTiles = newTiles\n            steps += 1\n\n        if len(finalTiles) == 1:\n            result.append(finalTiles[0][0])\n            result = \" \".join(str(step) for step in result)\n            steps += 1\n            if steps > searchLim:\n                result = \"IMPOSSIBLE\"\n        elif len(finalTiles) == 0:\n            result = \" \".join(str(step) for step in result)\n\n        return result\n\n    def getNextGeneration(self, tile, complexity, startingTile, size):\n        newTile = []\n        for i in tile:\n            for j in startingTile:\n                newLead = (i - 1) * size + j\n                newTile.append(newLead)\n\n        if complexity > 2:\n            newTile = self.getNextGeneration(newTile, complexity - 1, startingTile, size)\n        if complexity == 1:\n            newTile = tile\n\n        return newTile\n\n    def generateStartingComboPower2(self, size):\n        possibleCombos = []\n        inputLead = 1\n        while inputLead < size + 1:\n            leadArray = [inputLead]\n            inputLead += 1\n            possibleCombos.append(leadArray)\n        return possibleCombos\n\n# main function\ndef main_solution(size, complexity, searchLim):\n    fractals = Fractals()\n    result = fractals.process(size, complexity, searchLim)\n    return result", "funcname": "main_solution", "ios": [{"input": {"size": 8, "complexity": 1, "searchLim": 5}, "output": "8 8"}, {"input": {"size": 7, "complexity": 1, "searchLim": 2}, "output": "7 7"}, {"input": {"size": 6, "complexity": 3, "searchLim": 3}, "output": "2"}, {"input": {"size": 4, "complexity": 1, "searchLim": 2}, "output": "4 4"}, {"input": {"size": 2, "complexity": 2, "searchLim": 1}, "output": "2"}, {"input": {"size": 7, "complexity": 4, "searchLim": 3}, "output": "2"}, {"input": {"size": 2, "complexity": 3, "searchLim": 1}, "output": "2"}, {"input": {"size": 8, "complexity": 4, "searchLim": 6}, "output": "2"}, {"input": {"size": 2, "complexity": 2, "searchLim": 2}, "output": "1 4"}, {"input": {"size": 5, "complexity": 4, "searchLim": 2}, "output": "2"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DaHuO/Supergraph", "path": "/codes/CodeJamCrawler/16_0_4_neat/16_0_4_highOrderPoles_Fractals.py", "msgidx": 4481}}
{"problem_description": "In a game of Battleship, players attempt to sink each other's ships by guessing their positions on a grid. Given a game board with ships represented by non-zero integers and a list of attacks, determine how many ships are sunk, damaged, and untouched, as well as the total points earned based on the outcome of the attacks. What is the final status of the ships and the total points after all attacks?", "io_requirements": "Input:\n  `board` (list of lists of integers): A 2D list representing the game board where each integer represents a ship or empty space. 0 indicates an empty space, and non-zero integers represent different ships.\n  `attacks` (list of lists of integers): A list of attack coordinates where each coordinate is a list of two integers representing the row and column of the attack.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `sunk` (integer): The number of ships that have been completely sunk.\n    - `damaged` (integer): The number of ships that have been damaged but not sunk.\n    - `not_touched` (integer): The number of ships that have not been touched by any attack.\n    - `points` (float): The total points calculated based on the number of sunk, damaged, and untouched ships. Points are calculated as (sunk * 1) + (damaged * 0.5) - (not_touched * 1).", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(board, attacks):\n    # Convert the board to a numpy array and flip it vertically\n    npBoard = np.array(board)\n    board = np.flipud(npBoard)\n\n    # Initialize the result dictionary with default values\n    resultDictionary = {'sunk': 0, 'damaged': 0, 'not_touched': 0, 'points': 0}\n\n    # Get all unique ship numbers from the board\n    touchCheckList = []\n    for x in range(len(board)):\n        for y in range(len(board[0])):\n            if board[x][y] != 0 and board[x][y] not in touchCheckList:\n                touchCheckList.append(board[x][y])\n\n    touched = []\n    damaged = []\n\n    # Process each attack\n    for attack in attacks:\n        attackCol = attack[0] - 1\n        attackRow = attack[1] - 1\n        currentAttack = board[attackRow][attackCol]\n\n        if currentAttack != 0:\n            board[attackRow][attackCol] = 0\n\n            if currentAttack in board and currentAttack not in damaged:\n                damaged.append(currentAttack)\n                resultDictionary['damaged'] += 1\n                touched.append(currentAttack)\n            elif currentAttack not in board:\n                resultDictionary['sunk'] += 1\n                if resultDictionary['damaged'] >= 1:\n                    resultDictionary['damaged'] -= 1\n                touched.append(currentAttack)\n\n    # Check for untouched ships\n    for shipNum in touchCheckList:\n        if shipNum not in touched:\n            resultDictionary['not_touched'] += 1\n\n    # Calculate the points\n    resultDictionary['points'] = ((resultDictionary['sunk'] * 1) + (resultDictionary['damaged'] * 0.5)) - (resultDictionary['not_touched'] * 1)\n\n    # Convert the result dictionary to a JSON serializable format\n    return {\n        'sunk': resultDictionary['sunk'],\n        'damaged': resultDictionary['damaged'],\n        'not_touched': resultDictionary['not_touched'],\n        'points': round(resultDictionary['points'], 2)\n    }", "funcname": "main_solution", "ios": [{"input": {"board": [[0, 2, 3, 1], [1, 3, 1, 0], [0, 2, 0, 1]], "attacks": [[3, 2], [3, 1]]}, "output": {"sunk": 0, "damaged": 1, "not_touched": 2, "points": -1.5}}, {"input": {"board": [[1, 2, 3, 1], [1, 2, 1, 0], [3, 1, 0, 1]], "attacks": [[3, 3], [3, 2]]}, "output": {"sunk": 0, "damaged": 2, "not_touched": 1, "points": 0.0}}, {"input": {"board": [[0, 1, 2], [3, 2, 1], [1, 3, 2]], "attacks": [[1, 3], [1, 2]]}, "output": {"sunk": 0, "damaged": 1, "not_touched": 2, "points": -1.5}}, {"input": {"board": [[2, 3, 2], [0, 1, 2], [3, 0, 2]], "attacks": [[3, 1], [3, 3]]}, "output": {"sunk": 0, "damaged": 1, "not_touched": 2, "points": -1.5}}, {"input": {"board": [[2, 2, 2], [2, 0, 1], [1, 2, 2]], "attacks": [[3, 1], [3, 2]]}, "output": {"sunk": 0, "damaged": 2, "not_touched": 0, "points": 1.0}}, {"input": {"board": [[0, 2, 1, 0], [0, 1, 1, 0], [3, 2, 1, 1]], "attacks": [[3, 3], [2, 1]]}, "output": {"sunk": 0, "damaged": 2, "not_touched": 1, "points": 0.0}}, {"input": {"board": [[1, 3, 2], [1, 2, 3], [3, 2, 2]], "attacks": [[2, 3]]}, "output": {"sunk": 0, "damaged": 1, "not_touched": 2, "points": -1.5}}, {"input": {"board": [[2, 2, 1, 0], [0, 3, 0, 3], [0, 3, 3, 1]], "attacks": [[3, 1]]}, "output": {"sunk": 0, "damaged": 1, "not_touched": 2, "points": -1.5}}, {"input": {"board": [[1, 1, 3], [2, 3, 1], [2, 1, 1]], "attacks": [[2, 2]]}, "output": {"sunk": 0, "damaged": 1, "not_touched": 2, "points": -1.5}}, {"input": {"board": [[2, 3, 3, 1], [2, 2, 1, 0], [1, 0, 1, 2]], "attacks": [[1, 1]]}, "output": {"sunk": 0, "damaged": 1, "not_touched": 2, "points": -1.5}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DrZero1234/damagedOrSunk", "path": "/damagedOrSunk.py", "msgidx": 4215}}
{"problem_description": "Given a set of triangles defined by their vertices, how many of these triangles contain the origin (0,0) within their interior? The triangles are represented by their coordinates in the format \"x_0,y_0,x_1,y_1,x_2,y_2\".", "io_requirements": "Input:\n  `triangles` (list of strings): A list of strings where each string represents a triangle's coordinates in the format \"x_0,y_0,x_1,y_1,x_2,y_2\". Each coordinate is an integer.\n\nOutput:\n  `return` (int): The number of triangles that contain the origin (0,0) within their interior.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(triangles):\n    # Convert the input list of triangles to a list of lists\n    triangles = [list(map(int, triangle.split(','))) for triangle in triangles]\n    \n    count = 0\n    \n    for triangle in triangles:\n        # the composition of each triangle list is as follows\n        # [x_0, y_0, x_1, y_1, x_2, y_2]\n        x_0, y_0, x_1, y_1, x_2, y_2 = triangle\n\n        # Remove those triangles which lie entirely either side of\n        # x = 0 or y = 0.\n        if (x_0 > 0 and x_1 > 0 and x_2 > 0) or (x_0 < 0 and x_1 < 0 and x_2 < 0) or \\\n           (y_0 > 0 and y_1 > 0 and y_2 > 0) or (y_0 < 0 and y_1 < 0 and y_2 < 0):\n            continue\n\n        # Calculating the gradient of the sides\n        m_0 = float(y_1 - y_0) / (x_1 - x_0) if x_1 != x_0 else np.inf\n        m_1 = float(y_2 - y_1) / (x_2 - x_1) if x_2 != x_1 else np.inf\n        m_2 = float(y_0 - y_2) / (x_0 - x_2) if x_0 != x_2 else np.inf\n\n        # Calculating the y-intercept of the sides\n        c_0 = y_0 - m_0 * x_0 if m_0 != np.inf else x_0\n        c_1 = y_1 - m_1 * x_1 if m_1 != np.inf else x_1\n        c_2 = y_2 - m_2 * x_2 if m_2 != np.inf else x_2\n\n        # Check if the origin (0,0) is inside the triangle\n        def is_inside(x, y, m, c):\n            if m == np.inf:\n                return x == c\n            return y == m * x + c\n\n        if (is_inside(0, 0, m_0, c_0) or is_inside(0, 0, m_1, c_1) or is_inside(0, 0, m_2, c_2)):\n            count += 1\n\n    return count", "funcname": "main_solution", "ios": [{"input": {"triangles": ["-3,-5,5,1,0,-5", "2,2,-9,9,-5,3", "9,4,6,8,10,8", "5,4,8,3,-3,0", "2,0,10,3,1,-8", "2,-9,-10,2,3,-3", "-7,9,6,-8,-4,10", "-3,-1,-9,-6,4,-3"]}, "output": 0}, {"input": {"triangles": ["4,-4,-9,1,-2,-5", "4,-6,9,-3,-5,-9", "3,1,-3,7,-8,-6", "-3,5,1,-9,4,-7", "-6,6,-4,6,6,-8", "-4,0,1,-5,-8,10", "-3,6,-4,3,-8,-8", "-3,-10,-7,-5,-8,4"]}, "output": 0}, {"input": {"triangles": ["6,-5,-2,-7,3,-8", "3,8,-7,2,2,-7", "2,6,-9,10,-9,8", "0,-5,-7,-2,-10,2"]}, "output": 0}, {"input": {"triangles": ["2,-10,5,3,4,5", "-10,-4,-1,8,10,-5", "-5,-9,9,5,-2,-5", "-10,10,-2,-9,-10,3", "7,-7,5,9,-1,-2", "-2,7,-9,8,-4,1"]}, "output": 0}, {"input": {"triangles": ["-3,-10,2,-10,-9,-4", "0,9,-10,-9,-9,7", "-9,-2,-1,8,1,5", "-9,8,8,0,-8,5", "-7,5,-5,7,7,-1", "10,3,6,10,-4,-4"]}, "output": 0}, {"input": {"triangles": ["9,8,8,5,-4,-4", "-4,-2,3,-8,8,-2", "0,3,-10,7,-10,-6", "0,7,3,-3,-4,2", "-5,8,3,6,3,-3", "10,8,1,2,0,-8", "1,-7,6,4,-5,-3", "-1,-8,3,-10,0,-1"]}, "output": 0}, {"input": {"triangles": ["-9,-7,8,-1,9,2", "0,5,-10,-7,5,4", "1,5,-6,7,7,-5", "0,8,4,7,-5,0"]}, "output": 0}, {"input": {"triangles": ["10,-4,-5,0,9,3", "-6,-6,10,5,-9,9", "-10,-5,-7,-8,6,-10", "3,-5,4,1,-1,5", "-5,5,-9,10,-9,-5", "5,-4,-3,-7,8,5", "-1,-9,5,4,8,3", "8,-4,2,-8,2,6"]}, "output": 0}, {"input": {"triangles": ["9,-2,-9,-3,-7,1", "-9,5,6,7,-10,-1", "-10,-1,-9,-8,10,4", "2,8,2,-2,9,4", "-9,-10,-5,6,3,0", "1,10,8,9,-4,0"]}, "output": 0}, {"input": {"triangles": ["5,-9,9,-1,8,-10", "-7,8,-7,-2,-1,-6", "-4,-1,5,7,9,-2"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "slavojstar/project-euler", "path": "/102 TriangleContainment.py", "msgidx": 4033}}
{"problem_description": "Given a list of integers, what are all the possible ways to arrange the elements in the list?", "io_requirements": "Input:\n  `array` (list of integers): A list of integers for which all permutations need to be generated.\n\nOutput:\n  `return` (list of lists of integers): A list containing all possible permutations of the input array. Each permutation is represented as a list of integers.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(array):\n    # Convert the input list to a JSON serializable format\n    array = list(array)\n    \n    # Generate all permutations of the array\n    permutations = list(itertools.permutations(array))\n    \n    # Convert permutations to a JSON serializable format\n    permutations = [list(perm) for perm in permutations]\n    \n    return permutations", "funcname": "main_solution", "ios": [{"input": {"array": [4, 2, 7]}, "output": [[4, 2, 7], [4, 7, 2], [2, 4, 7], [2, 7, 4], [7, 4, 2], [7, 2, 4]]}, {"input": {"array": [4, 1]}, "output": [[4, 1], [1, 4]]}, {"input": {"array": [1, 3, 6]}, "output": [[1, 3, 6], [1, 6, 3], [3, 1, 6], [3, 6, 1], [6, 1, 3], [6, 3, 1]]}, {"input": {"array": [5, 2, 8]}, "output": [[5, 2, 8], [5, 8, 2], [2, 5, 8], [2, 8, 5], [8, 5, 2], [8, 2, 5]]}, {"input": {"array": [9, 3, 4]}, "output": [[9, 3, 4], [9, 4, 3], [3, 9, 4], [3, 4, 9], [4, 9, 3], [4, 3, 9]]}, {"input": {"array": [7, 10, 8]}, "output": [[7, 10, 8], [7, 8, 10], [10, 7, 8], [10, 8, 7], [8, 7, 10], [8, 10, 7]]}, {"input": {"array": [4, 1, 10]}, "output": [[4, 1, 10], [4, 10, 1], [1, 4, 10], [1, 10, 4], [10, 4, 1], [10, 1, 4]]}, {"input": {"array": [6, 8]}, "output": [[6, 8], [8, 6]]}, {"input": {"array": [2, 1]}, "output": [[2, 1], [1, 2]]}, {"input": {"array": [3, 6, 1]}, "output": [[3, 6, 1], [3, 1, 6], [6, 3, 1], [6, 1, 3], [1, 3, 6], [1, 6, 3]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zmatteson/epi-python", "path": "/chapter_15/15_3.py", "msgidx": 4328}}
{"problem_description": "Given a line of text containing 6-letter capitalized words separated by commas, how can we determine if the line meets the criteria for a proper word warp line? The criteria include:\n- The line should be composed of capitalized 6-letter words.\n- If there is more than one word, words should be separated by a comma and a space.\n- All words in the line should be anagrams of each other.\n- All words in the line should be sorted alphabetically.", "io_requirements": "Input:\n  `line` (str): A string representing a line of text containing words separated by commas. Each word should be a 6-letter capitalized word.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `result` (bool): Indicates whether the line is valid according to the criteria.\n    - `message` (str): A message describing the result, either 'All is well' for valid lines or a specific error message for invalid lines.", "refcode": "# import necessary packages\nimport re\nimport unicodedata\n\n# all class and function definitions in the code file, if any\ndef get_words(line):\n    \"\"\"Break a line into a list of words.\n\n    Use a comma as a separator.\n    Strip leading and trailing whitespace.\n    \"\"\"\n    return [word.strip() for word in line.split(',')]\n\ndef line_space_okay(line):\n    \"\"\"No whitespace at beginning/end and ', ' is word separator\"\"\"\n    if line.strip() != line:\n        return False\n    if line.split(', ') != get_words(line):\n        return False\n    return True\n\n# The unicode category for a codepoint is a 2-letter code.\n#   'Lu' is Letter, uppercase.\n#   'Ll' is Letter, lowercase.\n# A 6-letter capitalized word looks like this:\nCATEGORY_MATCH = 'Lu' + 'Ll'*5\n\ndef categories(s):\n    \"\"\"Return a string of unicode categories for the given input.\"\"\"\n    return ''.join(unicodedata.category(ch) for ch in s)\n\ndef words_okay(word_list):\n    \"\"\"Verify if the words in a line are good (6-letters, capitalized).\"\"\"\n    return all(categories(word) == CATEGORY_MATCH for word in word_list)\n\ndef words_are_anagrams(word_list):\n    \"\"\"Return whether words in list are anagrams of each other.\"\"\"\n    letters = sorted(word_list[0])\n    return all(sorted(word) == letters for word in word_list)\n\ndef words_are_alphabetic(word_list):\n    \"\"\"Return whether words in list are sorted alphabetically.\"\"\"\n    return sorted(word_list) == word_list\n\ndef line_is_good(line):\n    \"\"\"Verify if a line matches the criteria for a proper word warp line.\n\n    The criteria are:\n    Basic syntax (line parses):\n    - A line is composed of capitalized 6-letter words.\n    - If there is only 1 word, the line is just the 6 letters.\n    - If there are more than 1 words, words are separated by a comma and a\n      space.\n    Further:\n    - All the words in a line should be anagrams of each other.\n    - All the words in a line should be sorted alphabetically.\n    - All the lines in the file should be sorted alphabetically.\n    \"\"\"\n    if not line_space_okay(line):\n        return (False, 'Bad whitespace.')\n\n    word_list = get_words(line)\n    if not words_okay(word_list):\n        return (False, 'Did not parse.')\n\n    word_list = [word.casefold() for word in get_words(line)]\n    if not words_are_anagrams(word_list):\n        return (False, 'Not anagrams')\n    if not words_are_alphabetic(word_list):\n        return (False, 'Not alphabetic')\n\n    return (True, 'All is well')\n\n# main function\ndef main_solution(line):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result, message = line_is_good(line)\n    return {\"result\": result, \"message\": message}", "funcname": "main_solution", "ios": [{"input": {"line": "Nialvl, Xjveoo, Hfcgkv"}, "output": {"result": false, "message": "Not anagrams"}}, {"input": {"line": "Dgzjvy"}, "output": {"result": true, "message": "All is well"}}, {"input": {"line": "Ikyjsg, Cpydys, Msoyes, Xkxlpw"}, "output": {"result": false, "message": "Not anagrams"}}, {"input": {"line": "Rjxpgg, Dfncbi"}, "output": {"result": false, "message": "Not anagrams"}}, {"input": {"line": "Zmwhok"}, "output": {"result": true, "message": "All is well"}}, {"input": {"line": "Jdspey, Rzyvut, Bqalll, Kxezlh, Dsksjw"}, "output": {"result": false, "message": "Not anagrams"}}, {"input": {"line": "Yhhwsz, Wmvemp, Rjvyhy, Vbqjym, Ahrlmt"}, "output": {"result": false, "message": "Not anagrams"}}, {"input": {"line": "Lcvpix, Kaxfsc, Hrpmzq, Kgwxft, Xvrnbx"}, "output": {"result": false, "message": "Not anagrams"}}, {"input": {"line": "Edckxj, Dejqpb, Jhrkar, Wqqswn, Khvxsy"}, "output": {"result": false, "message": "Not anagrams"}}, {"input": {"line": "Mijkrq"}, "output": {"result": true, "message": "All is well"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tedzo/python_play", "path": "/word_warp/process_data.py", "msgidx": 3869}}
{"problem_description": "Given a string consisting of uppercase letters, what are all the unique permutations of the string, sorted in lexicographically increasing order, with each permutation separated by a single space?", "io_requirements": "Input:\n  `S` (str): A string containing uppercase letters. The length of the string should be between 1 and 5 characters.\n\nOutput:\n  `return` (str): A string containing all unique permutations of the input string `S`, sorted in lexicographically increasing order, separated by a single space.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(S):\n    # Convert the string to a list of characters\n    chars = list(S)\n    \n    # Generate all permutations of the list of characters\n    permutations = sorted(set(itertools.permutations(chars)))\n    \n    # Convert each permutation tuple back to a string\n    result = [''.join(perm) for perm in permutations]\n    \n    # Join the permutations with a single space and return as a string\n    return ' '.join(result)", "funcname": "main_solution", "ios": [{"input": {"S": "AS"}, "output": "AS SA"}, {"input": {"S": "AM"}, "output": "AM MA"}, {"input": {"S": "GLS"}, "output": "GLS GSL LGS LSG SGL SLG"}, {"input": {"S": "RCU"}, "output": "CRU CUR RCU RUC UCR URC"}, {"input": {"S": "XJF"}, "output": "FJX FXJ JFX JXF XFJ XJF"}, {"input": {"S": "NMO"}, "output": "MNO MON NMO NOM OMN ONM"}, {"input": {"S": "N"}, "output": "N"}, {"input": {"S": "PC"}, "output": "CP PC"}, {"input": {"S": "NBV"}, "output": "BNV BVN NBV NVB VBN VNB"}, {"input": {"S": "BFH"}, "output": "BFH BHF FBH FHB HBF HFB"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "saparia-data/data_structure", "path": "/geeksforgeeks/recursion/7_string_permutation.py", "msgidx": 4373}}
{"problem_description": "In a queue for a \"Double Cola\" drink vending machine, Sheldon, Leonard, Penny, Rajesh, and Howard are initially standing in that order. Each person, when they drink a cola, doubles and goes to the end of the queue. Given the initial queue order and a specific cola can number, which person will drink the n-th cola?", "io_requirements": "Input:\n  `names` (list of strings): A list of names representing the initial queue order. Each name is a string.\n  `n` (int): An integer representing the position of the cola can to be drunk, starting from 1.\n\nOutput:\n  `return` (string): The name of the person who drinks the n-th cola.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(names, n):\n    # Convert input variables if necessary\n    n = int(n)  # Ensure n is an integer\n    \n    # Core logic to determine who drinks the n-th cola\n    length = len(names)\n    while n > length:\n        n = (n - length + 1) // 2\n    return names[n - 1]", "funcname": "main_solution", "ios": [{"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 187271}, "output": "Sheldon"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 9156}, "output": "Rajesh"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 345862}, "output": "Sheldon"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 291927}, "output": "Rajesh"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 638317}, "output": "Howard"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 69109}, "output": "Rajesh"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 603387}, "output": "Howard"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 74755}, "output": "Howard"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 657191}, "output": "Sheldon"}, {"input": {"names": ["Sheldon", "Leonard", "Penny", "Rajesh", "Howard"], "n": 767514}, "output": "Sheldon"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yaelBrown/Codewars", "path": "/Python/WhoIsNext.py", "msgidx": 3988}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a valid combination of n pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generate(lst, s, left, right, lim):\n    if (len(s) == 2 * lim):\n        lst.append(s)\n    if (left < lim):\n        generate(lst, s + \"(\", left + 1, right, lim)\n    if (right < left):\n        generate(lst, s + \")\", left, right + 1, lim)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    lst = []\n    generate(lst, \"\", 0, 0, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return lst", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gddh/practice", "path": "/leetcode/python/generateParentheses/generateParentheses.py", "msgidx": 4018}}
{"problem_description": "Given a square matrix representing a graph, where each element is an integer, how can we determine the initial matching of vertices using the Hungarian algorithm? Specifically, which vertices are initially matched, and which are not?", "io_requirements": "Input:\n  `matrix` (list of lists of integers): A square matrix representing the graph where each element is an integer. The matrix should be of size n x n, where n is the number of vertices.\n\nOutput:\n  `return` (list of lists or None): A list where each element is either a list of two integers representing the indices of matched vertices or None if the vertex is not matched.", "refcode": "# import necessary packages\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\nclass Hungaro(object):\n    \"\"\" En esta clase se corre el algoritmo de Matching hungaro \"\"\"\n\n    filas_no_matcheadas = 0\n\n    def __init__(self, matrix):\n        self.matrix = deepcopy(matrix) # Matriz o grafo de entrada\n        self.filas = len(self.matrix) # Numero de filas, es una matriz cuadrada\n        # Matriz de macheo, tiene un 1 entre los vertices macheados\n        self.matriz_matcheo = [[0 for i in range(self.filas)] for j in range(self.filas)]\n        self.elementos_matcheados = [0 for i in range(self.filas)]\n\n    def matching_inicial(self):\n        \"\"\" Este metodo debuelve el primer matcheo de los vertices.\n           O sea, una matr\u00edz con un 1 en los vertices matcheados \"\"\"\n\n        # Primero recorremos la matriz buscando los 0 de cada fila\n        for i in range(self.filas): #filas\n            for j in range(self.filas): #columnas\n                if self.matrix[i][j] == 0:\n                    if i == 0: # para la primera fila marcamos el primer 0\n                        self.matrix[i][j] = 'M'\n                        self.elementos_matcheados[i] = (i, j)\n                        break\n                    else: # para las demas filas chequeamos si ya estan matcheadas las columnas\n                        var_w = 0\n                        var_count = 0\n                        # Vamos viendo las filas anteriores de la columna que contiene un 0\n                        # Vemos que no este matcheada la columna que contiene el 0\n                        while var_w < i: # recorremos las filas anteriores de esa columna\n                            if self.matrix[var_w][j] == 'M':\n                                var_count = var_count + 1 # Si est\u00e1 macheada lo contamos\n                            var_w = var_w + 1\n                        if var_count > 0: # si est\u00e1 matcheada no la marcamos\n                            continue\n                        else: # si no est\u00e1 matcheada la marcamos\n                            self.matrix[i][j] = 'M'\n                            self.elementos_matcheados[i] = (i, j)\n        return self.matrix\n\n    def indices_elementos_matcheados(self):\n        \"\"\" Devuelve los indices, en la matriz, de los elementos que fueron matcheados \"\"\"\n        return self.elementos_matcheados\n\n# main function\ndef main_solution(matrix):\n    # Convert input to the required format\n    matrix = deepcopy(matrix)\n    \n    # Initialize the Hungaro class\n    hungaro = Hungaro(matrix)\n    \n    # Perform the initial matching\n    hungaro.matching_inicial()\n    \n    # Get the indices of matched elements\n    matched_indices = hungaro.indices_elementos_matcheados()\n    \n    # Convert the output to JSON serializable format\n    matched_indices = [list(idx) if idx != 0 else None for idx in matched_indices]\n    \n    return matched_indices", "funcname": "main_solution", "ios": [{"input": {"matrix": [[6, 5, 7, 5], [1, 2, 4, 1], [10, 7, 8, 9], [10, 10, 4, 4]]}, "output": [null, null, null, null]}, {"input": {"matrix": [[5, 8, 2, 7], [0, 7, 3, 5], [4, 9, 10, 5], [9, 5, 5, 8]]}, "output": [null, [1, 0], null, null]}, {"input": {"matrix": [[4, 5, 1, 8], [1, 0, 9, 1], [8, 6, 7, 8], [6, 4, 0, 2]]}, "output": [null, [1, 1], null, [3, 2]]}, {"input": {"matrix": [[1, 10, 3], [2, 10, 6], [3, 0, 9]]}, "output": [null, null, [2, 1]]}, {"input": {"matrix": [[5, 1, 6, 5], [1, 5, 6, 1], [1, 9, 6, 4], [1, 0, 9, 10]]}, "output": [null, null, null, [3, 1]]}, {"input": {"matrix": [[1, 2, 0, 4], [0, 2, 9, 9], [9, 7, 10, 3], [4, 6, 5, 3]]}, "output": [[0, 2], [1, 0], null, null]}, {"input": {"matrix": [[8, 10], [10, 7]]}, "output": [null, null]}, {"input": {"matrix": [[5, 1, 2, 0], [7, 6, 7, 9], [6, 8, 3, 1], [6, 3, 9, 7]]}, "output": [[0, 3], null, null, null]}, {"input": {"matrix": [[2, 9], [10, 0]]}, "output": [null, [1, 1]]}, {"input": {"matrix": [[2, 2], [6, 10]]}, "output": [null, null]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "franciscocrespo/Matching", "path": "/hungaro.py", "msgidx": 3838}}
{"problem_description": "Imagine you are feeding pigeons in a park. You start with a certain number of portions of wheat. Each minute, more pigeons arrive, and the number of pigeons increases according to a specific pattern. Each pigeon eats one portion of wheat per minute. Given a certain amount of wheat, how many pigeons will be fed with at least one portion of wheat before the supply runs out?", "io_requirements": "Input:\n  `wheat` (int): The number of portions of wheat available, a positive integer.\n\nOutput:\n  `return` (int): The number of pigeons that will be fed with at least one portion of wheat.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef numPigeons(x):\n    \"\"\"Returns the number of pigeons present in the given minute\"\"\"\n    return int(x * (x + 1) / 2)\n\n# main function\ndef main_solution(wheat):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    for minute in range(1, 105):\n        if numPigeons(minute) < wheat:\n            wheat -= numPigeons(minute)\n            continue\n        if numPigeons(minute) == wheat:\n            return numPigeons(minute)\n        if numPigeons(minute) > wheat:\n            return max(numPigeons(minute - 1), wheat)\n    return 0", "funcname": "main_solution", "ios": [{"input": {"wheat": 13}, "output": 6}, {"input": {"wheat": 22}, "output": 10}, {"input": {"wheat": 60}, "output": 21}, {"input": {"wheat": 12}, "output": 6}, {"input": {"wheat": 57}, "output": 21}, {"input": {"wheat": 50}, "output": 15}, {"input": {"wheat": 64}, "output": 21}, {"input": {"wheat": 95}, "output": 28}, {"input": {"wheat": 98}, "output": 28}, {"input": {"wheat": 25}, "output": 10}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "syntaxaire/CheckiO", "path": "/Home/feedpigeons.py", "msgidx": 4273}}
{"problem_description": "Given a string of exactly 4 digits, what is the formula that uses each digit exactly once and any combination of addition and subtraction operators that evaluates to 7?", "io_requirements": "Input:\n  `abcd` (str): A string of exactly 4 digits (e.g., \"1234\").\n\nOutput:\n  `return` (str): A string representing the formula that evaluates to 7, followed by \"=7\" (e.g., \"1+2+3+4=7\"). If no such formula exists, an empty string is returned.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(abcd):\n    # Convert the input string to a list of characters\n    abcd_list = list(abcd)\n    \n    # Iterate over all possible combinations of + and -\n    for i in range(1 << 3):\n        formula = abcd_list[0]\n        for j in range(3):\n            formula += \"+-\"[(i >> j) % 2]\n            formula += abcd_list[j + 1]\n        \n        # Evaluate the formula and check if it equals 7\n        if eval(formula) == 7:\n            return formula + \"=7\"\n    \n    # If no solution is found, return an empty string\n    return \"\"", "funcname": "main_solution", "ios": [{"input": {"abcd": "6873"}, "output": ""}, {"input": {"abcd": "5903"}, "output": ""}, {"input": {"abcd": "7265"}, "output": ""}, {"input": {"abcd": "3089"}, "output": ""}, {"input": {"abcd": "5959"}, "output": ""}, {"input": {"abcd": "9525"}, "output": "9-5-2+5=7"}, {"input": {"abcd": "0277"}, "output": ""}, {"input": {"abcd": "7653"}, "output": ""}, {"input": {"abcd": "8377"}, "output": ""}, {"input": {"abcd": "5207"}, "output": ""}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yojiyama7/python", "path": "/ant_qiita/a_first/2_1_1_bit_search/b.py", "msgidx": 4348}}
{"problem_description": "Given a large rectangle of size 2*n, where n is a positive integer, and small rectangles of size 2*1, how many distinct ways can you cover the large rectangle using the small rectangles without any overlap?", "io_requirements": "Input:\n  `n` (int): The number of 2*1 small rectangles to be used to cover a 2*n large rectangle. `n` should be a positive integer.\n\nOutput:\n  `return` (int): The total number of ways to cover the 2*n large rectangle using `n` 2*1 small rectangles.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def rectCover(self, number):\n        if number < 1:\n            return 0\n        p = q = r = 0\n        for i in range(1, number + 1):\n            if i == 1:\n                p = q = r = 1\n            elif i == 2:\n                q = r = 2\n            else:\n                r = q + p\n                p = q\n                q = r\n        return r\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert the input to the required format for the rectCover function\n    solution = Solution()\n    result = solution.rectCover(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 14}, "output": 610}, {"input": {"n": 9}, "output": 55}, {"input": {"n": 20}, "output": 10946}, {"input": {"n": 19}, "output": 6765}, {"input": {"n": 8}, "output": 34}, {"input": {"n": 2}, "output": 2}, {"input": {"n": 5}, "output": 8}, {"input": {"n": 11}, "output": 144}, {"input": {"n": 12}, "output": 233}, {"input": {"n": 6}, "output": 13}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dengxiaohao/Sword-refers-to-offer", "path": "/\u5251\u6307offer/\u9012\u5f52\u548c\u5176\u4ed6/3.py", "msgidx": 4697}}
{"problem_description": "Given a string and a specific length, what are all the possible permutations of the string and all unique combinations of the specified length?", "io_requirements": "Input:\n  `input_string` (str): A string for which permutations and combinations need to be generated.\n  `combination_length` (int): The length of the combinations to be generated.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `permutations` (list of str): A list of all possible permutations of the input string.\n    - `combinations` (list of str): A list of all unique combinations of the specified length from the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string, combination_length):\n    # Convert the input string to a list of characters\n    input_list = list(input_string)\n    \n    # Generate all permutations of the input string\n    permutations_list = list(itertools.permutations(input_list))\n    \n    # Generate all unique combinations of the specified length\n    combinations_list = list(itertools.combinations(input_list, combination_length))\n    \n    # Convert the permutations and combinations to JSON serializable format\n    permutations_serializable = [''.join(p) for p in permutations_list]\n    combinations_serializable = [''.join(c) for c in combinations_list]\n    \n    return {\n        \"permutations\": permutations_serializable,\n        \"combinations\": combinations_serializable\n    }", "funcname": "main_solution", "ios": [{"input": {"input_string": "vwg", "combination_length": 3}, "output": {"permutations": ["vwg", "vgw", "wvg", "wgv", "gvw", "gwv"], "combinations": ["vwg"]}}, {"input": {"input_string": "yyh", "combination_length": 1}, "output": {"permutations": ["yyh", "yhy", "yyh", "yhy", "hyy", "hyy"], "combinations": ["y", "y", "h"]}}, {"input": {"input_string": "yvb", "combination_length": 3}, "output": {"permutations": ["yvb", "ybv", "vyb", "vby", "byv", "bvy"], "combinations": ["yvb"]}}, {"input": {"input_string": "pow", "combination_length": 3}, "output": {"permutations": ["pow", "pwo", "opw", "owp", "wpo", "wop"], "combinations": ["pow"]}}, {"input": {"input_string": "bwa", "combination_length": 3}, "output": {"permutations": ["bwa", "baw", "wba", "wab", "abw", "awb"], "combinations": ["bwa"]}}, {"input": {"input_string": "dxl", "combination_length": 3}, "output": {"permutations": ["dxl", "dlx", "xdl", "xld", "ldx", "lxd"], "combinations": ["dxl"]}}, {"input": {"input_string": "vec", "combination_length": 3}, "output": {"permutations": ["vec", "vce", "evc", "ecv", "cve", "cev"], "combinations": ["vec"]}}, {"input": {"input_string": "avg", "combination_length": 3}, "output": {"permutations": ["avg", "agv", "vag", "vga", "gav", "gva"], "combinations": ["avg"]}}, {"input": {"input_string": "csk", "combination_length": 3}, "output": {"permutations": ["csk", "cks", "sck", "skc", "kcs", "ksc"], "combinations": ["csk"]}}, {"input": {"input_string": "rxc", "combination_length": 3}, "output": {"permutations": ["rxc", "rcx", "xrc", "xcr", "crx", "cxr"], "combinations": ["rxc"]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "eff-kay/combination-and-permutation", "path": "/permutation.py", "msgidx": 4672}}
{"problem_description": "Given a range of numbers from 1 to a specified limit, what is the largest pandigital number that can be formed by concatenating the results of multiplying each number in the range by a sequence of integers starting from 1?", "io_requirements": "Input:\n  `limit` (int): The upper limit for the range of numbers to check for generating the largest pandigital number. The range will be from 1 to `limit` (inclusive).\n\nOutput:\n  `return` (int): The largest pandigital number found within the specified range. If no pandigital number is found, it returns 0.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef splitDigits(n):\n    digits = []\n    while n:\n        digits.append(n % 10)\n        n //= 10\n    return list(reversed(digits))\n\ndef generatePandigital(n):\n    used = [True] + [False] * 9\n    m = 1\n    s = \"\"\n    while m <= 8:\n        t = m * n\n        m += 1\n        digits = splitDigits(t)\n        for d in digits:\n            if used[d]:\n                return 0\n            used[d] = True\n        s += str(t)\n        if len(s) == 9:\n            return int(s)\n        if len(s) > 9:\n            return 0\n    return 0\n\n# main function\ndef main_solution(limit):\n    largest = 0\n    for i in range(1, limit + 1):\n        pan = generatePandigital(i)\n        if pan > largest:\n            largest = pan\n    return largest", "funcname": "main_solution", "ios": [{"input": {"limit": 5721}, "output": 918273645}, {"input": {"limit": 1053}, "output": 918273645}, {"input": {"limit": 5259}, "output": 918273645}, {"input": {"limit": 2399}, "output": 918273645}, {"input": {"limit": 8018}, "output": 918273645}, {"input": {"limit": 8596}, "output": 918273645}, {"input": {"limit": 6934}, "output": 918273645}, {"input": {"limit": 4806}, "output": 918273645}, {"input": {"limit": 4826}, "output": 918273645}, {"input": {"limit": 4588}, "output": 918273645}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "isaacsimmons/euler", "path": "/euler/euler_38.py", "msgidx": 4483}}
{"problem_description": "Given a set of digits from 1 to n, where n is a number between 1 and 9, what is the highest prime number that can be formed using each digit exactly once?", "io_requirements": "Input:\n  `n` (int): The number of digits to consider (1 <= n <= 9). This represents the range of digits from 1 to n that should be used to form the number.\n\nOutput:\n  `return` (int or None): The highest prime number formed by the digits from 1 to n, where each digit appears only once. If no such prime number is found, the function returns `None`.", "refcode": "# import necessary packages\nimport time\nfrom math import sqrt, floor\nfrom itertools import permutations\n\n# check for prime number\ndef isprime(n):\n    if n % 3 == 0:\n        return False\n    for k in range(5, floor(sqrt(n)), 6):\n        if n % k == 0 or n % (k + 2) == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(n):\n    # n (int): The number of digits to consider (1 <= n <= 9)\n    a = '123456789'\n    j = n\n    flag = True\n\n    while flag:\n        # permute the digits from 0-->j\n        p = permutations(a[:j])\n        # Reverse the list\n        p = list(p)[::-1]\n\n        for i in p:\n            # Since each element of the list are tuple containing the digits as string, join them and convert to integer\n            number = int(''.join(i))\n            if number % 2 != 0:  # Check if not even\n                if (number + 1) % 6 == 0 or (number - 1) % 6 == 0:  # Basic condition for being a prime number\n                    if isprime(number):  # Call the function to verify if prime number\n                        return number\n        j -= 1\n\n    return None  # Return None if no prime number is found", "funcname": "main_solution", "ios": [{"input": {"n": 8}, "output": 7652413}, {"input": {"n": 5}, "output": 4231}, {"input": {"n": 2}, "output": 1}, {"input": {"n": 4}, "output": 4231}, {"input": {"n": 9}, "output": 7652413}, {"input": {"n": 7}, "output": 7652413}, {"input": {"n": 3}, "output": 1}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 6}, "output": 4231}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mohitrobo/Project-Euler", "path": "/41_Pandigital prime.py", "msgidx": 3958}}
{"problem_description": "Given a set of 7 distinct integers, what are the values of `a`, `b`, `c`, `d`, `e`, `f`, and `g` that can be arranged in such a way that the sum of the first two numbers is equal to the sum of the next three numbers, which is equal to the sum of the next three numbers, and finally equal to the sum of the last two numbers?", "io_requirements": "Input:\n  `numbers` (list of integers): A list of 7 distinct integers.\n\nOutput:\n  `return` (dictionary or None): A dictionary containing the values of `a`, `b`, `c`, `d`, `e`, `f`, and `g` that satisfy the condition `sum([a, b]) == sum([b, c, d]) == sum([d, e, f]) == sum([f, g])`. If no such permutation exists, returns `None`.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list to a tuple to make it JSON serializable\n    numbers = tuple(numbers)\n    \n    for perm in permutations(numbers):\n        a, b, c, d, e, f, g = perm\n        if sum([a, b]) == sum([b, c, d]) == sum([d, e, f]) == sum([f, g]):\n            # Return the solution as a dictionary\n            return {\n                \"a\": a,\n                \"b\": b,\n                \"c\": c,\n                \"d\": d,\n                \"e\": e,\n                \"f\": f,\n                \"g\": g\n            }\n    return None", "funcname": "main_solution", "ios": [{"input": {"numbers": [53, 17, 11, 8, 47, 36, 14]}, "output": {"a": 53, "b": 8, "c": 17, "d": 36, "e": 11, "f": 14, "g": 47}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "choroba/perlweeklychallenge-club", "path": "/challenge-109/lubos-kolouch/python/ch-2.py", "msgidx": 4406}}
{"problem_description": "Given a string, determine the index of the character that can be removed to make the string a palindrome. If the string is already a palindrome, what should be returned?", "io_requirements": "Input:\n  `s` (str): A string for which we need to determine the index of the character that can be removed to make the string a palindrome.\n\nOutput:\n  `return` (int): The index of the character that can be removed to make the string a palindrome. If the string is already a palindrome, it returns `-1`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef removechar(s, i):\n    # removes char by index from string\n    return s[:i] + s[i+1:]\n\ndef reversestring(s):\n    return s[::-1]\n\ndef is_palindromeIndex(s):\n    return s == reversestring(s)\n\n# main function\ndef main_solution(s):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Constants\n    loop_range = len(s) // 2          # divide s in two\n    last_char_index = len(s) - 1\n\n    if is_palindromeIndex(s):\n        return -1\n    else:\n        for i in range(loop_range):\n            forward_index = i\n            backward_index = last_char_index - i\n\n            forward_s = removechar(s, forward_index)\n            backward_s = removechar(s, backward_index)\n\n            if is_palindromeIndex(forward_s):\n                return forward_index\n            elif is_palindromeIndex(backward_s):\n                return backward_index\n\n    return -1", "funcname": "main_solution", "ios": [{"input": {"s": "kluei"}, "output": -1}, {"input": {"s": "wqbzt"}, "output": -1}, {"input": {"s": "luregpe"}, "output": -1}, {"input": {"s": "ymgwjhlf"}, "output": -1}, {"input": {"s": "hjvtpeotl"}, "output": -1}, {"input": {"s": "xmhul"}, "output": -1}, {"input": {"s": "jvzt"}, "output": -1}, {"input": {"s": "biszetmf"}, "output": -1}, {"input": {"s": "tpsbg"}, "output": -1}, {"input": {"s": "wulkrc"}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Eezzeldin/HackerRankChallnges", "path": "/Palindrome Index/Palindrome_Index_V1_prod.py", "msgidx": 4243}}
{"problem_description": "Given a circle of numbers from 0 to n-1, where n is a positive integer, and starting from 0, every m-th number is removed from the circle. What is the last number remaining in the circle after all deletions?", "io_requirements": "Input:\n  `n` (int): The number of elements in the circle (n > 0).\n  `m` (int): The step count to delete the next element (m > 0).\n\nOutput:\n  `return` (int): The last remaining number in the circle after all deletions.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef method(n, m):\n    if n == 0:\n        return None\n    elif n == 1:\n        return 0\n    fn_1 = 0\n    for i in range(2, n + 1):\n        fn = (fn_1 + m) % i\n        fn_1 = fn\n    return fn\n\n# main function\ndef main_solution(n, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = method(n, m)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 9, "m": 6}, "output": 6}, {"input": {"n": 77, "m": 2}, "output": 26}, {"input": {"n": 12, "m": 2}, "output": 8}, {"input": {"n": 12, "m": 8}, "output": 4}, {"input": {"n": 57, "m": 2}, "output": 50}, {"input": {"n": 17, "m": 10}, "output": 10}, {"input": {"n": 77, "m": 5}, "output": 22}, {"input": {"n": 34, "m": 3}, "output": 9}, {"input": {"n": 6, "m": 8}, "output": 2}, {"input": {"n": 14, "m": 6}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "UalwaysKnow/-offer", "path": "/offer/\u52a8\u6001\u89c4\u5212/###\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570.py", "msgidx": 4461}}
{"problem_description": "Given a graph represented by an adjacency matrix, determine whether the graph contains a Hamiltonian circuit. A Hamiltonian circuit is a path that visits each node exactly once and returns to the starting node. What is the result of checking for a Hamiltonian circuit in the given graph?", "io_requirements": "Input:\n  `graph` (list of lists of integers): A square matrix representing the adjacency matrix of a graph. Each element in the matrix is either 0 or 1, where 1 indicates an edge between two nodes and 0 indicates no edge.\n\nOutput:\n  `return` (boolean): `True` if the graph has a Hamiltonian circuit, `False` otherwise.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(graph):\n    # Convert the input graph to a list of lists if it's not already\n    if not isinstance(graph, list) or not all(isinstance(row, list) for row in graph):\n        raise ValueError(\"Input graph must be a list of lists.\")\n    \n    # Function to check if a graph has a Hamiltonian circuit\n    def graph_has_Hamiltonian_circuit(g):\n        camino = list(range(1, len(g) + 1))\n        posibles_caminos = permutations(camino)\n        \n        for i in posibles_caminos:\n            nodos_conectados = 0\n            for j in range(len(i) - 1):\n                if g[i[j] - 1][i[j + 1] - 1] == 1:\n                    nodos_conectados += 1\n                else:\n                    break\n            if g[i[-1] - 1][i[0] - 1] == 1:\n                nodos_conectados += 1\n            \n            if nodos_conectados == len(i):\n                return True\n        \n        return False\n    \n    # Call the function and return the result\n    return graph_has_Hamiltonian_circuit(graph)", "funcname": "main_solution", "ios": [{"input": {"graph": [[0, 1, 1], [1, 0, 0], [1, 0, 0]]}, "output": false}, {"input": {"graph": [[0, 0, 1, 1], [0, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]}, "output": false}, {"input": {"graph": [[0, 1, 0, 1], [1, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]}, "output": false}, {"input": {"graph": [[0, 0, 1, 0], [0, 0, 1, 1], [1, 1, 0, 0], [0, 1, 0, 0]]}, "output": false}, {"input": {"graph": [[0, 0, 0], [0, 0, 0], [0, 0, 0]]}, "output": false}, {"input": {"graph": [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]}, "output": false}, {"input": {"graph": [[0, 1, 0, 1], [1, 0, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0]]}, "output": false}, {"input": {"graph": [[0, 0, 0], [0, 0, 1], [0, 1, 0]]}, "output": false}, {"input": {"graph": [[0, 1, 1], [1, 0, 1], [1, 1, 0]]}, "output": true}, {"input": {"graph": [[0, 1, 0, 1], [1, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "leroydeniz/modelos-abstractos-de-computo", "path": "/LAB2/lab02/Code For Students/lab02_hamiltonian.py", "msgidx": 4108}}
{"problem_description": "Given a size, generate a spiral matrix where the numbers start from the center and spiral outward in a counterclockwise direction. What is the resulting spiral matrix for a given size?", "io_requirements": "Input:\n  `size` (int): The size of the spiral matrix. If the size is even, it will be incremented by 1 to make it odd.\n\nOutput:\n  `return` (list of lists of int): A 2D list representing the spiral matrix filled with numbers from 1 to `size^2`.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(size):\n    if (size % 2 != 1):  # size\u5fc5\u987b\u662f\u5947\u6570\n        size += 1\n    spiralMatrix = np.zeros([size, size], int)  # \u751f\u62100\u77e9\u9635\n    x, y, side = int(size / 2), int(size / 2), size - 1  # x,y\u5148\u521d\u59cb\u5316\u4e3a\u4e2d\u5fc3\u70b91\u7684\u5750\u6807\uff0cside\u8868\u793a\u8fb9\u957f\n    # \u751f\u6210\u5750\u6807\u7cfb\uff0c\u6e38\u6807i\u901a\u8fc7\u5224\u65ad\u5750\u6807\u6240\u5c5e\u7684\u533a\u57df\u6765\u5224\u65ad\u5750\u6807\u5e94\u8be5\u8fdb\u884c\u7684\u53d8\u5316\n    for i in range(1, size ** 2 + 1):  # \u5750\u6807\u7684\u53d8\u5316\u662f x++ , y --, x--, y++,,,i \u8868\u793a\u6240\u6709\u7684\u503c\n        spiralMatrix[y][x] = i\n        if (y >= -x + side and y >= x):    # \u5212\u5206\u56db\u4e2a\u533a\u57df\uff08\u5206\u522b\u4e3ax++ , y --, x--, y++\u7684\u533a\u57df\uff09\uff0c\u7136\u540e\u5c31\u662f\u901a\u8fc7\u76f4\u7ebf\u6765\u5206\u5f00\n            x += 1\n        elif(-x + side < y and y < x):\n            y -= 1\n        elif(y <= -x+side and y < x):\n            x -= 1\n        elif(y >= x and y < -x+side):\n            y += 1\n\n    # Convert the numpy array to a list of lists for JSON serialization\n    return spiralMatrix.tolist()", "funcname": "main_solution", "ios": [{"input": {"size": 3}, "output": [[5, 4, 3], [6, 1, 2], [7, 8, 9]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gyh62357/test2", "path": "/Study/ni.py", "msgidx": 4579}}
{"problem_description": "Given a number of pairs of parentheses, how can we generate all combinations of well-formed parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        res = []\n        def func(string, L, R):\n            if L == 0 and R == 0:\n                res.append(string)   \n                return\n            if L > 0:\n                func(string + '(', L - 1, R)\n            if R > L:\n                func(string + ')', L, R - 1)\n        func('', n, n)\n        return res\n\n# main function\ndef main_solution(n: int) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EasonYang626/leetcode", "path": "/22_\u62ec\u53f7\u751f\u6210_\u9012\u5f52.py", "msgidx": 4912}}
{"problem_description": "Given a sorted list of integers, how can we determine the first permutation of a specified number of elements from this list? Specifically, what is the first permutation of `m` elements from the sorted list `arr`?", "io_requirements": "Input:\n  `n` (int): The number of elements in the array.\n  `m` (int): The number of elements to choose in each permutation.\n  `arr` (list of int): The sorted list of integers from which permutations are to be generated.\n\nOutput:\n  `return` (str): A string representing the first permutation of `m` elements from the sorted list `arr`, with elements separated by spaces.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef permutation(arr, result, depth, m):\n    if depth == m:\n        return ' '.join(str(e) for e in result[:m])\n    for i in range(len(arr) - depth):\n        result[depth] = arr.pop(i)\n        perm = permutation(arr, result, depth + 1, m)\n        if perm:\n            return perm\n        arr.insert(i, result[depth])\n\n# main function\ndef main_solution(n, m, arr):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    arr.sort()\n    result = [0] * n\n    return permutation(arr, result, 0, m)", "funcname": "main_solution", "ios": [{"input": {"n": 3, "m": 2, "arr": [75]}, "output": "54 57"}, {"input": {"n": 5, "m": 3, "arr": [80, 97]}, "output": "22 26 34"}, {"input": {"n": 4, "m": 2, "arr": [45, 53]}, "output": "5 28"}, {"input": {"n": 6, "m": 2, "arr": [33, 47, 68, 98]}, "output": "26 31"}, {"input": {"n": 4, "m": 2, "arr": [80, 86]}, "output": "35 52"}, {"input": {"n": 3, "m": 2, "arr": [71]}, "output": "4 36"}, {"input": {"n": 5, "m": 3, "arr": [85, 88]}, "output": "1 3 20"}, {"input": {"n": 4, "m": 2, "arr": [68, 85]}, "output": "22 48"}, {"input": {"n": 5, "m": 2, "arr": [11, 61, 99]}, "output": "6 8"}, {"input": {"n": 6, "m": 3, "arr": [32, 74, 75]}, "output": "7 9 27"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pjok1122/baekjoon-online-judge-practice", "path": "/N_and_M/N_and_M(5).py", "msgidx": 4869}}
{"problem_description": "Given a string containing only lowercase letters, what are the palindromic substrings of at least 3 characters long that can be found within the string?", "io_requirements": "Input:\n  `input_string` (str): A string in which to search for palindromes. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a palindrome found in the input string. Each palindrome is at least 3 characters long.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef search_palindrome(haystack):\n    palindromes = []\n    for i in range(len(haystack)-2):\n        for j in range(2, len(haystack)-i-1):\n            switch = 1\n            for k in range(0, j//2+1):\n                if haystack[i+k] == haystack[i+j-k]:\n                    switch *= 1\n                else:\n                    switch *= 0\n            if switch == 1:\n                palindromes.append(haystack[i:i+j+1])\n    return palindromes\n\n# main function\ndef main_solution(input_string):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  palindromes = search_palindrome(input_string)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return palindromes", "funcname": "main_solution", "ios": [{"input": {"input_string": "kppnjtbwvnpk"}, "output": []}, {"input": {"input_string": "baivdnkofuywn"}, "output": []}, {"input": {"input_string": "lizndbernubaiuurymy"}, "output": []}, {"input": {"input_string": "mnnhrqiakcjmiytuubsc"}, "output": []}, {"input": {"input_string": "vhxvvgiccs"}, "output": []}, {"input": {"input_string": "lxtczmbszejikzldlp"}, "output": ["ldl"]}, {"input": {"input_string": "bjvngaxlwe"}, "output": []}, {"input": {"input_string": "lqyiogfabou"}, "output": []}, {"input": {"input_string": "tluefcbbmbxzzyjxwr"}, "output": ["bmb"]}, {"input": {"input_string": "qbkernvlkro"}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "green-fox-academy/sepgab", "path": "/Week-02/weekly-project/searchpalindrome.py", "msgidx": 4775}}
{"problem_description": "You are tasked with initializing the docking program for a ferry using a sea port's computer system. The system uses a bitmask to modify memory addresses and values before writing them to memory. Given a set of initialization instructions, what is the sum of all values left in memory after the initialization program completes?", "io_requirements": "Input:\n  `data` (list of strings): A list of strings representing the initialization program. Each string can either be a mask definition (e.g., \"mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X\") or a memory write instruction (e.g., \"mem[8] = 11\").\n\nOutput:\n  `return` (int): The sum of all values left in memory after the initialization program completes.", "refcode": "# import necessary packages\nimport re\n\n# Function to apply the mask to memory addresses and values\ndef applymask(mask, offset, addr, val, mem):\n    if offset == len(mask):\n        mem[addr] = val\n    else:\n        if mask[offset] == \"X\":\n            addr |= 2**offset\n            applymask(mask, offset + 1, addr, val, mem)\n            addr -= 2**offset\n            applymask(mask, offset + 1, addr, val, mem)\n        elif mask[offset] == \"1\":\n            addr |= 2**offset\n            applymask(mask, offset + 1, addr, val, mem)\n        elif mask[offset] == \"0\":\n            applymask(mask, offset + 1, addr, val, mem)\n\n# Main function to solve the problem\ndef main_solution(data):\n    mem = {}\n    mask = \"\"\n\n    for line in data:\n        if line.startswith(\"mask\"):\n            mask = line.split(\" \")[2][::-1]\n        elif line.startswith(\"mem\"):\n            m = re.fullmatch(\"mem\\[(\\d+)\\] = (\\d+)\", line)\n            applymask(mask, 0, int(m.group(1)), int(m.group(2)), mem)\n\n    return sum(mem.values())", "funcname": "main_solution", "ios": [{"input": {"data": ["mem[96] = 560", "mem[64] = 504", "mask = 10X0XX00XXXX0X01000X0X0111100X000X00", "mask = 0101001X10X010110111X11X11XXX101X111", "mask = X001X00X1XXX010XXXXX100XX01100110100", "mem[91] = 65"]}, "output": 533544}, {"input": {"data": ["mem[81] = 928", "mem[63] = 356", "mask = 110XX0XXXX1101X11X101X0X0X1X00X0X100", "mask = 1000111XX0XX0X000X0001100X011X0XXXXX", "mask = X0X110X1X00X100X1X110XXX00XX101101XX", "mem[10] = 799", "mem[87] = 936", "mask = X0X1X0X01XX00101X1110XX1011XXX10X110"]}, "output": 28427524}, {"input": {"data": ["mask = 1010X1110XXX1X1111000010X11111X0XXXX", "mask = X1XX10101XX0XXX1XX11010XXXXXXX010X01", "mask = 1X00X1001100100010X01X1X0X0X0XXX10XX", "mask = 1X11XX0XX1XXX11X010X1X010XXX00X10010", "mem[46] = 616", "mask = 1XX01X1X0X110X1110XX10X0X1X0X110X100"]}, "output": 20185088}, {"input": {"data": ["mask = 11X100XX0XX1X110XX0X11XXX1XXX1100X10", "mem[22] = 729", "mask = 111101X1X11X1XX10X00011111X011X10010", "mem[85] = 743", "mem[25] = 17", "mask = 0X101XXX110XX0101X0XX1X0X0111011X010", "mem[0] = 732", "mask = 01X001011X10X101X101X0101X1XX0XX000X"]}, "output": 50968576}, {"input": {"data": ["mask = 1100X11XX1011X00X1X0X1111X0XXX1XXX01", "mem[76] = 466", "mask = 1XX11101XXX01101XX001X10X01X11XX1X00", "mask = 0X0X1X00X1X001XX0010XX11010XXXX1X010", "mem[46] = 357"]}, "output": 13484032}, {"input": {"data": ["mask = X010X101X1XX011X01000X1X1XX0XXXX0X1X", "mask = X10110X11XX0X001X01XX1XXX00X1010111X", "mem[96] = 973", "mask = X01XX011101001X01X10110X010X0X1111X1", "mem[40] = 691", "mem[93] = 16", "mask = 111X100XX01X0XXXX0111XX0XX1000101111"]}, "output": 7979008}, {"input": {"data": ["mem[55] = 304", "mask = 0X11101XX100XX0X011X1XXXX1X1X01X1111", "mask = XX0X0XX0X0XXX1XX10X0XXX10XX01111X0X1", "mask = 11X10X110X101001X11X1X11XXX11X101X1X", "mem[78] = 730"]}, "output": 2990384}, {"input": {"data": ["mem[26] = 333", "mask = X000X01X000X11XX0XX101010100X010X0X0", "mask = X1X10100000110X100X11XX0100X11110100", "mem[69] = 648", "mem[52] = 289", "mask = 00010010101110101X0X1XXXX1111X11X100", "mem[71] = 990", "mask = 0X01110XX0X01111X0101000X000X110110X"]}, "output": 373709}, {"input": {"data": ["mask = X0101XXXXX1100X1111X01XX0101111X1X10", "mem[22] = 178", "mem[54] = 372", "mask = XX0X10XXX010X01001XX10X01100111X01XX", "mem[30] = 349", "mem[23] = 466", "mem[97] = 119", "mask = X00010X0X0X010X000011XXX001X11XX011X"]}, "output": 5357568}, {"input": {"data": ["mask = X101XX1XX0XX0111XX01XXXX1X011X1X10X0", "mem[44] = 179", "mask = 0000100X1X011110X0011XXXX01X0XX01X01", "mem[66] = 815", "mask = 010X10100X1XX00XXX0X101XXXX01XX10100", "mem[4] = 848"]}, "output": 39024640}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "a-falcone/puzzles", "path": "/adventofcode/2020/14b.py", "msgidx": 4356}}
{"problem_description": "In a parking lot with only one empty spot, cars need to be rearranged from an initial state to a final state. Each step allows only one car to be moved into the empty spot. Given the initial and final states of the parking lot, how many steps are required to achieve the final state, and what is the sequence of intermediate states?", "io_requirements": "Input:\n  `initial_state` (list of integers): The initial state of the parking lot. Each integer represents a car, and 0 represents the empty spot.\n  `final_state` (list of integers): The final desired state of the parking lot. Each integer represents a car, and 0 represents the empty spot.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `steps` (integer): The minimum number of steps required to rearrange the parking lot from the initial state to the final state.\n    - `sequence` (list of lists of integers): The sequence of states from the initial state to the final state, where each state is represented as a list of integers.", "refcode": "# import necessary packages\nimport copy\n\n# main function\ndef main_solution(initial_state, final_state):\n  # Convert input lists to JSON serializable format\n  initial = copy.deepcopy(initial_state)\n  final = copy.deepcopy(final_state)\n  \n  step = 0\n  seq = []\n  while initial != final:\n    zero_index = initial.index(0)\n    if zero_index != final.index(0):\n      ele_to_move = initial.index(final[zero_index])\n      initial[zero_index], initial[ele_to_move] = initial[ele_to_move], initial[zero_index]\n    else:\n      for i in range(len(initial)):\n        if initial[i] != final[i]:\n          initial[i], initial[zero_index] = initial[zero_index], initial[i]\n          break\n    step += 1\n    seq.append(copy.deepcopy(initial))\n  \n  # Convert output to JSON serializable format\n  return {\"steps\": step, \"sequence\": seq}", "funcname": "main_solution", "ios": [{"input": {"initial_state": [3, 1, 0, 4, 2], "final_state": [0, 1, 3, 4, 2]}, "output": {"steps": 1, "sequence": [[0, 1, 3, 4, 2]]}}, {"input": {"initial_state": [3, 1, 4, 0, 2], "final_state": [3, 4, 1, 0, 2]}, "output": {"steps": 3, "sequence": [[3, 0, 4, 1, 2], [3, 4, 0, 1, 2], [3, 4, 1, 0, 2]]}}, {"input": {"initial_state": [2, 4, 1, 3, 0], "final_state": [2, 0, 1, 4, 3]}, "output": {"steps": 2, "sequence": [[2, 4, 1, 0, 3], [2, 0, 1, 4, 3]]}}, {"input": {"initial_state": [2, 4, 1, 0, 3], "final_state": [3, 4, 0, 2, 1]}, "output": {"steps": 3, "sequence": [[0, 4, 1, 2, 3], [3, 4, 1, 2, 0], [3, 4, 0, 2, 1]]}}, {"input": {"initial_state": [0, 2, 4, 1, 3], "final_state": [4, 2, 1, 0, 3]}, "output": {"steps": 2, "sequence": [[4, 2, 0, 1, 3], [4, 2, 1, 0, 3]]}}, {"input": {"initial_state": [0, 3, 4, 1, 2], "final_state": [4, 2, 3, 1, 0]}, "output": {"steps": 3, "sequence": [[4, 3, 0, 1, 2], [4, 0, 3, 1, 2], [4, 2, 3, 1, 0]]}}, {"input": {"initial_state": [1, 4, 0, 3, 2], "final_state": [0, 3, 4, 1, 2]}, "output": {"steps": 3, "sequence": [[1, 0, 4, 3, 2], [1, 3, 4, 0, 2], [0, 3, 4, 1, 2]]}}, {"input": {"initial_state": [4, 1, 0, 3, 2], "final_state": [3, 4, 1, 0, 2]}, "output": {"steps": 3, "sequence": [[4, 0, 1, 3, 2], [0, 4, 1, 3, 2], [3, 4, 1, 0, 2]]}}, {"input": {"initial_state": [0, 1, 3, 4, 2], "final_state": [1, 3, 0, 4, 2]}, "output": {"steps": 2, "sequence": [[1, 0, 3, 4, 2], [1, 3, 0, 4, 2]]}}, {"input": {"initial_state": [0, 3, 1, 4, 2], "final_state": [0, 3, 2, 4, 1]}, "output": {"steps": 3, "sequence": [[1, 3, 0, 4, 2], [1, 3, 2, 4, 0], [0, 3, 2, 4, 1]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "turpure/py_algo", "path": "/py_alg/play_array/garage.py", "msgidx": 4938}}
{"problem_description": "Given a string of unique characters, what are all the possible permutations of the characters in the string, sorted in dictionary order?", "io_requirements": "Input:\n  `input_string` (str): A string of characters for which the permutations need to be generated. The string should not contain duplicate characters.\n\nOutput:\n  `return` (list of str): A list of strings representing all possible permutations of the input string, sorted in lexicographical order.", "refcode": "# import necessary packages\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef isduplicate(li, n, t):\n    \"\"\"\n    \u4eceli\u7684\u4f4d\u7f6en\u5230\u4f4d\u7f6et-1\uff0c\u6709\u6ca1\u6709\u548cli[t]\u76f8\u7b49\u7684\u6570\u5b57\n    \"\"\"\n    while n < t:\n        if li[n] == li[t]:\n            return True\n        n += 1\n    return False\n\ndef swap(li, i, j):\n    if i == j:\n        return\n    temp = li[j]\n    li[j] = li[i]\n    li[i] = temp\n\ndef permutation(li, size, n, result):\n    '''\n    n -> size\u7684\u5168\u6392\u5217\n    :param li: \u5b57\u7b26\u4e32\u6570\u7ec4\n    :param size: \u5b57\u7b26\u4e32\u957f\u5ea6\n    :param n: \u5f53\u524d\u8981\u5360\u7684\u4f4d\u7f6e\n    :param result: \u4fdd\u7559\u7684\u7ed3\u679c\n    :return:\n    '''\n    if n == size - 1:\n        result.append(''.join(deepcopy(li)))\n        return\n    for i in list(range(n, size)):\n        if isduplicate(li, n, i):\n            continue\n        swap(li, i, n)\n        permutation(li, size, n + 1, result)\n        swap(li, i, n)\n\n# main function\ndef main_solution(input_string):\n  # Convert the input string to a list of characters\n  li = list(input_string)\n  size = len(li)\n  n = 0\n  result = []\n  permutation(li, size, n, result)\n  \n  # Convert the result list to a sorted list of strings\n  result = sorted(result)\n  \n  # Return the result as a JSON serializable list of strings\n  return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "xkn"}, "output": ["knx", "kxn", "nkx", "nxk", "xkn", "xnk"]}, {"input": {"input_string": "dhl"}, "output": ["dhl", "dlh", "hdl", "hld", "ldh", "lhd"]}, {"input": {"input_string": "npx"}, "output": ["npx", "nxp", "pnx", "pxn", "xnp", "xpn"]}, {"input": {"input_string": "zpc"}, "output": ["cpz", "czp", "pcz", "pzc", "zcp", "zpc"]}, {"input": {"input_string": "usm"}, "output": ["msu", "mus", "smu", "sum", "ums", "usm"]}, {"input": {"input_string": "eys"}, "output": ["esy", "eys", "sey", "sye", "yes", "yse"]}, {"input": {"input_string": "rvh"}, "output": ["hrv", "hvr", "rhv", "rvh", "vhr", "vrh"]}, {"input": {"input_string": "lby"}, "output": ["bly", "byl", "lby", "lyb", "ybl", "ylb"]}, {"input": {"input_string": "cwy"}, "output": ["cwy", "cyw", "wcy", "wyc", "ycw", "ywc"]}, {"input": {"input_string": "irp"}, "output": ["ipr", "irp", "pir", "pri", "rip", "rpi"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EdisonZhu33/Algorithm", "path": "/\u5251\u6307offer/027-\u5b57\u7b26\u4e32\u7684\u5168\u6392\u5217.py", "msgidx": 4930}}
{"problem_description": "A person and their mom have noticed that their ages, when reversed, match each other's ages six times so far. They believe that if they are lucky, this will happen two more times in the future, making it a total of eight times. Given the age difference between the person and their mom, how old is the person now when this has happened six times?", "io_requirements": "Input:\n  `age_difference` (str): A string representing the age difference between the user and their mom. This should be a two-digit number.\n\nOutput:\n  `return` (str): A string representing the current age of the user. If no solution is found, it returns \"No solution found\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_reverse(a, b):\n    return b == a[::-1]\n\n# main function\ndef main_solution(age_difference):\n    # Convert the age_difference to an integer\n    age_difference = int(age_difference)\n    \n    # Find the age difference that results in 8 reversible age pairs\n    diff = age_difference\n    while diff < 50:\n        ctr = 0\n        my_age = 0\n        while my_age < 99:\n            mom_age = my_age + diff\n            if is_reverse(str(my_age).zfill(2), str(mom_age)):\n                ctr += 1\n                if ctr == 8:\n                    # Find the current age when the counter is 6\n                    mom_age = my_age + diff\n                    my_age = 0\n                    ctr = 0\n                    while my_age < 99:\n                        if is_reverse(str(my_age).zfill(2), str(mom_age)):\n                            ctr += 1\n                            if ctr == 6:\n                                return str(my_age)\n                        mom_age += 1\n                        my_age += 1\n            my_age += 1\n        diff += 1\n    return \"No solution found\"", "funcname": "main_solution", "ios": [{"input": {"age_difference": "26"}, "output": "No solution found"}, {"input": {"age_difference": "23"}, "output": "No solution found"}, {"input": {"age_difference": "20"}, "output": "No solution found"}, {"input": {"age_difference": "21"}, "output": "No solution found"}, {"input": {"age_difference": "37"}, "output": "No solution found"}, {"input": {"age_difference": "35"}, "output": "No solution found"}, {"input": {"age_difference": "49"}, "output": "No solution found"}, {"input": {"age_difference": "38"}, "output": "No solution found"}, {"input": {"age_difference": "19"}, "output": "No solution found"}, {"input": {"age_difference": "47"}, "output": "No solution found"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Praveen-Murugan/thinkpython", "path": "/Chapter 9/Exercise_9_9.py", "msgidx": 4706}}
{"problem_description": "Given a sequence of mathematical operations starting with the number 3, determine if performing these operations in order will result in a specific target number. The operations allowed are taking the square root (\"sqrt\"), calculating the factorial (\"fact\"), and taking the floor value (\"floor\"). What is the result of applying the given sequence of operations to the number 3 and comparing it to the target number?", "io_requirements": "Input:\n  `expression` (str): A string representing a sequence of actions separated by spaces. Valid actions are \"3\", \"sqrt\", \"fact\", and \"floor\".\n  `target` (int): An integer representing the target value to be reached by performing the actions in the expression.\n\nOutput:\n  `return` (str): A string indicating the result of the evaluation. It can be either \"TARGET FOUND\" if the target is reached, or \"TARGET NOT FOUND\" if the target is not reached.", "refcode": "# import necessary packages\nimport math\nfrom decimal import Decimal\n\n# main function\ndef main_solution(expression, target):\n    # Convert the expression string into a list of actions\n    actions = expression.split()\n    current_value = 0\n    \n    # Perform each action in the expression\n    for action in actions:\n        if current_value == 0 and action != \"3\":\n            return 99999999  # Invalid start\n        elif action == \"3\" and current_value == 0:\n            current_value = 3\n        elif action == \"sqrt\":\n            if current_value < (1 << 100):\n                current_value = Decimal(math.sqrt(current_value))\n            else:\n                approximation = 1 << ((int(current_value).bit_length() + 1) >> 1)\n                while True:\n                    new_approx = (approximation + int(current_value) // approximation) >> 1\n                    if new_approx >= approximation:\n                        current_value = approximation\n                        break\n                    approximation = new_approx\n        elif action == \"fact\":\n            if current_value >= 720:\n                return 99999999  # Too large\n            current_value = Decimal(math.factorial(int(current_value)))\n        elif action == \"floor\":\n            current_value = math.floor(Decimal(current_value))\n        else:\n            return 99999999  # Invalid action\n    \n    # Check if the target is reached\n    if current_value == target:\n        return \"TARGET FOUND\"\n    else:\n        return \"TARGET NOT FOUND\"", "funcname": "main_solution", "ios": [{"input": {"expression": "3 floor floor 3 floor fact", "target": 87}, "output": 99999999}, {"input": {"expression": "3 3 floor 3", "target": 99}, "output": 99999999}, {"input": {"expression": "3 sqrt 3", "target": 19}, "output": 99999999}, {"input": {"expression": "3 sqrt floor fact", "target": 47}, "output": "TARGET NOT FOUND"}, {"input": {"expression": "3 3 sqrt fact", "target": 62}, "output": 99999999}, {"input": {"expression": "3 fact", "target": 33}, "output": "TARGET NOT FOUND"}, {"input": {"expression": "3 3 floor", "target": 76}, "output": 99999999}, {"input": {"expression": "3 3 fact sqrt", "target": 44}, "output": 99999999}, {"input": {"expression": "3 fact sqrt sqrt", "target": 67}, "output": "TARGET NOT FOUND"}, {"input": {"expression": "3 sqrt sqrt floor", "target": 88}, "output": "TARGET NOT FOUND"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "minhleeit/Group1-KnuthsExpression", "path": "/knuth_problem_update_10_6.py", "msgidx": 4542}}
{"problem_description": "Given a specific length `N` for a binary string that must start and end with '1', and a requirement to find `J` distinct such strings (called jamcoins), each of which is not a prime number in any base from 2 to 10, what are the jamcoins and their corresponding non-trivial divisors for each base?", "io_requirements": "Input:\n  `N` (int): The length of the jamcoin string, which must start and end with '1'.\n  `J` (int): The number of distinct jamcoins to find.\n\nOutput:\n  `return` (list of lists): A list where each element is a list containing a jamcoin string (str) and a list of its non-trivial divisors (list of ints) for each base from 2 to 10.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef changeBase(num, base):\n    newnum = 0\n    power = len(num) - 1\n    for i in num:\n        newnum += int(i) * (base ** power)\n        power -= 1\n    return newnum\n\ndef isPrime(num):\n    if num % 2 == 0:\n        return 2\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return i\n    return -1\n\ndef validate(J_str):\n    bases = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    base_factors = []\n    for b in bases:\n        newnum = changeBase(J_str, b)\n        check = isPrime(newnum)\n        if check == -1:\n            return False, []\n        else:\n            base_factors.append(check)\n    return True, base_factors\n\ndef calculate(N, J):\n    J_str = '1' + '0' * (N - 2) + '1'\n    J_found = []\n    J_count = 0\n    for i in range(0, (N - 2) ** 2):\n        binnm = str(bin(i))[2:]\n        J_str = '1' + binnm.zfill(N - 2) + '1'\n        valid, factors = validate(J_str)\n        if not valid:\n            continue\n        J_count += 1\n        J_found.append([J_str, factors])\n        if J_count >= J:\n            return J_found\n    return J_found\n\n# main function\ndef main_solution(N, J):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = calculate(N, J)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"N": 3, "J": 5}, "output": []}, {"input": {"N": 4, "J": 1}, "output": [["1001", [3, 2, 5, 2, 7, 2, 3, 2, 7]]]}, {"input": {"N": 9, "J": 1}, "output": [["100000011", [7, 5, 3, 31, 11, 3, 5, 7, 3]]]}, {"input": {"N": 8, "J": 1}, "output": [["10000001", [3, 2, 5, 2, 7, 2, 3, 2, 11]]]}, {"input": {"N": 2, "J": 3}, "output": []}, {"input": {"N": 10, "J": 2}, "output": [["1000000001", [3, 2, 5, 2, 7, 2, 3, 2, 7]], ["1000000111", [3, 2, 5, 2, 7, 2, 3, 2, 11]]]}, {"input": {"N": 3, "J": 1}, "output": []}, {"input": {"N": 3, "J": 4}, "output": []}, {"input": {"N": 6, "J": 1}, "output": [["100001", [3, 2, 5, 2, 7, 2, 3, 2, 11]]]}, {"input": {"N": 4, "J": 5}, "output": [["1001", [3, 2, 5, 2, 7, 2, 3, 2, 7]], ["1111", [3, 2, 5, 2, 7, 2, 3, 2, 11]]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DaHuO/Supergraph", "path": "/codes/CodeJamCrawler/16_0_3/timmyphysics/c.py", "msgidx": 4478}}
{"problem_description": "In a river crossing puzzle, a farmer needs to transport a goat, a cabbage, and a wolf from one side of the river to the other using a boat. The farmer can only take one item at a time, and there are certain constraints: the goat cannot be left alone with the cabbage (as the goat would eat the cabbage), and the wolf cannot be left alone with the goat (as the wolf would eat the goat). Given the initial state of the left and right sides of the river, what is the sequence of states that the farmer must follow to successfully transport all items to the other side without any of them being eaten?", "io_requirements": "Input:\n  `initial_left` (List[str]): A list of strings representing the initial state of the left side of the river. Each string can be one of 'f', 'g', 'c', 'w' representing the farmer, goat, cabbage, and wolf respectively.\n  `initial_right` (List[str]): A list of strings representing the initial state of the right side of the river. Each string can be one of 'f', 'g', 'c', 'w' representing the farmer, goat, cabbage, and wolf respectively.\n\nOutput:\n  `return` (List[str]): A list of strings representing the sequence of states that represent the solution. Each string is formatted as \"State [left side: [...], right side: [...]]\".", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass State:\n    \"\"\"\n    Represents a state.\n    \"\"\"\n\n    value = {'f': 10000, 'g': 1, 'c': 50, 'w': 100000}\n\n    def __init__(self, left: List[str] = None, right: List[str] = None):\n        self.leftSide = left\n        self.rightSide = right\n\n    def next(self) -> List['State']:\n        \"\"\"\n        Generates a list of next possible states.\n        \n        Returns:\n            List['State']: The list of next possible states.\n        \"\"\"\n        states = []\n\n        # getting the side with the farmer\n        farmerSide = self.leftSide if 'f' in self.leftSide else self.rightSide\n\n        # looping through every thing in the farmer side except the farmer\n        for thing in [i for i in farmerSide if i != 'f']:\n            # getting the state after moving the farmer and the thing to the \n            # other side\n            nextState = State.__moveFarmerAndThing(self, thing)\n            # if state is a valid state and it is not visited,\n            # append it. \n            if nextState.isValid():\n                states.append(nextState)\n\n        # checking if the farmer was on the right side. If he was on the right side\n        # another state is possible. That state is when the farmer comes back alone\n        if farmerSide == self.rightSide:\n            # making the state\n            nextState = State(\n                # adding farmer to the left side\n                left=self.leftSide + ['f'],\n                # removing farmer from right side\n                right=[i for i in self.rightSide if i != 'f']\n            )\n            # appending the state if the state is valid\n            if nextState.isValid():\n                states.append(nextState)\n\n        return states\n\n    def isValid(self) -> bool:\n        \"\"\"\n        checks whether the state is valid or not.\n        \n        Returns:\n            bool: True, if the state is valid, False otherwise.\n        \"\"\"\n        # if there is a goat and wolf on the side where the farmer is not there then return false\n        if ('w' in self.leftSide and 'g' in self.leftSide and 'f' not in self.leftSide) or \\\n           ('w' in self.rightSide and 'g' in self.rightSide and 'f' not in self.rightSide):\n            return False\n        # if there is a cabbage and a goat on the side the farmer is not there then return false\n        if ('c' in self.leftSide and 'g' in self.leftSide and 'f' not in self.leftSide) or \\\n           ('c' in self.rightSide and 'g' in self.rightSide and 'f' not in self.rightSide):\n            return False\n\n        # else return true\n        return True\n\n    def __int__(self) -> int:\n        \"\"\"\n        Maps the state to a unique key based on contents. The things on the left side\n        are added to the key, and the things on the right side are subtracted from the\n        key.\n        \n        Returns:\n            int: The value of the key\n        \"\"\"\n        key = 0\n        for thing in self.leftSide:\n            key += State.value[thing]\n        \n        for thing in self.rightSide:\n            key -= State.value[thing]\n        return key\n\n    def __str__(self) -> str:\n        return \"State [left side: {}, right side: {}\".format(self.leftSide, self.rightSide)\n\n    @staticmethod\n    def __moveFarmerAndThing(state, thing) -> 'State':\n        \"\"\"\n        Moves farmer and a thing from one side to another.\n        \n        Returns:\n            'State': The state that result in such movement.\n        \"\"\"\n\n        # if the farmer is on the left side, run if body\n        if 'f' in state.leftSide:\n            return State(\n                # removing farmer and `thing` from left side\n                left=[i for i in state.leftSide if i != 'f' and i != thing],\n                # adding farmer and `thing` to right side\n                right=state.rightSide + ['f', thing]\n            )\n\n        # this code runs when the farmer is on the right side. \n        return State(\n            # adding farmer and `thing` to the left side\n            left=state.leftSide + ['f', thing],\n            # removing farmer and `thing` from right side\n            right=[i for i in state.rightSide if i != 'f' and i != thing]\n        )\n        \n\n    @staticmethod\n    def initial() -> 'State':\n        \"\"\"\n        Returns the initial state.\n        \n        Returns:\n            State: The initial state.\n        \"\"\"\n\n        return State(left=['f', 'g', 'c', 'w'], right=[])\n\n# main function\ndef main_solution(initial_left: List[str], initial_right: List[str]) -> List[str]:\n    \"\"\"\n    Solves the problem of moving the farmer, goat, cabbage, and wolf to the other side of the river.\n    \n    Args:\n        initial_left (List[str]): The initial state of the left side of the river.\n        initial_right (List[str]): The initial state of the right side of the river.\n    \n    Returns:\n        List[str]: The sequence of states that represent the solution.\n    \"\"\"\n    initialState = State(left=initial_left, right=initial_right)\n    q = [initialState]\n    visited = []\n    solution_states = []\n\n    while len(q) != 0:\n        currentState = q.pop(0)\n\n        if int(currentState) in visited:\n            continue\n\n        solution_states.append(str(currentState))\n        visited.append(int(currentState))\n        nextStates = currentState.next()\n\n        for _state in nextStates:\n            if int(_state) not in visited:\n                q.append(_state)\n\n    return solution_states", "funcname": "main_solution", "ios": [{"input": {"initial_left": ["f", "w"], "initial_right": ["c", "g"]}, "output": ["State [left side: ['f', 'w'], right side: ['c', 'g']", "State [left side: [], right side: ['c', 'g', 'f', 'w']", "State [left side: ['f', 'g'], right side: ['c', 'w']"]}, {"input": {"initial_left": ["w", "f", "g"], "initial_right": ["c"]}, "output": ["State [left side: ['w', 'f', 'g'], right side: ['c']", "State [left side: ['g'], right side: ['c', 'f', 'w']", "State [left side: ['w'], right side: ['c', 'f', 'g']", "State [left side: ['g', 'f', 'c'], right side: ['w']", "State [left side: ['g', 'f'], right side: ['c', 'w']", "State [left side: ['w', 'f', 'c'], right side: ['g']", "State [left side: ['c'], right side: ['w', 'f', 'g']", "State [left side: [], right side: ['c', 'w', 'f', 'g']"]}, {"input": {"initial_left": ["w"], "initial_right": ["f", "g", "c"]}, "output": ["State [left side: ['w'], right side: ['f', 'g', 'c']", "State [left side: ['w', 'f', 'g'], right side: ['c']", "State [left side: ['w', 'f', 'c'], right side: ['g']", "State [left side: ['g'], right side: ['c', 'f', 'w']", "State [left side: ['c'], right side: ['g', 'f', 'w']", "State [left side: ['g', 'f', 'c'], right side: ['w']", "State [left side: ['g', 'f'], right side: ['c', 'w']", "State [left side: [], right side: ['c', 'w', 'f', 'g']"]}, {"input": {"initial_left": ["w"], "initial_right": ["c", "f", "g"]}, "output": ["State [left side: ['w'], right side: ['c', 'f', 'g']", "State [left side: ['w', 'f', 'c'], right side: ['g']", "State [left side: ['w', 'f', 'g'], right side: ['c']", "State [left side: ['c'], right side: ['g', 'f', 'w']", "State [left side: ['g'], right side: ['c', 'f', 'w']", "State [left side: ['c', 'f', 'g'], right side: ['w']", "State [left side: ['g', 'f'], right side: ['c', 'w']", "State [left side: [], right side: ['c', 'w', 'f', 'g']"]}, {"input": {"initial_left": ["g", "f"], "initial_right": ["w", "c"]}, "output": ["State [left side: ['g', 'f'], right side: ['w', 'c']", "State [left side: [], right side: ['w', 'c', 'f', 'g']"]}, {"input": {"initial_left": ["c", "f"], "initial_right": ["g", "w"]}, "output": ["State [left side: ['c', 'f'], right side: ['g', 'w']", "State [left side: [], right side: ['g', 'w', 'f', 'c']", "State [left side: ['f', 'g'], right side: ['w', 'c']"]}, {"input": {"initial_left": ["g"], "initial_right": ["c", "w", "f"]}, "output": ["State [left side: ['g'], right side: ['c', 'w', 'f']", "State [left side: ['g', 'f', 'c'], right side: ['w']", "State [left side: ['g', 'f', 'w'], right side: ['c']", "State [left side: ['g', 'f'], right side: ['c', 'w']", "State [left side: ['c'], right side: ['w', 'f', 'g']", "State [left side: ['w'], right side: ['c', 'f', 'g']", "State [left side: [], right side: ['c', 'w', 'f', 'g']", "State [left side: ['c', 'f', 'w'], right side: ['g']"]}, {"input": {"initial_left": ["g"], "initial_right": ["f", "c", "w"]}, "output": ["State [left side: ['g'], right side: ['f', 'c', 'w']", "State [left side: ['g', 'f', 'c'], right side: ['w']", "State [left side: ['g', 'f', 'w'], right side: ['c']", "State [left side: ['g', 'f'], right side: ['c', 'w']", "State [left side: ['c'], right side: ['w', 'f', 'g']", "State [left side: ['w'], right side: ['c', 'f', 'g']", "State [left side: [], right side: ['c', 'w', 'f', 'g']", "State [left side: ['c', 'f', 'w'], right side: ['g']"]}, {"input": {"initial_left": ["w"], "initial_right": ["g", "c", "f"]}, "output": ["State [left side: ['w'], right side: ['g', 'c', 'f']", "State [left side: ['w', 'f', 'g'], right side: ['c']", "State [left side: ['w', 'f', 'c'], right side: ['g']", "State [left side: ['g'], right side: ['c', 'f', 'w']", "State [left side: ['c'], right side: ['g', 'f', 'w']", "State [left side: ['g', 'f', 'c'], right side: ['w']", "State [left side: ['g', 'f'], right side: ['c', 'w']", "State [left side: [], right side: ['c', 'w', 'f', 'g']"]}, {"input": {"initial_left": ["g", "f", "c"], "initial_right": ["w"]}, "output": ["State [left side: ['g', 'f', 'c'], right side: ['w']", "State [left side: ['c'], right side: ['w', 'f', 'g']", "State [left side: ['g'], right side: ['w', 'f', 'c']", "State [left side: ['c', 'f', 'w'], right side: ['g']", "State [left side: ['g', 'f', 'w'], right side: ['c']", "State [left side: ['g', 'f'], right side: ['w', 'c']", "State [left side: ['w'], right side: ['g', 'f', 'c']", "State [left side: [], right side: ['w', 'c', 'f', 'g']"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rahulbansal16/theBetterEducationProject", "path": "/Lecture-2/code/wolf_goat_cabbage.py", "msgidx": 3839}}
{"problem_description": "Given a sequence of hydrogen and oxygen atoms represented by the characters 'H' and 'O', how can we group these atoms to form water molecules ('H2O') while ensuring that all atoms from one molecule bond before any atoms from the next molecule do? What will be the sequence of atoms in the order they bond?", "io_requirements": "Input:\n  `input_string` (str): A string composed of 'H' and 'O' characters, where 'H' represents hydrogen and 'O' represents oxygen. The length of the string will be 3n, where 1 \u2264 n \u2264 20, and there will be exactly 2n 'H' characters and n 'O' characters.\n\nOutput:\n  `return` (str): A string representing the sequence of atoms in the order they bond to form water molecules. The output string will contain the same number of 'H' and 'O' characters as the input string, grouped into valid 'H2O' molecules.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(input_string: str) -> str:\n    \"\"\"\n    This function takes an input string composed of 'H' and 'O' characters, representing hydrogen and oxygen atoms respectively.\n    It groups these atoms into water molecules ('H2O') and returns the sequence of atoms in the order they bond.\n    \n    Input:\n    - input_string (str): A string composed of 'H' and 'O' characters, where 'H' represents hydrogen and 'O' represents oxygen.\n    \n    Output:\n    - return (str): A string representing the sequence of atoms in the order they bond to form water molecules.\n    \"\"\"\n    h2o_generator = H2O()\n    output_sequence = []\n\n    for char in input_string:\n        if char == 'H':\n            h2o_generator.hydrogen(lambda: output_sequence.append('H'))\n        elif char == 'O':\n            h2o_generator.oxygen(lambda: output_sequence.append('O'))\n\n    return ''.join(output_sequence)\n\nclass H2O:\n    def __init__(self):\n        self.hq = deque()\n        self.oq = deque()\n\n    def hydrogen(self, releaseHydrogen):\n        self.hq.append(releaseHydrogen)\n        self.try_output()\n\n    def oxygen(self, releaseOxygen):\n        self.oq.append(releaseOxygen)\n        self.try_output()\n\n    def try_output(self):\n        if len(self.hq) >= 2 and len(self.oq) >= 1:\n            self.hq.popleft()()\n            self.hq.popleft()()\n            self.oq.popleft()()", "funcname": "main_solution", "ios": [{"input": {"input_string": "OHOHHHHHHHHHHHHHHH"}, "output": "HHOHHO"}, {"input": {"input_string": "OOHHOHHHOHHHHHHHHHHOHHOHOHOOHHOHHHHHHOHHHHHOHOOH"}, "output": "HHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHO"}, {"input": {"input_string": "HHHHHOHOOHHHHOHOOH"}, "output": "HHOHHOHHOHHOHHOHHO"}, {"input": {"input_string": "HHHHHHHOHHHOOHOHHHHHHHOHOHHHHHHHHHHHOOHOHOHHHHHOOHO"}, "output": "HHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHO"}, {"input": {"input_string": "HHHOOHHOHHOHHOOHHHHOHHHHHHHHOH"}, "output": "HHOHHOHHOHHOHHOHHOHHOHHO"}, {"input": {"input_string": "OHHHHHHHOOHHHOHOHHHHOHHHOOHHOHHHHHOHOOHOHO"}, "output": "HHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHOHHO"}, {"input": {"input_string": "HHHHHOHHOHHHHOHHHOHHOHHHHHHOOH"}, "output": "HHOHHOHHOHHOHHOHHOHHO"}, {"input": {"input_string": "HOHOOHOHHHHOHHHHHO"}, "output": "HHOHHOHHOHHOHHOHHO"}, {"input": {"input_string": "HOOHHHOHHHHHHOHHHH"}, "output": "HHOHHOHHOHHO"}, {"input": {"input_string": "HHHHHHHHHHHHHHHHHHHOHHHOHHHOHH"}, "output": "HHOHHOHHO"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "syurskyi/Algorithms_and_Data_Structure", "path": "/_algorithms_challenges/leetcode/LeetCode/1117 Building H2O.py", "msgidx": 4417}}
{"problem_description": "Given a number `n`, how many permutations can be generated from a set of `n` distinct items, and what are those permutations?", "io_requirements": "Input:\n  `n` (int): An integer representing the number of items to permute.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `number_of_permutations` (int): The total number of permutations.\n    - `permutations` (list of str): A list of strings where each string represents a permutation of the numbers from 1 to `n`.", "refcode": "# import necessary packages\nimport math\n\n# Helper function for listing all permutations of the list given as nums.\n# Uses recursion and backtracking.\ndef permutations(nums, start, end):\n    result = []\n    # Base case - everything has been swapped and sent down the recursion stack\n    if start == end:\n        result.append(' '.join(map(str, nums)))\n    else:\n        # Backtracking step\n        for i in range(start, end + 1):\n            # Python only - swap without temp var\n            nums[start], nums[i] = nums[i], nums[start]\n            # Recursion but with start incremented, since nums[start] has been swapped\n            result.extend(permutations(nums, start + 1, end))\n            # Backtrack - undo swap\n            nums[start], nums[i] = nums[i], nums[start]\n    return result\n\n# main function\ndef main_solution(n):\n  # Convert the input to a list of integers\n  nums = [i for i in range(1, n + 1)]\n  # Get all permutations\n  all_permutations = permutations(nums, 0, n - 1)\n  # Return the number of permutations and the permutations themselves\n  return {\"number_of_permutations\": math.factorial(n), \"permutations\": all_permutations}", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": {"number_of_permutations": 6, "permutations": ["1 2 3", "1 3 2", "2 1 3", "2 3 1", "3 2 1", "3 1 2"]}}, {"input": {"n": 2}, "output": {"number_of_permutations": 2, "permutations": ["1 2", "2 1"]}}, {"input": {"n": 1}, "output": {"number_of_permutations": 1, "permutations": ["1"]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jasonkimprojects/rosalind-challenge", "path": "/PERM.py", "msgidx": 4404}}
{"problem_description": "Given a partially filled 9x9 Sudoku board, where some cells are empty and represented by a period ('.'), what is the fully solved Sudoku board? The board is provided as a list of 9 strings, each representing a row of the Sudoku board. Each string contains 9 characters, where each character is either a digit (1-9) or a period ('.') representing an empty cell.", "io_requirements": "Input:\n  `board` (list of strings): A list of 9 strings, each representing a row of a Sudoku board. Each string contains 9 characters, where each character is either a digit (1-9) or a period ('.') representing an empty cell.\n\nOutput:\n  `return` (list of strings): A list of 9 strings, each representing a row of the solved Sudoku board. Each string contains 9 characters, where each character is a digit (1-9).", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        l = len(board)\n        \n        def val_adder(board, row, col):\n            def is_valid(row, col, val, board):\n                for i in range(l):\n                    if val == board[i][col]:\n                        return False \n                for i in range(l):\n                    if val == board[row][i]:\n                        return False\n                regions = int(math.sqrt(l))\n                I = row // regions\n                J = col // regions\n                rw = regions * I\n                cl = regions * J\n                \n                for i in range(regions):\n                    for j in range(regions):\n                        if val == board[rw + i][cl + j]:\n                            return False\n                return True \n                            \n            if col == l:\n                col = 0\n                row += 1\n            \n            if row == l:\n                return True \n            \n            if board[row][col] != '.':\n                return val_adder(board, row, col + 1)\n            \n            for i in range(1, l + 1):\n                val = str(i)\n                if is_valid(row, col, val, board):\n                    board[row][col] = val\n                    if val_adder(board, row, col + 1):\n                        return True \n            board[row][col] = '.'\n            return False\n                         \n        val_adder(board, 0, 0)\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists of strings\n    board = [list(row) for row in board]\n    \n    # Create an instance of the Solution class\n    solver = Solution()\n    \n    # Solve the Sudoku puzzle\n    solver.solveSudoku(board)\n    \n    # Convert the solved board back to a list of strings\n    solved_board = [''.join(row) for row in board]\n    \n    # Return the solved board as a JSON serializable output\n    return solved_board", "funcname": "main_solution", "ios": [{"input": {"board": ["321...96.", "5328...77", "7.31..9.5", ".89958.27", "89.6.5..5", "328..2529", "337429.79", "8.7.6.3.9", ".5.148273"]}, "output": ["321...96.", "5328...77", "7.31..9.5", ".89958.27", "89.6.5..5", "328..2529", "337429.79", "8.7.6.3.9", ".5.148273"]}, {"input": {"board": [".68635...", "944928.3.", ".57..7397", "37.44.76.", "78187.252", "8.98.1..5", "5..1.6.38", "19.5195.8", "259...8.4"]}, "output": [".68635...", "944928.3.", ".57..7397", "37.44.76.", "78187.252", "8.98.1..5", "5..1.6.38", "19.5195.8", "259...8.4"]}, {"input": {"board": ["2.9.12..9", "8236.3739", "3...394..", ".2317..4.", "9.82957.3", "1.7956..4", "33.485163", ".83866.5.", "4768.88.."]}, "output": ["2.9.12..9", "8236.3739", "3...394..", ".2317..4.", "9.82957.3", "1.7956..4", "33.485163", ".83866.5.", "4768.88.."]}, {"input": {"board": ["1271798.6", "....4.1.1", "..3.....3", "6.361.83.", ".6..824.2", "825698126", "978....88", ".46.1.71.", "8263273.6"]}, "output": ["1271798.6", "....4.1.1", "..3.....3", "6.361.83.", ".6..824.2", "825698126", "978....88", ".46.1.71.", "8263273.6"]}, {"input": {"board": ["....7.3.8", "....7299.", "9189179..", "776.4.184", "6558.62.7", "422.63813", ".9..8.7..", ".171.9.27", ".....7.43"]}, "output": ["....7.3.8", "....7299.", "9189179..", "776.4.184", "6558.62.7", "422.63813", ".9..8.7..", ".171.9.27", ".....7.43"]}, {"input": {"board": ["7989373.8", ".59....92", "5.6354353", ".8.3.72..", "4485.6974", "..26.8.81", ".66.4922.", ".3.9.47..", "..7766..9"]}, "output": ["7989373.8", ".59....92", "5.6354353", ".8.3.72..", "4485.6974", "..26.8.81", ".66.4922.", ".3.9.47..", "..7766..9"]}, {"input": {"board": ["48.4835..", "65.997342", ".1.4.3681", "5....45..", ".3762.491", "6.14...5.", "7965.96.5", "3.8212..8", "..55.8686"]}, "output": ["48.4835..", "65.997342", ".1.4.3681", "5....45..", ".3762.491", "6.14...5.", "7965.96.5", "3.8212..8", "..55.8686"]}, {"input": {"board": ["482.15.2.", ".45.....8", "354.6.894", ".94.443.3", "3831...3.", "35752.88.", "278...1.8", "62883....", "9341913.6"]}, "output": ["482.15.2.", ".45.....8", "354.6.894", ".94.443.3", "3831...3.", "35752.88.", "278...1.8", "62883....", "9341913.6"]}, {"input": {"board": ["..69896.1", "5..749752", "4.6.476.6", ".98.4.76.", "2383.4.33", "42.755...", "3.639781.", ".36.3.597", "...625144"]}, "output": ["..69896.1", "5..749752", "4.6.476.6", ".98.4.76.", "2383.4.33", "42.755...", "3.639781.", ".36.3.597", "...625144"]}, {"input": {"board": ["7.87.3.4.", "69...7869", "...459.99", "86.8.115.", "39.1.4.73", ".364.2.8.", "....16.59", ".3962...7", "...16479."]}, "output": ["7.87.3.4.", "69...7869", "...459.99", "86.8.115.", "39.1.4.73", ".364.2.8.", "....16.59", ".3962...7", "...16479."]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shubhrarajadhyaksha/Wallbreakers", "path": "/week4/solveSudoku.py", "msgidx": 4710}}
{"problem_description": "Given a range of integers, what are the palindromic prime numbers within that range?", "io_requirements": "Input:\n- `minNum` (int): The minimum number in the range to search for palindromic prime numbers.\n- `maxNum` (int): The maximum number in the range to search for palindromic prime numbers.\n\nOutput:\n- `return` (list of int): A list of palindromic prime numbers found within the specified range `[minNum, maxNum]`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef preprocessNum(num):\n    numDigits = 0\n    leftMost = num\n    while num > 0:\n        leftMost = num\n        num = num // 10\n        numDigits += 1\n    return numDigits, leftMost\n\ndef isPrime(n):\n    if n == 2 or n == 3: return True\n    if n < 2 or n % 2 == 0: return False\n    if n < 9: return True\n    if n % 3 == 0: return False\n    r = int(n**0.5)\n    f = 5\n    while f <= r:\n        if n % f == 0: return False\n        if n % (f + 2) == 0: return False\n        f += 6\n    return True\n\ndef formPalindrome(i, numLoop, numDigits, number, results, minNum, minNumDigits, leftMostMin, maxNum, maxNumDigits, leftMostMax):\n    if i == numLoop:\n        if isPrime(number) and number >= minNum and number <= maxNum:\n            results.append(number)\n        return\n    if i == 0:\n        digits = [1, 3, 7, 9]\n    else:\n        digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for digit in digits:\n        if i == 0:\n            if minNumDigits and digit < leftMostMin:\n                continue\n            elif maxNumDigits and digit > leftMostMax:\n                continue\n        if i != numLoop - 1 or numDigits % 2 == 0:\n            number += digit * (10**(numDigits - 1 - i)) + digit * (10**i)\n        else:\n            number += digit * (10**i)\n        formPalindrome(i + 1, numLoop, numDigits, number, results, minNum, minNumDigits, leftMostMin, maxNum, maxNumDigits, leftMostMax)\n        if i != numLoop - 1 or numDigits % 2 == 0:\n            number -= digit * (10**(numDigits - 1 - i)) + digit * (10**i)\n        else:\n            number -= digit * (10**i)\n\n# main function\ndef main_solution(minNum, maxNum):\n    minNumDigits, leftMostMin = preprocessNum(minNum)\n    maxNumDigits, leftMostMax = preprocessNum(maxNum)\n\n    results = []\n    for numDigits in range(minNumDigits, maxNumDigits + 1):\n        if numDigits % 2 == 0:\n            numLoop = numDigits // 2\n        else:\n            numLoop = numDigits // 2 + 1\n        if numDigits == 1:\n            digits = [2, 3, 5, 7]\n            for digit in digits:\n                if digit >= minNum:\n                    results.append(digit)\n        else:\n            number = 0\n            formPalindrome(0, numLoop, numDigits, number, results, minNum, numDigits == minNumDigits, leftMostMin, maxNum, numDigits == maxNumDigits, leftMostMax)\n\n    return results", "funcname": "main_solution", "ios": [{"input": {"minNum": 321, "maxNum": 1101}, "output": [353, 373, 383, 727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 180, "maxNum": 6354}, "output": [181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 249, "maxNum": 2240}, "output": [313, 353, 373, 383, 727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 512, "maxNum": 6893}, "output": [727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 809, "maxNum": 8275}, "output": [919, 929]}, {"input": {"minNum": 685, "maxNum": 2794}, "output": [727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 105, "maxNum": 1543}, "output": [131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 376, "maxNum": 2854}, "output": [383, 727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 644, "maxNum": 1299}, "output": [727, 757, 787, 797, 919, 929]}, {"input": {"minNum": 799, "maxNum": 7589}, "output": [919, 929]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhbngchen/USACO", "path": "/training/1.6/prime_palindrome/pprime.py", "msgidx": 4019}}
{"problem_description": "Given a polygon with `n` vertices, where `n` ants are placed on each vertex, what is the probability that at least two ants will collide if they start walking on the sides of the polygon in random directions?", "io_requirements": "Input:\n  `n` (int): The number of vertices in the polygon and the number of ants. It should be a positive integer greater than 1.\n\nOutput:\n  `return` (float): The probability of collision between any two or all of the ants on the polygon. The value is a float between 0 and 1.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # Calculate the probability of collision for 'n' ants on an 'n' vertex polygon\n    p_same_direction = (1 / 2) ** (n - 1)\n    p_collision = 1 - p_same_direction\n    return p_collision", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": 0.5}, {"input": {"n": 8}, "output": 0.9921875}, {"input": {"n": 3}, "output": 0.75}, {"input": {"n": 5}, "output": 0.9375}, {"input": {"n": 9}, "output": 0.99609375}, {"input": {"n": 10}, "output": 0.998046875}, {"input": {"n": 4}, "output": 0.875}, {"input": {"n": 6}, "output": 0.96875}, {"input": {"n": 7}, "output": 0.984375}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "danielzengqx/Python-practise", "path": "/CC150 5th/CH7/7.2.py", "msgidx": 4967}}
{"problem_description": "Given a rectangular grid with cells separated by walls, where some inner walls may be missing, how can we describe the size and number of connectivity components in the grid? The grid is always rectangular and will have all its outer walls, with only inner walls possibly missing. The '+' characters are considered bearing pillars and are always present.", "io_requirements": "Input:\n  `grid` (str): A string representing a grid with rows separated by newline characters. Each cell is represented by a 3x3 block of characters, where '+' denotes a pillar, '-' and '|' denote walls, and spaces denote missing walls.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple represents a connectivity component. The first element of the tuple is the size of the component, and the second element is the number of such components. The list is sorted in descending order by the size of the components.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef find_components(grid):\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        else:\n            parent[i] = find(parent, parent[i])\n            return parent[i]\n\n    def union(parent, rank, x, y):\n        root_x = find(parent, x)\n        root_y = find(parent, y)\n        if root_x != root_y:\n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n            elif rank[root_x] < rank[root_y]:\n                parent[root_x] = root_y\n            else:\n                parent[root_y] = root_x\n                rank[root_x] += 1\n\n    grid = grid.split('\\n')\n    rows = len(grid) // 2\n    cols = (len(grid[0]) - 1) // 3\n\n    parent = list(range(rows * cols))\n    rank = [0] * (rows * cols)\n\n    for i in range(rows):\n        for j in range(cols):\n            if j < cols - 1 and grid[2 * i + 1][3 * j + 2] == ' ':\n                union(parent, rank, i * cols + j, i * cols + j + 1)\n            if i < rows - 1 and grid[2 * i + 2][3 * j + 1] == ' ':\n                union(parent, rank, i * cols + j, (i + 1) * cols + j)\n\n    component_sizes = defaultdict(int)\n    for i in range(rows * cols):\n        root = find(parent, i)\n        component_sizes[root] += 1\n\n    result = defaultdict(int)\n    for size in component_sizes.values():\n        result[size] += 1\n\n    return sorted(result.items(), key=lambda x: x[0], reverse=True)\n\n# main function\ndef main_solution(grid):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = find_components(grid)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"grid": "+--++--+\n|  |   \n+--++--+\n|     |\n+--++--+\n|      \n+--++--+\n|      \n+--++--+\n|  |   \n+--++--+"}, "output": [[2, 5]]}, {"input": {"grid": "+--++--++--++--+\n|  |  |      \n+--++--++--++--+\n|        |  |\n+--++--++--++--+"}, "output": [[5, 2]]}, {"input": {"grid": "+--++--+\n|     |\n+--++--+\n|     |\n+--++--+\n|  |  |\n+--++--+\n|  |  |\n+--++--+"}, "output": [[2, 4]]}, {"input": {"grid": "+--++--+\n|      \n+--++--+\n|     |\n+--++--+\n|      \n+--++--+"}, "output": [[2, 3]]}, {"input": {"grid": "+--++--+\n|     |\n+--++--+\n|  |   \n+--++--+\n|     |\n+--++--+\n|  |   \n+--++--+\n|  |   \n+--++--+"}, "output": [[2, 5]]}, {"input": {"grid": "+--++--+\n|      \n+--++--+\n|  |   \n+--++--+\n|  |   \n+--++--+"}, "output": [[2, 3]]}, {"input": {"grid": "+--++--+\n|  |  |\n+--++--+\n|  |  |\n+--++--+\n|  |   \n+--++--+"}, "output": [[2, 3]]}, {"input": {"grid": "+--++--+\n|  |   \n+--++--+\n|      \n+--++--+\n|  |  |\n+--++--+\n|     |\n+--++--+"}, "output": [[2, 4]]}, {"input": {"grid": "+--++--++--++--+\n|        |   \n+--++--++--++--+\n|  |     |   \n+--++--++--++--+"}, "output": [[5, 2]]}, {"input": {"grid": "+--++--++--+\n|  |      \n+--++--++--+\n|     |   \n+--++--++--+"}, "output": [[3, 2]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "codingcerebrum/codewars-codes", "path": "/Kata/countConnectivityComponent.py", "msgidx": 4516}}
{"problem_description": "Given a set of rules for generating a sequence of 3-digit numbers called ticks, which includes all multiples of 100 between 0 and 1000, and other conditions such as the ratio between successive ticks being at most 6%, what is the resulting list of ticks when the upper bound for the score of sequences is defined by a specific fraction?", "io_requirements": "Input:\n  `bound` (str): A string representing the fraction used as the upper bound for the score of sequences. The format should be \"numerator/denominator\".\n\nOutput:\n  `return` (list of int): A list of integers representing the millenium ticks, which are the 3-digit numbers that satisfy the given conditions.", "refcode": "# import necessary packages\nimport fractions\n\n# all class and function definitions in the code file, if any\ndef generate_counts():\n    m5 = list(range(5, 100, 5))\n\n    for i in range(len(m5)):\n        for j in range(i+1, len(m5)):\n            a = m5[i]\n            b = m5[j]\n            n = (100 // b)+2\n            for b_count in range(n):\n                a_count = (100 - b_count * b) // a\n                if a_count < 0:\n                    continue\n                if a*a_count + b*b_count != 100:\n                    continue\n                if a_count == 0:\n                    yield ((b_count, b), )\n                elif b_count == 0:\n                    yield ((a_count, a), )\n                else:\n                    yield ((a_count, a), (b_count, b))\n\ndef sequence_from_counts(counts):\n    s = 0\n    for n, k in counts:\n        for i in range(n):\n            yield s\n            s += k\n\ndef compute_sequences():\n    seqs_uniq = []\n    s = set()\n    for c in generate_counts():\n        seq = tuple(sequence_from_counts(c))\n        if seq not in s:\n            s.add(seq)\n            seqs_uniq.append(seq)\n    return seqs_uniq\n\ndef score_sequence(base, s):\n    u = [e+base for e in s]\n    n = len(u)\n    u.append(base+100)\n    return max(fractions.Fraction(u[i+1], u[i]) for i in range(n))\n\ndef score_sequences(base):\n    for s in compute_sequences():\n        yield (score_sequence(base, s), s)\n\n# main function\ndef main_solution(bound):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    bound = fractions.Fraction(bound)\n    millenium = []\n\n    for base in range(100, 1000, 100):\n        passing_seqs = [(score, seq) for score, seq in score_sequences(base) if score < bound]\n        if passing_seqs:\n            best_score, best_seq = min(passing_seqs, key=lambda ss: (len(ss[1]), ss[0]))\n            millenium.extend([x+base for x in best_seq])\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return millenium", "funcname": "main_solution", "ios": [{"input": {"bound": "1786/930"}, "output": [100, 140, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1236/913"}, "output": [100, 130, 165, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1323/962"}, "output": [100, 130, 165, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1344/1001"}, "output": [100, 130, 165, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1329/980"}, "output": [100, 130, 165, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1774/910"}, "output": [100, 140, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1481/949"}, "output": [100, 140, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1692/1092"}, "output": [100, 140, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1345/939"}, "output": [100, 140, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}, {"input": {"bound": "1330/911"}, "output": [100, 140, 200, 245, 300, 345, 400, 445, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "openhive-network/hive", "path": "/programs/build_helpers/hive_build_helpers/mm_generate_millenium.py", "msgidx": 4621}}
{"problem_description": "Given a string containing a mix of letters, digits, and special characters, and a specified length, what are the first 10 permutations of the string that are of the given length?", "io_requirements": "Input:\n  `string` (str): A string containing all possible characters for permutations.\n  `length` (int): The length of the permutations to generate.\n\nOutput:\n  `return` (list of str): A list containing the first 10 permutations of the given length from the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(string, length):\n  # Convert the string to a list of characters\n  char_list = list(string)\n  \n  # Generate all permutations of the given length\n  permutations = [''.join(p) for p in itertools.permutations(char_list, length)]\n  \n  # Return the first 10 permutations as a list of strings\n  return permutations[:10]", "funcname": "main_solution", "ios": [{"input": {"string": "\\Lr%,y_QL[qb}", "length": 2}, "output": ["\\L", "\\r", "\\%", "\\,", "\\y", "\\_", "\\Q", "\\L", "\\[", "\\q"]}, {"input": {"string": ">!V;2%P@_q:u", "length": 4}, "output": [">!V;", ">!V2", ">!V%", ">!VP", ">!V@", ">!V_", ">!Vq", ">!V:", ">!Vu", ">!;V"]}, {"input": {"string": "*aE!D.Zk`CF6iR\\`p^", "length": 1}, "output": ["*", "a", "E", "!", "D", ".", "Z", "k", "`", "C"]}, {"input": {"string": "J_3P>U&~,Y&(#:)nc\"N", "length": 3}, "output": ["J_3", "J_P", "J_>", "J_U", "J_&", "J_~", "J_,", "J_Y", "J_&", "J_("]}, {"input": {"string": "-+H=\\PhRmMHW)I", "length": 5}, "output": ["-+H=\\", "-+H=P", "-+H=h", "-+H=R", "-+H=m", "-+H=M", "-+H=H", "-+H=W", "-+H=)", "-+H=I"]}, {"input": {"string": "F6~q:3)H27", "length": 4}, "output": ["F6~q", "F6~:", "F6~3", "F6~)", "F6~H", "F6~2", "F6~7", "F6q~", "F6q:", "F6q3"]}, {"input": {"string": "Iz$~hvRw2/?oUIn", "length": 2}, "output": ["Iz", "I$", "I~", "Ih", "Iv", "IR", "Iw", "I2", "I/", "I?"]}, {"input": {"string": "z$({r_'KHg.Ve!V%", "length": 2}, "output": ["z$", "z(", "z{", "zr", "z_", "z'", "zK", "zH", "zg", "z."]}, {"input": {"string": ";#,d5-/_wxkxi", "length": 2}, "output": [";#", ";,", ";d", ";5", ";-", ";/", ";_", ";w", ";x", ";k"]}, {"input": {"string": "!>dFE[nrx>l&", "length": 2}, "output": ["!>", "!d", "!F", "!E", "![", "!n", "!r", "!x", "!>", "!l"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kulkarnip150/wordlist-creator", "path": "/wordlist_creator.py", "msgidx": 5036}}
{"problem_description": "In a village, a traditional war game is held every year where archers are placed on hills of different altitudes. Due to a heavy south-east wind, each archer can only shoot in the south and east directions. Given the altitude of each hill represented by a matrix, how many total hits can all archers make?", "io_requirements": "Input:\n  `matrix` (list of lists of integers): A 2D list representing the altitude of hills where each sublist represents a row of hills. Each element in the sublist is an integer between 1 and 9 representing the altitude of the hill.\n\nOutput:\n  `return` (integer): The total number of hits that all archers can make, considering the constraints of shooting only in the south and east directions.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list to a numpy matrix\n    matrix = np.matrix(matrix)\n    m, n = matrix.shape\n    \n    count = 0\n    for row in range(m):\n        for columm in range(n):\n            for enemy_c in range(columm + 1, n):\n                if matrix[row, columm] >= matrix[row, enemy_c]:\n                    count += 1\n            for enemy_r in range(row + 1, m):\n                if matrix[row, columm] >= matrix[enemy_r, columm]:\n                    count += 1\n    \n    # Return the total number of hits\n    return count", "funcname": "main_solution", "ios": [{"input": {"matrix": [[9, 8, 9], [5, 8, 3], [4, 8, 3]]}, "output": 15}, {"input": {"matrix": [[9, 7, 4], [8, 5, 2], [3, 3, 5]]}, "output": 14}, {"input": {"matrix": [[7, 9, 4], [4, 6, 5], [9, 3, 9]]}, "output": 9}, {"input": {"matrix": [[6, 4, 9], [7, 5, 9], [5, 8, 1]]}, "output": 9}, {"input": {"matrix": [[2, 5, 2], [5, 2, 2], [9, 5, 6]]}, "output": 10}, {"input": {"matrix": [[3, 4, 3], [6, 5, 2], [2, 2, 7]]}, "output": 11}, {"input": {"matrix": [[9, 1, 1], [3, 4, 9], [2, 6, 1]]}, "output": 10}, {"input": {"matrix": [[1, 6, 6], [8, 7, 2], [3, 4, 9]]}, "output": 8}, {"input": {"matrix": [[6, 1, 8], [9, 9, 4], [6, 2, 2]]}, "output": 13}, {"input": {"matrix": [[6, 1, 3], [9, 5, 2], [5, 1, 8]]}, "output": 11}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "felipemaion/studying_python", "path": "/puja_game_archers.py", "msgidx": 5140}}
{"problem_description": "Given two binary trees, A and B, determine whether tree B is a subtree of tree A. Tree B is considered a subtree of tree A if there exists a node in tree A such that the subtree rooted at this node is identical to tree B in both structure and node values. What is the result of this determination?", "io_requirements": "Input:\n  `treeA_json` (str): A JSON string representing the structure of binary tree A. The JSON structure should be a dictionary with keys 'val' (float or int), 'left' (dict or None), and 'right' (dict or None).\n  `treeB_json` (str): A JSON string representing the structure of binary tree B. The JSON structure should be a dictionary with keys 'val' (float or int), 'left' (dict or None), and 'right' (dict or None).\n\nOutput:\n  `return` (bool): A boolean indicating if tree B is a subtree of tree A.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass BTNode(object):\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef Equal(num1, num2):\n    \"\"\"\n    \u4e24\u4e2a\u5c0f\u6570\u662f\u5426\u76f8\u7b49\u7684\u5224\u65ad\u65b9\u6cd5\n    :param num1:\n    :param num2:\n    :return:\n    \"\"\"\n    if num1 - num2 > -0.0000001 and num1 - num2 < 0.0000001:\n        return True\n    else:\n        return False\n\ndef HasSubtree(root1, root2):\n    \"\"\"\n    \u67e5\u627e\u6839\u503c\u76f8\u540c\u7684\u8282\u70b9\n    :param root1:\n    :param root2:\n    :return:\n    \"\"\"\n    result = False\n\n    if root1 != None and root2 != None:\n        if Equal(root1.val, root2.val):\n            result = DoesTree1HaveTree2(root1, root2)\n        if not result:\n            result = HasSubtree(root1.left, root2)\n        if not result:\n            result = HasSubtree(root1.right, root2)\n\n    return result\n\ndef DoesTree1HaveTree2(root1, root2):\n    \"\"\"\n    \u5224\u65adAB\u5de6\u53f3\u5b50\u6811\u662f\u5426\u7ed3\u6784\u76f8\u540c\n    :param root1:\n    :param root2:\n    :return:\n    \"\"\"\n    if root2 == None:\n        return True\n\n    if root1 == None:\n        return False\n\n    if not Equal(root1.val, root2.val):\n        return False\n\n    return DoesTree1HaveTree2(root1.left, root2.left) and DoesTree1HaveTree2(root1.right, root2.right)\n\n# main function\ndef main_solution(treeA_json, treeB_json):\n    \"\"\"\n    Determines if binary tree B is a subtree of binary tree A.\n    \n    :param treeA_json: JSON string representing the structure of binary tree A.\n    :param treeB_json: JSON string representing the structure of binary tree B.\n    :return: Boolean indicating if tree B is a subtree of tree A.\n    \"\"\"\n    def json_to_btnode(json_tree):\n        \"\"\"\n        Converts a JSON representation of a binary tree to a BTNode object.\n        \"\"\"\n        if not json_tree:\n            return None\n        return BTNode(\n            json_tree['val'],\n            json_to_btnode(json_tree['left']),\n            json_to_btnode(json_tree['right'])\n        )\n\n    treeA = json_to_btnode(json.loads(treeA_json))\n    treeB = json_to_btnode(json.loads(treeB_json))\n    \n    return HasSubtree(treeA, treeB)", "funcname": "main_solution", "ios": [{"input": {"treeA_json": "{\"val\": 15.879912554992327, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 46.10631529042853, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 57.98540447604164, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 59.02861081160583, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 31.579089499455147, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 50.42662827142895, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 77.79609458410872, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 59.049331496429666, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 4.743554113827553, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 84.99821011208704, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 97.13729677333797, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 81.73020833523051, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 44.87251948506228, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 18.7258716901633, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 83.15529000103147, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 33.82882452320155, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 88.71058066843865, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 89.51428754238617, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"treeA_json": "{\"val\": 74.39000874520111, \"left\": null, \"right\": null}", "treeB_json": "{\"val\": 15.990057165207784, \"left\": null, \"right\": null}"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhaoxinlu/leetcode-algorithms", "path": "/Offer_book_problems/026judgeSubTree.py", "msgidx": 4862}}
{"problem_description": "Given a number, what is the next value in a spiral grid where each cell's value is the sum of its neighboring cells' values, that is greater than the given number?", "io_requirements": "Input:\n  `inpt` (int): An integer representing the input number for which we need to find the next value in the spiral grid that is greater than this number.\n\nOutput:\n  `return` (int): An integer representing the next value in the spiral grid that is greater than the input number.", "refcode": "import math\nfrom typing import Dict, Tuple\n\nCoords = Tuple[int, int]  # center = (0,0)\n\ndef above(square: Coords) -> Coords:\n    x, y = square\n    return (x, y - 1)\n\ndef below(square: Coords) -> Coords:\n    x, y = square\n    return (x, y + 1)\n\ndef right_of(square: Coords) -> Coords:\n    x, y = square\n    return (x + 1, y)\n\ndef left_of(square: Coords) -> Coords:\n    x, y = square\n    return (x - 1, y)\n\ndef prev_square(position: Coords, grid_size: int) -> Coords:\n    assert grid_size % 2 == 1\n    max_r = (grid_size - 1) // 2\n\n    if position == (0, 0):\n        raise ValueError\n\n    if position == (max_r, max_r):\n        return left_of(position)\n    elif position == (-max_r, max_r):\n        return above(position)\n    elif position == (-max_r, -max_r):\n        return right_of(position)\n    elif position == (max_r, -max_r):\n        return below(position)\n\n    if position[1] == max_r:\n        return left_of(position)\n    elif position[0] == -max_r:\n        return above(position)\n    elif position[1] == -max_r:\n        return right_of(position)\n    elif position[0] == max_r:\n        return below(position)\n\n    raise Exception\n\ndef next_square(position: Coords, grid_size: int) -> Coords:\n    assert grid_size % 2 == 1\n    max_r = (grid_size - 1) // 2\n\n    if position == (0, 0):\n        return (1, 0)\n\n    if position == (max_r, max_r):\n        return above(position)\n    elif position == (-max_r, max_r):\n        return right_of(position)\n    elif position == (-max_r, -max_r):\n        return below(position)\n    elif position == (max_r, -max_r):\n        return left_of(position)\n\n    if position[1] == max_r:\n        return right_of(position)\n    elif position[0] == -max_r:\n        return below(position)\n    elif position[1] == -max_r:\n        return left_of(position)\n    elif position[0] == max_r:\n        return above(position)\n\n    raise Exception\n\ndef sum_neighbors(grid: Dict[Coords, int], point: Coords) -> int:\n    total = 0\n    for x in (point[0] - 1, point[0], point[0] + 1):\n        for y in (point[1] - 1, point[1], point[1] + 1):\n            if (x, y) in grid:\n                total += grid[(x, y)]\n    return total\n\ndef main_solution(inpt: int) -> int:\n    grid = {(0, 0): 1}\n    grid_size = 3\n    bottom_right = (1, 1)\n    x, y = (0, 0)\n    while grid[(x, y)] <= inpt:\n        x, y = next_square((x, y), grid_size)\n        grid[(x, y)] = sum_neighbors(grid, (x, y))\n        if (x, y) == bottom_right:\n            x, y = right_of(bottom_right)\n            grid[(x, y)] = sum_neighbors(grid, (x, y))\n            grid_size += 2\n            bottom_right = ((grid_size - 1) // 2, (grid_size - 1) // 2)\n    return grid[(x, y)]", "funcname": "main_solution", "ios": [{"input": {"inpt": 472}, "output": 747}, {"input": {"inpt": 141}, "output": 142}, {"input": {"inpt": 490}, "output": 747}, {"input": {"inpt": 357}, "output": 362}, {"input": {"inpt": 189}, "output": 304}, {"input": {"inpt": 422}, "output": 747}, {"input": {"inpt": 650}, "output": 747}, {"input": {"inpt": 824}, "output": 880}, {"input": {"inpt": 995}, "output": 1968}, {"input": {"inpt": 96}, "output": 122}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JensPfeifle/aoc-2017", "path": "/3.py", "msgidx": 4834}}
{"problem_description": "Given a set of minterms in a Boolean function, how can we simplify the function using the Quine McCluskey algorithm? Specifically, what are the simplified minterms for a function with `numVars` variables and the provided `minterms`?", "io_requirements": "Input:\n  `numVars` (int): The number of variables in the minterms.\n  `minterms` (list of int): A list of minterms represented as integers.\n\nOutput:\n  `return` (list of str): A list of strings representing the simplified minterms after applying the Quine McCluskey algorithm. Each string is a binary representation of the minterm with possible '-' characters indicating don't care conditions.", "refcode": "# import necessary packages\nimport platform\nimport os\n\n# all class and function definitions in the code file, if any\ndef clear_screen():\n    if platform.system() == 'Windows':\n        os.system('cls')\n    else:\n        os.system('clear')\n\n# main function\ndef main_solution(numVars, minterms):\n    # Convert minterms to binary and pad with zeros\n    bnums = []\n    for minterm in minterms:\n        minterm = bin(int(minterm)).replace(\"0b\", \"\", 1)\n        if len(minterm) < numVars:\n            minterm = \"0\" * (numVars - len(minterm)) + minterm\n        bnums.append(minterm)\n\n    # Sort into groups based on # of 1's\n    numsorted = 0\n    sorted_bnums = []\n    while numsorted < len(bnums):\n        sorted_bnums.append([])\n        for i in range(0, len(bnums)):\n            if bnums[i].count(\"1\") == numsorted:\n                sorted_bnums[numsorted].append(bnums[i])\n        numsorted += 1\n\n    # Remove empty boxes\n    limit = len(sorted_bnums)\n    count = 0\n    while count < limit:\n        if len(sorted_bnums[count]) == 0:\n            sorted_bnums.pop(count)\n            limit -= 1\n        else:\n            count += 1\n\n    # Do each Column\n    index_col = 0\n    cols = []\n    cols.append(sorted_bnums)\n\n    # Repeat until only one box in column\n    while len(cols[index_col]) > 1:\n        index = 0\n        # Add next column\n        cols.append([])\n\n        # Compare adjacent rows, add to new column\n        while index < len(cols[index_col]) - 1:\n            arr = []\n            cur_box = cols[index_col][index]\n            next_box = cols[index_col][index + 1]\n            index += 1\n            # All numbers in current box\n            for i in range(0, len(cur_box)):\n                # Against all numbers in next box\n                for x in range(0, len(next_box)):\n                    diffcount = 0\n                    diffi = 0\n                    # Compare each digit\n                    for y in range(0, numVars):\n                        # Count different digits\n                        if cur_box[i][y] != next_box[x][y]:\n                            diffcount += 1\n                            diffi = y\n\n                    # Only 1 digit varies, add to next column\n                    if diffcount == 1:\n                        b = list(cur_box[i])\n                        # Remove * to avoid stacking of *s\n                        if cur_box[i].endswith(\"*\"):\n                            b.pop()\n\n                        b[diffi] = \"-\"\n\n                        # Only add if not in array\n                        if not \"\".join(b) in arr:\n                            arr.append(\"\".join(b))\n\n                        # Mark values as used if not already marked\n                        if not cur_box[i].endswith(\"*\"):\n                            cur_box[i] += \"*\"\n                        if not next_box[x].endswith(\"*\"):\n                            next_box[x] += \"*\"\n\n            cols[index_col + 1].append(arr)\n\n        index_col += 1\n\n    # Flatten the final column to get the result\n    result = []\n    for box in cols[-1]:\n        result.extend(box)\n\n    return result", "funcname": "main_solution", "ios": [{"input": {"numVars": 2, "minterms": [0, 3, 0, 0]}, "output": []}, {"input": {"numVars": 2, "minterms": [3, 3, 2, 2, 0, 3, 3, 3, 0, 2]}, "output": []}, {"input": {"numVars": 2, "minterms": [0, 1, 1, 1, 3, 3, 3]}, "output": []}, {"input": {"numVars": 5, "minterms": [28, 15, 2, 10, 10]}, "output": []}, {"input": {"numVars": 5, "minterms": [20, 3, 7, 23, 14]}, "output": []}, {"input": {"numVars": 2, "minterms": [0, 0, 1, 2, 3, 2, 0, 3, 1, 3]}, "output": ["--"]}, {"input": {"numVars": 3, "minterms": [6, 7, 5]}, "output": ["110", "101"]}, {"input": {"numVars": 5, "minterms": [6, 6, 13, 1, 19, 4]}, "output": []}, {"input": {"numVars": 5, "minterms": [17, 25, 23, 21, 27, 15]}, "output": []}, {"input": {"numVars": 5, "minterms": [12, 6, 8, 23, 8, 22, 26, 25, 25]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "agernz/DigitalSystems", "path": "/QuineMcCluskey/QuineMcCluskey.py", "msgidx": 4446}}
{"problem_description": "Given a chessboard of a certain size, a queen is placed at a specific position. Additionally, there are some blockers placed on the chessboard that restrict the queen's movement. How many moves can the queen make on the chessboard, considering the blockers?", "io_requirements": "Input:\n  `queen` (list of int): A list containing two integers representing the coordinates of the queen on a chessboard. The first integer is the row index (y) and the second integer is the column index (x).\n  `length` (int): An integer representing the size of the chessboard (length x length).\n  `blockers` (list of list of int): A list of lists, where each inner list contains two integers representing the coordinates of blockers on the chessboard. The first integer is the row index (y) and the second integer is the column index (x).\n\nOutput:\n  `return` (int): An integer representing the total number of moves the queen can make on the chessboard, considering the blockers.", "refcode": "# import necessary packages\nfrom collections import namedtuple\n\n# all class and function definitions in the code file, if any\nCoordinates = namedtuple(\"Coordinates\", [\"y\", \"x\"])\n\nclass QueensAttack():\n\n    def get_right(self, queen, length):\n        x = [x for x in range(length)]\n        return len(x[queen:])\n\n    def get_left(self, queen, length):\n        x = [x for x in range(length)]\n        return len(x[:queen])\n\n    def sum_moves(self, coord, length):\n        return self.get_right(coord.x, length) + self.get_right(coord.y, length) +  self.get_left(coord.x - 1, length) +  self.get_left(coord.y - 1, length)\n\n    def solve_east_west(self, queen, length):\n        coord = Coordinates(y=queen[0], x=queen[1])\n        return self.sum_moves(coord, length)\n\n    def solve_diagonal(self, queen, length):\n        coord = Coordinates(y=queen[0], x=queen[1])\n        difference = abs(coord.x - coord.y)\n        if difference > 0:\n            return 2 * (self.get_right(coord.x, length - difference) + self.get_left(coord.x - 1, length - difference))\n        return self.get_right(coord.x, length - difference) + self.get_left(coord.x - 1, length - difference)\n\n    def solve_all(self, queen, length, blockers):\n        coord = Coordinates(y=queen[0], x=queen[1])\n        for blocker in blockers:\n            if blocker[0] == coord.y:\n                total = self.get_right(queen, length) + self.get_left(queen, length)\n        return 0\n\n# main function\ndef main_solution(queen, length, blockers):\n    # Convert input to namedtuple for internal use\n    queen_coord = Coordinates(y=queen[0], x=queen[1])\n    blockers_coords = [Coordinates(y=b[0], x=b[1]) for b in blockers]\n    \n    # Initialize the QueensAttack class\n    qa = QueensAttack()\n    \n    # Calculate the total number of moves\n    total_moves = qa.solve_east_west(queen, length) + qa.solve_diagonal(queen, length)\n    \n    # Adjust for blockers\n    for blocker in blockers_coords:\n        if blocker.y == queen_coord.y:\n            total_moves -= qa.get_right(queen_coord.x, length) + qa.get_left(queen_coord.x - 1, length)\n    \n    # Return the total number of moves\n    return total_moves", "funcname": "main_solution", "ios": [{"input": {"queen": [1, 6], "length": 7, "blockers": [[0, 0], [6, 6], [6, 5]]}, "output": 16}, {"input": {"queen": [1, 0], "length": 5, "blockers": [[4, 3], [3, 1]]}, "output": 27}, {"input": {"queen": [7, 5], "length": 8, "blockers": [[5, 2]]}, "output": 24}, {"input": {"queen": [7, 3], "length": 8, "blockers": [[4, 4], [6, 4]]}, "output": 20}, {"input": {"queen": [0, 5], "length": 7, "blockers": [[4, 0], [5, 4]]}, "output": 23}, {"input": {"queen": [5, 0], "length": 6, "blockers": [[4, 4], [0, 3]]}, "output": 18}, {"input": {"queen": [1, 1], "length": 7, "blockers": [[6, 3]]}, "output": 18}, {"input": {"queen": [4, 3], "length": 5, "blockers": [[1, 4], [4, 2]]}, "output": 10}, {"input": {"queen": [0, 1], "length": 5, "blockers": [[1, 3], [1, 0], [3, 2]]}, "output": 19}, {"input": {"queen": [1, 1], "length": 4, "blockers": [[0, 1]]}, "output": 9}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jakobpederson/queens_attack_2", "path": "/queens_attack_2.py", "msgidx": 3987}}
{"problem_description": "Given a target value, what is the distance from this value to the nearest perfect square in a spiral matrix where the values increase in a spiral pattern starting from the center?", "io_requirements": "Input:\n  `target_val` (int): The target value for which we need to find the nearest perfect square and calculate the distance.\n\nOutput:\n  `return` (int): The calculated distance from the target value to the nearest perfect square.", "refcode": "import math\n\ndef nearestPerfectSquare(input):\n    rootN = math.sqrt(input)\n    floorN = int(rootN)\n    ceilN = floorN + 1\n    floorN_sq = floorN * floorN\n    ceilN_sq = ceilN * ceilN\n    if input - floorN_sq < ceilN_sq - input:\n        return floorN_sq\n    else:\n        return ceilN_sq\n\ndef totalDistance(target, last_square):\n    midPoint = int(last_square / 2)\n    squares_per_vec = last_square - 1\n    total_squares = squares_per_vec * 4\n    distance = total_squares - target\n    y_step = 0\n    for i in range(0, int(last_square), 2):\n        y_step += 1\n    y_step -= 1\n    out = target - midPoint + y_step\n    return out\n\ndef main_solution(target_val):\n    cSquare = nearestPerfectSquare(target_val)\n    last_square = int(math.sqrt(cSquare))\n    target_pos = cSquare - target_val\n    output = totalDistance(target_pos, last_square)\n    return output", "funcname": "main_solution", "ios": [{"input": {"target_val": 964862}, "output": -539}, {"input": {"target_val": 579069}, "output": 52}, {"input": {"target_val": 640732}, "output": -733}, {"input": {"target_val": 189695}, "output": 400}, {"input": {"target_val": 775294}, "output": 867}, {"input": {"target_val": 364680}, "output": 135}, {"input": {"target_val": 691793}, "output": 430}, {"input": {"target_val": 774919}, "output": -520}, {"input": {"target_val": 481349}, "output": 286}, {"input": {"target_val": 152422}, "output": -323}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lallers/Advent-Of-Code", "path": "/2017/Day_03_Spiral_Memory.py", "msgidx": 4842}}
{"problem_description": "Given a proper fraction represented as a string, how can we express it as a sum of distinct unit fractions (Egyptian fractions)?", "io_requirements": "Input:\n  `fraction_str` (str): A string representing a proper fraction in the form 'numerator/denominator'.\n\nOutput:\n  `return` (str): A string representing the sum of Egyptian fractions. If the input is invalid, it returns \"Invalid input\" or \"Invalid fraction\".", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(fraction_str):\n    \"\"\"\n    Converts a proper fraction into a sum of Egyptian fractions.\n\n    Args:\n    fraction_str (str): A string representing a proper fraction in the form 'numerator/denominator'.\n\n    Returns:\n    str: A string representing the sum of Egyptian fractions.\n    \"\"\"\n    def divide(a, b):\n        a1, b1 = a, b\n        while a1 != 0 and b1 != 0 and b1 % a1 != 0:\n            r = b1 % a1\n            b1, a1 = a1, r\n\n        a /= a1\n        b /= a1\n\n        if a == 1:\n            return '{}/{}'.format(int(a), int(b))\n        elif a == 0:\n            return ''\n        else:\n            q = int(b / a)\n            return '{}/{}+{}'.format(1, q + 1, divide(a * (q + 1) - b, b * (q + 1)))\n\n    try:\n        a, b = [int(i) for i in fraction_str.split('/')]\n        if b == 0 or a >= b:\n            return \"Invalid fraction\"\n        return divide(a, b)\n    except:\n        return \"Invalid input\"", "funcname": "main_solution", "ios": [{"input": {"fraction_str": "27/89"}, "output": "1/4+1/19+1/1353+1/9151692"}, {"input": {"fraction_str": "68/100"}, "output": "1/2+1/6+1/75"}, {"input": {"fraction_str": "21/72"}, "output": "1/4+1/24"}, {"input": {"fraction_str": "31/73"}, "output": "1/3+1/11+1/2409"}, {"input": {"fraction_str": "41/81"}, "output": "1/2+1/162"}, {"input": {"fraction_str": "51/66"}, "output": "1/2+1/4+1/44"}, {"input": {"fraction_str": "31/52"}, "output": "1/2+1/11+1/191+1/109252"}, {"input": {"fraction_str": "57/78"}, "output": "1/2+1/5+1/33+1/2145"}, {"input": {"fraction_str": "10/57"}, "output": "1/6+1/114"}, {"input": {"fraction_str": "74/85"}, "output": "1/2+1/3+1/27+1/4590"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Huizhen-Tan/Small-Algorithm-Apps", "path": "/devide_proper_fraction_into_Egyptian_fractions.py", "msgidx": 4611}}
{"problem_description": "Given a maze represented by a grid of characters, where each character signifies a different type of cell (wall, open space, key, door, or starting position), how many steps are required to collect all the keys starting from a specified position? The maze contains walls ('#'), open spaces ('.') where movement is allowed, keys represented by lowercase letters, doors represented by uppercase letters, and a starting position ('@'). Each key can open a corresponding door (e.g., key 'a' opens door 'A'). The goal is to determine the minimum number of steps needed to collect all keys starting from the given position.", "io_requirements": "Input:\n  `maze_str` (str): A string representation of the maze where each character represents a cell.\n                    '#' represents a wall, '.' represents an open space, '@' represents the starting position,\n                    lowercase letters represent keys, and uppercase letters represent doors.\n                    Each line of the maze is separated by a newline character ('\\n').\n  `start_pos` (tuple): A tuple (x, y) representing the starting position in the maze.\n\nOutput:\n  `return` (int): The minimum number of steps required to collect all keys. If no solution is found, returns -1.", "refcode": "# import necessary packages\nimport string\nimport queue\n\n# main function\ndef main_solution(maze_str, start_pos):\n    \"\"\"\n    Solves the maze problem to collect all keys.\n\n    Args:\n    maze_str (str): A string representation of the maze where each character represents a cell.\n                    '#' represents a wall, '.' represents an open space, '@' represents the starting position,\n                    lowercase letters represent keys, and uppercase letters represent doors.\n    start_pos (tuple): A tuple (x, y) representing the starting position in the maze.\n\n    Returns:\n    int: The minimum number of steps required to collect all keys.\n    \"\"\"\n    maze = {}\n    doors = {}\n    keys = {}\n    current = start_pos\n\n    y = 0\n    for line in maze_str.split('\\n'):\n        x = 0\n        for c in line:\n            if c != ' ':  # Ignore spaces for simplicity\n                maze[(x, y)] = c\n                if c in string.ascii_lowercase:\n                    keys[(x, y)] = c\n                elif c in string.ascii_uppercase:\n                    doors[(x, y)] = c\n                elif c == '@':\n                    current = (x, y)\n                x += 1\n        y += 1\n\n    keylen = len(keys)\n\n    visited = {}\n    Q = queue.Queue()\n    Q.put((current, \"\", 0))\n    while not Q.empty():\n        node = Q.get()\n        steps = node[2]\n        keys_collected = node[1]\n        coord = node[0]\n        if (coord, keys_collected) not in visited:\n            visited[(coord, keys_collected)] = steps\n            neighbors = []\n            for coord in ((coord[0] + 1, coord[1]),\n                          (coord[0] - 1, coord[1]),\n                          (coord[0], coord[1] + 1),\n                          (coord[0], coord[1] - 1)):\n                newkeys = False\n                if coord in maze:\n                    if maze[coord] != \"#\":\n                        if maze[coord] in string.ascii_lowercase:\n                            if maze[coord] not in keys_collected:\n                                newkeys = keys_collected + maze[coord]\n                                newkeys = ''.join(sorted(newkeys))\n                                if len(newkeys) == keylen:\n                                    return steps + 1\n                        elif maze[coord] in string.ascii_uppercase:\n                            if maze[coord].lower() not in keys_collected:\n                                continue\n                        if newkeys:\n                            neighbors.append((coord, newkeys))\n                        else:\n                            neighbors.append((coord, keys_collected))\n            for neighbor in neighbors:\n                Q.put((neighbor[0], neighbor[1], steps + 1))\n    return -1  # If no solution is found", "funcname": "main_solution", "ios": [{"input": {"maze_str": "#nm#O\nS.###\n.#..#\n##.##\n..###\n#.@.#\n#.#..\n..#..\n.#...\n#.#..", "start_pos": [2, 5]}, "output": -1}, {"input": {"maze_str": "#d##eu#\nL##M#F.\n#####.#\n#..@.#.\n####.#.\n#....#.", "start_pos": [3, 3]}, "output": -1}, {"input": {"maze_str": "#gs##cX#ET\n#.##.#...#\n##.#.##..#\n#####@#.##\n##.#####..\n#.#..##...\n....####.#", "start_pos": [5, 3]}, "output": -1}, {"input": {"maze_str": "yxa#FSM##.\n#.########\n#...#..###\n.###.@.#..\n##..#....#\n.##.#.##..", "start_pos": [5, 3]}, "output": -1}, {"input": {"maze_str": "#x#mn\no####\n#xJE#\nHEK.#\n#.###\n#.@..\n##.#.\n#....\n####.\n.##..", "start_pos": [2, 5]}, "output": -1}, {"input": {"maze_str": "#an###s\nv##K###\n#G#Z#V#\n##...#.\n#..@##.\n..###.#\n#.#..##\n#..##..", "start_pos": [3, 4]}, "output": -1}, {"input": {"maze_str": "#uo#i###\nM##K##V.\n.#..#.##\n##.#@.##\n...###.#\n.....#..\n#.#...#.", "start_pos": [4, 3]}, "output": -1}, {"input": {"maze_str": "#u##b##g#w\nh#O#GA#Z#C\n..###..###\n.###.@..#.\n..###.....\n#####.#..#\n#.####..##", "start_pos": [5, 3]}, "output": -1}, {"input": {"maze_str": "#za#z#j\n###KNBP\n.##@#..\n#.##...\n##.##.#", "start_pos": [3, 2]}, "output": -1}, {"input": {"maze_str": "d#y##c#d\nFAIQ..##\n##.####.\n.#.##...\n....@#.#\n##..##.#\n.####.##\n###...#.\n######..", "start_pos": [4, 4]}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dcthomson/Advent-of-Code", "path": "/2019/18 - Many-Worlds Interpretation/part1nostrings.py", "msgidx": 4758}}
{"problem_description": "In a grim scenario, a group of `n` prisoners are standing in a circle awaiting execution. The executioner starts from an arbitrary position (0) and kills every `k`-th person until only one person remains. Given the number of prisoners `n` and the step size `k`, which prisoner's original position (index) will be the one to survive?", "io_requirements": "Input:\n  `n` (int): The number of prisoners standing in a circle.\n  `k` (int): The step size at which the executioner kills every k-th person.\n\nOutput:\n  `return` (int): The original position (index) of the person who survives the execution process.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    members = list(range(n))\n    count = 1\n    while len(members) > 1:\n        for x in range(len(members)):\n            if count == k:\n                members[x] = '-'\n                count = 1\n            else:\n                count += 1\n        members = [member for member in members if member != '-']\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return members[0]", "funcname": "main_solution", "ios": [{"input": {"n": 20, "k": 17}, "output": 5}, {"input": {"n": 30, "k": 10}, "output": 27}, {"input": {"n": 76, "k": 64}, "output": 14}, {"input": {"n": 75, "k": 43}, "output": 74}, {"input": {"n": 66, "k": 58}, "output": 29}, {"input": {"n": 33, "k": 25}, "output": 0}, {"input": {"n": 55, "k": 41}, "output": 5}, {"input": {"n": 11, "k": 5}, "output": 7}, {"input": {"n": 36, "k": 29}, "output": 33}, {"input": {"n": 28, "k": 11}, "output": 5}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/4AjWvJdZpFEMbGALd_23.py", "msgidx": 5290}}
{"problem_description": "Given a string of alphabetic characters, how can we encrypt it in a way that the resulting string is hard to quickly read, but is easy to convert back into the original string? Specifically, the encryption process involves appending the middle character of the string (or the left-most of the two central characters if the length is even) to an initially-empty resulting string, followed by appending the encrypted versions of the substrings to the left and right of the middle character. What is the encrypted string for a given input string?", "io_requirements": "Input:\n  `s` (str): The input string to be encrypted. It should be a non-empty string containing only alphabetic characters.\n\nOutput:\n  `return` (str): The encrypted string obtained by shuffling the characters of the input string `s` according to the described encryption method.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(s):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if len(s) == 0:\n        return ''\n    if len(s) == 1:\n        return s\n    \n    if len(s) % 2 == 0:\n        mid = len(s) // 2 - 1\n    else:\n        mid = len(s) // 2\n        \n    l = main_solution(s[:mid])\n    r = main_solution(s[mid+1:])\n    \n    return s[mid] + l + r", "funcname": "main_solution", "ios": [{"input": {"s": "PtOS"}, "output": "tPOS"}, {"input": {"s": "qMdANIwG"}, "output": "AMqdINwG"}, {"input": {"s": "UyjOOKCZ"}, "output": "OyUjKOCZ"}, {"input": {"s": "iVOS"}, "output": "ViOS"}, {"input": {"s": "RtVgSPc"}, "output": "gtRVPSc"}, {"input": {"s": "gUz"}, "output": "Ugz"}, {"input": {"s": "DfUSEFaV"}, "output": "SfDUFEaV"}, {"input": {"s": "jaBKZDJA"}, "output": "KajBDZJA"}, {"input": {"s": "JJhR"}, "output": "JJhR"}, {"input": {"s": "jS"}, "output": "jS"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kevicao/python", "path": "/sql/Encrypted Words.py", "msgidx": 4891}}
{"problem_description": "Given a list of integers and a single integer, what are the sum of the integers in the list and the factorial of the single integer?", "io_requirements": "Input:\n  `numbers` (list of integers): A list of integers for which the sum needs to be calculated.\n  `factorial_number` (integer): An integer for which the factorial needs to be calculated.\n\nOutput:\n  `return` (dictionary): A dictionary containing two keys:\n    - `sum_result` (integer): The sum of the numbers in the input list.\n    - `factorial_result` (integer): The factorial of the input integer.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef sum_recursive(lst):\n    if len(lst) == 1:\n        return lst[0]\n    num1 = lst.pop()\n    return sum_recursive(lst) + num1\n\ndef factorial_recursive(n):\n    if n == 1:\n        return 1\n    return factorial_recursive(n - 1) * n\n\n# main function\ndef main_solution(numbers, factorial_number):\n    # Convert JSON serializable inputs to the original input variables\n    numbers_list = list(numbers)\n    factorial_num = int(factorial_number)\n    \n    # Calculate the sum of the numbers\n    sum_result = sum_recursive(numbers_list)\n    \n    # Calculate the factorial of the given number\n    factorial_result = factorial_recursive(factorial_num)\n    \n    # Return the results as JSON serializable outputs\n    return {\"sum_result\": sum_result, \"factorial_result\": factorial_result}", "funcname": "main_solution", "ios": [{"input": {"numbers": [42, 60, 82, 94, 24], "factorial_number": 10}, "output": {"sum_result": 302, "factorial_result": 3628800}}, {"input": {"numbers": [21, 38, 79, 46, 33, 19, 53, 79, 11], "factorial_number": 3}, "output": {"sum_result": 379, "factorial_result": 6}}, {"input": {"numbers": [47, 43, 38, 15, 54], "factorial_number": 5}, "output": {"sum_result": 197, "factorial_result": 120}}, {"input": {"numbers": [8, 30, 36, 53, 78, 41, 11, 96], "factorial_number": 2}, "output": {"sum_result": 353, "factorial_result": 2}}, {"input": {"numbers": [7, 81, 2, 79], "factorial_number": 6}, "output": {"sum_result": 169, "factorial_result": 720}}, {"input": {"numbers": [5, 76, 18, 47, 31], "factorial_number": 6}, "output": {"sum_result": 177, "factorial_result": 720}}, {"input": {"numbers": [100, 30, 14, 71, 2, 59, 8, 93, 84], "factorial_number": 9}, "output": {"sum_result": 461, "factorial_result": 362880}}, {"input": {"numbers": [91, 95, 11, 53, 89, 75, 17], "factorial_number": 3}, "output": {"sum_result": 431, "factorial_result": 6}}, {"input": {"numbers": [88, 89, 100, 69], "factorial_number": 8}, "output": {"sum_result": 346, "factorial_result": 40320}}, {"input": {"numbers": [26, 84, 73, 5], "factorial_number": 4}, "output": {"sum_result": 188, "factorial_result": 24}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "liamlycoder/vipjr-programming", "path": "/\u7b49\u7ea7\u4e09\u7ea7/cls20\u5206\u6cbb\u7b97\u6cd5.py", "msgidx": 5230}}
{"problem_description": "Given a range of multiplicands and a maximum value for the multiplier, what is the sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1-9 pandigital number?", "io_requirements": "Input:\n  `min_multiplicand` (int): The minimum value for the multiplicand.\n  `max_multiplicand` (int): The maximum value for the multiplicand.\n  `max_multiplier` (int): The maximum value for the multiplier.\n\nOutput:\n  `return` (int): The sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1-9 pandigital number.", "refcode": "# import necessary packages\nfrom math import log10\n\n# main function\ndef main_solution(min_multiplicand, max_multiplicand, max_multiplier):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  products = []\n\n  for i in range(min_multiplicand, max_multiplicand + 1):\n    for j in range(2, max_multiplier + 1):\n      product = i * j\n      combined = str(i) + str(j) + str(product)\n      if len(combined) == 9:\n        if product not in products:\n          if \"123456789\".strip(combined) == \"\":\n            products.append(product)\n\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return sum(products)", "funcname": "main_solution", "ios": [{"input": {"min_multiplicand": 2, "max_multiplicand": 89, "max_multiplier": 800}, "output": 30424}, {"input": {"min_multiplicand": 3, "max_multiplicand": 12, "max_multiplier": 792}, "output": 5796}, {"input": {"min_multiplicand": 5, "max_multiplicand": 97, "max_multiplier": 642}, "output": 30424}, {"input": {"min_multiplicand": 3, "max_multiplicand": 24, "max_multiplier": 1742}, "output": 18094}, {"input": {"min_multiplicand": 8, "max_multiplicand": 18, "max_multiplier": 132}, "output": 0}, {"input": {"min_multiplicand": 2, "max_multiplicand": 51, "max_multiplier": 127}, "output": 0}, {"input": {"min_multiplicand": 3, "max_multiplicand": 60, "max_multiplier": 581}, "output": 30424}, {"input": {"min_multiplicand": 4, "max_multiplicand": 76, "max_multiplier": 1087}, "output": 30424}, {"input": {"min_multiplicand": 10, "max_multiplicand": 55, "max_multiplier": 1991}, "output": 30424}, {"input": {"min_multiplicand": 7, "max_multiplicand": 97, "max_multiplier": 1626}, "output": 30424}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "phlip9/project-euler", "path": "/pe_32.py", "msgidx": 5109}}
{"problem_description": "Given a digital image represented by an m x n grid of black ('B') and white ('W') pixels, how many black pixels are considered lonely? A black pixel is considered lonely if it is the only black pixel in both its row and column.", "io_requirements": "Input:\n  `picture` (List[List[str]]): A 2D list representing the picture, where each element is either 'B' (black pixel) or 'W' (white pixel). The dimensions of the picture are m x n, where 1 <= m, n <= 500.\n\nOutput:\n  `return` (int): The number of black lonely pixels in the picture. A black lonely pixel is a 'B' that is the only 'B' in both its row and column.", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(picture: List[List[str]]) -> int:\n    # Convert the input to JSON serializable format if necessary\n    # In this case, the input is already JSON serializable (List[List[str]])\n    \n    # Initialize the count of lonely black pixels\n    lonely_pixel_count = 0\n    \n    # Get the dimensions of the picture\n    m, n = len(picture), len(picture[0])\n    \n    # Create lists to count black pixels in each row and column\n    row_counts = [0] * m\n    col_counts = [0] * n\n    \n    # Count the number of black pixels in each row and column\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B':\n                row_counts[i] += 1\n                col_counts[j] += 1\n    \n    # Count the number of lonely black pixels\n    for i in range(m):\n        for j in range(n):\n            if picture[i][j] == 'B' and row_counts[i] == 1 and col_counts[j] == 1:\n                lonely_pixel_count += 1\n    \n    # Return the count of lonely black pixels\n    return lonely_pixel_count", "funcname": "main_solution", "ios": [{"input": {"picture": [["W", "W", "W"], ["W", "W", "B"], ["W", "W", "W"]]}, "output": 1}, {"input": {"picture": [["B", "B", "W", "W", "W"], ["B", "W", "W", "W", "W"]]}, "output": 0}, {"input": {"picture": [["B", "W", "W", "W", "W", "W", "B", "W"], ["W", "W", "W", "B", "W", "W", "W", "W"]]}, "output": 1}, {"input": {"picture": [["W", "W", "W"], ["W", "W", "W"], ["W", "B", "W"], ["W", "W", "W"], ["B", "W", "B"]]}, "output": 1}, {"input": {"picture": [["W", "B", "W", "B", "W"], ["B", "B", "W", "W", "W"], ["W", "B", "W", "W", "W"]]}, "output": 0}, {"input": {"picture": [["W", "W", "W"], ["W", "B", "W"], ["B", "W", "W"], ["B", "W", "W"]]}, "output": 1}, {"input": {"picture": [["W", "W", "W", "W", "W", "W", "W", "W"], ["W", "W", "W", "W", "W", "W", "W", "W"], ["W", "W", "W", "W", "W", "W", "W", "W"]]}, "output": 0}, {"input": {"picture": [["W"]]}, "output": 0}, {"input": {"picture": [["W"], ["B"], ["W"], ["B"], ["W"]]}, "output": 0}, {"input": {"picture": [["W"], ["B"]]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "erjan/coding_exercises", "path": "/lonely_pixel_i.py", "msgidx": 4929}}
{"problem_description": "Given a list of words, can you determine if it is possible to arrange them in a circle such that each word is connected to the next word by the last character of the first word matching the first character of the second word? For example, if the list contains words like 'eggs', 'karat', 'apple', 'snack', and 'tuna', is it possible to arrange them in a circle where each word connects to the next based on the mentioned rule?", "io_requirements": "Input:\n  `words` (List[str]): A list of strings where each string represents a word.\n\nOutput:\n  `return` (bool): A boolean value indicating whether all words in the list can be circle chained. `True` if they can be chained, `False` otherwise.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef determine_if_all_chained(arr: List[str]) -> bool:\n    firstWords = {}\n    for word in arr:\n        if word[0] not in firstWords:\n            firstWords[word[0]] = 0\n        firstWords[word[0]] += 1\n    \n    for word in arr:\n        if word[-1] not in firstWords:\n            return False\n        firstWords[word[-1]] -= 1\n    \n    return all(value == 0 for value in firstWords.values())\n\n# main function\ndef main_solution(words: List[str]) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return determine_if_all_chained(words)", "funcname": "main_solution", "ios": [{"input": {"words": ["tkeqbpa", "gmjf", "rnf", "loinij", "yzh", "nxdo", "cxmsrg", "nydeo", "nylosb"]}, "output": false}, {"input": {"words": ["haququc", "kante", "ulbuvn", "qjrfpfd", "vkm"]}, "output": false}, {"input": {"words": ["jppdxwv", "lyqmroh", "ecox", "cwkceb", "xuk", "eggghk"]}, "output": false}, {"input": {"words": ["xsjonsf", "ucni", "gdg", "syod", "wjsu", "gbmhbo", "hspc", "bzmtfy"]}, "output": false}, {"input": {"words": ["kuz", "sxd", "dgzu", "naiu", "crxr"]}, "output": false}, {"input": {"words": ["pmgzz", "xtdtirn", "nmq", "irhh", "lxdpiq", "mme", "eqghx"]}, "output": false}, {"input": {"words": ["viatmw", "gnyej", "splrepr", "gxsklo", "vzuoi", "fxj", "vil", "bwjgw"]}, "output": false}, {"input": {"words": ["eorgu", "cbiej", "ebu", "vdyedyy", "szobrt", "techpmn", "hqh", "scssnyp"]}, "output": false}, {"input": {"words": ["nafeo", "erup", "yhwf", "hrxsyy", "ikkdxmp"]}, "output": false}, {"input": {"words": ["zat", "rgiq", "baryh", "eblz", "rpk", "kst", "jtk", "fbu", "ztl"]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "clemencegoh/Python_Algorithms", "path": "/algorithms/Daily_Interview/circle_of_chained_words.py", "msgidx": 4969}}
{"problem_description": "Given a list of words in mixed case, how can we group them into anagram sets such that larger anagram groups come before smaller ones, and within each group, words are sorted in case-insensitive ascending order? Additionally, if two anagram groups have the same count, the group with the smaller starting word should come first. What is the final sorted list of words that meets these criteria?", "io_requirements": "Input:\n  `words` (list of strings): A list of words (mixed case) to be grouped into anagram groups.\n\nOutput:\n  `return` (string): A JSON-encoded string representing the sorted list of words, where words are grouped into anagram groups and sorted according to the problem's requirements.", "refcode": "# import necessary packages\nimport json\nfrom collections import defaultdict\n\n# main function\ndef main_solution(words):\n    # Convert the input list of words into a list of lowercase words\n    words = [word.lower() for word in words]\n    \n    # Group words by their sorted characters (anagram groups)\n    anagram_groups = defaultdict(list)\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        anagram_groups[sorted_word].append(word)\n    \n    # Sort each anagram group internally in case-insensitive ascending order\n    for key in anagram_groups:\n        anagram_groups[key].sort(key=lambda x: x.lower())\n    \n    # Convert the anagram groups dictionary to a list of lists\n    anagram_list = list(anagram_groups.values())\n    \n    # Sort the anagram groups by the size of the group (descending) and by the first word in the group (ascending)\n    anagram_list.sort(key=lambda x: (-len(x), x[0].lower()))\n    \n    # Convert the sorted anagram groups back to a list of words\n    sorted_words = [word for group in anagram_list for word in group]\n    \n    # Return the sorted list of words as a JSON serializable output\n    return json.dumps(sorted_words)", "funcname": "main_solution", "ios": [{"input": {"words": ["UOwez", "LvlO", "DMuxX", "xULE", "XWqti", "JbSj", "uSYwtMJ"]}, "output": "[\"dmuxx\", \"jbsj\", \"lvlo\", \"uowez\", \"usywtmj\", \"xule\", \"xwqti\"]"}, {"input": {"words": ["CNXGWPR", "fqG", "kRiKT", "yZcJKga", "Uad", "cBuss", "TCdDPn", "xNFtYX"]}, "output": "[\"cbuss\", \"cnxgwpr\", \"fqg\", \"krikt\", \"tcddpn\", \"uad\", \"xnftyx\", \"yzcjkga\"]"}, {"input": {"words": ["yZal", "wtP", "sVlk", "lcD", "PESVCpw", "gqgWa", "BBcBEjG", "BEfTiS", "xbVlM"]}, "output": "[\"bbcbejg\", \"beftis\", \"gqgwa\", \"lcd\", \"pesvcpw\", \"svlk\", \"wtp\", \"xbvlm\", \"yzal\"]"}, {"input": {"words": ["fwsU", "gtkjfP", "tnnF", "ULYIRkl", "BnhrE", "AZUh", "alWLhj", "oZz", "bDoxx"]}, "output": "[\"alwlhj\", \"azuh\", \"bdoxx\", \"bnhre\", \"fwsu\", \"gtkjfp\", \"ozz\", \"tnnf\", \"ulyirkl\"]"}, {"input": {"words": ["jYUOF", "nTR", "HCe", "GLBR", "wAR", "dppYk", "vOC", "zfh"]}, "output": "[\"dppyk\", \"glbr\", \"hce\", \"jyuof\", \"ntr\", \"voc\", \"war\", \"zfh\"]"}, {"input": {"words": ["iNWl", "duCwHzF", "DThbHD", "JOri", "czd", "huQqN"]}, "output": "[\"czd\", \"dthbhd\", \"ducwhzf\", \"huqqn\", \"inwl\", \"jori\"]"}, {"input": {"words": ["kSSfyT", "IgKtkf", "kBlDX", "voEK", "AsYb"]}, "output": "[\"asyb\", \"igktkf\", \"kbldx\", \"kssfyt\", \"voek\"]"}, {"input": {"words": ["sbFF", "tXj", "Tkl", "aMQuQ", "xAE", "pWh", "vTAcLhD", "qabeO"]}, "output": "[\"amquq\", \"pwh\", \"qabeo\", \"sbff\", \"tkl\", \"txj\", \"vtaclhd\", \"xae\"]"}, {"input": {"words": ["nqTXHMJ", "vYQV", "cdxM", "vkGVgAf", "QPfz", "tcic", "opgd", "lXjxE"]}, "output": "[\"cdxm\", \"lxjxe\", \"nqtxhmj\", \"opgd\", \"qpfz\", \"tcic\", \"vkgvgaf\", \"vyqv\"]"}, {"input": {"words": ["iAD", "AWXByoe", "qGBR", "vOAMNFv", "wmRI", "wwtllh", "Puc"]}, "output": "[\"awxbyoe\", \"iad\", \"puc\", \"qgbr\", \"voamnfv\", \"wmri\", \"wwtllh\"]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "meghana998/MissionRND2019-ProfessionalPythonCourse", "path": "/unit7_assignment_01.py", "msgidx": 4377}}
{"problem_description": "Given a positive integer, determine whether it is a \"happy number\". A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. For example, 19 is a happy number because:\n\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\n\nIs the given positive integer a happy number?", "io_requirements": "Input:\n  `n` (int): A positive integer for which we need to determine if it is a happy number.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input number `n` is a happy number (`True`) or not (`False`).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        squares_set = set()\n        while n != 1:\n            squares_sum = 0\n            while n != 0:\n                squares_sum += ((n % 10) * (n % 10))\n                n //= 10\n            n = squares_sum\n            if n in squares_set:\n                break\n            else:\n                squares_set.add(n)\n\n        return n == 1\n\n# main function\ndef main_solution(n):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.isHappy(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 227}, "output": false}, {"input": {"n": 839}, "output": false}, {"input": {"n": 816}, "output": false}, {"input": {"n": 598}, "output": false}, {"input": {"n": 566}, "output": true}, {"input": {"n": 84}, "output": false}, {"input": {"n": 201}, "output": false}, {"input": {"n": 641}, "output": false}, {"input": {"n": 387}, "output": false}, {"input": {"n": 541}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "SunnyMarkLiu/LeetCode", "path": "/201-300/202. Happy Number.py", "msgidx": 5223}}
{"problem_description": "Given a binary tree with nodes indexed from 1 to n, and a set of queries specifying depths, what will be the in-order traversal of the tree after performing the swap operation at each specified depth for each query? The swap operation involves swapping the left and right subtrees of nodes at the specified depths.", "io_requirements": "Input:\n  `indexes` (list of lists of int): A list of lists where each sublist contains two integers representing the left and right child of a node. If a child is null, the value is -1.\n  `queries` (list of int): A list of integers representing the depths at which to perform the swap operation.\n\nOutput:\n  `return` (list of lists of int): A list of lists where each sublist contains the node indices of an in-order traversal after each swap operation.", "refcode": "# import necessary packages\nfrom queue import Queue\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, value, height):\n        self.data = value\n        self.left = None\n        self.right = None\n        self.height = height\n\n    def build_tree(self, indexes):\n        \"\"\"\n        :param indexes:\n        :return:\n        \"\"\"\n        root = self\n        queue = Queue()\n        queue.put(root)\n        for i in range(len(indexes)):\n            current = queue.get()\n            current.left = TreeNode(indexes[i][0], current.height + 1) if indexes[i][0] != -1 else None\n            current.right = TreeNode(indexes[i][1], current.height + 1) if indexes[i][1] != -1 else None\n            if current.left is not None:\n                queue.put(current.left)\n            if current.right is not None:\n                queue.put(current.right)\n\n    def print_tree(self, tree):\n        \"\"\"\n        Prints In-Order traversal of the tree\n        \"\"\"\n        if self is None:\n            return\n        if self.left:\n            self.left.print_tree(tree)\n        tree.append(self.data)\n        if self.right:\n            self.right.print_tree(tree)\n        return tree\n\ndef swap_nodes(indexes, queries):\n    \"\"\"\n    :param indexes:\n    :param queries:\n    :return:\n    \"\"\"\n    tree = TreeNode(1, 1)\n    tree.build_tree(indexes)\n    queue = Queue()\n    result = []\n    for query in queries:\n        queue.put(tree)\n        while not (queue.empty()):\n            query_list = [query * x for x in range(1, max(queries)+1)]\n            current = queue.get()\n            if current.left is not None:\n                queue.put(current.left)\n            if current.right is not None:\n                queue.put(current.right)\n            if current.left is not None and current.right is not None and current.height in query_list:\n                temp = current.left\n                current.left = current.right\n                current.right = temp\n            elif current.left is not None and current.right is None and current.height in query_list:\n                current.right = current.left\n                current.left = None\n            elif current.left is None and current.right is not None and current.height in query_list:\n                current.left = current.right\n                current.right = None\n        result.append(tree.print_tree([]))\n    return result\n\n# main function\ndef main_solution(indexes, queries):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    indexes = [[int(x) for x in sublist] for sublist in indexes]\n    queries = [int(x) for x in queries]\n    \n    # call the swap_nodes function\n    result = swap_nodes(indexes, queries)\n    \n    # convert the result to a json serializable format\n    result = [[int(x) for x in sublist] for sublist in result]\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"indexes": [[1, 2], [-1, -1]], "queries": [1]}, "output": [[2, 1, 1]]}, {"input": {"indexes": [[-1, 3], [0, 3], [-1, 3], [4, 2]], "queries": [1, 1, 1, 1, 2]}, "output": [[4, 3, 2, 3, 0, 3, 1], [1, 0, 3, 3, 4, 3, 2], [4, 3, 2, 3, 0, 3, 1], [1, 0, 3, 3, 4, 3, 2], [1, 4, 3, 2, 3, 0, 3]]}, {"input": {"indexes": [[1, 3], [3, 2], [1, 1]], "queries": [3, 1, 3]}, "output": [[3, 1, 2, 1, 1, 3, 1], [1, 3, 1, 1, 2, 1, 3], [1, 3, 1, 1, 2, 1, 3]]}, {"input": {"indexes": [[4, 0], [3, 1], [-1, -1], [1, 0]], "queries": [1, 2, 4]}, "output": [[0, 1, 1, 4, 0, 3, 1], [0, 1, 0, 3, 1, 4, 1], [0, 1, 0, 3, 1, 4, 1]]}, {"input": {"indexes": [[-1, 1]], "queries": [1, 1, 1]}, "output": [[1, 1], [1, 1], [1, 1]]}, {"input": {"indexes": [[0, 1]], "queries": [1, 1]}, "output": [[1, 1, 0], [0, 1, 1]]}, {"input": {"indexes": [[3, 1], [3, 0], [2, 0]], "queries": [3, 2, 1, 3, 3]}, "output": [[3, 3, 0, 1, 2, 1, 0], [0, 3, 3, 1, 0, 1, 2], [2, 1, 0, 1, 3, 3, 0], [2, 1, 0, 1, 3, 3, 0], [2, 1, 0, 1, 3, 3, 0]]}, {"input": {"indexes": [[2, 2], [-1, -1]], "queries": [2, 1]}, "output": [[2, 1, 2], [2, 1, 2]]}, {"input": {"indexes": [[1, 0]], "queries": [1, 1]}, "output": [[0, 1, 1], [1, 1, 0]]}, {"input": {"indexes": [[0, 0]], "queries": [1, 1]}, "output": [[0, 1, 0], [0, 1, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "VSNanditha/SimpleProblems", "path": "/SwapNodes.py", "msgidx": 4736}}
{"problem_description": "Given a binary tree structure, determine whether the tree is a Binary Search Tree (BST). A BST is a binary tree where the value of every node in the left subtree is less than the value of the node, and the value of every node in the right subtree is greater than the value of the node. What is the result of checking if the provided binary tree structure is a BST?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys `\"val\"` (int), `\"left\"` (dict or None), and `\"right\"` (dict or None).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is a Binary Search Tree (BST).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def is_bst(self):\n        if self.right and self.left:\n            if self.left < self and self < self.right:\n                return self.right.is_bst() and self.left.is_bst()\n            else:\n                return False\n        elif self.right:\n            return self.right > self and self.right.is_bst()\n        elif self.left:\n            return self.left < self and self.left.is_bst()\n        else:\n            return True\n\n    def __lt__(self, other):\n        return self.val < other.val\n\n    def __gt__(self, other):\n        return self.val > other.val\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        return Node(data[\"val\"], build_tree(data[\"left\"]), build_tree(data[\"right\"]))\n\n    root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    result = root.is_bst()\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 99, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 64, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 53, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 12, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 82, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 47, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 20, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 41, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 86, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 93, "left": null, "right": null}}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bradyz/sandbox", "path": "/randoms/verify-bst.py", "msgidx": 5141}}
{"problem_description": "Given a set of `n` elements, we are interested in subsets of size `k` and the cliques of size `i` within these subsets. How many size `i` cliques can be found in the Johnson graph `J(n, k)`?", "io_requirements": "Input:\n  `n` (int): The total number of elements in the set.\n  `k` (int): The size of subsets to consider in the Johnson Scheme.\n  `i` (int): The size of cliques to count in the Johnson graph.\n\nOutput:\n  `return` (int): The number of size `i` cliques in the Johnson graph `J(n, k)`.", "refcode": "# import necessary packages\nimport networkx as nx\nimport itertools\n\n# main function\ndef main_solution(n, k, i):\n    # Convert inputs to integers\n    n = int(n)\n    k = int(k)\n    i = int(i)\n    \n    # Function to generate the set of k-subsets of an n-element set\n    def js_parameters(n, k):\n        TupleSubsets = set(itertools.combinations(set(list(range(n))), k))\n        ListSubsets = list()\n        for x in TupleSubsets:\n            x = set(x)\n            ListSubsets.append(x)\n        return ListSubsets\n    \n    # Generate the set of k-subsets\n    ListSubsets = js_parameters(n, k)\n    \n    # Create the Johnson graph\n    JGraph = nx.Graph()\n    for x in ListSubsets:\n        for y in ListSubsets:\n            if len(x & y) == i:\n                JGraph.add_edge(str(x), str(y))\n    \n    # Function to count all cliques of size i in the graph\n    def enumerate_all_cliques_size_k(G, k):\n        count = 0\n        for clique in nx.enumerate_all_cliques(G):\n            if len(clique) == k:\n                count += 1\n            elif len(clique) > k:\n                return count\n        return count\n    \n    # Count the number of size i cliques in the Johnson graph\n    result = enumerate_all_cliques_size_k(JGraph, i)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 7, "k": 5, "i": 1}, "output": 0}, {"input": {"n": 5, "k": 4, "i": 4}, "output": 0}, {"input": {"n": 10, "k": 2, "i": 1}, "output": 45}, {"input": {"n": 5, "k": 3, "i": 3}, "output": 0}, {"input": {"n": 9, "k": 9, "i": 5}, "output": 0}, {"input": {"n": 6, "k": 2, "i": 2}, "output": 0}, {"input": {"n": 7, "k": 4, "i": 2}, "output": 315}, {"input": {"n": 5, "k": 5, "i": 2}, "output": 0}, {"input": {"n": 8, "k": 6, "i": 5}, "output": 168}, {"input": {"n": 10, "k": 5, "i": 4}, "output": 6300}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jonxu88/puremath", "path": "/JohnsonSchemePackage.py", "msgidx": 4898}}
{"problem_description": "In a large organization, there are several people who need to be assigned to committees. However, some pairs of people cannot work together due to personal conflicts. Given the total number of people and the pairs of people who cannot be in the same committee, what is the minimum number of committees required to ensure that no conflicting pairs are placed together?", "io_requirements": "Input:\n  `numPeople` (int): The total number of people that need to be assigned to committees.\n  `numPairsThatDontWork` (int): The number of pairs of people that cannot be in the same committee.\n  `pairsThatDontWork` (list of tuples): A list of tuples where each tuple contains two integers representing the indices of people who cannot be in the same committee.\n\nOutput:\n  `return` (int): The minimum number of committees required to accommodate all people without placing any conflicting pairs in the same committee.", "refcode": "# import necessary packages\nfrom z3 import *\n\n# main function\ndef main_solution(numPeople, numPairsThatDontWork, pairsThatDontWork):\n    # Convert JSON serializable inputs to the original input variables\n    f = Function('f', IntSort(), IntSort())\n    s = Solver()\n\n    # If there aren't any pairs that don't get along, you only need one committee\n    if numPairsThatDontWork == 0:\n        return 1\n\n    # Add constraints for pairs that don't get along\n    for pair in pairsThatDontWork:\n        firstPerson, secondPerson = pair\n        s.add(f(firstPerson) != f(secondPerson))\n\n    # Check for the minimum number of committees needed\n    for person in range(1, numPeople + 1):\n        s.push()\n        for i in range(1, numPeople + 1):\n            s.add(f(i) <= person, f(i) >= 1)\n        if s.check() == sat:\n            s.pop()\n            return person\n        s.pop()\n\n    return numPeople  # In case no solution is found, return the maximum possible number of committees", "funcname": "main_solution", "ios": [{"input": {"numPeople": 3, "numPairsThatDontWork": 0, "pairsThatDontWork": []}, "output": 1}, {"input": {"numPeople": 9, "numPairsThatDontWork": 0, "pairsThatDontWork": []}, "output": 1}, {"input": {"numPeople": 1, "numPairsThatDontWork": 0, "pairsThatDontWork": []}, "output": 1}, {"input": {"numPeople": 2, "numPairsThatDontWork": 0, "pairsThatDontWork": []}, "output": 1}, {"input": {"numPeople": 6, "numPairsThatDontWork": 3, "pairsThatDontWork": [[3, 6], [1, 2], [2, 5]]}, "output": 2}, {"input": {"numPeople": 2, "numPairsThatDontWork": 1, "pairsThatDontWork": [[1, 2]]}, "output": 2}, {"input": {"numPeople": 3, "numPairsThatDontWork": 1, "pairsThatDontWork": [[1, 2]]}, "output": 2}, {"input": {"numPeople": 8, "numPairsThatDontWork": 1, "pairsThatDontWork": [[1, 6]]}, "output": 2}, {"input": {"numPeople": 10, "numPairsThatDontWork": 1, "pairsThatDontWork": [[3, 6]]}, "output": 2}, {"input": {"numPeople": 4, "numPairsThatDontWork": 1, "pairsThatDontWork": [[1, 4]]}, "output": 2}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "acvirts23/Projects-Labs", "path": "/450/lab6/constraints.py", "msgidx": 4976}}
{"problem_description": "Given a list of words, each consisting of uppercase letters, determine how many of these words are considered \"triangle words.\" A word is a triangle word if the sum of the alphabetical positions of its letters (e.g., A=1, B=2, ..., Z=26) is a triangle number. What is the total number of triangle words in the list?", "io_requirements": "Input:\n  `words` (list of strings): A list of words where each word is a string of uppercase letters. Each word is enclosed in double quotes and separated by commas.\n\nOutput:\n  `return` (int): The total number of words in the input list that are triangle words. A triangle word is defined as a word whose value (sum of the alphabetical positions of its letters) is a triangle number.", "refcode": "# import necessary packages\nimport string\nfrom itertools import count, islice\n\n# all class and function definitions in the code file, if any\ndef triangle_numbers(limit):\n    nums = set()\n    for i in range(1, limit):\n        nums.add(int(.5 * i * (i + 1)))\n    return nums\n\n# main function\ndef main_solution(words):\n    # Convert words from a list of strings to a list of integers representing their values\n    words = [word.strip('\"') for word in words]\n    \n    # Create a dictionary that maps each letter to its corresponding value\n    vals = islice(count(1), 26)\n    letters = string.ascii_uppercase\n    letterVals = dict(zip(letters, vals))\n    \n    # Generate a set of triangle numbers up to a reasonable limit\n    triangles = triangle_numbers(20)\n    \n    # Calculate the total number of triangle words\n    total = 0\n    for word in words:\n        word_value = sum(letterVals[c] for c in word)\n        if word_value in triangles:\n            total += 1\n    \n    # Return the total number of triangle words\n    return total", "funcname": "main_solution", "ios": [{"input": {"words": ["\"ACX\"", "\"CTK\"", "\"AYBAZRZD\"", "\"OBGU\"", "\"CGDWHX\"", "\"NVZF\"", "\"YUOEIXZEWH\"", "\"UBZMQHLMB\"", "\"MLS\"", "\"THH\""]}, "output": 3}, {"input": {"words": ["\"GTGUYOEJ\"", "\"VQFFFSEAYX\"", "\"NYEMV\"", "\"PMU\"", "\"HIYIIV\"", "\"JQS\"", "\"JZRTR\"", "\"DNZH\"", "\"YXLVX\"", "\"UMDBKD\""]}, "output": 1}, {"input": {"words": ["\"LUYQQ\"", "\"RYNQBQ\"", "\"WBIAMB\"", "\"MDT\"", "\"FTJZBZ\"", "\"JIHQ\"", "\"VPDA\"", "\"VMTXMF\"", "\"INN\"", "\"KCBMX\""]}, "output": 0}, {"input": {"words": ["\"JAEVP\"", "\"BVOP\"", "\"BTXPG\"", "\"GYNPV\"", "\"COCWKLGK\"", "\"XLHZYIBOZ\"", "\"AZZS\"", "\"AFEAOX\"", "\"VBHAU\"", "\"YIMJLREG\""]}, "output": 1}, {"input": {"words": ["\"ZFQPU\"", "\"GAFCBVS\"", "\"ZPNFMKE\"", "\"YFIK\"", "\"QLXIGNEU\"", "\"DGZ\"", "\"QQI\"", "\"AONJMFTT\"", "\"NZMP\"", "\"ZQTZ\""]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ledbutter/ProjectEulerPython", "path": "/Problem42.py", "msgidx": 4913}}
{"problem_description": "Given a set of non-standard dice, each with a specified number of sides and values ranging from a minimum to a maximum, determine which dice have a higher chance of winning against each other. Specifically, for each pair of dice, identify which die is more likely to roll a higher value than the other. What is the relationship between the dice in terms of winning and losing?", "io_requirements": "Input:\n  `min_value` (int): The minimum value of the sides of the dice.\n  `max_value` (int): The maximum value of the sides of the dice.\n  `sides` (int): The number of sides on each die.\n\nOutput:\n  `return` (dict): A dictionary where each key is a string representation of a die (e.g., \"444400\") and the value is another dictionary with two keys:\n    - `wins_against` (list of strings): A list of dice that the key die wins against.\n    - `loses_against` (list of strings): A list of dice that the key die loses against.", "refcode": "# import necessary packages\nimport sys\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef die_generator(*, min_value=0, max_value=4, sides=4):\n    \"\"\"\n    This returns a generator that generates all the possible dice, given the\n    minimum and maximum values of the sides, as well as the number of sides.\n    \"\"\"\n    for first_side in range(min_value, max_value + 1):\n        if sides == 1:\n            yield (first_side,)\n        else:\n            gen = die_generator(min_value=0, max_value=first_side, sides=sides - 1)\n            yield from ((first_side,) + die for die in gen)\n\ndef is_best(this, oponent):\n    \"\"\"\n    Determine which of the two given dice has a higher probability of rolling\n    a higher value than the other die.\n    \"\"\"\n    total = len(this) * len(oponent)\n    count = 0\n    ties = 0\n    for side1 in this:\n        count += sum(1 for side2 in oponent if side1 > side2)\n        ties += sum(1 for side2 in oponent if side1 == side2)\n    return count > total - ties - count\n\ndef clean(graph):\n    \"\"\"\n    Remove from the graph the dice that only win or only loose. Keep doing it\n    until no change occurs.\n    \"\"\"\n    while True:\n        to_delete = [die for die, (w, l) in graph.items() if len(w) == 0 or len(l) == 0]\n        if len(to_delete) == 0:\n            break\n        for die in to_delete:\n            del graph[die]\n        for (w, l) in graph.values():\n            for die in to_delete:\n                if die in w:\n                    w.remove(die)\n                if die in l:\n                    l.remove(die)\n\n# main function\ndef main_solution(min_value, max_value, sides):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Generate all pairs of dice\n    graph = defaultdict(lambda: ([], []))\n    \n    for this in die_generator(min_value=min_value, max_value=max_value, sides=sides):\n        for oponent in die_generator(min_value=min_value, max_value=max_value, sides=sides):\n            if is_best(this, oponent):\n                graph[this][0].append(oponent)\n                graph[oponent][1].append(this)\n    \n    # Remove all \"uninteresting\" information from the graph\n    clean(graph)\n    \n    # Convert the result to a JSON serializable format\n    result = {}\n    for this in sorted(graph):\n        w, l = graph[this]\n        this_name = \"\".join(map(str, this))\n        result[this_name] = {\n            \"wins_against\": [\"\".join(map(str, die)) for die in sorted(w)],\n            \"loses_against\": [\"\".join(map(str, die)) for die in sorted(l)]\n        }\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"min_value": 0, "max_value": 1, "sides": 4}, "output": {}}, {"input": {"min_value": 2, "max_value": 3, "sides": 3}, "output": {}}, {"input": {"min_value": 1, "max_value": 3, "sides": 2}, "output": {}}, {"input": {"min_value": 0, "max_value": 3, "sides": 2}, "output": {}}, {"input": {"min_value": 1, "max_value": 2, "sides": 4}, "output": {}}, {"input": {"min_value": 0, "max_value": 1, "sides": 5}, "output": {}}, {"input": {"min_value": 3, "max_value": 4, "sides": 2}, "output": {}}, {"input": {"min_value": 2, "max_value": 5, "sides": 2}, "output": {}}, {"input": {"min_value": 1, "max_value": 2, "sides": 5}, "output": {}}, {"input": {"min_value": 0, "max_value": 2, "sides": 4}, "output": {}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jdferreira/dice", "path": "/main.py", "msgidx": 5058}}
{"problem_description": "Given a list of integers, how can we represent the ranges of consecutive numbers in a string format where each range is separated by a dash (`-`) and individual numbers are separated by commas (`,`)? For example, if the list contains `[-6, -3, -2, -1, 0, 1, 7, 8, 9, 10, 11, 14, 15]`, the output should be `\"-6,-3-1,7-11,14,15\"`.", "io_requirements": "Input:\n  `numbers` (list of integers): A list of integers for which the ranges need to be determined.\n\nOutput:\n  `return` (string): A string representing the ranges of consecutive numbers separated by dashes (`-`) and individual numbers separated by commas (`,`).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(numbers):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    def numbers_range(r):\n        if not r:\n            return ''\n        elif len(r) == 1:\n            return str(r[0])\n        s, e, res = 0, 0, ''\n        for i in range(1, len(r)):\n            if r[i] - r[i - 1] == 1 and i < len(r) - 1:\n                e = i\n            else:\n                if i == len(r) - 1:\n                    e = i\n                if s == e:\n                    res += '{}, '.format(str(r[s]))\n                elif e - s == 1:\n                    res += '{}, {}, '.format(str(r[s]), str(r[e]))\n                else:\n                    res += '{}-{}, '.format(str(r[s]), str(r[e]))\n                s = i\n                e = i\n        return res[: -2]\n    \n    # Convert the input list to a sorted list of integers\n    sorted_numbers = sorted(numbers)\n    \n    # Call the numbers_range function with the sorted list\n    result = numbers_range(sorted_numbers)\n    \n    # Return the result as a string\n    return result", "funcname": "main_solution", "ios": [{"input": {"numbers": [38, -42, 14, 8, -21]}, "output": "-42, -21, 8, 14, 38"}, {"input": {"numbers": [-24, -14, 17, -36, 21, 35, 25, 5, 46, 1, -28]}, "output": "-36, -28, -24, -14, 1, 5, 17, 21, 25, 35, 46"}, {"input": {"numbers": [-23, 39, -47, -30, -6, 36]}, "output": "-47, -30, -23, -6, 36, 39"}, {"input": {"numbers": [-30, 16, 32, -10, 35, 18, 29, -9, -42, 28]}, "output": "-42, -30, -10, -9, 16, 18, 28, 29, 32, 35"}, {"input": {"numbers": [30, 34, -10, 36, 30, 0, 25, 34, 25, -45, -43, -38, 15, 19, -26, -34, -11, 8]}, "output": "-45, -43, -38, -34, -26, -11, -10, 0, 8, 15, 19, 25, 25, 30, 30, 34, 34, 36"}, {"input": {"numbers": [-28, 45, -13, 47, 32]}, "output": "-28, -13, 32, 45, 47"}, {"input": {"numbers": [46, 18, -48, -14, -45, 34, 38, -23, -15, 1, -27, 31, -25]}, "output": "-48, -45, -27, -25, -23, -15, -14, 1, 18, 31, 34, 38, 46"}, {"input": {"numbers": [-35, -14, 35, 5, -23, -8, -32, -14, 17, 39, -28, -32, -31]}, "output": "-35, -32, -32, -31, -28, -23, -14, -14, -8, 5, 17, 35, 39"}, {"input": {"numbers": [-39, -6, -4, -35, 13, -30, -32]}, "output": "-39, -35, -32, -30, -6, -4, 13"}, {"input": {"numbers": [45, 5, -38, -43, 45]}, "output": "-43, -38, 5, 45, 45"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/3dECspHz4fD7ijhky_2.py", "msgidx": 5291}}
{"problem_description": "Given a non-negative integer `n`, determine the number of digits in `n`, the sum of all integers from 1 to `n`, the factorial of `n`, the number of vowels in the string representation of `n`, and the maximum digit in the string representation of `n`. What are these values?", "io_requirements": "Input:\n  `n` (int): A non-negative integer for which the calculations will be performed.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `num_digits` (int): The number of digits in the integer `n`.\n    - `sum_n` (int): The sum of all integers from 1 to `n`.\n    - `fact_n` (int): The factorial of `n`.\n    - `num_vowels` (int): The number of vowels in the string representation of `n`.\n    - `max_digit` (int): The maximum digit in the string representation of `n`.", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef suma_rango(a, b):\n    return 0 if a > b else a + suma_rango(a + 1, b)\n\ndef factorial(n):\n    return 1 if n == 0 else n * factorial(n - 1)\n\ndef digitos(n):\n    return 1 if n < 10 else digitos(n // 10) + 1\n\ndef longitud(s):\n    return 0 if s == '' else 1 + longitud(s[1:])\n\ndef vocales(s):\n    return 0 if s == '' else vocales(s[1:]) + (1 if vocal(s[0]) else 0)\n\ndef vocal(s):\n    return s.lower() in 'aeiou\u00e1\u00e9\u00ed\u00f3\u00fa'\n\ndef maximo(t):\n    return reduce(max, t)\n\n# main function\ndef main_solution(n):\n    # Convert input to integer if necessary\n    n = int(n)\n    \n    # Calculate the number of digits in n\n    num_digits = digitos(n)\n    \n    # Calculate the sum of numbers from 1 to n\n    sum_n = suma_rango(1, n)\n    \n    # Calculate the factorial of n\n    fact_n = factorial(n)\n    \n    # Calculate the number of vowels in the string representation of n\n    num_vowels = vocales(str(n))\n    \n    # Calculate the maximum digit in the string representation of n\n    max_digit = maximo(tuple(map(int, str(n))))\n    \n    # Return the results as a dictionary\n    return {\n        \"num_digits\": num_digits,\n        \"sum_n\": sum_n,\n        \"fact_n\": fact_n,\n        \"num_vowels\": num_vowels,\n        \"max_digit\": max_digit\n    }", "funcname": "main_solution", "ios": [{"input": {"n": 102}, "output": {"num_digits": 3, "sum_n": 5253, "fact_n": 961446671503512660926865558697259548455355905059659464369444714048531715130254590603314961882364451384985595980362059157503710042865532928000000000000000000000000, "num_vowels": 0, "max_digit": 2}}, {"input": {"n": 86}, "output": {"num_digits": 2, "sum_n": 3741, "fact_n": 24227095383672732381765523203441259715284870552429381750838764496720162249742450276789464634901319465571660595200000000000000000000, "num_vowels": 0, "max_digit": 8}}, {"input": {"n": 60}, "output": {"num_digits": 2, "sum_n": 1830, "fact_n": 8320987112741390144276341183223364380754172606361245952449277696409600000000000000, "num_vowels": 0, "max_digit": 6}}, {"input": {"n": 55}, "output": {"num_digits": 2, "sum_n": 1540, "fact_n": 12696403353658275925965100847566516959580321051449436762275840000000000000, "num_vowels": 0, "max_digit": 5}}, {"input": {"n": 19}, "output": {"num_digits": 2, "sum_n": 190, "fact_n": 121645100408832000, "num_vowels": 0, "max_digit": 9}}, {"input": {"n": 91}, "output": {"num_digits": 2, "sum_n": 4186, "fact_n": 135200152767840296255166568759495142147586866476906677791741734597153670771559994765685283954750449427751168336768008192000000000000000000000, "num_vowels": 0, "max_digit": 9}}, {"input": {"n": 63}, "output": {"num_digits": 2, "sum_n": 2016, "fact_n": 1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000, "num_vowels": 0, "max_digit": 6}}, {"input": {"n": 114}, "output": {"num_digits": 3, "sum_n": 6555, "fact_n": 2543559733472187557120132004189335234812341496026552301496526393412538629248600474981599398141467853800514886431180030568224218435400019580180261753940817530060800000000000000000000000000, "num_vowels": 0, "max_digit": 4}}, {"input": {"n": 68}, "output": {"num_digits": 2, "sum_n": 2346, "fact_n": 2480035542436830599600990418569171581047399201355367672371710738018221445712183296000000000000000, "num_vowels": 0, "max_digit": 8}}, {"input": {"n": 110}, "output": {"num_digits": 3, "sum_n": 6105, "fact_n": 15882455415227429404253703127090772871724410234473563207581748318444567162948183030959960131517678520479243672638179990208521148623422266876757623911219200000000000000000000000000, "num_vowels": 0, "max_digit": 1}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ricpelo/pro2021", "path": "/definiciones.py", "msgidx": 5075}}
{"problem_description": "Given a range of numbers representing potential passwords, we need to determine how many of these passwords meet specific criteria. The criteria include having at least one pair of adjacent digits that are the same (but not part of a larger group of identical digits) and ensuring that the digits never decrease from left to right. How many passwords within the specified range satisfy these conditions?", "io_requirements": "Input:\n  `start` (int): The starting number of the range of passwords to check.\n  `end` (int): The ending number of the range of passwords to check.\n  `criteria` (str): The criteria to use for checking the passwords. It can be either \"double\" or \"at_least_one_double\".\n\nOutput:\n  `return` (int): The number of valid passwords that meet the specified criteria and are in increasing order.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef has_double(pwd):\n    for _ in range(5):\n        l, r = pwd[_:_+2]\n        if l == r:\n            return True\n    return False\n\ndef has_at_least_one_double(pwd):\n    p = ''\n    for _ in range(5):\n        (l, r), tail = pwd[_:_+2], pwd[_+2:_+3]\n        if p != l == r and tail != l:\n            return True\n        p = l\n    return False\n\ndef increasing(pwd):\n    for _ in range(5):\n        l, r = pwd[_:_+2]\n        if l > r:\n            return False\n    return True\n\n# main function\ndef main_solution(start, end, criteria):\n    # Convert input arguments to the required format\n    ins = range(start, end + 1)\n    \n    # Determine which criteria function to use\n    if criteria == \"double\":\n        criteria_func = has_double\n    elif criteria == \"at_least_one_double\":\n        criteria_func = has_at_least_one_double\n    else:\n        raise ValueError(\"Invalid criteria specified\")\n    \n    # Apply the criteria and increasing check\n    possible = [_ for _ in ins if criteria_func(str(_)) and increasing(str(_))]\n    \n    # Return the count of valid passwords\n    return len(possible)", "funcname": "main_solution", "ios": [{"input": {"start": 241456, "end": 598779, "criteria": "double"}, "output": 1078}, {"input": {"start": 416286, "end": 825472, "criteria": "at_least_one_double"}, "output": 288}, {"input": {"start": 220493, "end": 901601, "criteria": "at_least_one_double"}, "output": 1148}, {"input": {"start": 451532, "end": 702276, "criteria": "double"}, "output": 307}, {"input": {"start": 300333, "end": 697709, "criteria": "at_least_one_double"}, "output": 589}, {"input": {"start": 486793, "end": 919700, "criteria": "double"}, "output": 215}, {"input": {"start": 432608, "end": 997026, "criteria": "at_least_one_double"}, "output": 290}, {"input": {"start": 143320, "end": 417826, "criteria": "at_least_one_double"}, "output": 1008}, {"input": {"start": 251586, "end": 577772, "criteria": "double"}, "output": 937}, {"input": {"start": 248764, "end": 825461, "criteria": "at_least_one_double"}, "output": 671}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "addyess/aoc", "path": "/aoc2019/day4.py", "msgidx": 4920}}
{"problem_description": "Alice and Bob are playing a game where they take turns appending letters to substrings of two given strings, A and B. Alice wants to find the Kth lexicographically winning position for the first player (herself). Given the lengths of the strings A and B, the strings themselves, and the integer K, what are the substrings A' and B' that represent the Kth lexicographically winning position for Alice?", "io_requirements": "Input:\n  `N` (int): The length of string A.\n  `M` (int): The length of string B.\n  `K` (int): The Kth lexicographically winning position to find.\n  `A` (str): The string A consisting of N small Latin letters.\n  `B` (str): The string B consisting of M small Latin letters.\n\nOutput:\n  `return` (dict): A dictionary containing the keys \"A_prime\" and \"B_prime\". The value of \"A_prime\" is the substring of A that is the Kth lexicographically winning position, and \"B_prime\" is the corresponding substring of B. If no such position exists, both values will be \"no solution\".", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(N, M, K, A, B):\n    # Convert inputs to appropriate types if necessary\n    N = int(N)\n    M = int(M)\n    K = int(K)\n    A = str(A)\n    B = str(B)\n\n    # Helper function to check if a position is winning\n    def is_winning_position(A_prime, B_prime):\n        # Implement the logic to determine if the position (A_prime, B_prime) is winning\n        # This is a simplified version of the logic, you may need to expand it based on the game rules\n        return (A_prime, B_prime) in winning_positions\n\n    # Generate all possible positions and determine if they are winning\n    winning_positions = []\n    for a_len in range(N + 1):\n        for b_len in range(M + 1):\n            A_prime = A[:a_len]\n            B_prime = B[:b_len]\n            if is_winning_position(A_prime, B_prime):\n                winning_positions.append((A_prime, B_prime))\n\n    # Sort the winning positions lexicographically\n    winning_positions.sort()\n\n    # Return the Kth lexicographically winning position\n    if K <= len(winning_positions):\n        return {\"A_prime\": winning_positions[K - 1][0], \"B_prime\": winning_positions[K - 1][1]}\n    else:\n        return {\"A_prime\": \"no solution\", \"B_prime\": \"no solution\"}", "funcname": "main_solution", "ios": [{"input": {"N": 7, "M": 7, "K": 51, "A": "zlhesfr", "B": "mxzgqco"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 1, "M": 1, "K": 48, "A": "o", "B": "t"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 1, "M": 4, "K": 97, "A": "p", "B": "xege"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 4, "M": 7, "K": 47, "A": "jeqq", "B": "baabpmi"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 5, "M": 10, "K": 62, "A": "hwodk", "B": "usvccvalfr"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 8, "M": 3, "K": 53, "A": "tylkwzpa", "B": "yqy"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 2, "M": 7, "K": 51, "A": "ax", "B": "ltfasxx"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 7, "M": 1, "K": 90, "A": "eookpnx", "B": "t"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 4, "M": 10, "K": 42, "A": "pmdv", "B": "xdgzwnyptt"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}, {"input": {"N": 9, "M": 6, "K": 1, "A": "oirmhuudh", "B": "nhzjdj"}, "output": {"A_prime": "no solution", "B_prime": "no solution"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sagarnikam123/learnNPractice", "path": "/hackerRank/tracks/coreCS/algorithms/strings/twoStringsGame.py", "msgidx": 4776}}
{"problem_description": "Given a message that is either in plaintext or ciphertext using the Polybius Square cipher, what is the corresponding transformed message? The Polybius Square cipher uses a 5x5 grid where each letter is replaced by its row and column numbers, with \"I\" and \"J\" sharing a slot.", "io_requirements": "Input:\n  `text` (str): The input message which can be either plaintext or ciphertext. If plaintext, it should contain only letters and spaces. If ciphertext, it should contain only digits and spaces.\n\nOutput:\n  `return` (str): The transformed message. If the input was plaintext, the output will be the corresponding ciphertext. If the input was ciphertext, the output will be the corresponding plaintext.", "refcode": "# import necessary packages\nimport string\nfrom math import floor\n\n# main function\ndef main_solution(text):\n    # Helper functions\n    get_row = lambda idx, width=5: str(1 + floor(idx / width))\n    get_column = lambda idx, width=5: str(1 + idx % 5)\n\n    # Create cipher dictionary\n    cipher = {}\n    letters = 'a b c d e f g h i j k l m n o p q r s t u v w x y z'.split(' ')\n\n    for idx, letter in enumerate(letters):\n        if idx > 8:\n            idx -= 1  # Down shift to account for I/J sharing\n        if letter != 'j':\n            row = get_row(idx)\n            col = get_column(idx)\n            rc = int(row + col)\n            cipher[letter] = rc\n            cipher[rc] = letter\n        else:\n            row = get_row(8)  # letter i is index 8\n            col = get_column(8)\n            rc = int(row + col)\n            cipher[letter] = rc\n            cipher[rc] = 'i'\n\n    # Determine if message is encrypted already\n    try:\n        _ = int(text.split()[0])\n        encrypted = True\n    except ValueError:\n        text = text.lower()\n        text = text.translate(str.maketrans('', '', string.punctuation))\n        encrypted = False\n\n    if encrypted:\n        result = ''\n        for term in text.split(' '):\n            word = ''\n            for i in range(int(len(term) / 2)):\n                key = int(term[i * 2:i * 2 + 2])\n                word += cipher[key]\n            result += word\n            result += ' '\n    else:\n        result = ''\n        for word in text.split(' '):\n            term = ''\n            for letter in word:\n                term += str(cipher[letter])\n            result += '{} '.format(term)\n\n    return result[:-1]", "funcname": "main_solution", "ios": [{"input": {"text": "zcOhULIdsleLDJ"}, "output": "5513342345312414433115311424"}, {"input": {"text": "BKGoVudnlb"}, "output": "12252234514514333112"}, {"input": {"text": "UOTkk NmNV"}, "output": "4534442525 33323351"}, {"input": {"text": "mmUweUMZAABcnBj"}, "output": "323245521545325511111213331224"}, {"input": {"text": "15541434143511"}, "output": "eydodpa"}, {"input": {"text": "FPccVKSbsy"}, "output": "21351313512543124354"}, {"input": {"text": "KpaspGLdQ jY"}, "output": "253511433522311441 2454"}, {"input": {"text": "CVngMKOHtVM"}, "output": "1351332232253423445132"}, {"input": {"text": "qIenFdeuT"}, "output": "412415332114154544"}, {"input": {"text": "dhnfgKLV"}, "output": "1423332122253151"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/2C3gtb4treAFyWJMg_18.py", "msgidx": 5298}}
{"problem_description": "Given a binary tree and a target sum, what are the paths from the root to the leaf nodes in the tree where the sum of the node values equals the target sum?", "io_requirements": "Input:\n  `tree_structure` (list of integers): A list representing the binary tree. Each element in the list corresponds to a node value. If a node is `None`, it indicates a missing node. The list is constructed in a level-order traversal manner.\n  `target_sum` (integer): The target sum for which paths need to be found in the binary tree.\n\nOutput:\n  `return` (string): A JSON serialized string representing a list of lists. Each inner list represents a path in the binary tree whose node values sum up to the `target_sum`.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def FindPath(self, root, expectNumber):\n        if root is None or root.val > expectNumber:\n            return []\n        if root.left is None and root.right is None:\n            if expectNumber == root.val:\n                return [[root.val]]\n            else:\n                return []\n        left = self.FindPath(root.left, expectNumber - root.val)\n        right = self.FindPath(root.right, expectNumber - root.val)\n        a = left + right\n\n        return [[root.val] + x for x in a]\n\n# main function\ndef main_solution(tree_structure, target_sum):\n    # Convert JSON serializable input to original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    solution = Solution()\n    paths = solution.FindPath(root, target_sum)\n    \n    # Convert output to JSON serializable format\n    return json.dumps(paths)", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [5, 9, 20, 1, 12, 10, 7], "target_sum": 20}, "output": "[]"}, {"input": {"tree_structure": [7, 17, 13, 5, null, 9, 19, 8, 14, 5, 16, 8, 6, 18, 6], "target_sum": 20}, "output": "[]"}, {"input": {"tree_structure": [19, 12, 11, 6, null, 12, null], "target_sum": 37}, "output": "[[19, 12, 6]]"}, {"input": {"tree_structure": [14, 16, 1], "target_sum": 34}, "output": "[]"}, {"input": {"tree_structure": [5, 17, 9, 19, 15, 2, 10], "target_sum": 42}, "output": "[]"}, {"input": {"tree_structure": [6, 8, 12, 18, 2, 10, 16], "target_sum": 30}, "output": "[]"}, {"input": {"tree_structure": [15, 1, null, 19, 16, 12, 17], "target_sum": 25}, "output": "[]"}, {"input": {"tree_structure": [5, 17, 4], "target_sum": 36}, "output": "[]"}, {"input": {"tree_structure": [15, 8, 16, 18, 20, 4, 10, 20, 6, null, 20, null, 7, 14, 4], "target_sum": 16}, "output": "[]"}, {"input": {"tree_structure": [9, 4, 1, null, 3, 5, 2], "target_sum": 20}, "output": "[]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "alexkie007/offer", "path": "/Target Offer/34. \u4e8c\u53c9\u6811\u4e2d\u548c\u4e3a\u67d0\u4e00\u503c\u7684\u8def\u5f84.py", "msgidx": 4921}}
{"problem_description": "Given two binary trees represented by JSON strings, determine whether the second tree is a subtree of the first tree. Note that an empty tree is not considered a subtree of any tree. What is the result of this comparison?", "io_requirements": "Input:\n  `tree1_json` (str): A JSON string representing the first binary tree. The JSON structure should be a dictionary with keys \"val\" (int), \"left\" (dict or None), and \"right\" (dict or None).\n  `tree2_json` (str): A JSON string representing the second binary tree. The JSON structure should be the same as `tree1_json`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the second tree (`tree2_json`) is a subtree of the first tree (`tree1_json`).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def HasSubtree(self, pRoot1, pRoot2):\n        if pRoot1 == None or pRoot2 == None:\n            return False\n        return self.Tree1HasTree2(pRoot1, pRoot2) or self.HasSubtree(pRoot1.left, pRoot2) or \\\n               self.HasSubtree(pRoot1.right, pRoot2)\n\n    def Tree1HasTree2(self, tree1, tree2):\n        if tree2 == None:\n            return True\n        if tree1 == None:\n            return False\n        if tree1.val != tree2.val:\n            return False\n        return self.Tree1HasTree2(tree1.left, tree2.left) and self.Tree1HasTree2(tree1.right, tree2.right)\n\n# main function\ndef main_solution(tree1_json, tree2_json):\n    # Convert JSON strings to TreeNode objects\n    def json_to_tree(json_data):\n        if not json_data:\n            return None\n        root = TreeNode(json_data[\"val\"])\n        root.left = json_to_tree(json_data[\"left\"])\n        root.right = json_to_tree(json_data[\"right\"])\n        return root\n\n    tree1 = json_to_tree(json.loads(tree1_json))\n    tree2 = json_to_tree(json.loads(tree2_json))\n\n    # Check if tree2 is a subtree of tree1\n    solution = Solution()\n    result = solution.HasSubtree(tree1, tree2)\n\n    # Return the result as a boolean\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree1_json": "{\"val\": 70, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 71, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 95, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 74, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 1, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 41, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 14, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 79, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 74, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 5, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 96, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 29, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 31, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 20, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 12, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 81, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 44, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 41, \"left\": null, \"right\": null}"}, "output": false}, {"input": {"tree1_json": "{\"val\": 27, \"left\": null, \"right\": null}", "tree2_json": "{\"val\": 83, \"left\": null, \"right\": null}"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JaeZheng/jianzhi_offer", "path": "/17.py", "msgidx": 4657}}
{"problem_description": "Given a list of product pairs where each pair represents two products belonging to the same category, how many distinct product categories are there, and what are the products in each category?", "io_requirements": "Input:\n  `product_pairs` (str): A JSON string representing a list of tuples. Each tuple contains two integers representing pairs of products that belong to the same category.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `number_of_categories` (int): The number of distinct product categories.\n    - `categories` (list of lists): A list where each element is a list of integers representing the products in each category.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self, size, adjacency_list):\n        self.size = size\n        self.adjacency_list = adjacency_list\n\n    def add_edge(self, v1, v2):\n        if v1 in self.adjacency_list:\n            self.adjacency_list[v1].add(v2)\n        else: \n            self.adjacency_list[v1] = { v2 }\n\n        if v2 in self.adjacency_list:\n            self.adjacency_list[v2].add(v1)\n        else: \n            self.adjacency_list[v2] = { v1 }\n\n# Build the graph from the list of product pairs\ndef construct_graph(pairs):\n    adjacency_list = {}\n    graph = Graph(len(adjacency_list), adjacency_list) \n\n    for pair in pairs:\n        product1 = pair[0]\n        product2 = pair[1]\n        graph.add_edge(product1, product2)\n\n    return graph\n\n# Find disjoint components of a graph\ndef find_disjoint_subgraphs(graph):\n    adjacency_list = graph.adjacency_list\n    node_count = graph.size\n    nodes = list(adjacency_list.keys())\n\n    if len(nodes) == 0:\n        return []\n    \n    categories = []\n    visited = {node: False for node in nodes}\n\n    for node in nodes:\n        if not visited[node]:\n            queue = [node]\n            category = set()\n\n            while queue:\n                v = queue.pop(0)\n                category.add(v)\n                for neighbor in adjacency_list[v]:\n                    if not visited[neighbor]:\n                        queue.append(neighbor)\n                visited[v] = True\n            \n            categories.append(category)\n    \n    return categories\n\n# main function\ndef main_solution(product_pairs):\n    # Convert input to the required format\n    product_pairs = json.loads(product_pairs)\n    \n    # Construct the graph\n    product_graph = construct_graph(product_pairs)\n    \n    # Find disjoint subgraphs\n    categories = find_disjoint_subgraphs(product_graph)\n    \n    # Convert categories to JSON serializable format\n    categories_serializable = [list(category) for category in categories]\n    \n    # Return the number of categories and the list of products in each category\n    return {\n        \"number_of_categories\": len(categories),\n        \"categories\": categories_serializable\n    }", "funcname": "main_solution", "ios": [{"input": {"product_pairs": "[[1, 7]]"}, "output": {"number_of_categories": 1, "categories": [[1, 7]]}}, {"input": {"product_pairs": "[[5, 9], [11, 18], [12, 14], [18, 14]]"}, "output": {"number_of_categories": 2, "categories": [[9, 5], [18, 11, 12, 14]]}}, {"input": {"product_pairs": "[[18, 2]]"}, "output": {"number_of_categories": 1, "categories": [[18, 2]]}}, {"input": {"product_pairs": "[[11, 2], [20, 15], [13, 5], [17, 15]]"}, "output": {"number_of_categories": 3, "categories": [[2, 11], [17, 20, 15], [5, 13]]}}, {"input": {"product_pairs": "[[11, 14], [15, 5], [15, 16], [18, 19], [11, 10]]"}, "output": {"number_of_categories": 3, "categories": [[10, 11, 14], [16, 5, 15], [18, 19]]}}, {"input": {"product_pairs": "[[8, 4], [4, 1], [14, 4], [10, 15], [17, 10], [14, 13], [15, 12], [11, 8]]"}, "output": {"number_of_categories": 2, "categories": [[1, 4, 8, 11, 13, 14], [17, 10, 12, 15]]}}, {"input": {"product_pairs": "[[8, 19], [6, 6], [2, 5], [6, 16], [19, 4]]"}, "output": {"number_of_categories": 3, "categories": [[8, 19, 4], [16, 6], [2, 5]]}}, {"input": {"product_pairs": "[[2, 11], [4, 11], [6, 9], [14, 13], [1, 18]]"}, "output": {"number_of_categories": 4, "categories": [[2, 11, 4], [9, 6], [13, 14], [1, 18]]}}, {"input": {"product_pairs": "[[6, 8]]"}, "output": {"number_of_categories": 1, "categories": [[8, 6]]}}, {"input": {"product_pairs": "[[9, 17], [7, 16], [6, 12], [15, 8]]"}, "output": {"number_of_categories": 4, "categories": [[9, 17], [16, 7], [12, 6], [8, 15]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tonyvu2014/algorithm", "path": "/bst/category_counter_graph.py", "msgidx": 5178}}
{"problem_description": "Given a knight on a chessboard of size `n x n`, what is the minimum number of moves required for the knight to travel from its starting position `(src_x, src_y)` to the target position `(dst_x, dst_y)`? The knight moves in an L-shape pattern, which means it can move to any of the eight positions that are two squares away horizontally and one square vertically, or two squares vertically and one square horizontally.", "io_requirements": "Input:\n  `n` (int): The size of the chessboard (n x n).\n  `src_x` (int): The x-coordinate of the knight's starting position.\n  `src_y` (int): The y-coordinate of the knight's starting position.\n  `dst_x` (int): The x-coordinate of the knight's target position.\n  `dst_y` (int): The y-coordinate of the knight's target position.\n\nOutput:\n  `return` (int): The minimum number of steps required for the knight to move from the starting position to the target position on the chessboard.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nmoves = [(1, 2), (2, 1), (1, -2), (2, -1), (-1, 2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef min_jumps(n, src, dst):\n    board = [[0] * n for _ in range(n)]\n    q = deque()\n    q.append((src, 0))\n    \n    while q:\n        (i, j), dist = q.popleft()\n        if i < 0 or j < 0 or i >= n or j >= n:\n            continue\n        if (i, j) == dst:\n            return dist\n\n        if board[i][j]:\n            continue\n        board[i][j] = 1\n        \n        for mi, mj in moves:\n            q.append(((i + mi, j + mj), dist + 1))\n            \n    return 1\n\n# main function\ndef main_solution(n, src_x, src_y, dst_x, dst_y):\n    # Convert JSON serializable inputs to the original input variables\n    src = (src_x, src_y)\n    dst = (dst_x, dst_y)\n    \n    # Call the function to get the result\n    result = min_jumps(n, src, dst)\n    \n    # Return the result, which is already JSON serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 9, "src_x": 8, "src_y": 4, "dst_x": 5, "dst_y": 1}, "output": 2}, {"input": {"n": 9, "src_x": 6, "src_y": 7, "dst_x": 4, "dst_y": 3}, "output": 2}, {"input": {"n": 4, "src_x": 3, "src_y": 4, "dst_x": 1, "dst_y": 3}, "output": 1}, {"input": {"n": 8, "src_x": 5, "src_y": 8, "dst_x": 6, "dst_y": 7}, "output": 1}, {"input": {"n": 9, "src_x": 6, "src_y": 4, "dst_x": 9, "dst_y": 1}, "output": 1}, {"input": {"n": 6, "src_x": 5, "src_y": 5, "dst_x": 4, "dst_y": 5}, "output": 3}, {"input": {"n": 7, "src_x": 6, "src_y": 2, "dst_x": 2, "dst_y": 7}, "output": 1}, {"input": {"n": 4, "src_x": 2, "src_y": 4, "dst_x": 3, "dst_y": 2}, "output": 1}, {"input": {"n": 10, "src_x": 5, "src_y": 1, "dst_x": 9, "dst_y": 3}, "output": 2}, {"input": {"n": 10, "src_x": 6, "src_y": 6, "dst_x": 9, "dst_y": 8}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "atulanandnitt/questionsBank", "path": "/dp/knight.py", "msgidx": 5190}}
{"problem_description": "Given a graph with a certain number of nodes, how can we partition the graph into the maximum number of independent cliques using a greedy algorithm? Specifically, what are the cliques found when generating a graph using either the Barab\u00e1si-Albert or Erd\u00f6s-R\u00e9nyi model with a specified edge probability and affinity, and then applying the greedy clique partition algorithm?", "io_requirements": "Input:\n  `n_nodes` (int): The number of nodes in the graph.\n  `edge_probability` (float): The probability of generating each edge. This parameter must be in the range [0, 1]. This parameter will only be used if graph_type = \"erdos_renyi\".\n  `affinity` (int): The number of nodes each new node will be attached to, in the sampling scheme. This parameter must be an integer >= 1. This parameter will only be used if graph_type = \"barabasi_albert\".\n  `graph_type` (str): The method used to generate graphs. This parameter must be one of \"barabasi_albert\" or \"erdos_renyi\".\n  `seed` (int): The seed to set the random number generator with.\n\nOutput:\n  `return` (List[List[int]]): A list of cliques found by the greedy algorithm. Each clique is represented as a list of node indices.", "refcode": "# import necessary packages\nimport numpy as np\nfrom itertools import combinations\nfrom typing import List, Set, Tuple, Dict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(\n        self,\n        n_nodes: int,\n        edges: Set[Tuple[int]],\n        degrees: np.ndarray,\n        neighbors: Dict[int, Set[int]],\n    ):\n        self.n_nodes = n_nodes\n        self.edges = edges\n        self.degrees = degrees\n        self.neighbors = neighbors\n\n    def __len__(self):\n        return self.n_nodes\n\n    def greedy_clique_partition(self):\n        cliques = []\n        leftover_nodes = (-self.degrees).argsort().tolist()\n\n        while leftover_nodes:\n            clique_center, leftover_nodes = leftover_nodes[0], leftover_nodes[1:]\n            clique = {clique_center}\n            neighbors = self.neighbors[clique_center].intersection(leftover_nodes)\n            densest_neighbors = sorted(neighbors, key=lambda x: -self.degrees[x])\n            for neighbor in densest_neighbors:\n                if all([neighbor in self.neighbors[clique_node] for clique_node in clique]):\n                    clique.add(neighbor)\n            cliques.append(clique)\n            leftover_nodes = [node for node in leftover_nodes if node not in clique]\n\n        return cliques\n\n    @staticmethod\n    def erdos_renyi(n_nodes: int, edge_probability: float, rng: np.random.RandomState):\n        edges = set()\n        degrees = np.zeros(n_nodes, dtype=int)\n        neighbors = {node: set() for node in range(n_nodes)}\n        for edge in combinations(np.arange(n_nodes), 2):\n            if rng.uniform() < edge_probability:\n                edges.add(edge)\n                degrees[edge[0]] += 1\n                degrees[edge[1]] += 1\n                neighbors[edge[0]].add(edge[1])\n                neighbors[edge[1]].add(edge[0])\n        return Graph(n_nodes, edges, degrees, neighbors)\n\n    @staticmethod\n    def barabasi_albert(n_nodes: int, affinity: int, rng: np.random.RandomState):\n        assert affinity >= 1 and affinity < n_nodes\n\n        edges = set()\n        degrees = np.zeros(n_nodes, dtype=int)\n        neighbors = {node: set() for node in range(n_nodes)}\n        for new_node in range(affinity, n_nodes):\n            if new_node == affinity:\n                neighborhood = np.arange(new_node)\n            else:\n                neighbor_prob = degrees[:new_node] / (2 * len(edges))\n                neighborhood = rng.choice(new_node, affinity, replace=False, p=neighbor_prob)\n            for node in neighborhood:\n                edges.add((node, new_node))\n                degrees[node] += 1\n                degrees[new_node] += 1\n                neighbors[node].add(new_node)\n                neighbors[new_node].add(node)\n\n        return Graph(n_nodes, edges, degrees, neighbors)\n\n# main function\ndef main_solution(n_nodes: int, edge_probability: float, affinity: int, graph_type: str, seed: int):\n    # Convert JSON serializable inputs to original input variables\n    rng = np.random.RandomState(seed)\n\n    # Generate graph\n    if graph_type == \"barabasi_albert\":\n        graph = Graph.barabasi_albert(n_nodes, affinity, rng)\n    elif graph_type == \"erdos_renyi\":\n        graph = Graph.erdos_renyi(n_nodes, edge_probability, rng)\n    else:\n        raise Exception(\"graph_type must be one of 'barabasi_albert' or 'erdos_renyi'\")\n\n    # Partition graph into cliques\n    cliques = graph.greedy_clique_partition()\n\n    # Convert output to JSON serializable\n    cliques_serializable = [list(clique) for clique in cliques]\n\n    return cliques_serializable", "funcname": "main_solution", "ios": [{"input": {"n_nodes": 11, "edge_probability": 0.747637447014916, "affinity": 2, "graph_type": "barabasi_albert", "seed": 682}, "output": [[0, 2, 4], [1, 3], [9, 5], [10, 7], [6], [8]]}, {"input": {"n_nodes": 13, "edge_probability": 0.5909345763660155, "affinity": 4, "graph_type": "erdos_renyi", "seed": 526}, "output": [[0, 2, 3, 6, 10], [11, 12, 4], [1, 9], [8, 7], [5]]}, {"input": {"n_nodes": 18, "edge_probability": 0.8803551036279499, "affinity": 6, "graph_type": "erdos_renyi", "seed": 284}, "output": [[0, 5, 6, 7, 8, 9, 10, 11, 13, 16, 17], [1, 2, 3, 4, 12], [14, 15]]}, {"input": {"n_nodes": 12, "edge_probability": 0.4340142622357991, "affinity": 1, "graph_type": "erdos_renyi", "seed": 605}, "output": [[8, 10, 3, 4], [0, 11], [2, 5, 6], [1], [9, 7]]}, {"input": {"n_nodes": 13, "edge_probability": 0.18281228599223356, "affinity": 5, "graph_type": "barabasi_albert", "seed": 547}, "output": [[4, 5, 6, 8, 11], [9, 2, 7], [0, 10], [3], [12], [1]]}, {"input": {"n_nodes": 10, "edge_probability": 0.8796317040000513, "affinity": 1, "graph_type": "erdos_renyi", "seed": 818}, "output": [[0, 1, 3, 4, 5, 8, 9], [2, 7], [6]]}, {"input": {"n_nodes": 10, "edge_probability": 0.8401895364838949, "affinity": 1, "graph_type": "erdos_renyi", "seed": 191}, "output": [[1, 3, 4, 5, 6, 9], [0, 2, 7], [8]]}, {"input": {"n_nodes": 13, "edge_probability": 0.4971709251741533, "affinity": 1, "graph_type": "erdos_renyi", "seed": 191}, "output": [[0, 2, 4, 5, 7], [8, 1, 3, 6], [10, 11], [9], [12]]}, {"input": {"n_nodes": 12, "edge_probability": 0.5256403345410288, "affinity": 3, "graph_type": "barabasi_albert", "seed": 576}, "output": [[0, 3, 4, 7], [2, 10, 6], [1, 11], [5], [8], [9]]}, {"input": {"n_nodes": 13, "edge_probability": 0.3749239938358164, "affinity": 5, "graph_type": "barabasi_albert", "seed": 593}, "output": [[0, 5, 6, 9, 10], [8, 1, 7], [3, 12], [11], [2], [4]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jiaodaxiaozi/ecole", "path": "/python/src/ecole/_independent_set_generator.py", "msgidx": 4477}}
{"problem_description": "In a manufacturing facility, there are multiple jobs that need to be processed on several machines. Each job has a specific duration for each machine. The goal is to find the optimal sequence of jobs that minimizes the total processing time across all machines. Given the number of jobs, the number of machines, and the duration of each job on each machine, what is the optimal sequence of jobs and the corresponding total processing time?", "io_requirements": "Input:\n  `nb_jobs` (int): The number of jobs to be scheduled.\n  `nb_machines` (int): The number of machines available for scheduling.\n  `job_durations` (list of lists of int): A list where each element is a list of integers representing the duration of each job on each machine.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `sequence_opt` (list of int): The optimal sequence of job indices.\n    - `duree_opt` (int): The optimal duration of the schedule.", "refcode": "# import necessary packages\nimport copy\nimport itertools\nimport heapq\n\n# all class and function definitions in the code file, if any\nclass Job:\n    def __init__(self, num, durations):\n        self.num = num\n        self.durations = durations\n\n    def duree(self):\n        return sum(self.durations)\n\n    def duree_operation(self, machine):\n        return self.durations[machine]\n\nclass Ordonnancement:\n    def __init__(self, nb_machines):\n        self.nb_machines = nb_machines\n        self.jobs = []\n\n    def ordonnancer_job(self, job):\n        self.jobs.append(job)\n\n    def ordonnancer_liste_job(self, list_jobs):\n        self.jobs.extend(list_jobs)\n\n    def duree(self):\n        # Simplified for brevity\n        return sum(job.duree() for job in self.jobs)\n\n    def to_index(self):\n        return [job.num for job in self.jobs]\n\nclass Sommet:\n    def __init__(self, sequence, jobs_non_places, evaluation, numero):\n        self.sequence = sequence\n        self.jobs_non_places = jobs_non_places\n        self.evaluation = evaluation\n        self.numero = numero\n\n    def jobs_non_places(self):\n        return self.jobs_non_places\n\n    def sequence(self):\n        return self.sequence\n\nclass Flowshop:\n    def __init__(self, nb_jobs=0, nb_machines=0, l_job=[]):\n        self.nb_jobs = nb_jobs\n        self.nb_machines = nb_machines\n        self.l_job = l_job\n\n    def get_job_by_id(self, job_id):\n        for job in self.l_job:\n            if job.num == job_id:\n                return job\n\n    def trier_jobs(self):\n        L = [(job, job.duree()) for job in self.l_job]\n        L.sort(key=lambda tup: tup[1], reverse=True)\n        self.l_job = [tup[0] for tup in L]\n\n    def permutations_with_order(self, L):\n        M = []\n        for i in range(len(L)):\n            temp = L[:-1]\n            temp.insert(i, L[-1])\n            M.append(tuple(temp))\n        return M\n\n    def creer_liste_NEH(self):\n        self.trier_jobs()\n        l = [self.l_job[0].num]\n        for index in range(1, self.nb_jobs):\n            l.append(self.l_job[index].num)\n            list_permutation = self.permutations_with_order(l)\n            list_ordo = []\n            for tup in list_permutation:\n                list_jobs = [self.get_job_by_id(i) for i in tup]\n                ordo = Ordonnancement(self.nb_machines)\n                ordo.ordonnancer_liste_job(list_jobs)\n                list_ordo.append(ordo)\n            m1 = min(ordo.duree() for ordo in list_ordo)\n            temp_ordo = next(ordo for ordo in list_ordo if ordo.duree() == m1)\n            l = temp_ordo.to_index()\n        return temp_ordo\n\n    def calculer_borne_inf(self, ordo, list_jobs):\n        L = []\n        for i in range(self.nb_machines - 1):\n            r = [self.calculer_date_dispo(ordo, i, self.get_job_by_id(job)) for job in list_jobs]\n            p = sum(self.get_job_by_id(job).duree_operation(i) for job in list_jobs)\n            q = [self.calculer_duree_latence(ordo, i, self.get_job_by_id(job)) for job in list_jobs]\n            L.append(min(r) + p + min(q))\n        return max(L)\n\n    def calculer_date_dispo(self, ordo, machine, new_job):\n        new_ordo = copy.copy(ordo)\n        new_ordo.ordonnancer_job(new_job)\n        return new_ordo.date_debut_operation(new_job, machine)\n\n    def calculer_duree_latence(self, ordo, machine, new_job):\n        new_ordo = copy.copy(ordo)\n        new_ordo.ordonnancer_job(new_job)\n        fin = new_ordo.date_disponibilite(self.nb_machines - 1)\n        debut = new_ordo.date_disponibilite(machine)\n        return fin - debut\n\n# main function\ndef main_solution(nb_jobs, nb_machines, job_durations):\n    # Convert JSON serializable inputs to original input variables\n    l_job = [Job(i, durations) for i, durations in enumerate(job_durations)]\n    flow_shop = Flowshop(nb_jobs, nb_machines, l_job)\n    \n    # Core solution logic\n    liste_NEH = flow_shop.creer_liste_NEH()\n    sequence_opt = liste_NEH.to_index()\n    duree_opt = liste_NEH.duree()\n    \n    # Convert output to JSON serializable\n    return {\"sequence_opt\": sequence_opt, \"duree_opt\": duree_opt}", "funcname": "main_solution", "ios": [{"input": {"nb_jobs": 3, "nb_machines": 3, "job_durations": [[3, 9, 1], [4, 7, 1], [7, 1, 4]]}, "output": {"sequence_opt": [2, 1, 0], "duree_opt": 37}}, {"input": {"nb_jobs": 3, "nb_machines": 2, "job_durations": [[3, 7], [8, 4], [4, 10]]}, "output": {"sequence_opt": [0, 1, 2], "duree_opt": 36}}, {"input": {"nb_jobs": 3, "nb_machines": 2, "job_durations": [[9, 3], [1, 8], [8, 6]]}, "output": {"sequence_opt": [1, 0, 2], "duree_opt": 35}}, {"input": {"nb_jobs": 3, "nb_machines": 4, "job_durations": [[6, 9, 7, 3], [2, 1, 3, 7], [7, 7, 1, 8]]}, "output": {"sequence_opt": [1, 2, 0], "duree_opt": 61}}, {"input": {"nb_jobs": 3, "nb_machines": 2, "job_durations": [[2, 1], [1, 9], [9, 4]]}, "output": {"sequence_opt": [0, 1, 2], "duree_opt": 26}}, {"input": {"nb_jobs": 3, "nb_machines": 2, "job_durations": [[9, 5], [2, 4], [8, 6]]}, "output": {"sequence_opt": [1, 2, 0], "duree_opt": 34}}, {"input": {"nb_jobs": 3, "nb_machines": 2, "job_durations": [[2, 5], [5, 10], [3, 6]]}, "output": {"sequence_opt": [0, 2, 1], "duree_opt": 31}}, {"input": {"nb_jobs": 3, "nb_machines": 3, "job_durations": [[4, 1, 8], [5, 10, 2], [2, 2, 4]]}, "output": {"sequence_opt": [2, 0, 1], "duree_opt": 38}}, {"input": {"nb_jobs": 3, "nb_machines": 3, "job_durations": [[7, 10, 9], [6, 1, 10], [3, 7, 4]]}, "output": {"sequence_opt": [2, 1, 0], "duree_opt": 57}}, {"input": {"nb_jobs": 3, "nb_machines": 2, "job_durations": [[1, 5], [6, 2], [10, 8]]}, "output": {"sequence_opt": [0, 1, 2], "duree_opt": 32}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Atadeno/Projet_RO_Groupe_8", "path": "/flowshop.py", "msgidx": 4336}}
{"problem_description": "You are a magician's assistant performing a trick with a square grid. The grid is filled with either empty or occupied squares, and the spectator has chosen a secret square. After making a single change to the grid (flipping one square from empty to occupied or vice versa), you need to determine the coordinates of the secret square. Given the configuration of the grid as a string of '0's and '1's, where '0' represents an empty square and '1' represents an occupied square, what are the coordinates of the secret square?", "io_requirements": "Input:\n  `board_config` (str): A string representing the board configuration. Each character in the string is either '0' (empty) or '1' (occupied). The length of the string should be a perfect square (e.g., 4, 9, 16, etc.).\n\nOutput:\n  `return` (dict): A dictionary containing the coordinates of the secret square. The dictionary has two keys:\n    - `x_coordinate` (int): The x-coordinate of the secret square.\n    - `y_coordinate` (int): The y-coordinate of the secret square.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef ReadBoard(board, board_length):\n    list_binary = []\n    for twice in range(2):\n        for x in range(int(math.log2(board_length))):\n            check_even = 0\n            for row in range(int(board_length/(2**(x+1)))):\n                for col in range(board_length):\n                    for jump in range(2**x):\n                        if board[row+jump*int((board_length/2**x))][col]:\n                            check_even += 1\n            if check_even %2 == 0:\n                list_binary.append(1)\n            else:\n                list_binary.append(0)\n        if twice == 0:\n            board = [[board[j][i] for j in range(len(board))] for i in range(len(board[0]))]\n    return list_binary\n\ndef Decode(list_binary, board_length):\n    x_coordinate = 1\n    y_coordinate = 1\n    \n    pow_x = pow_y = int(math.log2(board_length))-1\n    \n    for i in range(len(list_binary)):\n        if list_binary[i]:\n            y_coordinate += 2**pow_y\n        pow_y -= 1\n    for i in range(int(len(list_binary)/2), len(list_binary)):\n        if not list_binary[i]:\n            x_coordinate += 2**pow_x\n        pow_x -= 1\n    \n    return x_coordinate, y_coordinate\n\n# main function\ndef main_solution(board_config):\n    # Convert the board configuration string to a list of integers\n    user_board = [int(x) for x in board_config]\n    \n    # Calculate the board length\n    board_length = int(math.sqrt(len(user_board)))\n    \n    # Check if the board length is a perfect square\n    if board_length**2 != len(user_board):\n        raise ValueError(\"The length of the board is incorrect.\")\n    \n    # Convert the user board to a 2D list\n    board = []\n    for i in range(board_length):\n        board.append(user_board[i*board_length:(i+1)*board_length])\n    \n    # Read the board and decode the secret square\n    list_binary = ReadBoard(board, board_length)\n    x_coordinate, y_coordinate = Decode(list_binary, board_length)\n    \n    # Return the coordinates of the secret square\n    return {\"x_coordinate\": x_coordinate, \"y_coordinate\": y_coordinate}", "funcname": "main_solution", "ios": [{"input": {"board_config": "1000000001011000"}, "output": {"x_coordinate": 3, "y_coordinate": 1.25}}, {"input": {"board_config": "011010000010110011011111000010011011010011100001100110011101000010111000101101001"}, "output": {"x_coordinate": 5, "y_coordinate": 8.375}}, {"input": {"board_config": "1001000100110101"}, "output": {"x_coordinate": 1, "y_coordinate": 2.75}}, {"input": {"board_config": "0011110011000011"}, "output": {"x_coordinate": 1, "y_coordinate": 4.75}}, {"input": {"board_config": "011100010011000000000011101100100100000101010101000001100010010101010001100010100"}, "output": {"x_coordinate": 3, "y_coordinate": 4.625}}, {"input": {"board_config": "011110111011111001010100110000110000111100001100010101011011011011101101010011100"}, "output": {"x_coordinate": 3, "y_coordinate": 4.625}}, {"input": {"board_config": "0111100000100101"}, "output": {"x_coordinate": 4, "y_coordinate": 4}}, {"input": {"board_config": "0110010000010001"}, "output": {"x_coordinate": 2, "y_coordinate": 1.5}}, {"input": {"board_config": "0110111001101100"}, "output": {"x_coordinate": 2, "y_coordinate": 2.5}}, {"input": {"board_config": "101000111010001110100000111101100110001000100001100001111010001110011001110110010"}, "output": {"x_coordinate": 4, "y_coordinate": 8.5}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AyrtonTwigg/PersonalProjects", "path": "/Square Trick (Assistant)/NxN_Square.py", "msgidx": 5175}}
{"problem_description": "In a card game, two players start with their own decks of cards. Each player draws the top card from their deck, and the player with the higher card wins the round, taking both cards and placing them at the bottom of their deck in a specific order. The game continues until one player has all the cards. Given the initial decks of both players, what is the final score of the winning deck, considering that the game can be played either in a standard mode or in a recursive mode where sub-games are played to determine the winner of certain rounds?", "io_requirements": "Input:\n  `deck1` (list of int): A list of integers representing the cards in Player 1's deck.\n  `deck2` (list of int): A list of integers representing the cards in Player 2's deck.\n  `recursive` (bool): A boolean flag indicating whether to use the recursive version of the game (default is `False`).\n\nOutput:\n  `return` (int): The final score of the winning deck.", "refcode": "# import necessary packages\nfrom datetime import datetime\n\n# all class and function definitions in the code file, if any\ndef score(deck):\n    return sum([(len(deck)-i)*v for (i, v) in enumerate(deck)])\n\ndef play(deck1, deck2):\n    while len(deck1) > 0 and len(deck2) > 0:\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if card1 > card2:\n            deck1.extend([card1, card2])\n        else:\n            deck2.extend([card2, card1])\n    return deck1 if len(deck1) > 0 else deck2\n\ndef playRecursive(deck1, deck2, depth):\n    gameIndex = 0\n    gameIndex += 1\n    myIndex = gameIndex\n    seenStates = set()\n    while len(deck1) > 0 and len(deck2) > 0:\n        state = (tuple(deck1), tuple(deck2))\n        if state in seenStates:\n            return (deck1, 1)\n        seenStates.add(state)\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if len(deck1) >= card1 and len(deck2) >= card2:\n            (_, outcome) = playRecursive(list(deck1[:card1]), list(deck2[:card2]), depth + 1)\n        else:\n            outcome = 1 if card1 > card2 else 2\n        if outcome == 1:\n            deck1.extend([card1, card2])\n            winner = deck1\n        else:\n            deck2.extend([card2, card1])\n            winner = deck2\n    return (winner, outcome)\n\n# main function\ndef main_solution(deck1, deck2, recursive=False):\n    # Convert input lists to JSON serializable format\n    deck1 = list(deck1)\n    deck2 = list(deck2)\n    \n    if recursive:\n        (winner, _) = playRecursive(deck1, deck2, 0)\n    else:\n        winner = play(deck1, deck2)\n    \n    # Calculate the score\n    final_score = score(winner)\n    \n    # Return the final score as a JSON serializable output\n    return final_score", "funcname": "main_solution", "ios": [{"input": {"deck1": [6, 10, 1, 2, 12], "deck2": [2, 7, 13, 1, 8], "recursive": false}, "output": 344}, {"input": {"deck1": [6, 3, 9, 13, 11], "deck2": [6, 13, 7, 9, 12], "recursive": false}, "output": 521}, {"input": {"deck1": [13, 6, 12, 3, 10], "deck2": [3, 5, 11, 7, 4], "recursive": false}, "output": 486}, {"input": {"deck1": [7, 13, 5, 3, 12], "deck2": [12, 5, 1, 3, 9], "recursive": true}, "output": 415}, {"input": {"deck1": [4, 8, 7, 9, 3], "deck2": [2, 10, 8, 4, 13], "recursive": true}, "output": 397}, {"input": {"deck1": [7, 12, 5, 11, 4], "deck2": [1, 7, 4, 3, 6], "recursive": true}, "output": 342}, {"input": {"deck1": [10, 8, 5, 3, 11], "deck2": [3, 11, 4, 6, 8], "recursive": false}, "output": 423}, {"input": {"deck1": [13, 6, 10, 8, 12], "deck2": [3, 5, 13, 10, 8], "recursive": true}, "output": 444}, {"input": {"deck1": [11, 5, 2, 10, 4], "deck2": [10, 11, 8, 1, 9], "recursive": false}, "output": 434}, {"input": {"deck1": [7, 11, 8, 6, 9], "deck2": [9, 8, 5, 7, 2], "recursive": true}, "output": 419}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "afoix/advent-calendar-2020", "path": "/Day22/day22.py", "msgidx": 5089}}
{"problem_description": "Given a linked list with nodes containing integer data, a loop is created by connecting the last node to a node at a specific index. How can we detect and remove this loop from the linked list? Specifically, what is the result of detecting and removing the loop in the linked list with the given data and loop start index?", "io_requirements": "Input:\n  `linked_list_data` (list of int): A list of integers representing the data of the nodes in the linked list.\n  `loop_start_index` (int): An integer representing the index of the node where the loop starts. If the value is negative or greater than or equal to the length of `linked_list_data`, no loop will be created.\n\nOutput:\n  `return` (str): A string indicating whether a loop was found and removed (\"Loop found and sorted\") or no loop was found (\"No loop found\").", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def push(self, data):\n        node = Node(data)\n        node.next = self.head\n        self.head = node\n\n    def detectAndRemoveLoop(self):\n        slowP = fastP = self.head\n\n        while slowP and fastP and fastP.next:\n            slowP = slowP.next\n            fastP = fastP.next.next\n\n            if slowP == fastP:\n                self.removeLoop(slowP)\n                return \"Loop found and sorted\"\n        return \"No loop found\"\n\n    def removeLoop(self, loopN):\n        p1 = loopN\n        p2 = loopN\n        \n        k = 1\n        while p1.next != p2:\n            p1 = p1.next\n            k += 1\n\n        p1 = self.head\n        p2 = self.head\n        for _ in range(k):\n            p2 = p2.next\n            \n        while p2 != p1:\n            p1 = p1.next\n            p2 = p2.next\n\n        while p2.next != p1:\n            p2 = p2.next\n\n        p2.next = None\n\n    def modifiedRemoveLoop(self):\n        if self.head is None or self.head.next is None:\n            return\n\n        slow = self.head\n        fast = self.head\n\n        slow = slow.next\n        fast = fast.next.next\n\n        while fast is not None:\n            if fast.next is None:\n                break\n            if slow == fast:\n                break\n            slow = slow.next\n            fast = fast.next.next\n\n        if slow == fast:\n            slow = self.head\n            while slow.next != fast.next:\n                slow = slow.next\n                fast = fast.next\n\n            fast.next = None\n\n# main function\ndef main_solution(linked_list_data, loop_start_index):\n    # Convert JSON serializable input to original input variables\n    linked_list = LinkedList()\n    for data in reversed(linked_list_data):\n        linked_list.push(data)\n    \n    # Create the loop in the linked list\n    if loop_start_index >= 0 and loop_start_index < len(linked_list_data):\n        loop_start_node = linked_list.head\n        for _ in range(loop_start_index):\n            loop_start_node = loop_start_node.next\n        \n        current = linked_list.head\n        while current.next:\n            current = current.next\n        current.next = loop_start_node\n\n    # Detect and remove the loop\n    result = linked_list.detectAndRemoveLoop()\n\n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"linked_list_data": [27, 51, 89, 45, 95], "loop_start_index": -1}, "output": "No loop found"}, {"input": {"linked_list_data": [99, 22, 79, 98, 88, 95], "loop_start_index": 6}, "output": "No loop found"}, {"input": {"linked_list_data": [93, 39, 97, 90, 92, 8, 46], "loop_start_index": 1}, "output": "Loop found and sorted"}, {"input": {"linked_list_data": [59, 34, 98, 19, 33], "loop_start_index": 4}, "output": "Loop found and sorted"}, {"input": {"linked_list_data": [97, 97, 56, 4, 98, 86, 94, 84], "loop_start_index": -1}, "output": "No loop found"}, {"input": {"linked_list_data": [10, 78, 19, 54, 76], "loop_start_index": 2}, "output": "Loop found and sorted"}, {"input": {"linked_list_data": [48, 73, 99, 47, 69, 0, 88], "loop_start_index": 3}, "output": "Loop found and sorted"}, {"input": {"linked_list_data": [83, 99, 10, 15, 64, 10, 73, 74, 64], "loop_start_index": 5}, "output": "Loop found and sorted"}, {"input": {"linked_list_data": [66, 80, 82, 47, 17, 36, 57, 9], "loop_start_index": 0}, "output": "Loop found and sorted"}, {"input": {"linked_list_data": [51, 27, 63, 4, 21], "loop_start_index": 1}, "output": "Loop found and sorted"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shanku01/100-days-of-code", "path": "/Day 19/19.py", "msgidx": 4926}}
{"problem_description": "In a social network of infatuation, where each person can have a crush on one or more other people, we want to analyze the relationships. Given a dictionary that maps each person to the set of people they are infatuated with, what are the people who love themselves, those who are loved by at least one person, the potential couples who could be happily in love, and the set of people who are overly compliant to a specific person?", "io_requirements": "Input:\n  `infatuation_dict` (dict): A dictionary where each key is a person's name (str) and the value is a list of strings representing the names of people infatuated with the key person.\n  `query_type` (str): A string indicating the type of query to perform. Possible values are \"narcissists\", \"loved_ones\", \"couples\", and \"compliant_people\".\n  `query_name` (str, optional): Required only if `query_type` is \"compliant_people\". It is the name of the person for whom we want to find compliant people.\n\nOutput:\n  `return` (list or dict): The result of the query. If the query type is \"narcissists\", \"loved_ones\", or \"compliant_people\", it returns a list of strings. If the query type is \"couples\", it returns a list of tuples where each tuple contains two strings representing a couple.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef narcissists(d):\n    return {person for person, crushes in d.items() if person in crushes}\n\ndef loved_ones(d):\n    return {crush for crushes in d.values() for crush in crushes}\n\ndef couples(d):\n    return {tuple(sorted((person, crush))) for person, crushes in d.items() for crush in crushes if person in d.get(crush, set())}\n\ndef compliant_people(name, d):\n    compliant_set = set()\n    def find_compliant(person):\n        if person not in compliant_set:\n            compliant_set.add(person)\n            for crush in d.get(person, set()):\n                find_compliant(crush)\n    find_compliant(name)\n    return compliant_set\n\n# main function\ndef main_solution(infatuation_dict, query_type, query_name=None):\n    # Convert input dictionary to a JSON serializable format\n    infatuation_dict = {person: list(crushes) for person, crushes in infatuation_dict.items()}\n    \n    # Convert back to set for internal processing\n    infatuation_dict = {person: set(crushes) for person, crushes in infatuation_dict.items()}\n    \n    if query_type == \"narcissists\":\n        result = narcissists(infatuation_dict)\n    elif query_type == \"loved_ones\":\n        result = loved_ones(infatuation_dict)\n    elif query_type == \"couples\":\n        result = couples(infatuation_dict)\n    elif query_type == \"compliant_people\":\n        if query_name is None:\n            raise ValueError(\"query_name is required for compliant_people query type\")\n        result = compliant_people(query_name, infatuation_dict)\n    else:\n        raise ValueError(\"Invalid query_type\")\n    \n    # Convert result to JSON serializable format\n    if isinstance(result, set):\n        result = list(result)\n    elif isinstance(result, dict):\n        result = {k: list(v) for k, v in result.items()}\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"infatuation_dict": {"Person0": [], "Person1": ["Person0", "Person2", "Person1"], "Person2": []}, "query_type": "loved_ones", "query_name": null}, "output": ["Person2", "Person1", "Person0"]}, {"input": {"infatuation_dict": {"Person0": [], "Person1": ["Person0", "Person1"], "Person2": ["Person0"]}, "query_type": "compliant_people", "query_name": "Person1"}, "output": ["Person1", "Person0"]}, {"input": {"infatuation_dict": {"Person0": ["Person1"], "Person1": ["Person2", "Person0"], "Person2": []}, "query_type": "compliant_people", "query_name": "Person2"}, "output": ["Person2"]}, {"input": {"infatuation_dict": {"Person0": [], "Person1": ["Person2", "Person1", "Person0"], "Person2": ["Person2"]}, "query_type": "couples", "query_name": null}, "output": [["Person1", "Person1"], ["Person2", "Person2"]]}, {"input": {"infatuation_dict": {"Person0": [], "Person1": ["Person0", "Person2", "Person1"], "Person2": ["Person1"]}, "query_type": "compliant_people", "query_name": "Person2"}, "output": ["Person2", "Person1", "Person0"]}, {"input": {"infatuation_dict": {"Person0": [], "Person1": [], "Person2": ["Person2", "Person0", "Person1"]}, "query_type": "compliant_people", "query_name": "Person1"}, "output": ["Person1"]}, {"input": {"infatuation_dict": {"Person0": ["Person2"], "Person1": [], "Person2": ["Person2", "Person0"]}, "query_type": "loved_ones", "query_name": null}, "output": ["Person2", "Person0"]}, {"input": {"infatuation_dict": {"Person0": ["Person1"], "Person1": ["Person2", "Person1", "Person0"], "Person2": []}, "query_type": "couples", "query_name": null}, "output": [["Person1", "Person1"], ["Person0", "Person1"]]}, {"input": {"infatuation_dict": {"Person0": ["Person0"], "Person1": ["Person1", "Person2"], "Person2": ["Person2", "Person0"]}, "query_type": "couples", "query_name": null}, "output": [["Person1", "Person1"], ["Person2", "Person2"], ["Person0", "Person0"]]}, {"input": {"infatuation_dict": {"Person0": ["Person2", "Person0"], "Person1": [], "Person2": ["Person0", "Person2"]}, "query_type": "compliant_people", "query_name": "Person2"}, "output": ["Person2", "Person0"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "TdotA/Python_for_CS1", "path": "/Exercises_5/love.py", "msgidx": 4777}}
{"problem_description": "Imagine you are at a ferry terminal waiting area, and you notice a seating system where people follow specific rules to choose or abandon their seats. The seating area is represented by a grid where each position can be an empty seat (L), an occupied seat (#), or floor (.). The rules for seating are based on the number of occupied seats adjacent to a given seat (Part 1) or the first seat visible in each of eight directions (Part 2). Given a seating layout, how many seats end up occupied once the seating area reaches equilibrium under each set of rules?", "io_requirements": "Input:\n  `seat_layout` (list of strings): A list where each string represents a row of seats in a seating area. Each character in the string can be one of three values: 'L' (empty seat), '#' (occupied seat), or '.' (floor).\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `part1` (int): The number of occupied seats after the seating area stabilizes using the rules for adjacent seats.\n    - `part2` (int): The number of occupied seats after the seating area stabilizes using the rules for visible seats.", "refcode": "# import necessary packages\nimport copy\n\n# main function\ndef main_solution(seat_layout):\n    # Convert the input seat layout to a list of lists for easier manipulation\n    seating_matrix = [list(row) for row in seat_layout]\n\n    # Part 1: Simulate seating changes based on adjacent seats\n    changes = 1\n    while changes > 0:\n        changes = 0\n        new_seating_matrix = copy.deepcopy(seating_matrix)\n        for row in range(len(seating_matrix)):\n            for col in range(len(seating_matrix[row])):\n                if seating_matrix[row][col] == \"L\" and AdjacentOccupiedSeats(seating_matrix, row, col) == 0:\n                    new_seating_matrix[row][col] = \"#\"\n                    changes += 1\n                elif seating_matrix[row][col] == \"#\" and AdjacentOccupiedSeats(seating_matrix, row, col) >= 4:\n                    new_seating_matrix[row][col] = \"L\"\n                    changes += 1\n        seating_matrix = copy.deepcopy(new_seating_matrix)\n    part1 = sum(row.count('#') for row in seating_matrix)\n\n    # Part 2: Simulate seating changes based on visible seats\n    seating_matrix = [list(row) for row in seat_layout]\n    changes = 1\n    while changes > 0:\n        changes = 0\n        new_seating_matrix = copy.deepcopy(seating_matrix)\n        for row in range(len(seating_matrix)):\n            for col in range(len(seating_matrix[row])):\n                if seating_matrix[row][col] == \"L\" and ExtendedAdjacentOccupiedSeats(seating_matrix, row, col) == 0:\n                    new_seating_matrix[row][col] = \"#\"\n                    changes += 1\n                elif seating_matrix[row][col] == \"#\" and ExtendedAdjacentOccupiedSeats(seating_matrix, row, col) >= 5:\n                    new_seating_matrix[row][col] = \"L\"\n                    changes += 1\n        seating_matrix = copy.deepcopy(new_seating_matrix)\n    part2 = sum(row.count('#') for row in seating_matrix)\n\n    # Return the results as a dictionary\n    return {\"part1\": part1, \"part2\": part2}\n\n# Helper functions from the original code\ndef AdjacentOccupiedSeats(aMatrix, aRow, aCol):\n    prevRow = aRow - 1\n    nextRow = aRow + 1\n    prevCol = aCol - 1\n    nextCol = aCol + 1\n    maxRow = len(aMatrix) - 1\n    maxCol = len(aMatrix[aRow]) - 1\n\n    seats = 0\n    if (prevRow >= 0 and aMatrix[prevRow][aCol] == \"#\"):\n        seats += 1\n    if (prevRow >= 0 and nextCol <= maxCol and aMatrix[prevRow][nextCol] == \"#\"):\n        seats += 1\n    if (nextCol <= maxCol and aMatrix[aRow][nextCol] == \"#\"):\n        seats += 1\n    if (nextRow <= maxRow and nextCol <= maxCol and aMatrix[nextRow][nextCol] == \"#\"):\n        seats += 1\n    if (nextRow <= maxRow and aMatrix[nextRow][aCol] == \"#\"):\n        seats += 1\n    if (nextRow <= maxRow and prevCol >= 0 and aMatrix[nextRow][prevCol] == \"#\"):\n        seats += 1\n    if (prevCol >= 0 and aMatrix[aRow][prevCol] == \"#\"):\n        seats += 1  \n    if (prevRow >= 0 and prevCol >= 0 and aMatrix[prevRow][prevCol] == \"#\"):\n        seats += 1\n        \n    return seats\n\ndef ExtendedAdjacentOccupiedSeats(aMatrix, aRow, aCol):\n    maxRow = len(aMatrix) - 1\n    maxCol = len(aMatrix[aRow]) - 1\n    seats = 0\n    multiplier = 1\n    exitBool = False\n    foundList = ['?'] * 8\n    \n    while not exitBool:\n        prevRow = aRow - (1 * multiplier)\n        nextRow = aRow + (1 * multiplier)\n        prevCol = aCol - (1 * multiplier)\n        nextCol = aCol + (1 * multiplier)\n        if (prevRow >= 0 and aMatrix[prevRow][aCol] != '.' and foundList[0] == '?'):\n            foundList[0] = aMatrix[prevRow][aCol]\n        if (prevRow >= 0 and nextCol <= maxCol and aMatrix[prevRow][nextCol] != '.' and foundList[1] == '?'):\n            foundList[1] = aMatrix[prevRow][nextCol]\n        if (nextCol <= maxCol and aMatrix[aRow][nextCol] != '.' and foundList[2] == '?'):\n            foundList[2] = aMatrix[aRow][nextCol]\n        if (nextRow <= maxRow and nextCol <= maxCol and aMatrix[nextRow][nextCol] != '.' and foundList[3] == '?'):\n            foundList[3] = aMatrix[nextRow][nextCol]\n        if (nextRow <= maxRow and aMatrix[nextRow][aCol] != '.' and foundList[4] == '?'):\n            foundList[4] = aMatrix[nextRow][aCol]\n        if (nextRow <= maxRow and prevCol >= 0 and aMatrix[nextRow][prevCol] != '.' and foundList[5] == '?'):\n            foundList[5] = aMatrix[nextRow][prevCol]\n        if (prevCol >= 0 and aMatrix[aRow][prevCol] != '.' and foundList[6] == '?'):\n            foundList[6] = aMatrix[aRow][prevCol]\n        if (prevRow >= 0 and prevCol >= 0 and aMatrix[prevRow][prevCol] != '.' and foundList[7] == '?'):\n            foundList[7] = aMatrix[prevRow][prevCol]\n        multiplier += 1\n\n        if multiplier >= max(maxRow, maxCol) or '?' not in foundList:\n            exitBool = True\n            \n    seats = foundList.count('#')\n    return seats", "funcname": "main_solution", "ios": [{"input": {"seat_layout": [".L#..#LL.L", "..##LLL.L#", ".#.L.LLL##", "###L.##.#L", ".L.LL#####", "L...L#L##L", "L##.LLLL#.", "LLLL#...#.", "##..###.##"]}, "output": {"part1": 27, "part2": 29}}, {"input": {"seat_layout": ["LLLLL.LL#", "####...#.", ".#.L..L##", ".L.L..#LL", "L...L.L#.", ".L##.....", "#LL#LL.L."]}, "output": {"part1": 19, "part2": 15}}, {"input": {"seat_layout": ["LLL.L#", "L####.", "#.#.LL", ".##.#L", "####LL", "##L#L#", "...L##", ".#.L.."]}, "output": {"part1": 14, "part2": 13}}, {"input": {"seat_layout": ["L###..", ".##..L", "#LL.#.", ".#.L#L", ".L#.LL", "LL.LL#", "L#....", "#L.#LL"]}, "output": {"part1": 12, "part2": 12}}, {"input": {"seat_layout": ["L.L#.L##L", "..#LL..L#", "...L.L#.#", "#LL#.#L##", "L#L..#.L.", "##L#.#L##"]}, "output": {"part1": 21, "part2": 19}}, {"input": {"seat_layout": ["L.#LL#..LL", "..##L#L#.L", ".LL.L##.L.", "..L#..#LL.", "..L..###L#", "LLLL..#L..", "#.#L####.L", "L#.LL...L#", "..##.LL##."]}, "output": {"part1": 27, "part2": 22}}, {"input": {"seat_layout": ["..LL.#", "##L.L.", "L..L#L", "..###L", ".L.#LL", "L#LL.."]}, "output": {"part1": 9, "part2": 8}}, {"input": {"seat_layout": ["L#.L.L.", "##.LL##", "#.#.#L.", "L##LL..", "...####", "..LL..#"]}, "output": {"part1": 15, "part2": 13}}, {"input": {"seat_layout": ["LLLLL.", "#LL.L.", "L..L.L", ".LL.L#", "L..#..", ".L#.##", "###L..", "L..L##", "L#L..L", ".##.LL"]}, "output": {"part1": 23, "part2": 19}}, {"input": {"seat_layout": ["##...LL", "LL.#L..", "##.#..L", "...LL##", "LLL..##"]}, "output": {"part1": 15, "part2": 11}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "a-grimes/adventofcode2020", "path": "/days/day11.py", "msgidx": 4742}}
{"problem_description": "Given a maze represented by a grid of '0's and '1's, where '0' represents a path and '1' represents a wall, determine the coordinates of all possible exits from the maze. The maze is guaranteed to have at least one entrance and one exit. The entrance is always located at the bottom row of the maze, and the exits are located at the edges of the maze (top, bottom, left, or right) but not at the entrance. What are the coordinates of all the exits in the maze?", "io_requirements": "Input:\n  `maze_str` (str): A string representing the maze. Each line in the string represents a row in the maze, where '0' represents a path and '1' represents a wall. The rows are separated by newline characters ('\\n').\n\nOutput:\n  `return` (str): A JSON-formatted string representing the list of exit coordinates in the maze. Each coordinate is a list of two integers [x, y], where x and y are the coordinates of an exit.", "refcode": "# import necessary packages\nimport re\nimport json\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass Maze(object):\n    def __init__(self, maze_str):\n        # Transform maze string into array\n        self.maze = [x for x in maze_str.split('\\n') if x]\n        self.maze.reverse()  # reverse list to follow x,y pattern from instructions\n        self.entrance = self.find_start()\n\n    # checks if a legal move is on an edge tile and not the start\n    def exit(self, x, y):\n        if (x == 0 or (x == self.dim()[0] - 1) or y == 0 or (y == self.dim()[1] - 1)):\n            if (self.maze[y][x] == '0' and x != self.entrance[0] and y != self.entrance[1]):\n                return True\n        return False\n\n    # checks if a move is in bounds and not a wall\n    def legal_move(self, x, y):\n        if (x < 0 or (x > self.dim()[0] - 1)):\n            return False\n        elif (y < 0 or (y > self.dim()[1] - 1)):\n            return False\n        elif (self.maze[y][x] == '1'):\n            return False\n        else:\n            return True\n\n    # returns all siblings for a given pair as an array\n    # max of four pairs\n    def get_sibling(self, x, y):\n        sibs = []\n        if (self.legal_move(x, y + 1)):\n            sibs.append((x, y + 1))\n        if (self.legal_move(x, y - 1)):\n            sibs.append((x, y - 1))\n        if (self.legal_move(x + 1, y)):\n            sibs.append((x + 1, y))\n        if (self.legal_move(x - 1, y)):\n            sibs.append((x - 1, y))\n\n        return sibs\n\n    # returns size of (x,y) dims as a pair\n    def dim(self):\n        return (len(self.maze[0]), len(self.maze))\n\n    # searches for initial starting point\n    # guaranteed to be only 1 as explained in lecture\n    def find_start(self):\n        m = re.compile(\"[0]\")\n        for x in m.finditer(self.maze[0]):\n            return (x.start(), 0)\n        return 'error, no start found'\n\n    def find_exits(self, initial):\n        exits = []\n        visited, stack = [], [initial]\n        while stack:\n            vertex = stack.pop()\n            if vertex not in visited:\n                visited.append(vertex)\n                if self.exit(vertex[0], vertex[1]):\n                    exits.append(vertex)\n                for x in self.get_sibling(vertex[0], vertex[1]):\n                    stack.append(x)\n        return exits\n\n# main function\ndef main_solution(maze_str):\n    # Convert the maze string to a Maze object\n    maze = Maze(maze_str)\n    \n    # Find the entrance\n    entrance = maze.entrance\n    \n    # Find all exits from the maze\n    exits = maze.find_exits(entrance)\n    \n    # Convert the exits to a JSON serializable format\n    exits_serializable = [list(exit) for exit in exits]\n    \n    # Return the exits\n    return json.dumps(exits_serializable)", "funcname": "main_solution", "ios": [{"input": {"maze_str": "011000\n100111\n110000\n100111\n101100"}, "output": "[[5, 2]]"}, {"input": {"maze_str": "011101\n110001\n101100\n001101\n111011\n000001\n100000\n011000"}, "output": "[]"}, {"input": {"maze_str": "001001\n100000\n010111\n000110\n110100\n000000\n110100\n000110"}, "output": "[[5, 2], [5, 1], [5, 3], [5, 4], [1, 7], [5, 6], [4, 7], [3, 7]]"}, {"input": {"maze_str": "0111011\n1100110\n0001110\n0111101\n1011010"}, "output": "[]"}, {"input": {"maze_str": "0000111001\n0010011010\n1011111011\n1111001100\n0111011100\n0000010010\n1010010110"}, "output": "[[0, 1], [0, 2]]"}, {"input": {"maze_str": "0110001\n0000010\n0111101\n0110001\n1001101\n1111001\n0011101\n1101100\n1010010"}, "output": "[]"}, {"input": {"maze_str": "01100101\n11000111\n10100010\n01000001\n11100101\n11001011\n00111000"}, "output": "[]"}, {"input": {"maze_str": "0101101001\n1111110010\n0001111111\n1110111010\n1110001101\n1011000010"}, "output": "[]"}, {"input": {"maze_str": "0100101\n0001100\n0011110\n1010000\n0101001\n1001011\n1001001\n1010000\n0001110"}, "output": "[]"}, {"input": {"maze_str": "001001\n010100\n111100\n101110\n010110\n110010\n101000\n111111\n011010"}, "output": "[]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jcookeak/SP17-IU-B351-Assignments", "path": "/hw2/Maze.py", "msgidx": 4521}}
{"problem_description": "Given a string consisting of lowercase alphabetic characters, what are all the possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = list(itertools.permutations(char_list))\n    \n    # Convert each permutation tuple to a string\n    permutation_strings = [''.join(perm) for perm in permutations]\n    \n    # Return the list of permutation strings\n    return permutation_strings", "funcname": "main_solution", "ios": [{"input": {"input_string": "iex"}, "output": ["iex", "ixe", "eix", "exi", "xie", "xei"]}, {"input": {"input_string": "qha"}, "output": ["qha", "qah", "hqa", "haq", "aqh", "ahq"]}, {"input": {"input_string": "tij"}, "output": ["tij", "tji", "itj", "ijt", "jti", "jit"]}, {"input": {"input_string": "ynj"}, "output": ["ynj", "yjn", "nyj", "njy", "jyn", "jny"]}, {"input": {"input_string": "yqz"}, "output": ["yqz", "yzq", "qyz", "qzy", "zyq", "zqy"]}, {"input": {"input_string": "hij"}, "output": ["hij", "hji", "ihj", "ijh", "jhi", "jih"]}, {"input": {"input_string": "hnz"}, "output": ["hnz", "hzn", "nhz", "nzh", "zhn", "znh"]}, {"input": {"input_string": "kch"}, "output": ["kch", "khc", "ckh", "chk", "hkc", "hck"]}, {"input": {"input_string": "tdr"}, "output": ["tdr", "trd", "dtr", "drt", "rtd", "rdt"]}, {"input": {"input_string": "cmy"}, "output": ["cmy", "cym", "mcy", "myc", "ycm", "ymc"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shakefu/bevy-interview", "path": "/main.py", "msgidx": 5372}}
{"problem_description": "Given a spiral matrix formed by starting with the number 1 and moving to the right in a clockwise direction, what is the sum of the numbers on the diagonals of a spiral matrix with a specified side length?", "io_requirements": "Input:\n  `sideLength` (int): The side length of the spiral matrix. It must be an odd integer greater than or equal to 1.\n\nOutput:\n  `return` (int): The sum of the numbers on the diagonals of the spiral matrix with the given side length.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef sumOfDiagonals(sideLength):\n    sumOfDiagonals = 1\n    if sideLength == 1:\n        return sumOfDiagonals\n    if sideLength < 1:\n        return -1\n    squareSeeds = range(3, sideLength + 1, 2)\n    for seed in squareSeeds:\n        previousSeed = seed - 2\n        wallOfNumbers = range(previousSeed ** 2 + 1, seed ** 2 + 1)\n        for i in range(previousSeed, len(wallOfNumbers), previousSeed + 1):\n            sumOfDiagonals = sumOfDiagonals + wallOfNumbers[i]\n    return sumOfDiagonals\n\n# main function\ndef main_solution(sideLength):\n    # Convert input to integer if necessary\n    sideLength = int(sideLength)\n    \n    # Calculate the sum of the diagonals\n    result = sumOfDiagonals(sideLength)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"sideLength": 103}, "output": 733925}, {"input": {"sideLength": 629}, "output": 166104117}, {"input": {"sideLength": 193}, "output": 4811585}, {"input": {"sideLength": 427}, "output": 51994721}, {"input": {"sideLength": 545}, "output": 108068321}, {"input": {"sideLength": 513}, "output": 90136065}, {"input": {"sideLength": 25}, "output": 10761}, {"input": {"sideLength": 991}, "output": 649320541}, {"input": {"sideLength": 667}, "output": 198050641}, {"input": {"sideLength": 5}, "output": 101}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dpflann/Project_Euler", "path": "/pe28/pe28.py", "msgidx": 5047}}
{"problem_description": "Given a positive integer `n`, what are all the possible binary strings of length `n` where no two consecutive '1's are present?", "io_requirements": "Input:\n  `n` (int): The length of each binary string. It should be a positive integer.\n\nOutput:\n  `return` (str): A space-separated string of all nonconsecutive binary strings of length `n`. Each binary string is represented as a sequence of '0's and '1's without any consecutive '1's.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Generates all nonconsecutive binary strings of length `n` where no two consecutive '1's are present.\n\n    Args:\n        n (int): The length of each binary string.\n\n    Returns:\n        str: A space-separated string of all nonconsecutive binary strings of length `n`.\n    \"\"\"\n    def bin_l(n, l):\n        return \"{value:0{length:d}b}\".format(value=n, length=l)\n\n    def all_strings(l):\n        for n in range(0, 2 ** l):\n            yield bin_l(n, l)\n\n    has_consecutive = lambda s: not any(g == ('1', '1') for g in zip(s, s[1:]))\n    return ' '.join(filter(has_consecutive, all_strings(n)))", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": "000 001 010 100 101"}, {"input": {"n": 4}, "output": "0000 0001 0010 0100 0101 1000 1001 1010"}, {"input": {"n": 2}, "output": "00 01 10"}, {"input": {"n": 5}, "output": "00000 00001 00010 00100 00101 01000 01001 01010 10000 10001 10010 10100 10101"}, {"input": {"n": 1}, "output": "0 1"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/9AMT6SC4Jz8tExihs_10.py", "msgidx": 5448}}
{"problem_description": "Given a string that contains digits and the character '$', where '$' represents a placeholder for any digit present in the string, what are all possible combinations of the string with each '$' replaced by any digit from the string?", "io_requirements": "Input:\n  `input_string` (str): A string containing digits and the character '$'. The '$' character represents a placeholder that needs to be replaced by any digit present in the string.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a possible combination of the original string with all '$' characters replaced by digits from the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list for easier manipulation\n    input_list = list(input_string)\n    \n    # Find all unique digits in the input string\n    unique_digits = set(char for char in input_list if char.isdigit())\n    \n    # Find all positions of '$' in the input string\n    dollar_positions = [i for i, char in enumerate(input_list) if char == '$']\n    \n    # Generate all possible combinations by replacing '$' with unique digits\n    combinations = []\n    for digits in itertools.product(unique_digits, repeat=len(dollar_positions)):\n        for pos, digit in zip(dollar_positions, digits):\n            input_list[pos] = digit\n        combinations.append(\"\".join(input_list))\n        input_list = list(input_string)  # Reset input_list for next iteration\n    \n    # Return the list of combinations\n    return combinations", "funcname": "main_solution", "ios": [{"input": {"input_string": "23859$"}, "output": ["238592", "238598", "238593", "238595", "238599"]}, {"input": {"input_string": "50$"}, "output": ["505", "500"]}, {"input": {"input_string": "89$"}, "output": ["898", "899"]}, {"input": {"input_string": "18$"}, "output": ["188", "181"]}, {"input": {"input_string": "07$120"}, "output": ["072120", "077120", "071120", "070120"]}, {"input": {"input_string": "$80960"}, "output": ["980960", "680960", "880960", "080960"]}, {"input": {"input_string": "8973$"}, "output": ["89733", "89738", "89737", "89739"]}, {"input": {"input_string": "7191$"}, "output": ["71919", "71917", "71911"]}, {"input": {"input_string": "9$5063"}, "output": ["965063", "955063", "935063", "995063", "905063"]}, {"input": {"input_string": "56$"}, "output": ["565", "566"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "qmnguyenw/python_py4e", "path": "/geeksforgeeks/algorithm/easy_algo/2_1.py", "msgidx": 5315}}
{"problem_description": "Given a number `n`, how can we generate all possible combinations of round brackets of size `2 * n`?", "io_requirements": "Input:\n  `n` (int): The size of the round brackets, where the total number of brackets will be `2 * n`.\n\nOutput:\n  `return` (list of str): A list of strings, where each string represents a valid combination of round brackets of size `2 * n`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generateParenthesis(n):\n    def generate(p, left, right, parens=[]):\n        if left:         generate(p + '(', left-1, right)\n        if right > left: generate(p + ')', left, right-1)\n        if not right:    parens += p,\n        return parens\n    return generate('', n, n)\n\n# main function\ndef main_solution(n):\n    # Convert the output to a JSON serializable format\n    result = generateParenthesis(n)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rayankikavitha/InterviewPrep", "path": "/IK-Homwork/recursion/find_all_wellformed_brackets.py", "msgidx": 5393}}
{"problem_description": "Given a partially filled Sudoku grid, how can we determine the complete and correct configuration of the grid? Specifically, what is the solved Sudoku grid for the given input grid?", "io_requirements": "Input:\n  `sudoku_grid` (str): A string representing a Sudoku grid. The string should be 81 characters long, where each character represents a cell in the Sudoku grid. Empty cells are represented by a period ('.').\n\nOutput:\n  `return` (dict): A dictionary representing the solved Sudoku grid. The keys are the box identifiers (e.g., 'A1', 'B2'), and the values are the corresponding digits (e.g., '1', '2', ..., '9').", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef cross(A, B):\n    \"Cross product of elements in A and elements in B.\"\n    return [i+j for i in A for j in B]\n\nrows = 'ABCDEFGHI'\ncols = '123456789'\nboxes = cross(rows, cols)\nrow_units = [cross(r, cols) for r in rows]\ncol_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(i, j) for i in ['ABC', 'DEF', 'GHI'] for j in ['123', '456', '789']]\ndiagonal_units = [[i+j for i, j in zip(rows, cols)], [i+j for i, j in zip(rows, cols[::-1])]]\nunitlist = row_units + col_units + square_units + diagonal_units\nunits = dict((b, [u for u in unitlist if b in u]) for b in boxes)\npeers = dict((b, set(sum(units[b], [])) - set([b])) for b in boxes)\n\ndef assign_value(values, box, value):\n    \"\"\"\n    Assigns a value to a given box. If it updates the board record it.\n    \"\"\"\n    values[box] = value\n    return values\n\ndef naked_twins(values):\n    \"\"\"Eliminate values using the naked twins strategy.\"\"\"\n    doubles = defaultdict(list)\n    for k, v in values.items():\n        if len(v) == 2:\n            doubles[v].append(k)\n    for k, v in doubles.items():\n        num_boxes = len(v)\n        if num_boxes >= 2:\n            pairs = [(v[i], v[j]) for i in range(num_boxes-1) for j in range(i+1, num_boxes)]\n            for i, j in pairs:\n                mutual_units = [u for u in units[i] if j in u]\n                to_eliminate = set(sum(mutual_units, [])) - set([i, j])\n                for b in to_eliminate:\n                    assign_value(values, b, values[b].replace(k[0], '').replace(k[1], ''))\n    return values\n\ndef grid_values(grid):\n    \"\"\"Convert grid into a dict of {square: char} with '123456789' for empties.\"\"\"\n    values = []\n    all_digits = '123456789'\n    for c in grid:\n        if c == '.':\n            values.append(all_digits)\n        elif c in all_digits:\n            values.append(c)\n    assert len(values) == 81\n    return dict(zip(boxes, values))\n\ndef eliminate(values):\n    singles = [(k, v) for k, v in values.items() if len(v) == 1]\n    for k, v in singles:\n        for p in peers[k]:\n            assign_value(values, p, values[p].replace(v, ''))\n    return values\n\ndef only_choice(values):\n    for u in unitlist:\n        for d in '123456789':\n            d_boxes = [b for b in u if d in values[b]]\n            if len(d_boxes) == 1:\n                assign_value(values, d_boxes[0], d)\n    return values\n\ndef reduce_puzzle(values):\n    stalled = False\n    while not stalled:\n        solved_values_before = len([box for box in values.keys() if len(values[box]) == 1])\n        values = eliminate(values)\n        values = only_choice(values)\n        values = naked_twins(values)\n        solved_values_after = len([box for box in values.keys() if len(values[box]) == 1])\n        stalled = solved_values_before == solved_values_after\n        if len([box for box in values.keys() if len(values[box]) == 0]):\n            return False\n    return values\n\ndef search(values):\n    values = reduce_puzzle(values)\n    if not values:\n        return False\n    unsolved_boxes = [(v, k) for k, v in values.items() if len(v) > 1]\n    if unsolved_boxes == []:\n        return values\n    choices, min_box = min(unsolved_boxes)\n    for d in choices:\n        new_values = values.copy()\n        assign_value(new_values, min_box, d)\n        ans = search(new_values)\n        if ans:\n            return ans\n\n# main function\ndef main_solution(sudoku_grid):\n    \"\"\"\n    Solve a Sudoku puzzle and return the solved grid.\n    \n    Args:\n        sudoku_grid (str): A string representing a Sudoku grid.\n            Example: '2.............62....1....7...6..8...3...9...7...6..4...4....8....52.............3'\n    \n    Returns:\n        dict: A dictionary representing the solved Sudoku grid.\n            Keys: The boxes, e.g., 'A1'\n            Values: The value in each box, e.g., '8'.\n    \"\"\"\n    values = grid_values(sudoku_grid)\n    solved_values = search(values)\n    return solved_values", "funcname": "main_solution", "ios": [{"input": {"sudoku_grid": "86311359731386515636414.245446898.61242623412836233379.696195766449515616.24654.7"}, "output": false}, {"input": {"sudoku_grid": "727..6916292.843871467.589869311.512761938174844.1...7841694745252351441.95.58566"}, "output": false}, {"input": {"sudoku_grid": "5.1789791178.67.27242.44163.98844197783411926.862574586641558159.554148765288.694"}, "output": false}, {"input": {"sudoku_grid": "1691641961858.418814644345.9795494..29899.16441179263963.186147764334558.7899151."}, "output": false}, {"input": {"sudoku_grid": "1526828931971645.299797438.72.6.8944763163214.65782..646.384.4645454924.1737634.1"}, "output": false}, {"input": {"sudoku_grid": "38413863595954521234964164128261.88.8241.74291252637.567858.51588824635841.932413"}, "output": false}, {"input": {"sudoku_grid": "82528635611818.32.821178278176.373422.9828331619..18967261538391463713878727692.2"}, "output": false}, {"input": {"sudoku_grid": "37795741.887162.211467383.6.17885969743513252223.99644..324862753247265871.6.364."}, "output": false}, {"input": {"sudoku_grid": "28972834271147877246542679..39647.647167716.6477724932941555538.96326424469846978"}, "output": false}, {"input": {"sudoku_grid": "164138622.541994211154829935.2961181641221.458.9679276.3478656893432264659.6.9247"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ThaoNguyen15/AIND-Sudoku", "path": "/solution.py", "msgidx": 5410}}
{"problem_description": "Given a chessboard of size `n` by `n`, where `n` is a positive integer, how can you place `n` queens on the board such that no two queens threaten each other? Each queen must be placed in a unique row and column, and no two queens should be in the same diagonal. What is the arrangement of queens that satisfies these conditions?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[int]): A list representing the positions of queens on the chessboard where each index represents the row and the value at that index represents the column. If no solution exists, it returns `None`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef place_queen(q: List[int], r: int):\n    if r == len(q):\n        return q\n    else:\n        # looping columns in the row of r\n        for j in range(len(q)):\n            legal = True\n            # looping previous rows\n            for i in range(r):\n                if q[i] == j or q[i] == j + r - i or q[i] == j - r + i:\n                    legal = False\n            if legal:\n                q[r] = j\n                result = place_queen(q, r + 1)\n                if result:\n                    return result\n        return None\n\n# main function\ndef main_solution(n: int):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    q = [0] * n\n    result = place_queen(q, 0)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 8}, "output": [0, 4, 7, 5, 2, 6, 1, 3]}, {"input": {"n": 6}, "output": [1, 3, 5, 0, 2, 4]}, {"input": {"n": 5}, "output": [0, 2, 4, 1, 3]}, {"input": {"n": 4}, "output": [1, 3, 0, 2]}, {"input": {"n": 7}, "output": [0, 2, 4, 6, 1, 3, 5]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lamida/algorithms-drills", "path": "/n_queens.py", "msgidx": 5011}}
{"problem_description": "Given a binary tree with a certain number of leaves, how many internal nodes does the tree contain? The number of leaves is a positive integer between 3 and 10000.", "io_requirements": "Input:\n  `n` (int): The number of leaves in the binary tree. Must be between 3 and 10000.\n\nOutput:\n  `return` (int): The number of internal nodes in the binary tree with `n` leaves.", "refcode": "# import necessary packages\nimport json\n\n# main function\ndef main_solution(n):\n    # Ensure n is within the valid range\n    if not (3 <= n <= 10000):\n        raise ValueError(\"The number of leaves must be between 3 and 10000.\")\n    \n    # Initialize the tree with a root and two leaves\n    tree = [\n        {\"parent\": None, \"data\": \"\", \"node0\": None, \"node1\": None},\n        {\"parent\": 0, \"data\": \"\", \"node0\": None, \"node1\": None},\n        {\"parent\": 0, \"data\": \"\", \"node0\": None, \"node1\": None}\n    ]\n    \n    # Initialize counters for leaves and internal nodes\n    n_leaf = 2\n    n_intro = 0\n    \n    # Build the tree until the desired number of leaves is reached\n    while n_leaf < n:\n        # Find the first node with an empty branch\n        i_start = next(i for i in range(len(tree) - 1, -1, -1) if tree[i][\"node0\"] is None or tree[i][\"node1\"] is None)\n        \n        # Add two new leaves to this node\n        for branch in [\"node0\", \"node1\"]:\n            tree.append({\"parent\": i_start, \"data\": \"\", \"node0\": None, \"node1\": None})\n            tree[i_start][branch] = len(tree) - 1\n            n_leaf += 1\n            if branch == \"node0\":\n                n_intro += 1\n    \n    # Return the number of internal nodes\n    return n_intro", "funcname": "main_solution", "ios": [{"input": {"n": 7257}, "output": 3628}, {"input": {"n": 2792}, "output": 1395}, {"input": {"n": 9518}, "output": 4758}, {"input": {"n": 2661}, "output": 1330}, {"input": {"n": 100}, "output": 49}, {"input": {"n": 9519}, "output": 4759}, {"input": {"n": 1371}, "output": 685}, {"input": {"n": 775}, "output": 387}, {"input": {"n": 1642}, "output": 820}, {"input": {"n": 8064}, "output": 4031}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "VadimSerov/Zarina2", "path": "/\u0424\u0430\u0439\u043b\u044b in Python/14 \u0437\u0430\u0434\u0430\u043d\u0438\u0435 \u0437\u0435\u043b\u0435\u043d\u043e\u0435 INOD .py", "msgidx": 5017}}
{"problem_description": "Given a string, how can we generate a list of all unique permutations of its characters, sorted in lexicographical order?", "io_requirements": "Input:\n  `input_string` (str): A string for which all unique permutations need to be generated.\n\nOutput:\n  `return` (list of str): A sorted list of all unique permutations of the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    items = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = list(itertools.permutations(items))\n    \n    # Convert each permutation tuple to a string\n    result = [''.join(p) for p in permutations]\n    \n    # Return the sorted list of permutations\n    return sorted(result)", "funcname": "main_solution", "ios": [{"input": {"input_string": "rip"}, "output": ["ipr", "irp", "pir", "pri", "rip", "rpi"]}, {"input": {"input_string": "yfs"}, "output": ["fsy", "fys", "sfy", "syf", "yfs", "ysf"]}, {"input": {"input_string": "yvz"}, "output": ["vyz", "vzy", "yvz", "yzv", "zvy", "zyv"]}, {"input": {"input_string": "fcf"}, "output": ["cff", "cff", "fcf", "fcf", "ffc", "ffc"]}, {"input": {"input_string": "jlm"}, "output": ["jlm", "jml", "ljm", "lmj", "mjl", "mlj"]}, {"input": {"input_string": "eic"}, "output": ["cei", "cie", "eci", "eic", "ice", "iec"]}, {"input": {"input_string": "clj"}, "output": ["cjl", "clj", "jcl", "jlc", "lcj", "ljc"]}, {"input": {"input_string": "our"}, "output": ["oru", "our", "rou", "ruo", "uor", "uro"]}, {"input": {"input_string": "fdl"}, "output": ["dfl", "dlf", "fdl", "fld", "ldf", "lfd"]}, {"input": {"input_string": "kuu"}, "output": ["kuu", "kuu", "uku", "uku", "uuk", "uuk"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vishnukarthikl/NLP-HW", "path": "/hw1/anagram.py", "msgidx": 5764}}
{"problem_description": "Given a grid of tiles, where each tile contains a unique number, how can we determine if the current arrangement of tiles is the goal state where all tiles are in ascending order?", "io_requirements": "Input:\n  `width` (int): The width of the grid.\n  `height` (int): The height of the grid.\n  `tiles` (list of int): A list representing the current state of the tiles in the grid. The length of the list should be equal to `width * height`.\n\nOutput:\n  `return` (bool): True if the current state is the goal state, False otherwise.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(width, height, tiles):\n    \"\"\"\n    Solves the Sliders puzzle by checking if the given state is the goal state.\n    \n    Parameters:\n    width (int): The width of the grid.\n    height (int): The height of the grid.\n    tiles (list of int): A list representing the current state of the tiles in the grid.\n    \n    Returns:\n    bool: True if the current state is the goal state, False otherwise.\n    \"\"\"\n    # Convert the input tiles list to a numpy array\n    tiles_array = np.array(tiles).reshape(height, width)\n    \n    # Create a goal state array\n    goal_state = np.arange(width * height).reshape(height, width)\n    \n    # Check if the current state matches the goal state\n    return np.array_equal(tiles_array, goal_state)", "funcname": "main_solution", "ios": [{"input": {"width": 5, "height": 2, "tiles": [7, 4, 5, 8, 3, 1, 0, 6, 9, 2]}, "output": false}, {"input": {"width": 2, "height": 5, "tiles": [6, 3, 9, 5, 4, 8, 2, 0, 1, 7]}, "output": false}, {"input": {"width": 4, "height": 3, "tiles": [10, 2, 0, 5, 8, 1, 3, 7, 6, 4, 9, 11]}, "output": false}, {"input": {"width": 4, "height": 2, "tiles": [2, 0, 7, 1, 3, 5, 4, 6]}, "output": false}, {"input": {"width": 3, "height": 4, "tiles": [11, 5, 10, 2, 9, 3, 7, 4, 6, 1, 8, 0]}, "output": false}, {"input": {"width": 2, "height": 3, "tiles": [1, 2, 3, 5, 0, 4]}, "output": false}, {"input": {"width": 4, "height": 2, "tiles": [3, 1, 5, 7, 4, 0, 6, 2]}, "output": false}, {"input": {"width": 2, "height": 2, "tiles": [2, 1, 0, 3]}, "output": false}, {"input": {"width": 3, "height": 2, "tiles": [3, 2, 4, 1, 0, 5]}, "output": false}, {"input": {"width": 2, "height": 4, "tiles": [3, 0, 7, 6, 4, 2, 5, 1]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rafafdz/university-assignments", "path": "/Artificial Intelligence/Assignment_2/sliders/sliders.py", "msgidx": 5125}}
{"problem_description": "Vasily the Programmer has a certain number of candles and a clever way to recycle burnt candles into new ones. Given the initial number of candles `a` and the number of burnt candles required to make a new one `b`, how many hours can Vasily keep his room illuminated if he acts optimally well?", "io_requirements": "Input:\n  `a` (int): The number of initial candles.\n  `b` (int): The number of burnt candles needed to make a new candle.\n\nOutput:\n  `return` (int): The total number of hours Vasily can light up the room for.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(a, b):\n    # a: number of initial candles (int)\n    # b: number of burnt candles needed to make a new candle (int)\n    \n    hours = 0\n    candle = a\n    candies = 0\n    \n    while candle >= 1 or candies >= b:\n        hours += candle\n        candies += candle\n        candle = candies // b\n        candies = candies % b\n    \n    # return the total number of hours the candles can light up the room\n    return hours", "funcname": "main_solution", "ios": [{"input": {"a": 962, "b": 684}, "output": 963}, {"input": {"a": 965, "b": 895}, "output": 966}, {"input": {"a": 635, "b": 816}, "output": 635}, {"input": {"a": 256, "b": 890}, "output": 256}, {"input": {"a": 225, "b": 820}, "output": 225}, {"input": {"a": 266, "b": 490}, "output": 266}, {"input": {"a": 634, "b": 302}, "output": 636}, {"input": {"a": 517, "b": 321}, "output": 518}, {"input": {"a": 821, "b": 172}, "output": 825}, {"input": {"a": 142, "b": 321}, "output": 142}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Ashishpurbey/warHammer", "path": "/dealingProbs/python/codeforces/379a.py", "msgidx": 5545}}
{"problem_description": "Given a number `n`, which represents the length of numbers, what are all the strobogrammatic numbers of that length? A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).", "io_requirements": "Input:\n  `n` (int): The length of the strobogrammatic numbers to generate. Must be a positive integer.\n\nOutput:\n  `return` (list of str): A list of strings representing all strobogrammatic numbers of length `n`. Each string in the list is a strobogrammatic number.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef helper(targetlen, totallen):\n    if targetlen == 0:\n        return ['']\n    if targetlen == 1:\n        return ['0', '1', '8']\n    sub = helper(targetlen - 2, totallen)\n    result = []\n    for word in sub:\n        if targetlen != totallen:\n            result.append('0' + word + '0')\n        result.append('1' + word + '1')\n        result.append('6' + word + '9')\n        result.append('9' + word + '6')\n        result.append('8' + word + '8')\n    return result\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = helper(n, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["11", "69", "96", "88"]}, {"input": {"n": 1}, "output": ["0", "1", "8"]}, {"input": {"n": 3}, "output": ["101", "609", "906", "808", "111", "619", "916", "818", "181", "689", "986", "888"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "borisachen/leetcode", "path": "/247. Strobogrammatic Number II.py", "msgidx": 5383}}
{"problem_description": "Given a sequence of \"fizz\", \"buzz\", and \"fizzbuzz\" words, what are all possible combinations of numbers (3, 5, or 15) that can generate this sequence?", "io_requirements": "Input:\n  `fizz_buzz_string` (str): A string composed of the words \"fizz\", \"buzz\", and \"fizzbuzz\". Each \"fizz\" represents the number 3, each \"buzz\" represents the number 5, and each \"fizzbuzz\" represents the number 15. The string should be non-empty and should not contain any other words or characters.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a possible combination of numbers (3, 5, or 15) that can generate the input `fizz_buzz_string`. Each number in the combination is separated by a comma.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef reverse_fizz_buzz(s):\n    if not s:\n        return [\"\"]\n    combos = []\n\n    child_combos = reverse_fizz_buzz(s[4:])\n    for child in child_combos:\n        if s[:4] == 'fizz':\n            combos.append(\"3,\" + child)\n        elif s[:4] == 'buzz':\n            combos.append(\"5,\" + child)\n\n    if s[:8] == 'fizzbuzz':\n        child_combos = reverse_fizz_buzz(s[8:])\n        for child in child_combos:\n            combos.append(\"15,\" + child)\n    return combos\n\n# main function\ndef main_solution(fizz_buzz_string):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = reverse_fizz_buzz(fizz_buzz_string)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"fizz_buzz_string": "buzzfizzbuzzbuzzfizzbuzzfizzbuzz"}, "output": ["5,3,5,5,3,5,3,5,", "5,3,5,5,3,5,15,", "5,3,5,5,15,3,5,", "5,3,5,5,15,15,", "5,15,5,3,5,3,5,", "5,15,5,3,5,15,", "5,15,5,15,3,5,", "5,15,5,15,15,"]}, {"input": {"fizz_buzz_string": "fizzbuzz"}, "output": ["3,5,", "15,"]}, {"input": {"fizz_buzz_string": "buzzbuzzfizzbuzz"}, "output": ["5,5,3,5,", "5,5,15,"]}, {"input": {"fizz_buzz_string": "buzzbuzzbuzz"}, "output": ["5,5,5,"]}, {"input": {"fizz_buzz_string": "fizzbuzzfizzbuzzfizzfizzfizz"}, "output": ["3,5,3,5,3,3,3,", "3,5,15,3,3,3,", "15,3,5,3,3,3,", "15,15,3,3,3,"]}, {"input": {"fizz_buzz_string": "buzzbuzzbuzzbuzzfizzfizzbuzzfizzfizzfizzfizz"}, "output": ["5,5,5,5,3,3,5,3,3,3,3,", "5,5,5,5,3,15,3,3,3,3,"]}, {"input": {"fizz_buzz_string": "fizzfizzfizzbuzzfizzfizzbuzzfizzfizzbuzzbuzz"}, "output": ["3,3,3,5,3,3,5,3,3,5,5,", "3,3,3,5,3,3,5,3,15,5,", "3,3,3,5,3,15,3,3,5,5,", "3,3,3,5,3,15,3,15,5,", "3,3,15,3,3,5,3,3,5,5,", "3,3,15,3,3,5,3,15,5,", "3,3,15,3,15,3,3,5,5,", "3,3,15,3,15,3,15,5,"]}, {"input": {"fizz_buzz_string": "buzz"}, "output": ["5,"]}, {"input": {"fizz_buzz_string": "buzzfizzbuzzbuzzbuzzfizzbuzzbuzzbuzzbuzz"}, "output": ["5,3,5,5,5,3,5,5,5,5,", "5,3,5,5,5,15,5,5,5,", "5,15,5,5,3,5,5,5,5,", "5,15,5,5,15,5,5,5,"]}, {"input": {"fizz_buzz_string": "fizzfizzbuzzbuzz"}, "output": ["3,3,5,5,", "3,15,5,"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "parthnvaswani/Hacktoberfest-2020-FizzBuzz", "path": "/Python/FizzBuzz-ReverseFizzBuzz.py", "msgidx": 5239}}
{"problem_description": "Given a mathematical problem where a certain integer, when added to 100, results in a perfect square, and when added to 268, also results in a perfect square, what are the possible values of this integer within specified ranges for `i` and `j`? Specifically, if `i` and `j` are integers such that `i * j = 168` and `i > j`, and both `i` and `j` are either both even or both odd, what are the integers `x` that satisfy the condition where `x + 100` and `x + 268` are perfect squares?", "io_requirements": "Input:\n  `i_range` (int): The upper limit for the range of `i` in the calculation. Must be greater than or equal to 2.\n  `j_range` (int): The upper limit for the range of `j` in the calculation. Must be greater than or equal to 2.\n\nOutput:\n  `return` (list of int): A list of integers that satisfy the condition where the integer plus 100 is a perfect square and the integer plus 268 is also a perfect square.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Num:\n    def __init__(self):\n        pass\n    \n    def calc(self, i_range, j_range):\n        results = []\n        for i in range(2, i_range + 1):\n            for j in range(2, j_range + 1):\n                if (i * j == 168) and (i > j):\n                    if ((i % 2 == 0) and (j % 2 == 0)) or ((i % 2 != 0) and (j % 2 != 0)):\n                        n = (i - j) / 2\n                        d = int(n * n - 100)\n                        results.append(d)\n        return results\n\n# main function\ndef main_solution(i_range, j_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    num_instance = Num()\n    results = num_instance.calc(i_range, j_range)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return results", "funcname": "main_solution", "ios": [{"input": {"i_range": 27, "j_range": 10}, "output": []}, {"input": {"i_range": 32, "j_range": 61}, "output": [-99, 21]}, {"input": {"i_range": 77, "j_range": 44}, "output": [-99, 21, 261]}, {"input": {"i_range": 10, "j_range": 60}, "output": []}, {"input": {"i_range": 53, "j_range": 18}, "output": [-99, 21, 261]}, {"input": {"i_range": 73, "j_range": 85}, "output": [-99, 21, 261]}, {"input": {"i_range": 68, "j_range": 24}, "output": [-99, 21, 261]}, {"input": {"i_range": 26, "j_range": 45}, "output": [-99]}, {"input": {"i_range": 15, "j_range": 75}, "output": [-99]}, {"input": {"i_range": 78, "j_range": 47}, "output": [-99, 21, 261]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rbmiao/python_tutorials", "path": "/q3_168.py", "msgidx": 5266}}
{"problem_description": "Given a target sum `S`, a starting prime number `P`, and the number of prime numbers `N`, what is the first sequence of `N` prime numbers starting from `P` that sum up to `S`?", "io_requirements": "Input:\n  `N` (int): The number of prime numbers to find.\n  `P` (int): The starting prime number.\n  `S` (int): The target sum of the prime numbers.\n\nOutput:\n  `return` (str): A string representing the sequence of prime numbers that sum up to `S`. If multiple sequences exist, only the first valid sequence is returned. If no valid sequence exists, `None` is returned.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef next_prime(prime):\n    if prime < 2:\n        return 2\n    found = False\n    while not found:\n        prime = prime + 1\n        if is_Prime(prime):\n            found = True\n    return prime\n\ndef is_Prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(5, int(math.sqrt(n) + 1), 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(N, P, S):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    plist = []\n    \n    def solve_problem(num, prime, temp, sum_num):\n        if (temp == sum_num) and (len(plist) == num):\n            return \" \".join(plist)\n        if len(plist) == num or prime >= sum_num:\n            return None\n        else:\n            if temp < sum_num:\n                np = next_prime(prime)\n                plist.append(str(np))\n                result = solve_problem(num, np, temp + np, sum_num)\n                if result:\n                    return result\n                plist.pop()\n                result = solve_problem(num, np, temp, sum_num)\n                if result:\n                    return result\n        return None\n    \n    # Convert the result to a JSON serializable output\n    result = solve_problem(N, P, 0, S)\n    return result", "funcname": "main_solution", "ios": [{"input": {"N": 3, "P": 2, "S": 77}, "output": "3 7 67"}, {"input": {"N": 3, "P": 3, "S": 63}, "output": "5 11 47"}, {"input": {"N": 3, "P": 3, "S": 29}, "output": "5 7 17"}, {"input": {"N": 4, "P": 7, "S": 78}, "output": "11 13 17 37"}, {"input": {"N": 3, "P": 5, "S": 49}, "output": "7 11 31"}, {"input": {"N": 2, "P": 11, "S": 48}, "output": "17 31"}, {"input": {"N": 3, "P": 7, "S": 51}, "output": "11 17 23"}, {"input": {"N": 3, "P": 2, "S": 55}, "output": "3 5 47"}, {"input": {"N": 3, "P": 11, "S": 49}, "output": "13 17 19"}, {"input": {"N": 4, "P": 11, "S": 82}, "output": "13 17 23 29"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Raj-Kumar2208/Recursion-and-BackTracking", "path": "/backtrackPrimeSum.py", "msgidx": 5090}}
{"problem_description": "Given a chessboard of size N x N, where N is a positive integer, the task is to place N queens on the board such that no two queens threaten each other. A queen can move horizontally, vertically, and diagonally. The problem requires determining the configuration of the board after placing the queens. What is the board configuration after successfully placing the queens on the board of size N?", "io_requirements": "Input:\n  `grid_size` (int): The size of the grid (N x N) on which the N-Queens problem is to be solved. The value should be a positive integer.\n\nOutput:\n  `return` (str): A JSON-serialized string representing the board configuration after placing the queens. Each cell in the board is represented by an integer (0 for empty, 1 for a queen).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nGRID_SIZE = 4\n\ndef place_queens(row, board):\n    if row == GRID_SIZE:\n        return True\n    else:\n        for col in range(GRID_SIZE):\n            if check_valid(board, row, col):\n                board[row][col] = 1\n                if place_queens(row+1, board):\n                    return True\n                board[row][col] = 0\n    return False\n\ndef check_valid(board, row, col):\n    for i in range(row):\n        if board[i][col] == 1:\n            return False\n\n    for i, j in zip(range(row, -1, -1),\n                    range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n\n    for i, j in zip(range(row, GRID_SIZE, 1),\n                    range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n\n    return True\n\n# main function\ndef main_solution(grid_size):\n    # Convert JSON serializable input to the original input variables\n    GRID_SIZE = grid_size\n    board = [[0 for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    \n    # Call the original function\n    place_queens(0, board)\n    \n    # Convert the output to JSON serializable format\n    board_str = json.dumps(board)\n    \n    return board_str", "funcname": "main_solution", "ios": [{"input": {"grid_size": 4}, "output": "[[0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 0]]"}, {"input": {"grid_size": 5}, "output": "[[0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nirjharij/cracking-the-coding-interview-in-python", "path": "/recursion_and_dp/eight_queens.py", "msgidx": 5270}}
{"problem_description": "Given a string composed of alphabetic characters and spaces, determine if it can be rearranged to form a palindrome. What is the result of this check for a randomly generated string?", "io_requirements": "Input:\n  `input_string` (str): A string that may or may not be a permutation of a palindrome. The string should not contain any special characters or numbers, and should be composed of alphabetic characters and spaces.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string is a permutation of a palindrome (`True`) or not (`False`).", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# main function\ndef main_solution(input_string):\n    \"\"\"\n    Function that checks if a string is a permutation of a palindrome.\n    The function normalizes the string by making it lower case and removing spaces.\n    It then checks the frequency of each character to determine if the string can be rearranged into a palindrome.\n    \"\"\"\n    # Normalizing the string by making it lower case and removing spaces\n    string = input_string.lower().replace(' ', '')\n\n    # Creating a frequency dictionary from the string's letters\n    counter = Counter(list(string))\n\n    # If the string is odd sized, there can be only one odd-frequency letter\n    # so we start this flag with False in this case. If the string is even\n    # sized, there can be no odd frequency letters so we start this flag as\n    # true.\n    has_odd_letter_occured = bool(len(string) % 2 == 0)\n\n    # Looping through the string's unique characters\n    for key in counter:\n\n        # Getting that char's frequency\n        frequency = counter[key]\n\n        # Creating a flag to check the frequency's parity\n        odd_frequency = frequency % 2 == 1\n\n        # If the frequency is odd and we already have an odd-frequent letter,\n        # we cannot make a palindrome out of it. Keep in mind that if the\n        # string is even sized there can be NO odd frequent letters, that's\n        # why in that case, I had already initialized this flag as True\n        if odd_frequency and has_odd_letter_occured:\n            return False\n        elif not has_odd_letter_occured and odd_frequency:\n            # If we don't have an odd frequent letter, we do now. Flagging it\n            has_odd_letter_occured = True\n\n    # If the loop did not return False, the string is a palindrome permutation\n    return True", "funcname": "main_solution", "ios": [{"input": {"input_string": "awcivnp"}, "output": false}, {"input": {"input_string": "fiebfc"}, "output": false}, {"input": {"input_string": "xduswrn "}, "output": false}, {"input": {"input_string": " zzuirfge"}, "output": false}, {"input": {"input_string": "plsjkv"}, "output": false}, {"input": {"input_string": " pncx"}, "output": false}, {"input": {"input_string": "voxu"}, "output": false}, {"input": {"input_string": "nvmsiuiub"}, "output": false}, {"input": {"input_string": "jyrahyh"}, "output": false}, {"input": {"input_string": "sohb"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "fbidu/Etudes", "path": "/cracking-interview/01-arrays-and-strings/exercises/palindrome_permutation.py", "msgidx": 5258}}
{"problem_description": "Given a set of 8 unique integers between 1 and 9, what are all the possible arrangements of these integers such that the first three integers form a number `num1`, the fourth integer forms a number `num2`, and the last four integers form a number `num3`, where `num1 * num2` equals `num3`?", "io_requirements": "Input:\n  `possible_numbers` (list of integers): A list of 8 unique integers between 1 and 9.\n\nOutput:\n  `return` (list of lists of integers): A list of all possible solutions where each solution is a list of 8 integers that satisfy the condition `num1 * num2 == num3`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef calculated(current_list):\n    num1 = 0\n    for i in range(3):\n        num1 = num1 * 10 + current_list[i]\n\n    num2 = current_list[3]\n\n    num3 = 0\n    for i in range(4, 8):\n        num3 = num3 * 10 + current_list[i]\n\n    return num1 * num2 == num3\n\n# main function\ndef main_solution(possible_numbers):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    possible_numbers = list(possible_numbers)\n    current_list = [0] * 8\n    solutions = []\n\n    def find_all_solution(current_list, possible_number, index):\n        if index == 8:\n            if calculated(current_list):\n                solutions.append(current_list[:])\n            return\n        for num in possible_number:\n            current_list[index] = num\n            new_possible = possible_number[:]\n            new_possible.remove(num)\n            find_all_solution(current_list, new_possible, index + 1)\n\n    find_all_solution(current_list, possible_numbers, 0)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return solutions", "funcname": "main_solution", "ios": [{"input": {"possible_numbers": [6, 1, 2, 4, 3, 5, 9, 7]}, "output": [[4, 5, 6, 7, 3, 1, 9, 2], [5, 2, 9, 6, 3, 1, 7, 4], [5, 7, 9, 4, 2, 3, 1, 6]]}, {"input": {"possible_numbers": [7, 9, 1, 6, 4, 2, 5, 3]}, "output": [[4, 5, 6, 7, 3, 1, 9, 2], [5, 7, 9, 4, 2, 3, 1, 6], [5, 2, 9, 6, 3, 1, 7, 4]]}, {"input": {"possible_numbers": [5, 9, 7, 6, 4, 8, 1, 2]}, "output": []}, {"input": {"possible_numbers": [5, 4, 3, 8, 1, 9, 6, 2]}, "output": [[3, 9, 2, 4, 1, 5, 6, 8]]}, {"input": {"possible_numbers": [5, 3, 8, 4, 7, 1, 9, 2]}, "output": [[5, 8, 9, 7, 4, 1, 2, 3], [5, 9, 4, 3, 1, 7, 8, 2], [8, 1, 9, 3, 2, 4, 5, 7], [9, 1, 8, 3, 2, 7, 5, 4]]}, {"input": {"possible_numbers": [5, 6, 7, 8, 1, 9, 3, 2]}, "output": [[6, 7, 9, 2, 1, 3, 5, 8], [7, 6, 9, 2, 1, 5, 3, 8], [7, 9, 3, 2, 1, 5, 8, 6], [8, 9, 3, 7, 6, 2, 5, 1], [2, 9, 3, 6, 1, 7, 5, 8]]}, {"input": {"possible_numbers": [5, 7, 1, 3, 9, 6, 4, 8]}, "output": [[7, 8, 9, 4, 3, 1, 5, 6], [9, 1, 3, 6, 5, 4, 7, 8], [6, 5, 8, 3, 1, 9, 7, 4], [6, 9, 3, 7, 4, 8, 5, 1], [8, 7, 9, 4, 3, 5, 1, 6]]}, {"input": {"possible_numbers": [8, 6, 3, 4, 5, 9, 2, 1]}, "output": [[3, 9, 2, 4, 1, 5, 6, 8]]}, {"input": {"possible_numbers": [3, 6, 7, 1, 8, 9, 5, 4]}, "output": [[6, 9, 3, 7, 4, 8, 5, 1], [6, 5, 8, 3, 1, 9, 7, 4], [7, 8, 9, 4, 3, 1, 5, 6], [8, 7, 9, 4, 3, 5, 1, 6], [9, 1, 3, 6, 5, 4, 7, 8]]}, {"input": {"possible_numbers": [4, 8, 1, 3, 2, 9, 7, 5]}, "output": [[8, 1, 9, 3, 2, 4, 5, 7], [9, 1, 8, 3, 2, 7, 5, 4], [5, 8, 9, 7, 4, 1, 2, 3], [5, 9, 4, 3, 1, 7, 8, 2]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wangyouan/PythonTest", "path": "/ForFun/layton_148.py", "msgidx": 5468}}
{"problem_description": "Given a string representation of a binary tree's preorder traversal, where each node value is followed by a number of dashes indicating its depth in the tree, how can you reconstruct the binary tree and return its preorder traversal as a list of integers?", "io_requirements": "Input:\n  `S` (str): A string representing the preorder traversal of a binary tree. Each node value is followed by a number of dashes indicating its depth in the tree. For example, \"1-2--3--4-5--6--7\".\n\nOutput:\n  `return` (list): A list of integers representing the preorder traversal of the reconstructed binary tree. For example, [1, 2, 5, 3, 4, 6, 7].", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# main function\ndef main_solution(S: str) -> list:\n    # Convert the input string S to a list of integers representing the tree nodes in preorder traversal\n    if not S:\n        return []\n    \n    level = 0  # Node level\n    num = 0  # Record node's value\n    n = len(S)\n    dic = defaultdict(list)\n    for i, c in enumerate(S):\n        if c == '-':\n            level += 1\n        else:\n            num = num * 10 + int(c)\n            if i == n - 1 or S[i+1] == '-':\n                # num value is a TreeNode.val, its parent node is the last node in the previous level\n                node = TreeNode(num)\n                dic[level].append(node)\n                if dic[level-1]:\n                    if dic[level-1][-1].left:\n                        dic[level-1][-1].right = node\n                    else:\n                        dic[level-1][-1].left = node\n                num = 0\n                level = 0\n    \n    # Traverse the tree to get the preorder traversal list\n    result = []\n    def traverse(node):\n        if node:\n            result.append(node.val)\n            traverse(node.left)\n            traverse(node.right)\n    \n    traverse(dic[0][0])\n    return result", "funcname": "main_solution", "ios": [{"input": {"S": "66760907551021053"}, "output": [66760907551021053]}, {"input": {"S": "43557261694426266-570691942-29833812-439207701-681788999--777222095---900771688---139040711"}, "output": [43557261694426266, 570691942, 681788999, 777222095, 900771688, 139040711]}, {"input": {"S": "404308193447887982-233851201-15527681--527807205--981478142--137458093--755842539"}, "output": [404308193447887982, 233851201, 15527681, 527807205, 755842539]}, {"input": {"S": "565021899719886477163353075599755393276632536538930727"}, "output": [565021899719886477163353075599755393276632536538930727]}, {"input": {"S": "680305191165927190-207211190-291664983--15933669"}, "output": [680305191165927190, 207211190, 291664983, 15933669]}, {"input": {"S": "183070593"}, "output": [183070593]}, {"input": {"S": "812546663-762267824-577078234"}, "output": [812546663, 762267824, 577078234]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sakurasakura1996/Leetcode", "path": "/\u4e8c\u53c9\u6811/problem1028.py", "msgidx": 4887}}
{"problem_description": "In a game of chess, a knight moves in an \"L\" shape: two squares in one direction and then one square perpendicular, or vice versa. Given a chessboard numbered from 0 to 63, what is the minimum number of moves required for a knight to travel from a starting square (`src`) to a destination square (`dest`)?", "io_requirements": "Input:\n  `src` (int): The starting square on a chessboard, an integer between 0 and 63, inclusive.\n  `dest` (int): The destination square on a chessboard, an integer between 0 and 63, inclusive.\n\nOutput:\n  `return` (int): The smallest number of moves required for a chess knight to travel from the source square to the destination square.", "refcode": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\ndir = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]\n\ndef isout(n, d):\n    x = n % 8 + d[0]\n    y = n // 8 + d[1]\n    if x < 0 or x > 7 or y < 0 or y > 7:\n        return True\n    else:\n        return False\n\ndef answer(src, dest):\n    if src == dest:\n        return 0\n\n    f = set()\n    b = set()\n    map = set(range(64))\n    f.add(src)\n    b.add(dest)\n    map.remove(src)\n    map.remove(dest)\n    step = 0\n\n    while len(map) != 0:\n        if len(f) > len(b):\n            f, b = b, f\n\n        step += 1\n\n        next = set()\n        for n in f:\n            for d in dir:\n                if isout(n, d):\n                    continue\n                new = n + 8 * d[1] + d[0]\n                if new in b:\n                    return step\n                if new not in map:\n                    continue\n                map.remove(new)\n                next.add(new)\n        f = copy.deepcopy(next)\n    return 0\n\n# main function\ndef main_solution(src, dest):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = answer(src, dest)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"src": 4, "dest": 20}, "output": 2}, {"input": {"src": 30, "dest": 50}, "output": 3}, {"input": {"src": 54, "dest": 39}, "output": 1}, {"input": {"src": 60, "dest": 54}, "output": 1}, {"input": {"src": 5, "dest": 38}, "output": 3}, {"input": {"src": 32, "dest": 17}, "output": 1}, {"input": {"src": 48, "dest": 6}, "output": 4}, {"input": {"src": 4, "dest": 19}, "output": 1}, {"input": {"src": 50, "dest": 60}, "output": 1}, {"input": {"src": 47, "dest": 17}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bluebambu/Leetcode_cpp", "path": "/Chess Knight Moves/knight_moves.py", "msgidx": 5580}}
{"problem_description": "In a game of chess, two queens are placed on an 8x8 board. Given the positions of the white queen and the black queen, what is the configuration of the board and can the white queen attack the black queen?", "io_requirements": "Input:\n  `white` (list of int): A list containing two integers representing the coordinates of the white queen on an 8x8 chessboard. The first integer is the row (0-7) and the second integer is the column (0-7).\n  `black` (list of int): A list containing two integers representing the coordinates of the black queen on an 8x8 chessboard. The first integer is the row (0-7) and the second integer is the column (0-7).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `board_config` (list of str): A list of 8 strings, each representing a row on the chessboard. The white queen is represented by 'W', the black queen by 'B', and empty squares by '_'.\n    - `attack_possible` (bool): A boolean indicating whether the white queen can attack the black queen.", "refcode": "# import necessary packages\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef validate(function):\n    board = set(product(range(8), range(8)))\n    def wrapper(white, black):\n        if black not in board or white not in board or \\\n           white == black:\n               raise ValueError\n        return function(white, black)\n\n    return wrapper\n\n@validate\ndef board(white, black):\n    board = [['_' for _ in range(8)] for _ in range(8)]\n    board[white[0]][white[1]] = 'W'\n    board[black[0]][black[1]] = 'B'\n\n    return [''.join(row) for row in board]\n\n@validate\ndef can_attack(white, black):\n    squares = set(product(range(8), range(8)))\n    visible = {(x, y) for x, y in squares\n                       if x == white[0] or y == white[1] or # column & row\n                          (x+y) == sum(white) or (x-y) == white[0] - white[1]}  # diagonals\n\n    return black in visible\n\n# main function\ndef main_solution(white, black):\n    # Convert input to tuple if necessary\n    white = tuple(white)\n    black = tuple(black)\n    \n    # Get the board configuration\n    board_config = board(white, black)\n    \n    # Determine if the white queen can attack the black queen\n    attack_possible = can_attack(white, black)\n    \n    # Return the result as a dictionary\n    return {\n        \"board_config\": board_config,\n        \"attack_possible\": attack_possible\n    }", "funcname": "main_solution", "ios": [{"input": {"white": [7, 0], "black": [6, 4]}, "output": {"board_config": ["________", "________", "________", "________", "________", "________", "____B___", "W_______"], "attack_possible": false}}, {"input": {"white": [5, 2], "black": [7, 7]}, "output": {"board_config": ["________", "________", "________", "________", "________", "__W_____", "________", "_______B"], "attack_possible": false}}, {"input": {"white": [3, 4], "black": [0, 1]}, "output": {"board_config": ["_B______", "________", "________", "____W___", "________", "________", "________", "________"], "attack_possible": true}}, {"input": {"white": [5, 4], "black": [0, 1]}, "output": {"board_config": ["_B______", "________", "________", "________", "________", "____W___", "________", "________"], "attack_possible": false}}, {"input": {"white": [2, 3], "black": [0, 4]}, "output": {"board_config": ["____B___", "________", "___W____", "________", "________", "________", "________", "________"], "attack_possible": false}}, {"input": {"white": [2, 5], "black": [6, 2]}, "output": {"board_config": ["________", "________", "_____W__", "________", "________", "________", "__B_____", "________"], "attack_possible": false}}, {"input": {"white": [1, 6], "black": [5, 7]}, "output": {"board_config": ["________", "______W_", "________", "________", "________", "_______B", "________", "________"], "attack_possible": false}}, {"input": {"white": [3, 4], "black": [5, 6]}, "output": {"board_config": ["________", "________", "________", "____W___", "________", "______B_", "________", "________"], "attack_possible": true}}, {"input": {"white": [6, 6], "black": [3, 1]}, "output": {"board_config": ["________", "________", "________", "_B______", "________", "________", "______W_", "________"], "attack_possible": false}}, {"input": {"white": [5, 2], "black": [3, 6]}, "output": {"board_config": ["________", "________", "________", "______B_", "________", "__W_____", "________", "________"], "attack_possible": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "itsolutionscorp/AutoStyle-Clustering", "path": "/all_data/exercism_data/python/queen-attack/03cd208da15c4bf1a97859dd8a90a336.py", "msgidx": 5445}}
{"problem_description": "Given a chessboard of size `NUM` x `NUM`, how many distinct ways can you place `NUM` queens on the board such that no two queens threaten each other, and what is the configuration of the first solution?", "io_requirements": "Input:\n  `NUM` (int): The size of the chessboard and the number of queens to be placed on it.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `total_solutions` (int): The total number of distinct solutions to the N-Queens problem for the given board size.\n    - `first_solution` (list): The first solution found, represented as a list of integers where each integer represents the column position of the queen in each row.", "refcode": "# import necessary packages\nimport itertools\nimport threading\nimport sys\n\n# all class and function definitions in the code file, if any\ndef get_reverse_board(board):\n    return [len(board) - x - 1 for x in board]\n\ndef check(arglist, pos):\n    lenn = len(arglist)\n    for index, i in enumerate(arglist):\n        if i == pos or abs(i - pos) == lenn - index:\n            return False\n    return True\n\ndef nqueens(NUM):\n    arglists = []\n    isOdd = NUM % 2\n    n = (NUM // 2 + 1) if isOdd else NUM // 2\n    for i in range(n):\n        arglists.append([i])\n    while arglists:\n        arglist = arglists.pop()\n        if len(arglist) == NUM:\n            yield arglist\n            if not isOdd or arglist[0] != (n - 1):\n                yield get_reverse_board(arglist)\n        else:\n            for i in range(NUM):\n                if check(arglist, i):\n                    arglists.append(arglist + [i])\n\n# main function\ndef main_solution(NUM):\n    # Convert input to the required format\n    NUM = int(NUM)\n    \n    # Generate solutions\n    solutions = list(nqueens(NUM))\n    \n    # Convert output to JSON serializable format\n    result = {\n        \"total_solutions\": len(solutions),\n        \"first_solution\": solutions[0] if solutions else []\n    }\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"NUM": 5}, "output": {"total_solutions": 10, "first_solution": [2, 4, 1, 3, 0]}}, {"input": {"NUM": 10}, "output": {"total_solutions": 724, "first_solution": [4, 9, 7, 0, 2, 8, 6, 1, 3, 5]}}, {"input": {"NUM": 4}, "output": {"total_solutions": 2, "first_solution": [1, 3, 0, 2]}}, {"input": {"NUM": 6}, "output": {"total_solutions": 4, "first_solution": [2, 5, 1, 4, 0, 3]}}, {"input": {"NUM": 7}, "output": {"total_solutions": 40, "first_solution": [3, 6, 4, 1, 5, 0, 2]}}, {"input": {"NUM": 8}, "output": {"total_solutions": 92, "first_solution": [3, 7, 4, 2, 0, 6, 1, 5]}}, {"input": {"NUM": 9}, "output": {"total_solutions": 352, "first_solution": [4, 8, 3, 5, 7, 1, 6, 0, 2]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ltltlt/algorithms", "path": "/algorithms/eight-queen/bt_it_td.py", "msgidx": 5515}}
{"problem_description": "In a spiral memory grid, numbers are stored in a spiral pattern starting from the center (position 1) and moving outward. Given a position in this grid, what is the Manhattan distance from that position to the center of the grid?", "io_requirements": "Input:\n  `number` (int): A positive integer representing the position in a spiral memory grid.\n\nOutput:\n  `return` (int): The Manhattan distance from the given position to the center of the spiral memory grid.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # 1 is edge case\n    if number == 1:\n        return 0\n    \n    # Find closest bottom right corner by finding closest odd sqrt\n    closest_root = math.floor(math.sqrt(number))\n\n    # If this is even, then it's the next lowest one\n    if not closest_root % 2:\n        closest_root -= 1\n\n    # Get bottom right corner value\n    bottom_right_corner = closest_root ** 2\n\n    # Get edge length, which is one more than the closest_root\n    edge_length = closest_root + 1\n    half_edge_length = edge_length / 2\n\n    # Determine how far along outside we've gone\n    distance_along_outside = number - bottom_right_corner\n\n    y = 0\n    x = 0\n\n    if distance_along_outside >= 3 * edge_length:\n        x = distance_along_outside - 3 * edge_length\n    elif distance_along_outside >= edge_length and distance_along_outside <= (2 * edge_length):\n        x = distance_along_outside - edge_length\n    else:\n        x = edge_length\n\n    if distance_along_outside >= 2 * edge_length and distance_along_outside <= (3 * edge_length):\n        y = distance_along_outside - (2 * edge_length)\n    elif distance_along_outside <= edge_length:\n        y = distance_along_outside\n    else:\n        y = edge_length\n\n    y = abs(y - half_edge_length)\n    x = abs(x - half_edge_length)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return x + y", "funcname": "main_solution", "ios": [{"input": {"number": 92869}, "output": 156.0}, {"input": {"number": 246865}, "output": 352.0}, {"input": {"number": 588381}, "output": 676.0}, {"input": {"number": 210258}, "output": 423.0}, {"input": {"number": 962400}, "output": 943.0}, {"input": {"number": 173926}, "output": 381.0}, {"input": {"number": 135315}, "output": 258.0}, {"input": {"number": 470969}, "output": 372.0}, {"input": {"number": 608585}, "output": 596.0}, {"input": {"number": 722524}, "output": 827.0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AlexanderEllis/AdventOfCode", "path": "/2017/31.py", "msgidx": 5189}}
{"problem_description": "Given a directed graph represented by an adjacency matrix, determine if the start state is a goal state and find all possible successor states along with their respective costs. What is the result of checking if the start state is a goal state and listing all successors with their costs?", "io_requirements": "Input:\n  `matrix` (List[List[Optional[float]]]): A 2D list representing the adjacency matrix of a directed graph. Each element can be a float (representing the cost of the edge) or `None` (indicating no edge between the nodes).\n  `goal_indices` (List[int]): A list of integers representing the indices of the goal states in the graph.\n  `start_state` (int, optional): An integer representing the index of the start state. Defaults to 0.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `is_goal` (bool): A boolean indicating whether the start state is a goal state.\n    - `successors` (List[Tuple[int, float]]): A list of tuples where each tuple contains an integer (representing the successor state) and a float (representing the cost to reach that state).", "refcode": "# import necessary packages\nfrom typing import List, Optional, Set\n\n# all class and function definitions in the code file, if any\nclass DGraph:\n    def __init__(self, matrix: List[List[Optional[float]]], goal_indices: Set[int], start_state: int = 0):\n        self.matrix = matrix\n        self.goal_indices = goal_indices\n        self.start_state = start_state\n\n    def get_start_state(self):\n        return self.start_state\n\n    def is_goal_state(self, state):\n        return state in self.goal_indices\n\n    def get_successors(self, state):\n        row = self.matrix[state]\n        successors = {}\n        index = 0\n        for cost in row:\n            if cost is not None:\n                successors[index] = cost\n            index += 1\n        return successors\n\n# main function\ndef main_solution(matrix: List[List[Optional[float]]], goal_indices: List[int], start_state: int = 0):\n    # Convert JSON serializable inputs to original input variables\n    goal_indices_set = set(goal_indices)\n    \n    # Create an instance of DGraph\n    graph = DGraph(matrix, goal_indices_set, start_state)\n    \n    # Get the start state\n    start_state = graph.get_start_state()\n    \n    # Check if the start state is a goal state\n    is_goal = graph.is_goal_state(start_state)\n    \n    # Get the successors of the start state\n    successors = graph.get_successors(start_state)\n    \n    # Convert the output to JSON serializable format\n    successors_list = [(key, value) for key, value in successors.items()]\n    \n    # Return the final output\n    return {\"is_goal\": is_goal, \"successors\": successors_list}", "funcname": "main_solution", "ios": [{"input": {"matrix": [[null, 4.65, 5.57], [null, 9.7, null], [null, 1.64, 7.56]], "goal_indices": [1, 2], "start_state": 2}, "output": {"is_goal": true, "successors": [[1, 1.64], [2, 7.56]]}}, {"input": {"matrix": [[5.58, null, 4.67], [null, 7.64, 6.27], [null, null, 0.94]], "goal_indices": [2, 1], "start_state": 1}, "output": {"is_goal": true, "successors": [[1, 7.64], [2, 6.27]]}}, {"input": {"matrix": [[2.56, 3.86, null], [4.07, 6.88, null], [null, null, 3.26]], "goal_indices": [1], "start_state": 2}, "output": {"is_goal": false, "successors": [[2, 3.26]]}}, {"input": {"matrix": [[4.28, null, 8.03], [null, 4.69, null], [3.49, null, 7.03]], "goal_indices": [1, 2], "start_state": 1}, "output": {"is_goal": true, "successors": [[1, 4.69]]}}, {"input": {"matrix": [[7.56, 7.21, null], [null, 8.93, null], [null, null, null]], "goal_indices": [0, 1], "start_state": 1}, "output": {"is_goal": true, "successors": [[1, 8.93]]}}, {"input": {"matrix": [[null, 7.32, 8.78], [9.94, 6.52, null], [null, null, 5.93]], "goal_indices": [0, 2], "start_state": 2}, "output": {"is_goal": true, "successors": [[2, 5.93]]}}, {"input": {"matrix": [[null, 5.96, 9.29], [null, 7.84, null], [0.32, null, 8.42]], "goal_indices": [1, 0], "start_state": 0}, "output": {"is_goal": true, "successors": [[1, 5.96], [2, 9.29]]}}, {"input": {"matrix": [[null, 5.93, null], [null, null, null], [4.79, 8.86, 6.46]], "goal_indices": [0, 2], "start_state": 2}, "output": {"is_goal": true, "successors": [[0, 4.79], [1, 8.86], [2, 6.46]]}}, {"input": {"matrix": [[null, 6.4, 5.59], [0.42, 3.93, null], [null, 7.44, null]], "goal_indices": [1, 2], "start_state": 0}, "output": {"is_goal": false, "successors": [[1, 6.4], [2, 5.59]]}}, {"input": {"matrix": [[9.54, null, null], [null, 3.31, null], [2.92, null, 6.9]], "goal_indices": [2, 0], "start_state": 2}, "output": {"is_goal": true, "successors": [[0, 2.92], [2, 6.9]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ama4bob/Assignment-1", "path": "/dgraph.py", "msgidx": 5233}}
{"problem_description": "Given a subsequence and an alphabet, determine the position of the subsequence in a De Bruijn sequence generated over the given alphabet. If the subsequence is not found, return `-1`. What is the position of the given subsequence in the De Bruijn sequence?", "io_requirements": "Input:\n  `subseq` (str): The subsequence to look for. This can either be a string or a list.\n  `alphabet` (str): List or string to generate the sequence over. Default is `string.ascii_lowercase`.\n  `n` (int): The length of subsequences that should be unique. If `None`, it will be inferred from the length of `subseq`.\n\nOutput:\n  `return` (int): The position of the subsequence in the De Bruijn sequence or `-1` if not found.", "refcode": "# import necessary packages\nimport string\n\n# main function\ndef main_solution(subseq, alphabet=string.ascii_lowercase, n=None):\n    \"\"\"\n    Calculates the position of a substring into a De Bruijn sequence.\n\n    Arguments:\n      subseq (str): The subsequence to look for. This can either be a string or a list.\n      alphabet (str): List or string to generate the sequence over. Default is string.ascii_lowercase.\n      n (int): The length of subsequences that should be unique. If None, it will be inferred from the length of subseq.\n\n    Returns:\n      int: The position of the subsequence in the De Bruijn sequence or -1 if not found.\n    \"\"\"\n    if any(c not in alphabet for c in subseq):\n        return -1\n\n    n = n or len(subseq)\n\n    return _gen_find(subseq, de_bruijn(alphabet, n))\n\ndef de_bruijn(alphabet, n):\n    \"\"\"\n    Generator for a sequence of unique substrings of length `n`. This is implemented using a\n    De Bruijn Sequence over the given `alphabet`.\n\n    Arguments:\n      alphabet (str): List or string to generate the sequence over.\n      n (int): The length of subsequences that should be unique.\n\n    Yields:\n      str: Characters from the De Bruijn sequence.\n    \"\"\"\n    k = len(alphabet)\n    a = [0] * k * n\n    def db(t, p):\n        if t > n:\n            if n % p == 0:\n                for j in range(1, p + 1):\n                    yield alphabet[a[j]]\n        else:\n            a[t] = a[t - p]\n            for c in db(t + 1, p):\n                yield c\n\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                for c in db(t + 1, t):\n                    yield c\n\n    return db(1, 1)\n\ndef _gen_find(subseq, generator):\n    \"\"\"\n    Returns the first position of subseq in the generator or -1 if there is no such position.\n\n    Arguments:\n      subseq (list): The subsequence to look for.\n      generator (generator): The generator producing the sequence.\n\n    Returns:\n      int: The position of the subsequence in the sequence or -1 if not found.\n    \"\"\"\n    subseq = list(subseq)\n    pos = 0\n    saved = []\n\n    for c in generator:\n        saved.append(c)\n        if len(saved) > len(subseq):\n            saved.pop(0)\n            pos += 1\n        if saved == subseq:\n            return pos\n    return -1", "funcname": "main_solution", "ios": [{"input": {"subseq": "jhvvffjf", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 4}, "output": -1}, {"input": {"subseq": "noxhiok", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 2}, "output": -1}, {"input": {"subseq": "t", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 5}, "output": 95}, {"input": {"subseq": "igcphd", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 4}, "output": -1}, {"input": {"subseq": "czljndt", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 3}, "output": -1}, {"input": {"subseq": "yoncb", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 3}, "output": -1}, {"input": {"subseq": "sq", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 2}, "output": 580}, {"input": {"subseq": "zomuf", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 4}, "output": -1}, {"input": {"subseq": "ackoscwedi", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 4}, "output": -1}, {"input": {"subseq": "d", "alphabet": "abcdefghijklmnopqrstuvwxyz", "n": 4}, "output": 12}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zh-explorer/pwndemo", "path": "/pwnlib/util/cyclic.py", "msgidx": 5439}}
{"problem_description": "Given a piece of text, how can we efficiently compress it using Huffman coding? Specifically, what is the encoded form of the given text using Huffman coding?", "io_requirements": "Input:\n  `plaintext` (str): A string representing the text to be encoded using Huffman coding.\n\nOutput:\n  `return` (str): A string representing the encoded text using Huffman coding.", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, name, freq):\n        self.parent = None\n        self.left = None\n        self.right = None\n        self.name = name\n        self.freq = freq\n\nclass MinNodePriorityQueue:\n    def __init__(self):\n        self.queue = []\n\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    def isSizeOne(self):\n        return len(self.queue) == 1\n\n    def push(self, node):\n        self.queue.append(node)\n\n    def size(self):\n        return len(self.queue)\n\n    def pop(self):\n        try:\n            min = 0\n            for i in range(len(self.queue)):\n                if self.queue[i].freq < self.queue[min].freq:\n                    min = i\n            item = self.queue[min]\n            del self.queue[min]\n            return item\n        except IndexError:\n            exit()\n\ndef buildFreqTable(plaintext):\n    freq_table = Counter()\n    for letter in plaintext:\n        freq_table[letter] += 1\n    return freq_table\n\ndef buildPriorityQueue(freq_table):\n    pqueue = MinNodePriorityQueue()\n    for item, freq in freq_table.items():\n        pqueue.push(Node(item, freq))\n    return pqueue\n\ndef buildTree(pqueue):\n    while pqueue.size() > 1:\n        left = pqueue.pop()\n        right = pqueue.pop()\n        newName = right.name + left.name\n        newFreq = right.freq + left.freq\n        newParent = Node(newName, newFreq)\n        newParent.left = left\n        newParent.right = right\n        pqueue.push(newParent)\n    return pqueue.pop()\n\ndef buildEncodingTable(node):\n    encodingtable = {}\n    def rbuildEncodingTable(node, currentpath):\n        if not node:\n            return\n        elif not node.left and not node.right:\n            encodingtable[node.name] = currentpath\n        else:\n            rbuildEncodingTable(node.left, currentpath + \"0\")\n            rbuildEncodingTable(node.right, currentpath + \"1\")\n    rbuildEncodingTable(node, \"\")\n    return encodingtable\n\ndef buildEncodedText(encodingtable, plaintext):\n    return_string = \"\"\n    for letter in plaintext:\n        if letter in encodingtable:\n            return_string += encodingtable[letter]\n    return return_string\n\n# main function\ndef main_solution(plaintext):\n    # Build frequency table\n    freq_table = buildFreqTable(plaintext)\n    \n    # Build priority queue\n    pqueue = buildPriorityQueue(freq_table)\n    \n    # Build Huffman tree\n    tree = buildTree(pqueue)\n    \n    # Build encoding table\n    encodingtable = buildEncodingTable(tree)\n    \n    # Build encoded text\n    encodedtext = buildEncodedText(encodingtable, plaintext)\n    \n    # Return encoded text\n    return encodedtext", "funcname": "main_solution", "ios": [{"input": {"plaintext": "GDQjTTuLX6mh2OjlRWHwCO"}, "output": "1101011011111001010101110111110111110111110000000100100011110010100100010101100111100010011100"}, {"input": {"plaintext": "CRNkSt1AjUr9C"}, "output": "01110001001101010111100110111101111000001010011"}, {"input": {"plaintext": "sECAiZA4XI3FDoSJKhmS"}, "output": "111001110111110110011111000011000001001000110100010101100111110110001001101010111101"}, {"input": {"plaintext": "vyBPHXNwaY6sxGflLsq"}, "output": "11100111011111011111000000010010001101000101011011010111100010011010101111011100"}, {"input": {"plaintext": "AbJvPmZALOJ2Wz4"}, "output": "0010110010011110001001101000110111100010110111101111000"}, {"input": {"plaintext": "OR2Z9TaQDrO"}, "output": "1011100110111101111000001010011100101"}, {"input": {"plaintext": "MaDcC56PnEnxIb"}, "output": "0110011110001001101010111100110101011100101111000001"}, {"input": {"plaintext": "yvaRk38IfcLwVOLMH"}, "output": "00000001001000110100010101100111100010011111101010111100111111011110"}, {"input": {"plaintext": "AG6dI7LgUaT0ySi9M1"}, "output": "1110011101111101111100000001001000110100010101100111100010011010101111001101"}, {"input": {"plaintext": "17SJfkZvLYfYEgbLs3l"}, "output": "0000000100100011110101000101011011101111110111110111100010011110101010111100"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "buy1/HuffmanCompression", "path": "/huffman.py", "msgidx": 5644}}
{"problem_description": "Given a set of unique digits, what is the specific permutation of these digits that appears at a certain position when all possible permutations are arranged in lexicographic order?", "io_requirements": "Input:\n  `digits` (str): A comma-separated string of integers representing the digits to be permuted.\n  `n` (str): A string representing the position of the permutation to be found, starting from 0.\n\nOutput:\n  `return` (str): A string representing the nth permutation of the given digits.", "refcode": "# import necessary packages\nfrom math import factorial\n\n# all class and function definitions in the code file, if any\ndef create_all_permutations(digits):\n    if len(digits) == 1:\n        return [str(digits[0])]\n    permutations = []\n    for i in range(0, len(digits)):\n        starting_digit = digits[i]\n        other_digits = [x for x in digits if x != starting_digit]\n        remaining_permutations = create_all_permutations(other_digits)\n        for i in range(0, len(remaining_permutations)):\n            remaining_permutations[i] = str(starting_digit) + remaining_permutations[i]\n        permutations.extend(remaining_permutations)\n    return permutations\n\ndef create_nth_permutation(digits, n):\n    counter = 0\n    for i in range(0, len(digits)):\n        starting_digit = digits[i]\n        remaining_permutations = factorial(len(digits) - 1)\n        if counter + remaining_permutations > n - 1:\n            difference = n - counter\n            if len(digits) > 5:\n                other_digits = [x for x in digits if x != starting_digit]\n                return str(starting_digit) + create_nth_permutation(other_digits, difference)\n            else:\n                perms = create_all_permutations(digits)\n                return perms[counter + difference]\n        else:\n            counter += remaining_permutations\n\n# main function\ndef main_solution(digits, n):\n    # Convert input to the required format\n    digits = list(map(int, digits.split(',')))\n    n = int(n)\n    \n    # Call the function to get the nth permutation\n    result = create_nth_permutation(digits, n)\n    \n    # Return the result as a string\n    return result", "funcname": "main_solution", "ios": [{"input": {"digits": "9,2,5", "n": "5"}, "output": "529"}, {"input": {"digits": "7,4,5,8,9", "n": "95"}, "output": "89547"}, {"input": {"digits": "4,3", "n": "1"}, "output": "34"}, {"input": {"digits": "8,5", "n": "1"}, "output": "58"}, {"input": {"digits": "4,9,5,3", "n": "7"}, "output": "9435"}, {"input": {"digits": "0,2,4,1", "n": "0"}, "output": "0241"}, {"input": {"digits": "9,0", "n": "1"}, "output": "09"}, {"input": {"digits": "6,0,1,8,2,3,5,9", "n": "29719"}, "output": "39021658"}, {"input": {"digits": "2,6,4,1,3,7,0,5", "n": "35114"}, "output": "05312467"}, {"input": {"digits": "5,7,1,3,9,4,8,0", "n": "33364"}, "output": "89157034"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "LangdalP/EulerCode", "path": "/Problem1-24/Problem024/peder.py", "msgidx": 728}}
{"problem_description": "Given a binary tree with unique integer values ranging from 1 to 100, and two distinct node values `x` and `y`, determine whether the nodes corresponding to `x` and `y` are cousins. In a binary tree, two nodes are cousins if they are at the same depth but have different parents. What is the result of this check?", "io_requirements": "Input:\n  `tree_list` (list of integers or None): A list representing the binary tree in level order traversal. `None` represents a missing node.\n  `x` (int): The value of the first node to check for cousin relationship.\n  `y` (int): The value of the second node to check for cousin relationship.\n\nOutput:\n  `return` (bool): `True` if the nodes corresponding to `x` and `y` are cousins, otherwise `False`.", "refcode": "# import necessary packages\nimport json\nfrom collections import deque\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Function to convert a list to a binary tree\ndef list_to_tree(lst):\n    if not lst:\n        return None\n    root = TreeNode(lst[0])\n    queue = deque([root])\n    i = 1\n    while queue and i < len(lst):\n        node = queue.popleft()\n        if lst[i] is not None:\n            node.left = TreeNode(lst[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(lst) and lst[i] is not None:\n            node.right = TreeNode(lst[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\n# main function\ndef main_solution(tree_list, x, y):\n    # Convert the JSON serializable input to the original input variables\n    root = list_to_tree(tree_list)\n    \n    # Solution function\n    def isCousins(root, x, y):\n        xval = []\n        yval = []\n        dep = 0\n        par = None\n        if root is None:\n            return False\n\n        def sfd(root, x, y, dep, par, xval, yval):\n            if root is None:\n                return None\n            if root.val == x:\n                xval.append((dep, par))\n            if root.val == y:\n                yval.append((dep, par))\n\n            sfd(root.left, x, y, dep + 1, root, xval, yval)\n            sfd(root.right, x, y, dep + 1, root, xval, yval)\n\n        sfd(root, x, y, 0, None, xval, yval)\n        return xval[0][0] == yval[0][0] and xval[0][1] != yval[0][1]\n\n    # Return the result of the solution function\n    return isCousins(root, x, y)", "funcname": "main_solution", "ios": [{"input": {"tree_list": [92, 60, 79, 45, 42, 17, 69, 68, 77, 61, 34, 47, 81, 2, null], "x": 42, "y": 60}, "output": false}, {"input": {"tree_list": [81, 8, 85, 19, null], "x": 85, "y": 81}, "output": false}, {"input": {"tree_list": [40, 8, 88, 95, 50, 52, 57, 33, null], "x": 40, "y": 8}, "output": false}, {"input": {"tree_list": [43, 94, 84, 63, 98, 48, 30], "x": 63, "y": 30}, "output": true}, {"input": {"tree_list": [20, 96, 71, 57, 56, 60, 22], "x": 96, "y": 56}, "output": false}, {"input": {"tree_list": [25, 44, 58, 36, 66, 28, 74, 98, 61, 88, 63, 5, null], "x": 63, "y": 28}, "output": false}, {"input": {"tree_list": [93, 3, 5, 2, null], "x": 93, "y": 5}, "output": false}, {"input": {"tree_list": [64, 27, 7, 69, 72, 81, 52, 45, 9, 1, 30, 50, 42], "x": 45, "y": 42}, "output": true}, {"input": {"tree_list": [24, 50, 43, 22, 82, 52, 71, 40, 6, 49, 21, 84, 35, 78, null], "x": 71, "y": 24}, "output": false}, {"input": {"tree_list": [78, 51, 90, 52, 46, 87, 30, 98, 41, 93, null], "x": 87, "y": 98}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "adityachhajer/LeetCode-may-challenge2020", "path": "/day7_CousinsinBinaryTree.py", "msgidx": 3303}}
{"problem_description": "Given a grid with obstacles, a starting point, and an ending point, what is the shortest path from the starting point to the ending point, avoiding all obstacles? The grid is represented as a 2D matrix where `0` indicates a free cell and `-1` indicates an obstacle. The path should be described in the format `\"[start_row][start_col]--->[next_row][next_col]--->...--->[end_row][end_col]\"`.", "io_requirements": "Input:\n- `matrix_str` (str): A string representation of a 2D list (list of lists) representing the matrix. The matrix should contain integers where `0` represents a free cell and `-1` represents an obstacle.\n- `start_row` (int): The row index of the starting point.\n- `start_col` (int): The column index of the starting point.\n- `end_row` (int): The row index of the ending point.\n- `end_col` (int): The column index of the ending point.\n\nOutput:\n- `return` (str): A string representing the shortest path from the starting point to the ending point in the format `\"[start_row][start_col]--->[next_row][next_col]--->...--->[end_row][end_col]\"`.", "refcode": "import numpy as np\n\ndef perception(matrix, row, col):\n    array = np.array([False, False, False, False])\n    superiorBorder = 0\n    inferiorBorder = matrix.shape[0] - 1\n    leftBorder = 0\n    rightBorder = matrix.shape[1] - 1\n    \n    up = row - 1\n    down = row + 1\n    left = col - 1\n    right = col + 1\n    \n    if up >= superiorBorder and matrix[up][col] == 0:\n        array[0] = True\n    if down <= inferiorBorder and matrix[down][col] == 0:\n        array[1] = True\n    if left >= leftBorder and matrix[row][left] == 0:\n        array[2] = True\n    if right <= rightBorder and matrix[row][right] == 0:\n        array[3] = True\n    return array\n\ndef updateMatrix(matrix, row, col):\n    perceptionArray = perception(matrix, row, col)\n    up = row - 1\n    down = row + 1\n    left = col - 1\n    right = col + 1\n    list = []\n\n    if perceptionArray[0]:\n        matrix[up][col] = matrix[row][col] + 1\n        list.append(up)\n        list.append(col)\n    if perceptionArray[1]:\n        matrix[down][col] = matrix[row][col] + 1\n        list.append(down)\n        list.append(col)\n    if perceptionArray[2]:\n        matrix[row][left] = matrix[row][col] + 1\n        list.append(row)\n        list.append(left)\n    if perceptionArray[3]:\n        matrix[row][right] = matrix[row][col] + 1\n        list.append(row)\n        list.append(right)\n\n    return list\n\ndef completeCoefficientsMatrix(matrix, rowGoal, colGoal):\n    nuevosPunto = updateMatrix(matrix, rowGoal, colGoal)\n    while len(nuevosPunto) > 0:\n        row = nuevosPunto.pop(0)\n        col = nuevosPunto.pop(0)\n        nuevosPunto.extend(updateMatrix(matrix, row, col))\n\ndef main_solution(matrix_str, start_row, start_col, end_row, end_col):\n    matrix = np.array(eval(matrix_str))\n    completeCoefficientsMatrix(matrix, end_row, end_col)\n    \n    currentRow = start_row\n    currentCol = start_col\n    superiorBorder = 0\n    inferiorBorder = matrix.shape[0] - 1\n    leftBorder = 0\n    rightBorder = matrix.shape[1] - 1\n    \n    path = f\"[{start_row}][{start_col}]\"\n    count = matrix[start_row][start_col]\n    \n    while count != 1:\n        if currentRow - 1 >= superiorBorder and matrix[currentRow - 1][currentCol] == matrix[currentRow][currentCol] - 1:\n            currentRow -= 1\n            path += f\"--->[{currentRow}][{currentCol}]\"\n            count -= 1\n            continue\n        if currentRow + 1 <= inferiorBorder and matrix[currentRow + 1][currentCol] == matrix[currentRow][currentCol] - 1:\n            currentRow += 1\n            path += f\"--->[{currentRow}][{currentCol}]\"\n            count -= 1\n            continue\n        if currentCol - 1 >= leftBorder and matrix[currentRow][currentCol - 1] == matrix[currentRow][currentCol] - 1:\n            currentCol -= 1\n            path += f\"--->[{currentRow}][{currentCol}]\"\n            count -= 1\n            continue\n        if currentCol + 1 <= rightBorder and matrix[currentRow][currentCol + 1] == matrix[currentRow][currentCol] - 1:\n            currentCol += 1\n            path += f\"--->[{currentRow}][{currentCol}]\"\n            count -= 1\n            continue\n    \n    return path", "funcname": "main_solution", "ios": [{"input": {"matrix_str": "[[-1, 0, 0, -1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, -1, 0, -1, 0]]", "start_row": 0, "start_col": 2, "end_row": 2, "end_col": 3}, "output": "[0][2]--->[1][2]--->[2][2]"}, {"input": {"matrix_str": "[[-1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, -1, -1, 0, 0]]", "start_row": 3, "start_col": 4, "end_row": 2, "end_col": 2}, "output": "[3][4]--->[2][4]--->[2][3]"}, {"input": {"matrix_str": "[[0, 0, 0], [-1, 0, 0], [-1, 0, 0]]", "start_row": 0, "start_col": 0, "end_row": 1, "end_col": 0}, "output": "[0][0]--->[0][1]"}, {"input": {"matrix_str": "[[0, 0, 0, -1, 0], [0, 0, 0, 0, 0], [0, 0, -1, 0, 0], [0, -1, 0, 0, 0], [0, 0, 0, -1, 0]]", "start_row": 1, "start_col": 2, "end_row": 3, "end_col": 3}, "output": "[1][2]--->[1][3]--->[2][3]"}, {"input": {"matrix_str": "[[-1, -1, 0, 0, 0], [0, 0, 0, 0, -1], [0, 0, 0, 0, 0]]", "start_row": 0, "start_col": 2, "end_row": 0, "end_col": 3}, "output": "[0][2]"}, {"input": {"matrix_str": "[[-1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]", "start_row": 4, "start_col": 0, "end_row": 2, "end_col": 0}, "output": "[4][0]--->[3][0]"}, {"input": {"matrix_str": "[[0, -1, 0, 0], [0, 0, 0, 0], [0, -1, 0, -1]]", "start_row": 2, "start_col": 0, "end_row": 2, "end_col": 2}, "output": "[2][0]--->[1][0]--->[1][1]--->[1][2]"}, {"input": {"matrix_str": "[[0, 0, 0, 0], [0, 0, 0, 0], [-1, 0, 0, 0], [0, 0, 0, 0]]", "start_row": 3, "start_col": 2, "end_row": 0, "end_col": 0}, "output": "[3][2]--->[2][2]--->[1][2]--->[0][2]--->[0][1]"}, {"input": {"matrix_str": "[[0, 0, 0, 0, -1], [0, 0, 0, -1, 0], [0, 0, -1, -1, 0], [0, 0, 0, -1, -1], [0, -1, 0, 0, -1]]", "start_row": 4, "start_col": 2, "end_row": 4, "end_col": 0}, "output": "[4][2]--->[3][2]--->[3][1]--->[3][0]"}, {"input": {"matrix_str": "[[-1, 0, 0, 0, 0, 0], [0, 0, 0, 0, -1, 0], [0, 0, 0, 0, 0, 0]]", "start_row": 1, "start_col": 5, "end_row": 2, "end_col": 5}, "output": "[1][5]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "johnj-hernandez/WaveFront", "path": "/waveFront.py", "msgidx": 3661}}
{"problem_description": "Given a tree structure represented by a dictionary where each key is a node and its value is a list of child nodes, and a leaf node from which to find the root, what is the root node, the distance from the leaf to the root, and the path from the leaf to the root?", "io_requirements": "Input:\n  `tree` (dict): A dictionary representing the tree structure where each key is a node and its value is a list of child nodes. The keys and values are strings.\n  `leaf` (str): A string representing the leaf node from which to find the root.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `root` (str): The root node found.\n    - `distance` (int): The distance from the leaf to the root.\n    - `path` (list of str): The path from the leaf to the root, represented as a list of node names.", "refcode": "# import necessary packages\nimport types\n\n# all class and function definitions in the code file, if any\ndef fact_iter(num, product=1):\n    if num == 1:\n        yield product\n    yield fact_iter(num - 1, num * product)\n\ndef tramp(gen, *args, **kwargs):\n    g = gen(*args, **kwargs)\n    while isinstance(g, types.GeneratorType):\n        g = g.__next__()\n    return g\n\ndef find_root(tree, leaf, path=None):\n    if path is None:\n        path = []\n    root = leaf\n    if root in tree:\n        for root in tree[root]:\n            path.append(root)\n            yield from find_root(tree, root, path)\n    else:\n        yield root, len(path), path\n\n# main function\ndef main_solution(tree, leaf):\n    # Convert input to JSON serializable format if necessary\n    tree = {str(k): [str(v) for v in vs] for k, vs in tree.items()}\n    leaf = str(leaf)\n    \n    # Call the core function\n    result = next(find_root(tree, leaf))\n    \n    # Convert output to JSON serializable format\n    return {\n        \"root\": str(result[0]),\n        \"distance\": result[1],\n        \"path\": [str(p) for p in result[2]]\n    }", "funcname": "main_solution", "ios": [{"input": {"tree": {"0": ["4"], "1": ["1", "4"], "2": ["4", "2"]}, "leaf": "4"}, "output": {"root": "4", "distance": 0, "path": []}}, {"input": {"tree": {"3": ["2", "3", "0"]}, "leaf": "4"}, "output": {"root": "4", "distance": 0, "path": []}}, {"input": {"tree": {"2": ["6", "1", "4"]}, "leaf": "3"}, "output": {"root": "3", "distance": 0, "path": []}}, {"input": {"tree": {"0": ["0"], "2": ["1"]}, "leaf": "2"}, "output": {"root": "1", "distance": 1, "path": ["1"]}}, {"input": {"tree": {"5": ["4", "2", "1"]}, "leaf": "3"}, "output": {"root": "3", "distance": 0, "path": []}}, {"input": {"tree": {}, "leaf": "4"}, "output": {"root": "4", "distance": 0, "path": []}}, {"input": {"tree": {"2": ["5", "3", "4"], "7": ["5", "2"]}, "leaf": "5"}, "output": {"root": "5", "distance": 0, "path": []}}, {"input": {"tree": {"2": ["4", "1", "3"]}, "leaf": "4"}, "output": {"root": "4", "distance": 0, "path": []}}, {"input": {"tree": {"2": ["3"], "6": ["1"]}, "leaf": "6"}, "output": {"root": "1", "distance": 1, "path": ["1"]}}, {"input": {"tree": {"0": ["0"], "1": ["1"]}, "leaf": "3"}, "output": {"root": "3", "distance": 0, "path": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gudeqing/biodev", "path": "/\u9012\u5f52\u5426.py", "msgidx": 4699}}
{"problem_description": "Given two maps represented by 2D matrices, where each element is either 0 (water) or 1 (land), how many islands are present in both maps? An island is defined as a group of connected land cells (1s) in a map, where connectivity is defined as horizontal or vertical adjacency.", "io_requirements": "Input:\n  `a` (List[List[int]]): A 2D list representing the first map where each element is either 0 (water) or 1 (land).\n  `b` (List[List[int]]): A 2D list representing the second map where each element is either 0 (water) or 1 (land).\n\nOutput:\n  `return` (int): The number of islands that are present in both maps `a` and `b`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solve(self, a: List[List[int]], b: List[List[int]]) -> int:\n        def getHashOfIslands(grid: List[List[int]]) -> List[str]:\n            \"\"\"\u83b7\u53d6\u77e9\u9635\u4e2d\u5404\u4e2a\u5c9b\u5c7f\u7684\u54c8\u5e0c\u503c\"\"\"\n\n            def dfs(r: int, c: int, path: List[str]) -> None:\n                if visited[r][c]:\n                    return\n\n                visited[r][c] = True\n                dirs = [(r, c + 1), (r + 1, c), (r, c - 1), (r - 1, c)]\n                for i in range(4):\n                    nr, nc = dirs[i]\n                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 1:\n                        path.append(str(i + 1))\n                        dfs(nr, nc, path)\n\n            row, col = len(grid), len(grid[0])\n            visited = [[False for _ in range(col)] for _ in range(row)]\n\n            res = []\n            for r in range(row):\n                for c in range(col):\n                    if grid[r][c] == 1 and not visited[r][c]:\n                        path = []\n                        dfs(r, c, path)\n                        path.extend(['_', str(r), '_', str(c)])\n                        res.append(''.join(path))\n\n            return res\n\n        s1, s2 = getHashOfIslands(a), getHashOfIslands(b)\n        return len(set(s1) & set(s2))\n\n# main function\ndef main_solution(a: List[List[int]], b: List[List[int]]) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.solve(a, b)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"a": [[1, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1]], "b": [[1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "981377660LMT/algorithm-study", "path": "/7_graph/\u7ecf\u5178\u9898/\u91cd\u53e0\u5c9b\u5c7f\u7684\u6570\u91cf-\u8ba1\u7b97\u5c9b\u5c7f\u7684\u54c8\u5e0c\u503c.py", "msgidx": 4375}}
{"problem_description": "Given a spiral pattern formed by wrapping numbers around a central point, where the numbers increase as the spiral grows, we are interested in the ratio of prime numbers along the diagonals of this spiral. Starting from a 1x1 spiral and growing it outward, at what side length of the square spiral does the ratio of prime numbers along both diagonals first fall below a specified threshold?", "io_requirements": "Input:\n  `target_ratio` (float): The target ratio of primes along both diagonals that should be the threshold for stopping the spiral growth. It should be a value between 0 and 1.\n\nOutput:\n  `return` (dict): A dictionary containing the key `side_length` which is an integer representing the side length of the square spiral when the ratio of primes along both diagonals first falls below the `target_ratio`.", "refcode": "# import necessary packages\nimport math\n\n# Function to check if a number is prime\ndef is_prime(number):\n    if number < 0:\n        return 0\n    elif number == 2 or number == 3:\n        return 1\n    elif number % 2 == 0 or number % 3 == 0 or number == 1:\n        return 0\n    else:\n        start = 5\n        while start <= int(math.sqrt(number)):\n            if number % start == 0:\n                return 0\n            if number % (start + 2) == 0:\n                return 0\n            start += 6\n        return 1\n\n# main function\ndef main_solution(target_ratio):\n    num = 1\n    step = 2\n    dia = 1\n    prime_count = 0\n\n    while True:\n        for i in range(4):\n            num += step\n            if is_prime(num):\n                prime_count += 1\n        dia += 4\n        current_ratio = prime_count * 1.0 / dia\n        if current_ratio < target_ratio:\n            break\n        step += 2\n\n    # Return the side length of the square spiral\n    return {\"side_length\": step + 1}", "funcname": "main_solution", "ios": [{"input": {"target_ratio": 0.2892539418793769}, "output": {"side_length": 49}}, {"input": {"target_ratio": 0.37018672690510956}, "output": {"side_length": 33}}, {"input": {"target_ratio": 0.15286729470260885}, "output": {"side_length": 885}}, {"input": {"target_ratio": 0.28684136804598104}, "output": {"side_length": 53}}, {"input": {"target_ratio": 0.18459699482329622}, "output": {"side_length": 375}}, {"input": {"target_ratio": 0.26401584252988985}, "output": {"side_length": 87}}, {"input": {"target_ratio": 0.31429621853791073}, "output": {"side_length": 47}}, {"input": {"target_ratio": 0.3443784579841867}, "output": {"side_length": 37}}, {"input": {"target_ratio": 0.2059766550266439}, "output": {"side_length": 275}}, {"input": {"target_ratio": 0.4370344340846618}, "output": {"side_length": 19}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vivekpabani/projecteuler", "path": "/python/058/problem_058.py", "msgidx": 5226}}
{"problem_description": "Given a chessboard of size `n` x `n`, how can you place `n` queens on the board such that no two queens threaten each other? Each solution should be represented as a configuration of the chessboard where 'Q' indicates the position of a queen and '.' indicates an empty space. What are all possible configurations for the given size `n`?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of all possible solutions to the N-Queens problem. Each solution is represented as a list of strings, where each string represents a row of the chessboard. 'Q' indicates the position of a queen, and '.' indicates an empty space.", "refcode": "# import necessary packages\nfrom copy import deepcopy\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def backtracking(self, grid, row, n, result):\n        if row == n:\n            temp = deepcopy(grid)\n            for i in range(n):\n                temp[i] = \"\".join(temp[i])\n            result.append(temp)\n            return\n        else:\n            def checkValid(row, i):\n                #check current col i\n                for j in range(row-1,-1,-1):\n                    if grid[j][i] == 'Q':\n                        return False\n\n                #check diagonal\n                k=1\n                for j in range(row-1,-1,-1):\n                    if i+k < n and grid[j][i+k] == 'Q':\n                        return False\n                    if i-k >=0 and grid[j][i-k] == 'Q':\n                        return False\n                    k+=1\n\n                return True\n\n\n            for i in range(n):\n                if checkValid(row,i):\n                    grid[row][i] = 'Q'\n                    self.backtracking(grid, row+1, n, result)\n                    grid[row][i] = '.'\n\n        \n    def solveNQueens(self, n: int) -> List[List[str]]:\n        if not n:\n            return []\n        \n        result = []\n        grid = [['.'] * n for _ in range(n)]\n        \n        self.backtracking(grid, 0, n, result)\n        \n        return result\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": [["Q"]]}, {"input": {"n": 3}, "output": []}, {"input": {"n": 2}, "output": []}, {"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yukai-chiu/CodingPractice", "path": "/LeetCode/Problems/Python/51. N-Queens.py", "msgidx": 5398}}
{"problem_description": "In a seating system, seats can be either empty (`'L'`), occupied (`'#'`), or floor (`'.'`). The system evolves based on specific rules. For part 1, a seat becomes occupied if it is empty and all adjacent seats are empty. For part 2, a seat becomes occupied if it is empty and all visible seats in all eight directions are empty. Given an initial seating arrangement and the part of the problem to solve, how many seats will be occupied when the seating system stabilizes?", "io_requirements": "Input:\n  `initial_seating` (List[str]): A list of strings representing the initial seating arrangement. Each string represents a row of seats, where each character can be `'.'` (floor), `'L'` (empty seat), or `'#'` (occupied seat).\n  `part` (int): An integer indicating the part of the problem to solve. `1` for part 1 and `2` for part 2.\n\nOutput:\n  `return` (int): The number of occupied seats (`'#'`) after the seating system stabilizes.", "refcode": "# import necessary packages\nfrom typing import List\nfrom copy import copy\n\n# Constants\nFLOOR = '.'\nEMPTY = 'L'\nOCCUPIED = '#'\ndirections = [(x, y) for x in {-1, 0, 1} for y in {-1, 0, 1} if (x != 0 or y != 0)]\n\n# Function to get adjacent seats\ndef get_adjacent_seats(inp: List[str], coord: List[int]) -> List[str]:\n    res = []\n    for dx, dy in directions:\n        x, y = coord[0] + dx, coord[1] + dy\n        if (x in range(len(inp[0]))) and (y in range(len(inp))):\n            res.append(inp[y][x])\n    return res\n\n# Function to get first seats seen\ndef get_first_seats_seen(inp: List[str], coord: List[int]) -> List[str]:\n    res = []\n    for dx, dy in directions:\n        x, y = coord\n        while True:\n            x += dx\n            y += dy\n            if (x not in range(len(inp[0]))) or (y not in range(len(inp))):\n                break\n            if (inp[y][x] == FLOOR):\n                continue\n            res.append(inp[y][x])\n            break\n    return res\n\n# Function to simulate a cycle\ndef simulate_cycle(inp: List[str], is_part1: bool) -> List[str]:\n    new = []\n    max_adjacent = 4 if is_part1 else 5\n    for y in range(len(inp)):\n        row = ''\n        for x in range(len(inp[0])):\n            seat = inp[y][x]\n            if is_part1:\n                adjacent_seats = get_adjacent_seats(inp, [x, y])\n            else:\n                adjacent_seats = get_first_seats_seen(inp, [x, y])\n            if (seat == EMPTY) and (OCCUPIED not in adjacent_seats):\n                row += OCCUPIED\n            elif (seat == OCCUPIED) and (adjacent_seats.count(OCCUPIED) >= max_adjacent):\n                row += EMPTY\n            else:\n                row += seat\n        new.append(row)\n    return new\n\n# Main solution function\ndef main_solution(initial_seating: List[str], part: int) -> int:\n    curr = copy(initial_seating)\n    is_part1 = part == 1\n    while True:\n        new = simulate_cycle(curr, is_part1)\n        if curr == new:\n            break\n        curr = new\n    return ''.join(new).count(OCCUPIED)", "funcname": "main_solution", "ios": [{"input": {"initial_seating": ["##.LL#.", "L..#L.L", "#.L#..#", "#..#.#L", "L..###.", "L#..L##", ".LL...."], "part": 2}, "output": 11}, {"input": {"initial_seating": [".LL...LL#", ".L#.....L", "#LL..L###", "#L#LLL.L#", "#.....#..", "#.L#LLL..", "##LLL..L."], "part": 2}, "output": 16}, {"input": {"initial_seating": ["L..L.##.L", "L.##..#.#", "#.##.LLL#", ".L##.LL..", "###.##L#.", "#...#LLLL", "..L#L..L#"], "part": 1}, "output": 18}, {"input": {"initial_seating": ["L##L.#L##L", ".LLL.L.##.", "#L..L#.LL.", ".L.###.#L#", "..L#L#LL#L", "LLL.L##L.L", "L#L...L..#", "L.L..LL#LL"], "part": 2}, "output": 20}, {"input": {"initial_seating": ["LL.##", "####.", "##L.L", "LL#L.", "#.LL#", ".LL#.", "LL##."], "part": 2}, "output": 13}, {"input": {"initial_seating": [".##LLL#LL#", "L#L.L..###", "#.#L....#.", "L.##.#..LL", "L#.L#L...."], "part": 1}, "output": 16}, {"input": {"initial_seating": ["##.#LL##", "LL##LL#L", "..#..L#.", ".##.L.LL", "...L#.##"], "part": 2}, "output": 14}, {"input": {"initial_seating": ["L###...L.L", "#..#.##L#.", ".L....#L.#", ".....#L.L#", "L.#L.#L#.L", ".#.###.#.#", ".LLLL.###.", "L#L..#..#L"], "part": 2}, "output": 20}, {"input": {"initial_seating": ["L#.#...L.L", ".L.L.#..#.", ".LL..#L##.", "##LL#LL..L", "##L.#L#.L.", "....LL..#.", "L#LL#LLL#L", "L.L.L##L.L"], "part": 2}, "output": 20}, {"input": {"initial_seating": ["#.LL.", "LL#..", "...L.", "#.L..", "#L..L", "L#L##", "...L#"], "part": 2}, "output": 8}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zenyichong/advent-of-code-2020", "path": "/day_11/day_11.py", "msgidx": 5505}}
{"problem_description": "Given a k-ary tree, where each node can have up to k children, determine whether the tree is symmetric. A tree is symmetric if its data and shape remain unchanged when it is reflected about the root node. What is the result of checking if the given k-ary tree is symmetric?", "io_requirements": "Input:\n  `tree_data` (list): A list representing the k-ary tree. The first element is the root node's data, and the second element is a list of lists, where each sublist represents the data of the children nodes. If a child node is None, it indicates that the corresponding child position is empty.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the k-ary tree is symmetric.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data: int, k: int):\n        self.data = data\n        if k < 0:\n            raise ValueError(\"k must be >= 0\")\n        self.k = k\n        self.children = [None] * k\n\n    def add(self, index: int, data: int):\n        if index >= 0 and index < self.k:\n            self.children[index] = Node(data, self.k)\n        else:\n            msg = \"Invalid index: \" + str(index)\n            raise IndexError(msg)\n\n    def remove(self, index: int):\n        if index >= 0 and index < self.k:\n            self.children[index] = None\n        else:\n            msg = \"Invalid index: \" + str(index)\n            raise IndexError(msg)\n\n    def get_child_data(self):\n        ret = []\n        for child in self.children:\n            if not child is None:\n                ret.append(child.data)\n            else:\n                ret.append(None)\n        return ret\n\n# main function\ndef main_solution(tree_data: list):\n    # Convert JSON serializable input to the original input variables\n    def build_tree(data: list, k: int):\n        if not data:\n            return None\n        node = Node(data[0], k)\n        for i, child_data in enumerate(data[1]):\n            if child_data is not None:\n                node.children[i] = build_tree(child_data, k)\n        return node\n\n    k = len(tree_data[1])\n    tree = build_tree(tree_data, k)\n\n    # Function to check if the tree is symmetric\n    def is_symmetric(tree: Node):\n        odds = []\n        evens = []\n        k = tree.k\n        is_odd = k % 2 == 1\n\n        def helper(node: Node):\n            nonlocal odds, evens, k, is_odd\n\n            for i in range(k):\n                if i == k // 2:\n                    evens.append(node.data)\n                    if is_odd:\n                        if not node.children[i] is None:\n                            helper(node.children[i])\n                            odds.append(node.children[i].data)\n                        else:\n                            odds.append(None)\n                        continue\n                if not node.children[i] is None:\n                    helper(node.children[i])\n                else:\n                    evens.append(None)\n\n        helper(tree)\n        len_odds = len(odds)\n        len_evens = len(evens)\n\n        mid = len_odds // 2\n        if len_odds % 2 == 1:\n            first = odds[:mid]\n            second = list(reversed(odds[mid + 1:]))\n            if first != second:\n                return False\n        else:\n            first = odds[:mid]\n            second = list(reversed(odds[mid:]))\n            if first != second:\n                return False\n\n        mid = len_evens // 2\n        if len_evens % 2 == 1:\n            first = evens[:mid]\n            second = list(reversed(evens[mid + 1:]))\n            if first != second:\n                return False\n        else:\n            first = evens[:mid]\n            second = list(reversed(evens[mid:]))\n            if first != second:\n                return False\n\n        return True\n\n    # Return the result of the is_symmetric function\n    return is_symmetric(tree)", "funcname": "main_solution", "ios": [{"input": {"tree_data": [78, [null, null]]}, "output": true}, {"input": {"tree_data": [22, [null, null]]}, "output": true}, {"input": {"tree_data": [78, [null, [33, [null, [97, [null, null, null]], null]], null]]}, "output": false}, {"input": {"tree_data": [42, [null, [33, [[60, [null, null, null]], null, null]], null]]}, "output": false}, {"input": {"tree_data": [23, [[28, [null, null, null, [98, [null, null, null, null, null]], null]], null, null, null, null]]}, "output": false}, {"input": {"tree_data": [88, [[28, [null, null]], null]]}, "output": false}, {"input": {"tree_data": [60, [null, [70, [null, null]]]]}, "output": false}, {"input": {"tree_data": [83, [[87, [null, null, null]], null, null]]}, "output": false}, {"input": {"tree_data": [73, [null, [63, [null, [12, [null, null]]]]]]}, "output": false}, {"input": {"tree_data": [73, [null, null]]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zstoebs/Daily-Coding-Problem", "path": "/January 2020/1-3-2020.py", "msgidx": 5591}}
{"problem_description": "Given a target sum, how can you arrange the numbers 1 through 9 with the operators +, -, or nothing between them to achieve the target sum?", "io_requirements": "Input:\n  `target_sum` (int): The target sum that the sequence of numbers should evaluate to. For example, if `target_sum` is 100, the function will find all sequences of numbers from 1 to 9 with operators (+, -, or nothing) that sum to 100.\n\nOutput:\n  `return` (list of str): A list of strings, where each string represents a valid sequence of numbers from 1 to 9 with operators (+, -, or nothing) that sum to the `target_sum`. Each string is formatted as \"1+2+34-5+67-8+9 = 100\".", "refcode": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(target_sum):\n    results, numbers = [], range(1, 10)\n    for permutation in product(['+', '-', ''], repeat=8):\n        tuples = zip(numbers, permutation + ('', ))\n        sequence = ''.join([str(e1) + e2 for (e1, e2) in tuples])\n        if eval(sequence) == target_sum:\n            results.append(sequence + f' = {target_sum}')\n    return results", "funcname": "main_solution", "ios": [{"input": {"target_sum": 148}, "output": ["1+2+3+4+56-7+89 = 148", "1+2-3-4+56+7+89 = 148", "12+3+45+6-7+89 = 148", "12-3-4+56+78+9 = 148", "123+4+5+6-7+8+9 = 148"]}, {"input": {"target_sum": 150}, "output": ["1+23+45-6+78+9 = 150", "1+234+5+6-7-89 = 150", "1-2+3-4+56+7+89 = 150", "12+3+45-6+7+89 = 150", "123+4+5-6+7+8+9 = 150", "123+45+6-7-8-9 = 150", "123-4-56+78+9 = 150"]}, {"input": {"target_sum": 112}, "output": ["1+2-34+56+78+9 = 112", "1-2+34-5+67+8+9 = 112", "1-23-4+56-7+89 = 112", "12+3+4+5+6-7+89 = 112", "12+34+56-7+8+9 = 112", "12-3-4+5+6+7+89 = 112", "123-4+5-6-7-8+9 = 112", "123-4-5+6-7+8-9 = 112"]}, {"input": {"target_sum": 95}, "output": ["1+2+3+4-5-6+7+89 = 95", "1+2+3-4+5+6-7+89 = 95", "1+2+34-5-6+78-9 = 95", "1+2-3+45+67-8-9 = 95", "1-2+3+4+5+67+8+9 = 95", "1-2+3-4-5+6+7+89 = 95", "1-2+34+56+7+8-9 = 95", "1-2-3+4+5-6+7+89 = 95", "12+3+4-5-6+78+9 = 95", "123+4-56+7+8+9 = 95"]}, {"input": {"target_sum": 86}, "output": ["1+2+3+4-5-6+78+9 = 86", "1+23+4-5-6+78-9 = 86", "1+23-4+56-7+8+9 = 86", "1-2+3+4+5+6+78-9 = 86", "1-2+3+4+56+7+8+9 = 86", "1-2+3-4-5+6+78+9 = 86", "1-2-3+4+5-6+78+9 = 86", "1-23+45-6+78-9 = 86", "12+34-56+7+89 = 86", "12-3+4+5+67-8+9 = 86", "12-3-4+5-6-7+89 = 86"]}, {"input": {"target_sum": 102}, "output": ["1+2-3+4+5+6+78+9 = 102", "12+3+4-5+6-7+89 = 102", "12-3+4+5+67+8+9 = 102", "12-3-4-5+6+7+89 = 102", "123+4+5-6-7-8-9 = 102", "123+45-67-8+9 = 102", "123-4+5+67-89 = 102", "123-4-5-6-7-8+9 = 102"]}, {"input": {"target_sum": 128}, "output": ["1+234-5-6-7-89 = 128", "1-2+3+45-6+78+9 = 128", "1-2+34+5-6+7+89 = 128", "12+3+45+67-8+9 = 128", "123+4+5+6+7-8-9 = 128", "123-4+5-6-7+8+9 = 128", "123-4-5+6+7-8+9 = 128", "123-45+67-8-9 = 128"]}, {"input": {"target_sum": 103}, "output": ["1+2+3+4+5+6-7+89 = 103", "1+2+34+56-7+8+9 = 103", "1+2-3-4+5+6+7+89 = 103", "1+23-4-5+6-7+89 = 103", "1-2+3+4-5+6+7+89 = 103", "1-2+34-5+6+78-9 = 103", "1-2-34+56-7+89 = 103", "12-3-4+5+6+78+9 = 103", "12-34+56+78-9 = 103"]}, {"input": {"target_sum": 110}, "output": ["1+2+34+5+67-8+9 = 110", "1+234-56-78+9 = 110", "1-2+3+45-6+78-9 = 110", "12+3+45+67-8-9 = 110", "12+34+56+7-8+9 = 110", "12-3+4-5+6+7+89 = 110", "123+4+5+67-89 = 110", "123+4-5-6-7-8+9 = 110", "123-4+5-6-7+8-9 = 110", "123-4-5+6+7-8-9 = 110"]}, {"input": {"target_sum": 111}, "output": ["1+2-3+4+5+6+7+89 = 111", "1+2-3+45+67+8-9 = 111", "1+2-3-45+67+89 = 111", "1+23+4-5+6-7+89 = 111", "1-23+45+6-7+89 = 111", "12-3+4+5+6+78+9 = 111"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "iKonon/checkio", "path": "/less_than_one_hour/5_always100.py", "msgidx": 5558}}
{"problem_description": "Given a number, how many different ways can you express it as a sum of integers greater than or equal to 1?", "io_requirements": "Input:\n  `targetNumber` (int): The number for which the function will calculate the total number of ways to sum up to this number using integers greater than or equal to 1.\n\nOutput:\n  `return` (int): The total number of ways to sum up to `targetNumber` using integers greater than or equal to 1.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef f_print(x, y, d=0):\n    if x == 1 or x == 0:\n        return 1\n    total = 0\n    for i in range(1, min(x, y) + 1):\n        total += f_print(x - i, i, d + 1)\n    return total\n\ndef g(x):\n    return f_print(x, x)\n\n# main function\ndef main_solution(targetNumber):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = g(targetNumber)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"targetNumber": 6}, "output": 11}, {"input": {"targetNumber": 7}, "output": 15}, {"input": {"targetNumber": 8}, "output": 22}, {"input": {"targetNumber": 3}, "output": 3}, {"input": {"targetNumber": 1}, "output": 1}, {"input": {"targetNumber": 4}, "output": 5}, {"input": {"targetNumber": 2}, "output": 2}, {"input": {"targetNumber": 10}, "output": 42}, {"input": {"targetNumber": 5}, "output": 7}, {"input": {"targetNumber": 9}, "output": 30}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EdmundGoodman/partition-numbers", "path": "/outputPartitions.py", "msgidx": 5581}}
{"problem_description": "In a game, players aim to achieve a specific score by arranging numbers on a board. The board is represented as a square matrix filled with integers. A win condition is met if the product of any four consecutive numbers (either horizontally, vertically, or diagonally) equals the score raised to the power of 4. Given the current state of the game board and the target score, determine if the win condition is met.", "io_requirements": "Input:\n  `original_matrix` (list of lists of int): A 2D list representing the game board, where each element is an integer. The board is assumed to be a square matrix with a size of at least 4x4.\n  `score` (int): An integer representing the score to check for a win condition.\n\nOutput:\n  `return` (bool): A boolean value indicating whether a win condition is met (`True`) or not (`False`).", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\nclass GameChecker():\n    \"\"\"\n    Class Game Checker to check for scores and wins\n    \"\"\"\n\n    def __init__(self, original_matrix, score):\n        \"\"\"\n        Constructor to create game checker\n        :param original_matrix: current board state\n        :param score: score to check for\n        \"\"\"\n        self.original_matrix = original_matrix\n        self.score = score**4\n\n    @staticmethod\n    def slice_four(input_array):\n        \"\"\"\n        Function to chunk matrix into 4*4 chunks\n        :param input_array: list\n        :return: list of list\n        \"\"\"\n        result = []\n        for i in range(len(input_array)):\n            if len(input_array[i:i + 4]) == 4:\n                result.append(input_array[i:i + 4])\n        return result\n\n    @staticmethod\n    def calculate_product(input_list):\n        \"\"\"\n        Function to return score product of an array\n        :param input_list: list\n        :return: int\n        \"\"\"\n        return reduce(lambda x, y: x * y, input_list, 1)\n\n    def calculate_vertical(self, filtered_matrix):\n        \"\"\"\n        Function to check win on all vertical product\n        :param filtered_matrix: list\n        :return: bool\n        \"\"\"\n        column_product = [self.calculate_product(list(s)) for s in\n                          zip(*filtered_matrix)]\n        if sum(column_product) > 0:\n            for s in column_product:\n                if s == self.score:\n                    return True\n        return False\n\n    def calculate_horizontal(self, filtered_matrix):\n        \"\"\"\n        Function to check win on horizontal product\n        :param filtered_matrix: list\n        :return: bool\n        \"\"\"\n        for each_row in filtered_matrix:\n            single_row = self.slice_four(each_row)\n            for s in single_row:\n                if self.calculate_product(s) == self.score:\n                    return True\n        return False\n\n    def calculate_diagonal(self, filtered_matrix):\n        \"\"\"\n        Function to check win on diagonal product\n        :param filtered_matrix: list\n        :return: bool\n        \"\"\"\n        result = []\n        for i in range(3, len(filtered_matrix[0])):\n            start_row = 0\n            start_col = i\n            sub_array = []\n            for _ in range(4):\n                sub_array.append(filtered_matrix[start_row][start_col])\n                start_row += 1\n                start_col -= 1\n            result.append(sub_array)\n        for k in range(len(filtered_matrix[0]) - 4, -1, -1):\n            start_row = 0\n            start_col = k\n            sub_array = []\n            for _ in range(4):\n                sub_array.append(filtered_matrix[start_row][start_col])\n                start_row += 1\n                start_col += 1\n            result.append(sub_array)\n        for r in result:\n            if self.calculate_product(r) == self.score:\n                return True\n        return False\n\n    def check_matrix(self):\n        \"\"\"\n        Function to check win in all directions\n        :return: bool\n        \"\"\"\n        filter_matrix = [m for m in self.original_matrix if sum(m) > 0]\n        if len(filter_matrix) < 4:\n            # When the rows are not filled up to 4 rows\n            # only check horizontal\n            hor_result = self.calculate_horizontal(filter_matrix)\n            if hor_result:\n                return hor_result\n        else:\n            # when rows are more than 4 rows then check all\n            # directions\n            to_check = self.slice_four(self.original_matrix)\n            for sub_matrix in to_check:\n                vert_result = self.calculate_vertical(sub_matrix)\n                if vert_result:\n                    return True\n                hor_result = self.calculate_horizontal(sub_matrix)\n                if hor_result:\n                    return True\n                diag_result = self.calculate_diagonal(sub_matrix)\n                if diag_result:\n                    return True\n\n# main function\ndef main_solution(original_matrix, score):\n    \"\"\"\n    Function to check if a win condition is met in a game board.\n    :param original_matrix: list of lists, representing the game board.\n    :param score: int, the score to check for a win condition.\n    :return: bool, True if a win condition is met, False otherwise.\n    \"\"\"\n    game_checker = GameChecker(original_matrix, score)\n    return game_checker.check_matrix()", "funcname": "main_solution", "ios": [{"input": {"original_matrix": [[8, 4, 8, 1], [1, 8, 2, 8], [7, 0, 6, 1], [9, 4, 9, 0]], "score": 4}, "output": true}, {"input": {"original_matrix": [[4, 5, 2, 7], [4, 4, 2, 8], [3, 6, 4, 5], [8, 7, 3, 2]], "score": 4}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "minhchan11/mlh_code_sample", "path": "/game_checker.py", "msgidx": 4948}}
{"problem_description": "Given a rectangular piece of material with sides of lengths `x` and `y`, how many squares can be cut from it if each time a square of the largest possible size is cut from the remaining rectangle until no more squares can be cut?", "io_requirements": "Input:\n  `x` (int): The length of one side of the initial rectangle.\n  `y` (int): The length of the other side of the initial rectangle.\n\nOutput:\n  `return` (int): The total number of squares that can be cut from the initial rectangle.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(x, y):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = 0\n    while x != y:\n        if x > y:\n            x = x - y\n        else:\n            y = y - x\n        n += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return n + 1", "funcname": "main_solution", "ios": [{"input": {"x": 8017, "y": 5748}, "output": 89}, {"input": {"x": 9788, "y": 8888}, "output": 46}, {"input": {"x": 863, "y": 5011}, "output": 43}, {"input": {"x": 9025, "y": 9375}, "output": 33}, {"input": {"x": 4832, "y": 3009}, "output": 24}, {"input": {"x": 2129, "y": 3822}, "output": 23}, {"input": {"x": 4425, "y": 1052}, "output": 23}, {"input": {"x": 7066, "y": 2515}, "output": 130}, {"input": {"x": 3271, "y": 8050}, "output": 28}, {"input": {"x": 3255, "y": 2290}, "output": 18}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gschen/where2go-python-test", "path": "/1906101105\u77f3\u6d9b/\u84dd\u6865\u676f\u5bd2\u5047\u7ec3\u4e60/2019\u5e74java C\u7ec4/test2.py", "msgidx": 5751}}
{"problem_description": "In a game of Rock-Paper-Scissors, a player wants to determine their optimal strategy against an opponent who follows a known strategy. Given the number of iterations to train the model and the opponent's strategy, what is the computed average strategy for the player?", "io_requirements": "Input:\n- `iterations` (int): The number of iterations to train the model.\n- `opp_strategy` (list of float): The opponent's strategy represented as a list of probabilities for Rock, Paper, and Scissors respectively. The sum of the probabilities should be 1.\n\nOutput:\n- `return` (list of float): The computed average strategy for Rock, Paper, and Scissors respectively, represented as a list of probabilities.", "refcode": "# import necessary packages\nimport numpy as np\n\n# Constants\nROCK = 0\nPAPER = 1\nSCISSORS = 2\nNUM_ACTIONS = 3\n\n# Function to get the payoff matrix for Rock-Paper-Scissors\ndef getPayoffMatrix():\n    matrix = np.zeros((3, 3, 2))\n    for i in [ROCK, PAPER, SCISSORS]:\n        for j in [ROCK, PAPER, SCISSORS]:\n            if (i + 1) % 3 == j:\n                matrix[i, j, 0] = -1\n                matrix[i, j, 1] = 1\n            elif i == (j + 1) % 3:\n                matrix[i, j, 0] = 1\n                matrix[i, j, 1] = -1\n    return matrix\n\n# Function to get the strategy based on regret matching\ndef getStrategy(regretSum):\n    strategy = regretSum.copy()\n    strategy[strategy < 0] = 0\n    if strategy.sum() == 0:\n        strategy = np.ones(len(strategy)) / len(strategy)\n    else:\n        strategy = strategy / strategy.sum()\n    return strategy\n\n# Function to get an action based on the strategy\ndef getAction(strategy):\n    return np.random.choice(len(strategy), 1, p=strategy)[0]\n\n# Main function to compute the average strategy after training\ndef main_solution(iterations, opp_strategy):\n    # Convert JSON serializable inputs to original input variables\n    opp_strategy = np.array(opp_strategy)\n    \n    # Initialize variables\n    regretSum = np.zeros(NUM_ACTIONS)\n    strategySum = np.zeros(NUM_ACTIONS)\n    matrix = getPayoffMatrix()\n    actionUtility = np.zeros(NUM_ACTIONS)\n    \n    # Training loop\n    for _ in range(iterations):\n        strategy = getStrategy(regretSum)\n        myAction = getAction(strategy)\n        otherAction = getAction(opp_strategy)\n        actionUtility = matrix[:, otherAction, 0].reshape(NUM_ACTIONS,)\n        regrets = actionUtility - actionUtility[myAction]\n        regretSum += regrets\n        strategySum += strategy\n    \n    # Compute average strategy\n    avgStrategy = np.zeros(NUM_ACTIONS)\n    normalizationSum = strategySum.sum()\n    if normalizationSum > 0:\n        avgStrategy = strategySum / normalizationSum\n    else:\n        avgStrategy = 1.0 / normalizationSum\n    \n    # Convert output to JSON serializable\n    return avgStrategy.tolist()", "funcname": "main_solution", "ios": [{"input": {"iterations": 47609, "opp_strategy": [0.3756100345824185, 0.5719969093887142, 0.052393056028867464]}, "output": [4.901034118198939e-05, 0.9993317473042481, 0.0006192423545698319]}, {"input": {"iterations": 10481, "opp_strategy": [0.28621810209130777, 0.6735305404323476, 0.04025135747634469]}, "output": [6.360716216645994e-05, 0.03548077668390617, 0.9644556161539273]}, {"input": {"iterations": 31917, "opp_strategy": [0.27249212014885055, 0.01071489693304406, 0.7167929829181054]}, "output": [0.9999791124896868, 1.0443755156604108e-05, 1.0443755156604108e-05]}, {"input": {"iterations": 47577, "opp_strategy": [0.4041833869117154, 0.22941019994283487, 0.36640641314544986]}, "output": [0.9919513062550943, 0.008015597854567865, 3.309589033783498e-05]}, {"input": {"iterations": 35131, "opp_strategy": [0.08956512266290714, 0.6954806493497291, 0.21495422798736372]}, "output": [1.8976592373307524e-05, 1.8976592373307524e-05, 0.9999620468152534]}, {"input": {"iterations": 56931, "opp_strategy": [0.24051264843439799, 0.645709889852824, 0.11377746171277797]}, "output": [5.8550408974606685e-06, 0.0012408802155076785, 0.9987532647435949]}, {"input": {"iterations": 70478, "opp_strategy": [0.02505832583630606, 0.709861127740385, 0.2650805464233088]}, "output": [2.3648041469205522e-05, 2.3648041469205522e-05, 0.9999527039170617]}, {"input": {"iterations": 72254, "opp_strategy": [0.22024807751283018, 0.19834871420197245, 0.5814032082851975]}, "output": [0.9998235227049549, 1.3840064217897972e-05, 0.00016263723082722727]}, {"input": {"iterations": 59046, "opp_strategy": [0.2883994984776411, 0.6504690960568988, 0.06113140546545982]}, "output": [5.64531608124739e-06, 0.0003086594896370326, 0.9996856951942817]}, {"input": {"iterations": 16638, "opp_strategy": [0.7102581900992477, 0.24911905133638387, 0.04062275856436823]}, "output": [2.003445926994431e-05, 0.9999298793925553, 5.008614817486077e-05]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "13jqq/CFR-2", "path": "/RegretMatching_Rock-Paper-Scissors.py", "msgidx": 5376}}
{"problem_description": "Given a number, what are all the prime numbers that are less than or equal to this number?", "io_requirements": "Input:\n  `number` (int): An integer representing the upper limit for finding prime numbers.\n\nOutput:\n  `return` (list of int): A list of integers representing all prime numbers less than or equal to the input `number`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime_num(number):\n    if((number == 2) or (number == 3)):\n        return True\n    elif(((number % 6) != 1) and ((number % 6) != 5)):\n        return False\n    n_1 = math.floor(math.sqrt(number))\n    for i in range(5, n_1 + 1, 6) :\n        if ((number % i == 0) or (number % (i + 2) == 0)):\n            return False\n    return True\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    prime_numbers = []\n    for i in range(2, number + 1):\n        if is_prime_num(i):\n            prime_numbers.append(i)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return prime_numbers", "funcname": "main_solution", "ios": [{"input": {"number": 55}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]}, {"input": {"number": 34}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]}, {"input": {"number": 56}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]}, {"input": {"number": 63}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]}, {"input": {"number": 48}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]}, {"input": {"number": 29}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]}, {"input": {"number": 59}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]}, {"input": {"number": 70}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]}, {"input": {"number": 61}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]}, {"input": {"number": 51}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "FatDou/pyCourse", "path": "/lesson_02/assignment.py", "msgidx": 6004}}
{"problem_description": "Given an infinite plane where a robot initially stands at the origin (0, 0) and faces north, the robot can receive one of three instructions: \"G\" to go straight 1 unit, \"L\" to turn 90 degrees to the left, and \"R\" to turn 90 degrees to the right. The robot performs the instructions given in order and repeats them forever. What is the result indicating whether there exists a circle in the plane such that the robot never leaves the circle, based on the provided sequence of instructions?", "io_requirements": "Input:\n  `instructions` (str): A string of instructions consisting of 'G', 'L', and 'R'. 'G' means go straight 1 unit, 'L' means turn 90 degrees to the left, and 'R' means turn 90 degrees to the right.\n\nOutput:\n  `return` (bool): A boolean value indicating whether there exists a circle in the plane such that the robot never leaves the circle.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        x, y = 0, 0\n        direction = (0, 1)\n        \n        for i in instructions:\n            if i == \"G\":\n                x = x + direction[0]\n                y = y + direction[1]\n            elif i == \"L\":\n                direction = (-direction[1], direction[0])\n            else:\n                direction = (direction[1], -direction[0])\n                \n        return (x == y == 0) or (direction != (0, 1))\n\n# main function\ndef main_solution(instructions: str) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    sol = Solution()\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sol.isRobotBounded(instructions)", "funcname": "main_solution", "ios": [{"input": {"instructions": "LGRGLGRLRG"}, "output": false}, {"input": {"instructions": "GGLGG"}, "output": true}, {"input": {"instructions": "LLRGR"}, "output": false}, {"input": {"instructions": "RLRGGLLGLG"}, "output": true}, {"input": {"instructions": "LGRRRLRL"}, "output": true}, {"input": {"instructions": "GRGRR"}, "output": true}, {"input": {"instructions": "GLGLRLLGRL"}, "output": true}, {"input": {"instructions": "GL"}, "output": true}, {"input": {"instructions": "L"}, "output": true}, {"input": {"instructions": "RLLLLLGRRG"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nehabais31/LeetCode-Solutions", "path": "/1041. Robot Bounded In Circle.py", "msgidx": 5866}}
{"problem_description": "Given the positions of a white bishop and a black pawn on a standard chessboard, determine if the bishop can capture the pawn in one move. The bishop moves diagonally and can move any number of squares along a diagonal. What is the result of whether the bishop can capture the pawn in one move, given the positions of the bishop and the pawn?", "io_requirements": "Input:\n  `bishop` (str): A string representing the position of the white bishop on the chessboard. It should be in the format of a letter (a-h) followed by a number (1-8).\n  `pawn` (str): A string representing the position of the black pawn on the chessboard. It should be in the format of a letter (a-h) followed by a number (1-8).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the bishop can capture the pawn in one move. `True` if the bishop can capture the pawn, `False` otherwise.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef bishopAndPawn(bishop, pawn):\n    bishX, bishY = ord(bishop[0]), int(bishop[1])\n    pawnX, pawnY = ord(pawn[0]), int(pawn[1])\n\n    b = bishY - bishX\n    neg_b = bishY + bishX\n    return (pawnY == pawnX + b) or (pawnY == (-1 * pawnX) + neg_b)\n\n# main function\ndef main_solution(bishop, pawn):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = bishopAndPawn(bishop, pawn)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"bishop": "g1", "pawn": "a8"}, "output": false}, {"input": {"bishop": "b5", "pawn": "f8"}, "output": false}, {"input": {"bishop": "g7", "pawn": "b8"}, "output": false}, {"input": {"bishop": "e6", "pawn": "h2"}, "output": false}, {"input": {"bishop": "g3", "pawn": "g5"}, "output": false}, {"input": {"bishop": "h3", "pawn": "g8"}, "output": false}, {"input": {"bishop": "h5", "pawn": "c3"}, "output": false}, {"input": {"bishop": "c2", "pawn": "g5"}, "output": false}, {"input": {"bishop": "g7", "pawn": "d3"}, "output": false}, {"input": {"bishop": "a5", "pawn": "h5"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Developernation/codefights", "path": "/cfights/python3_solutions/bishopNPawn.py", "msgidx": 5824}}
{"problem_description": "Consider a spiral matrix formed by starting with the number 1 and moving to the right in a clockwise direction. For example, a 5 by 5 spiral is formed as follows:\n\n```\n21 22 23 24 25\n20  7  8  9 10\n19  6  1  2 11\n18  5  4  3 12\n17 16 15 14 13\n```\n\nIt can be verified that the sum of the numbers on the diagonals is 101. What is the sum of the numbers on the diagonals in a spiral matrix of size `sz` by `sz`?", "io_requirements": "Input:\n  `sz` (int): The size of the spiral matrix (must be an odd integer).\n\nOutput:\n  `return` (int): The sum of the numbers on the diagonals in the spiral matrix of size `sz` by `sz`.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef diag(n):\n    if(n==1):\n        UR = 1\n        UL = 0\n        LL = 0\n        LR = 0\n    else:\n        [old_ur, old_ul, old_ll, old_lr] = diag(n-2)\n        UR = old_ur + n*2 + (n-2)*2\n        UL = UR - (n-1)\n        LL = UR - 2*(n-1)\n        LR = UR - 3*(n-1)\n    return UR, UL, LL, LR\n\n# main function\ndef main_solution(sz):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    sum_diag = 0\n    for i in range(0, (sz+1)//2):\n        n = 2*i + 1\n        [ur, ul, ll, lr] = diag(n)\n        sum_diag = sum_diag + ur + ul + ll + lr\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum_diag", "funcname": "main_solution", "ios": [{"input": {"sz": 315}, "output": 20887281}, {"input": {"sz": 451}, "output": 61258201}, {"input": {"sz": 741}, "output": 271521541}, {"input": {"sz": 159}, "output": 2692637}, {"input": {"sz": 715}, "output": 243940481}, {"input": {"sz": 121}, "output": 1188521}, {"input": {"sz": 669}, "output": 199836877}, {"input": {"sz": 791}, "output": 330256341}, {"input": {"sz": 463}, "output": 66276365}, {"input": {"sz": 525}, "output": 96607261}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "armandyam/euler_projects", "path": "/py/euler_28.py", "msgidx": 5428}}
{"problem_description": "Given a dragon curve algorithm that simulates the movement of a turtle, how much total distance would the turtle travel after a certain number of iterations, starting with a specified initial step size and direction, and considering a swapping flag that alternates the turns?", "io_requirements": "Input:\n  `iteration` (int): The number of iterations to perform in the dragon curve algorithm.\n  `size` (float): The initial size of the step taken by the turtle.\n  `direction` (int, optional): The direction of the initial turn (1 for right, -1 for left). Default is 1.\n  `swap` (bool, optional): A boolean flag to determine the swapping of turns. Default is False.\n\nOutput:\n  `return` (dict): A dictionary containing the key `total_distance` with the total distance traveled by the turtle as a float.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(iteration, size, direction=1, swap=False):\n    # Convert JSON serializable inputs to the original input variables\n    iteration = int(iteration)\n    size = float(size)\n    direction = int(direction)\n    swap = bool(swap)\n\n    # Helper function to simulate the dragon curve logic without turtle graphics\n    def simulate_dragon_curve(iteration, size, direction, swap):\n        if iteration == 0:\n            return size\n        else:\n            new_size = size / math.sqrt(2)\n            return (\n                simulate_dragon_curve(iteration - 1, new_size, int(not swap) - int(swap), swap) +\n                simulate_dragon_curve(iteration - 1, new_size, int(swap) - int(not swap), swap)\n            )\n\n    # Calculate the total distance traveled by the turtle\n    total_distance = simulate_dragon_curve(iteration, size, direction, swap)\n\n    # Return the total distance as a JSON serializable output\n    return {\"total_distance\": total_distance}", "funcname": "main_solution", "ios": [{"input": {"iteration": 3, "size": 55.88, "direction": -1, "swap": true}, "output": {"total_distance": 158.05250773081707}}, {"input": {"iteration": 2, "size": 16.17, "direction": -1, "swap": true}, "output": {"total_distance": 32.339999999999996}}, {"input": {"iteration": 5, "size": 80.38, "direction": -1, "swap": false}, "output": {"total_distance": 454.6979445741973}}, {"input": {"iteration": 9, "size": 31.81, "direction": -1, "swap": true}, "output": {"total_distance": 719.7781347054099}}, {"input": {"iteration": 2, "size": 69.25, "direction": 1, "swap": true}, "output": {"total_distance": 138.49999999999997}}, {"input": {"iteration": 1, "size": 88.23, "direction": -1, "swap": false}, "output": {"total_distance": 124.77606260817818}}, {"input": {"iteration": 3, "size": 47.72, "direction": -1, "swap": false}, "output": {"total_distance": 134.97254239288816}}, {"input": {"iteration": 7, "size": 95.33, "direction": -1, "swap": false}, "output": {"total_distance": 1078.535831208217}}, {"input": {"iteration": 5, "size": 12.12, "direction": 1, "swap": false}, "output": {"total_distance": 68.56107350384762}}, {"input": {"iteration": 10, "size": 66.13, "direction": 1, "swap": false}, "output": {"total_distance": 2116.1599999999994}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "TeachingKidsProgramming/TeachingKidsProgramming.Python", "path": "/fractals/dragon_curve.py", "msgidx": 6032}}
{"problem_description": "In a historical game, a group of people stand in a circle. Starting from the first person, every nth person is eliminated from the circle, where n is a prime number that changes each round. The game continues until only one person remains. Given the number of people in the circle, which position will the last person standing occupy?", "io_requirements": "Input:\n  `pessoas` (int): The number of people in the circle. Must be a positive integer.\n\nOutput:\n  `return` (int): The position of the last remaining person in the circle.", "refcode": "# import necessary packages\nfrom math import sqrt, floor\n\n# all class and function definitions in the code file, if any\ndef eh_primo(numero):\n    piso_sqrt = floor(sqrt(numero))\n    \n    for i in range(2, piso_sqrt+1):\n        if numero % i == 0:\n            return False\n    return True\n\ndef gera_proximo_primo(prime):\n    prime += 1\n    \n    while not eh_primo(prime):\n        prime += 1\n    return prime\n\n# main function\ndef main_solution(pessoas):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    pessoas = [x for x in range(1, pessoas + 1)]\n\n    i = 1\n    primo = 1\n    while len(pessoas) != 1:\n        pessoas.pop(i)\n\n        primo = gera_proximo_primo(primo + 1)\n        i = (i + primo) % len(pessoas)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return pessoas[0]", "funcname": "main_solution", "ios": [{"input": {"pessoas": 47}, "output": 15}, {"input": {"pessoas": 99}, "output": 17}, {"input": {"pessoas": 21}, "output": 17}, {"input": {"pessoas": 13}, "output": 4}, {"input": {"pessoas": 12}, "output": 5}, {"input": {"pessoas": 3}, "output": 3}, {"input": {"pessoas": 5}, "output": 3}, {"input": {"pessoas": 75}, "output": 14}, {"input": {"pessoas": 89}, "output": 62}, {"input": {"pessoas": 34}, "output": 21}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "da-ferreira/uri-online-judge", "path": "/uri/1032.py", "msgidx": 5948}}
{"problem_description": "Given a set of four distinct digits, what is the maximum number of consecutive positive integers that can be formed using each digit exactly once, along with the four basic arithmetic operations (+, \u2212, *, /) and parentheses?", "io_requirements": "Input:\n  `digits` (list of int): A list containing exactly four distinct digits (0-9).\n\nOutput:\n  `return` (int): The length of the longest set of consecutive positive integers that can be obtained using the given digits and the four arithmetic operations.", "refcode": "# import necessary packages\nfrom itertools import combinations, permutations\nfrom operator import add, sub, mul\n\n# Define the division function to handle division by zero\ndef div(a, b):\n    if b == 0:\n        return 0\n    return a / b\n\n# main function\ndef main_solution(digits):\n    # Convert the input list of digits to a set of four distinct digits\n    digits_set = set(digits)\n    if len(digits_set) != 4:\n        raise ValueError(\"The input must contain exactly four distinct digits.\")\n    \n    # Generate all possible combinations of operations\n    op_combos = [perm for comb in combinations((add, sub, mul, div), 3) for perm in permutations(comb)]\n    \n    # Initialize a set to store the results for the given digits\n    hits = set()\n    \n    # Iterate over all permutations of the digits and all combinations of operations\n    for d1, d2, d3, d4 in permutations(digits_set):\n        for op1, op2, op3 in op_combos:\n            expressions = (\n                op1(d1, op2(d2, op3(d3, d4))),\n                op1(d1, op3(op2(d2, d3), d4)),\n                op2(op1(d1, d2), op3(d3, d4)),\n                op3(op1(d1, op2(d2, d3)), d4),\n                op3(op2(op1(d1, d2), d3), d4)\n            )\n\n            # Add the integer results to the hits set\n            for value in expressions:\n                if 0 < value == int(value):\n                    hits.add(int(value))\n    \n    # Find the longest streak of consecutive positive integers\n    i = 1\n    while i in hits:\n        i += 1\n    max_streak = i - 1\n    \n    # Return the longest streak of consecutive positive integers\n    return max_streak", "funcname": "main_solution", "ios": [{"input": {"digits": [9, 5, 6, 2]}, "output": 9}, {"input": {"digits": [2, 3, 9, 1]}, "output": 10}, {"input": {"digits": [9, 7, 6, 4]}, "output": 9}, {"input": {"digits": [5, 6, 0, 9]}, "output": 1}, {"input": {"digits": [8, 7, 2, 4]}, "output": 19}, {"input": {"digits": [7, 2, 0, 1]}, "output": 9}, {"input": {"digits": [4, 1, 7, 8]}, "output": 0}, {"input": {"digits": [7, 8, 3, 4]}, "output": 13}, {"input": {"digits": [9, 8, 7, 5]}, "output": 7}, {"input": {"digits": [5, 8, 0, 7]}, "output": 5}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ktp-forked-repos/euler", "path": "/problem093/problem093.py", "msgidx": 5713}}
{"problem_description": "Given a chessboard of size `n` by `n`, how can you place `n` queens on the board such that no two queens threaten each other? Each solution should be represented as a configuration of the chessboard where 'Q' indicates the position of a queen and '.' indicates an empty space. What are all possible configurations for the given size `n`?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (list of lists of strings): A list of all possible solutions to the N-Queens problem. Each solution is represented as a list of strings, where each string represents a row of the chessboard. 'Q' indicates the position of a queen, and '.' indicates an empty space.", "refcode": "# import necessary packages\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    result = []\n    result2 = []\n\n    def solveNQueens(self, n):\n        self.result = []\n        self.result2 = []\n        lst = {}\n        for i in range(n):\n            lst[i] = -100000\n        self.dfs(0, n, n, lst)\n\n        for res in self.result:\n            board = []\n            for row in range(n):\n                str = \"\"\n                queen = res[row]\n                for col in range(n):\n                    if col == queen:\n                        str += \"Q\"\n                    else:\n                        str += \".\"\n                board.append(str)\n            self.result2.append(board)\n        return self.result2\n\n    def dfs(self, x, n, count, lst):\n        if count == 0:\n            new = deepcopy(lst)\n            self.result.append(new)\n            return\n        else:\n            for i in range(n):\n                if self.vaild(x, i, lst):\n                    lst[x] = i\n                    self.dfs(x + 1, n, count - 1, lst)\n                    lst[x] = -100000\n\n    def vaild(self, x, y, lst):\n        for row in lst:\n            if lst[row] == y or abs(y - lst[row]) == abs(x - row):\n                return False\n        return True\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # Convert the result to a JSON serializable format\n    json_result = [[''.join(row) for row in board] for board in result]\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return json_result", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zzh730/LeetCode", "path": "/Backtracking/N Queens.py", "msgidx": 5829}}
{"problem_description": "Given a natural number, can you determine if it can be expressed as the sum of the cubes of three natural numbers? If so, what are the three natural numbers?", "io_requirements": "Input:\n  `n` (int): A natural number to be checked if it can be represented as the sum of the cubes of three natural numbers.\n\nOutput:\n  `return` (tuple or bool): If `n` can be represented as the sum of the cubes of three natural numbers, returns a tuple `(a, b, c)` such that `n == a**3 + b**3 + c**3`. Otherwise, returns `False`.", "refcode": "# import necessary packages\nfrom math import ceil, pow\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Determines if a given natural number can be represented as the sum of the cubes of three natural numbers.\n    Returns a tuple (a, b, c) such that n == a**3 + b**3 + c**3, or False if no such tuple exists.\n    \"\"\"\n    # find (a, b, c) such that n == a ** 3 + b ** 3 + c ** 3 and a <= b <= c\n    c = 1\n    while n >= 1 ** 3 + 1 ** 3 + c ** 3:\n        m = n - c ** 3\n        \n        # find (a, b) such that m == a ** 3 + b ** 3 and a <= b <= c\n        a = 1 # set a to min possible value\n        b = min(ceil(pow(m - 1 ** 3, 1 / 3)), c) # set b to max possible value\n        while a <= b:\n            x = a ** 3 + b ** 3\n            if m < x:\n                b -= 1\n            elif m > x:\n                a += 1\n            else:\n                return (a, b, c)\n        c += 1\n    return False", "funcname": "main_solution", "ios": [{"input": {"n": 88651}, "output": false}, {"input": {"n": 96096}, "output": false}, {"input": {"n": 28222}, "output": false}, {"input": {"n": 73918}, "output": false}, {"input": {"n": 66335}, "output": false}, {"input": {"n": 3800}, "output": false}, {"input": {"n": 60491}, "output": false}, {"input": {"n": 15303}, "output": false}, {"input": {"n": 96320}, "output": false}, {"input": {"n": 87468}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "stoat1/micro-projects", "path": "/thumbtack-test-solutions/Task3.py", "msgidx": 6341}}
{"problem_description": "Given a set of disks and three rods, how can you solve the Hanoi Tower problem to move all disks from the source rod to the target rod using the helper rod, following the rules of the Hanoi Tower puzzle? (The input variables are `n`, `f`, `h`, and `t`.)", "io_requirements": "Input:\n  `n` (int): The number of disks in the Hanoi Tower problem.\n  `f` (str): The name of the source rod.\n  `h` (str): The name of the helper rod.\n  `t` (str): The name of the target rod.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"result\" and value \"Hanoi Tower problem solved\".", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef move(f, t):\n    pass  # This function is a placeholder for the move operation in the Hanoi Tower problem\n\ndef hanoi(n, f, h, t):\n    if n == 0:\n        pass\n    else:\n        hanoi(n-1, f, t, h)\n        move(f, t)\n        hanoi(n-1, h, f, t)\n\n# main function\ndef main_solution(n, f, h, t):\n    # Convert JSON serializable inputs to the original input variables\n    n = int(n)\n    f = str(f)\n    h = str(h)\n    t = str(t)\n    \n    # Call the original hanoi function\n    hanoi(n, f, h, t)\n    \n    # Return a JSON serializable output\n    return {\"result\": \"Hanoi Tower problem solved\"}", "funcname": "main_solution", "ios": [{"input": {"n": 7, "f": "B", "h": "C", "t": "A"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 6, "f": "C", "h": "B", "t": "A"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 5, "f": "B", "h": "C", "t": "A"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 9, "f": "A", "h": "B", "t": "C"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 2, "f": "A", "h": "C", "t": "B"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 10, "f": "A", "h": "B", "t": "C"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 5, "f": "A", "h": "B", "t": "C"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 4, "f": "B", "h": "A", "t": "C"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 4, "f": "A", "h": "C", "t": "B"}, "output": {"result": "Hanoi Tower problem solved"}}, {"input": {"n": 2, "f": "A", "h": "B", "t": "C"}, "output": {"result": "Hanoi Tower problem solved"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jadedocelot/Bin2rong", "path": "/python/playground/roundTwo.py", "msgidx": 6152}}
{"problem_description": "Given the size of a chessboard, how can you place `n` queens on an `n x n` chessboard such that no two queens attack each other? What are the distinct configurations of the queens' placement on the board?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of all distinct solutions to the n-queens puzzle. Each solution is represented as a list of strings, where each string represents a row on the chessboard. 'Q' indicates a queen and '.' indicates an empty space.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        \n        def generateBoard(board):\n            curr = []\n            for row in board:\n                curr.append(''.join(row))\n            return curr\n        \n        def backtrack(row, diagonal, anti_diagonal, cols, board):\n            if row == n:\n                res.append(generateBoard(board))\n                return\n            \n            for col in range(n):\n                curr_diagonal = row - col\n                curr_anti_diagonal = row + col\n                if ((curr_diagonal not in diagonal) and \n                    (curr_anti_diagonal not in anti_diagonal) and\n                    (col not in cols)):\n                    diagonal.add(curr_diagonal)\n                    anti_diagonal.add(curr_anti_diagonal)\n                    cols.add(col)\n                    board[row][col] = 'Q'\n\n                    backtrack(row + 1, diagonal, anti_diagonal, cols, board)\n\n                    diagonal.remove(curr_diagonal)\n                    anti_diagonal.remove(curr_anti_diagonal)\n                    cols.remove(col)\n                    board[row][col] = '.'\n        \n        backtrack(0, set(), set(), set(), board)\n        return res\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": []}, {"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}, {"input": {"n": 1}, "output": [["Q"]]}, {"input": {"n": 2}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "XihangJ/leetcode", "path": "/DFS/51. N-Queens.py", "msgidx": 5972}}
{"problem_description": "Given a number `n`, how would you construct a square matrix where each integer value is represented as rings of integers in expanding increasing order, starting from the outermost ring?", "io_requirements": "Input:\n  `n` (int): An integer greater than or equal to 1, representing the size of the outermost ring in the square matrix.\n\nOutput:\n  `return` (list of lists of int): A 2D list representing the square matrix where each integer value is represented as rings of integers in expanding increasing order.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef paste_matrix_into_larger_in_ij(m, larger_m, i, j):\n    larger_m[i:i+m.shape[0], j:j+m.shape[1]] = m\n    return larger_m\n\ndef incremental_ring_square(n):\n    if n == 1:\n        return np.array([[1]])\n    else:\n        # create matrix first filled with zeros\n        dim = (n * 2) - 1\n        m = np.zeros(shape=(dim, dim)).astype('int')\n\n        # Fill outermost ring: equals to filling first and last rows, and left and right columns:\n        for i in range(dim):\n            m[0][i] = n\n            m[dim-1][i] = n\n            m[i][0] = n\n            m[i][dim-1] = n\n        # center\n        m[dim//2][dim//2] = 1\n\n        # compute smaller rings one at a time\n        nested_ring = n - 1\n        upperLeftCornerStart = 1  # upper left corner coordinates where we start pasting our inner rings\n        while nested_ring >= 2:\n            m = paste_matrix_into_larger_in_ij(incremental_ring_square(nested_ring), m, upperLeftCornerStart, upperLeftCornerStart)\n            nested_ring -= 1\n            upperLeftCornerStart += 1\n        return m\n\n# main function\ndef main_solution(n):\n    # Convert the output matrix to a list of lists for JSON serialization\n    result_matrix = incremental_ring_square(n).tolist()\n    return result_matrix", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": [[1]]}, {"input": {"n": 2}, "output": [[2, 2, 2], [2, 1, 2], [2, 2, 2]]}, {"input": {"n": 3}, "output": [[3, 3, 3, 3, 3], [3, 2, 2, 2, 3], [3, 2, 1, 2, 3], [3, 2, 2, 2, 3], [3, 3, 3, 3, 3]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "NataliaDiaz/BrainGym", "path": "/incremental-ring-square.py", "msgidx": 5947}}
{"problem_description": "In the game of darts, players aim to reduce their score to zero by hitting specific sections of the board. Each section has a different score, and the player must finish on a double (including the double bullseye) to win. Given a maximum score, how many distinct ways can a player checkout with a score less than this maximum score?", "io_requirements": "Input:\n  `max_score` (int): The maximum score for which to calculate the number of distinct checkout ways. It should be a positive integer less than 100.\n\nOutput:\n  `return` (int): The number of distinct ways a player can checkout with a score less than `max_score`.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef generate_scores():\n    scores = []\n    for i in range(1, 21):\n        scores.append(('S', i))\n        scores.append(('D', i * 2))\n        scores.append(('T', i * 3))\n    scores.append(('S', 25))\n    scores.append(('D', 50))\n    return scores\n\ndef generate_checkouts(max_score):\n    scores = generate_scores()\n    checkouts = set()\n    for dart1 in scores:\n        for dart2 in scores:\n            for dart3 in scores:\n                if dart3[0] == 'D':  # Only consider doubles for the last dart\n                    total_score = dart1[1] + dart2[1] + dart3[1]\n                    if total_score < max_score:\n                        checkout = tuple(sorted([dart1, dart2, dart3]))\n                        checkouts.add(checkout)\n    return checkouts\n\n# main function\ndef main_solution(max_score):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    checkouts = generate_checkouts(max_score)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(checkouts)", "funcname": "main_solution", "ios": [{"input": {"max_score": 33}, "output": 2868}, {"input": {"max_score": 50}, "output": 8764}, {"input": {"max_score": 29}, "output": 1935}, {"input": {"max_score": 19}, "output": 474}, {"input": {"max_score": 41}, "output": 5291}, {"input": {"max_score": 82}, "output": 21747}, {"input": {"max_score": 83}, "output": 22089}, {"input": {"max_score": 39}, "output": 4620}, {"input": {"max_score": 87}, "output": 23281}, {"input": {"max_score": 40}, "output": 4932}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nickfang/classes", "path": "/projectEuler/webScraping/problemTemplates/109.py", "msgidx": 6344}}
{"problem_description": "Given a binary tree where each node has a value, a unival subtree is defined as a subtree where all nodes under it have the same value. How many unival subtrees are there in the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the binary tree structure. Each node is represented as a dictionary with keys:\n    - `val` (str or int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as another dictionary or None if there is no right child.\n\nOutput:\n  `return` (int): The number of unival subtrees in the given binary tree.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef num_unival(node, above=None):\n    if node is None:\n        return 0\n\n    below = set()\n    if above is None:\n        above = set()\n\n    if node.left is None and node.right is None:\n        above.add(node.val)\n        return 1\n\n    num = num_unival(node.left, below)\n    num += num_unival(node.right, below)\n\n    if len(below) == 1 and node.val in below:\n        num += 1\n\n    above.update(below)\n    return num\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        return Node(data[\"val\"], build_tree(data[\"left\"]), build_tree(data[\"right\"]))\n\n    tree = build_tree(tree_structure)\n    \n    # Call the original function with the converted input\n    result = num_unival(tree)\n    \n    # Return the result, which is already JSON serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 1, "left": null, "right": null}}, "output": 1}, {"input": {"tree_structure": {"val": 0, "left": null, "right": null}}, "output": 1}, {"input": {"tree_structure": {"val": "a", "left": null, "right": null}}, "output": 1}, {"input": {"tree_structure": {"val": "c", "left": null, "right": null}}, "output": 1}, {"input": {"tree_structure": {"val": "b", "left": null, "right": null}}, "output": 1}, {"input": {"tree_structure": {"val": 0, "left": {"val": 0, "left": null, "right": null}, "right": {"val": 0, "left": null, "right": null}}}, "output": 3}, {"input": {"tree_structure": {"val": 1, "left": {"val": 1, "left": null, "right": null}, "right": {"val": 1, "left": null, "right": null}}}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Legoben/DailyProgrammingProblems", "path": "/8.py", "msgidx": 5487}}
{"problem_description": "In a decision-making scenario, a tree structure is used to evaluate possible outcomes. Each node in the tree represents a decision point, and the tree is built to a certain depth. Given a maximum depth and an initial value for the root node, what is the best value that can be achieved by traversing the tree?", "io_requirements": "Input:\n  `max_depth` (int): The maximum depth of the tree to be built.\n  `initial_a_value` (int): The initial value of `a_value` for the root node.\n\nOutput:\n  `return` (dict): A dictionary containing the key `best_value` which holds the best value found in the tree.", "refcode": "# import necessary packages\nfrom sys import maxsize\n\n# all class and function definitions in the code file, if any\nclass Node():\n    \"\"\"\n    Defines how a node is built.\n    \"\"\"\n    def __init__(self, depth, max_depth, player, a_value, value=0):\n        self.depth = depth\n        self.max_depth = max_depth\n        self.player = player\n        self.a_value = a_value\n        self.value = value\n        self.children = []\n        self.build_children()\n\n    def build_children(self):\n        if self.depth < self.max_depth:\n            for i in range(1, 3):\n                v = self.a_value - i\n                child_node = Node(self.depth+1, self.max_depth, -self.player, v, self.value_of(v))\n                self.children.append(child_node)\n\n    def value_of(self, val):\n        if val == 0:\n            return maxsize * self.player\n        elif val < 0:\n            return maxsize * -self.player\n        return 0\n\ndef choose(node, depth, max_d, player):\n    if (depth == max_d) or (abs(node.value) == maxsize):\n        return node.value\n\n    best_value = maxsize * -player\n\n    for x in range(len(node.children)):\n        child = node.children[x]\n        val = choose(child, depth+1, max_d, -player)\n        if abs(maxsize * -player - val) < abs(maxsize * -player - best_value):\n            best_value = val\n\n    return best_value\n\n# main function\ndef main_solution(max_depth, initial_a_value):\n    # Convert JSON serializable inputs to the original input variables\n    max_depth = int(max_depth)\n    initial_a_value = int(initial_a_value)\n\n    # Build the tree\n    root_node = Node(0, max_depth, 1, initial_a_value)\n\n    # Choose the best value\n    best_value = choose(root_node, 0, max_depth, 1)\n\n    # Convert the output to JSON serializable\n    return {\"best_value\": best_value}", "funcname": "main_solution", "ios": [{"input": {"max_depth": 7, "initial_a_value": 10}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 3, "initial_a_value": 14}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 7, "initial_a_value": 13}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 4, "initial_a_value": 8}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 6, "initial_a_value": 6}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 6, "initial_a_value": 15}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 5, "initial_a_value": 6}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 6, "initial_a_value": 20}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 6, "initial_a_value": 7}, "output": {"best_value": -9223372036854775807}}, {"input": {"max_depth": 4, "initial_a_value": 19}, "output": {"best_value": -9223372036854775807}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Trolley33/python-dump", "path": "/maths/minimax.py", "msgidx": 6014}}
{"problem_description": "Given a set of 2-digit square numbers, how many distinct arrangements of two cubes, each with six different digits (0 to 9), allow for all of the given square numbers to be displayed when the cubes are placed side-by-side? Note that the digits 6 and 9 can be considered interchangeable due to their upside-down symmetry.", "io_requirements": "Input:\n  `squares` (list of strings): A list of strings representing the square numbers to be displayed. Each string is a 2-digit number.\n\nOutput:\n  `return` (int): The number of distinct arrangements of the two cubes that allow for all of the square numbers to be displayed.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef diceHelper(start):\n    if start > 9:\n        return [[]]\n\n    dice = []\n    for die in diceHelper(start + 1):\n        if len(die) < 6:\n            dice.append([start] + die)\n        dice.append(die)\n\n    return dice\n\ndef getDice():\n    dice = []\n    for die in diceHelper(0):\n        if len(die) == 6:\n            dice.append(die)\n    return dice\n\n# main function\ndef main_solution(squares):\n    # Convert squares list to a set of tuples for easier comparison\n    squares_set = set(map(tuple, squares))\n\n    # Generate all possible dice combinations\n    dice = getDice()\n    goal = []\n\n    for d1 in dice:\n        for d2 in dice:\n            satisfies = True\n            for square in squares_set:\n                i1, i2 = square\n\n                if (i2 == 6 or i2 == 9) and ((i1 in d1 and (6 in d2 or 9 in d2)) or ((6 in d1 or 9 in d1) and i1 in d2)):\n                    pass\n                elif (i1 in d1 and i2 in d2) or (i2 in d1 and i1 in d2):\n                    pass\n                else:\n                    satisfies = False\n                    break\n            if satisfies:\n                if [d1, d2] not in goal and [d2, d1] not in goal:\n                    goal.append([d1, d2])\n\n    # Return the number of distinct arrangements\n    return len(goal)", "funcname": "main_solution", "ios": [{"input": {"squares": ["46"]}, "output": 0}, {"input": {"squares": ["25", "09", "01", "46"]}, "output": 0}, {"input": {"squares": ["81", "01"]}, "output": 0}, {"input": {"squares": ["36", "04", "25", "01", "16", "49", "46", "81", "09"]}, "output": 0}, {"input": {"squares": ["09", "46", "16", "01", "81", "49"]}, "output": 0}, {"input": {"squares": ["36", "81", "49", "04", "46", "01", "16"]}, "output": 0}, {"input": {"squares": ["01", "46", "04", "09", "49", "36"]}, "output": 0}, {"input": {"squares": ["49", "01", "25", "81", "16"]}, "output": 0}, {"input": {"squares": ["04"]}, "output": 0}, {"input": {"squares": ["16", "09"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kruthar/euler", "path": "/probs81-90/prob90.py", "msgidx": 6273}}
{"problem_description": "Imagine you are a henchman on Commander Lambda's space station, and you need to solve a daily movement puzzle to cross the floor. The floor is designed like a chessboard, and you must move as a knight. Given a starting square (`src`) and a destination square (`dest`) on the chessboard, how many moves will it take for you to reach the destination using the knight's L-shaped moves?", "io_requirements": "Input:\n  `src` (int): The starting square on the chessboard, an integer between 0 and 63 inclusive.\n  `dest` (int): The destination square on the chessboard, an integer between 0 and 63 inclusive.\n\nOutput:\n  `return` (int): The minimum number of moves required for a knight to travel from the source square to the destination square on a chessboard.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# Constants\nBOARD_SIZE = 8\n\n# Function to generate next possible moves for a knight\ndef next_moves(i, j):\n    moves = [\n        (1, -2), (2, -1), (2, 1), (1, 2),\n        (-1, 2), (-2, 1), (-2, -1), (-1, -2)\n    ]\n\n    for di, dj in moves:\n        nexti, nextj = i + di, j + dj\n        if 0 <= nexti < BOARD_SIZE and 0 <= nextj < BOARD_SIZE:\n            yield nexti, nextj\n\n# Main function to solve the knight's movement problem\ndef main_solution(src, dest):\n    if src == dest:\n        return 0\n\n    starti, startj = divmod(src, BOARD_SIZE)\n    endi, endj = divmod(dest, BOARD_SIZE)\n\n    # -1 for unvisited\n    visited = [[-1] * BOARD_SIZE for _ in range(BOARD_SIZE)]\n\n    q = deque([(starti, startj)])\n    visited[starti][startj] = 0\n\n    while q:\n        i, j = q.popleft()\n        for nexti, nextj in next_moves(i, j):\n            if visited[nexti][nextj] == -1:\n                q.append((nexti, nextj))\n                visited[nexti][nextj] = visited[i][j] + 1\n\n            if nexti == endi and nextj == endj:\n                return visited[nexti][nextj]\n\n    return -1  # In case no path is found (though the problem guarantees a path)", "funcname": "main_solution", "ios": [{"input": {"src": 12, "dest": 12}, "output": 0}, {"input": {"src": 47, "dest": 24}, "output": 5}, {"input": {"src": 54, "dest": 18}, "output": 4}, {"input": {"src": 19, "dest": 15}, "output": 3}, {"input": {"src": 30, "dest": 40}, "output": 4}, {"input": {"src": 36, "dest": 51}, "output": 1}, {"input": {"src": 5, "dest": 37}, "output": 2}, {"input": {"src": 12, "dest": 53}, "output": 4}, {"input": {"src": 63, "dest": 14}, "output": 3}, {"input": {"src": 34, "dest": 47}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Sacry/google_foobar", "path": "/level_2/02_dont_get_volunteered.py", "msgidx": 6094}}
{"problem_description": "Given a range of numbers from `start_number` to `end_number` inclusive, how many letters are used when writing out each number in words, following British usage and excluding spaces and hyphens?", "io_requirements": "Input:\n  `start_number` (int): The starting number of the range (inclusive) for which the number of letters in their written form should be counted.\n  `end_number` (int): The ending number of the range (inclusive) for which the number of letters in their written form should be counted.\n\nOutput:\n  `return` (int): The total number of letters used to write out all numbers in the specified range in words, excluding spaces and hyphens.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(start_number, end_number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    a_l = {0: 0, 1: 3, 2: 3, 3: 5, 4: 4, 5: 4, 6: 3, 7: 5, 8: 5, 9: 4, 10: 3, 11: 6, 12: 6, 13: 8, 14: 8, 15: 7, 16: 7, 17: 9, 18: 8, 19: 9, 20: 6, 30: 6, 40: 5, 50: 5, 60: 5, 70: 7, 80: 6, 90: 9}\n    m = 0\n    \n    for n in range(start_number, end_number + 1):\n        if n < 100:\n            m += a_l[n // 10 * 10] + a_l[n - (n // 10) * 10]\n        elif 100 <= n < 1000:\n            if n % 100 == 0:\n                m += a_l[n // 100] + 7\n            else:\n                m += a_l[n // 100] + 7 + 3 + a_l[(n - (n // 100) * 100) // 10 * 10] + a_l[int(str(n)[2])]\n        else:\n            m += 11\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return m", "funcname": "main_solution", "ios": [{"input": {"start_number": 774, "end_number": 775}, "output": 52}, {"input": {"start_number": 280, "end_number": 814}, "output": 12255}, {"input": {"start_number": 44, "end_number": 259}, "output": 3975}, {"input": {"start_number": 144, "end_number": 830}, "output": 15611}, {"input": {"start_number": 17, "end_number": 575}, "output": 11483}, {"input": {"start_number": 193, "end_number": 995}, "output": 18391}, {"input": {"start_number": 601, "end_number": 803}, "output": 4612}, {"input": {"start_number": 325, "end_number": 340}, "output": 392}, {"input": {"start_number": 929, "end_number": 987}, "output": 1371}, {"input": {"start_number": 914, "end_number": 951}, "output": 866}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Yaxian/ProjectEuler", "path": "/17.py", "msgidx": 5457}}
{"problem_description": "Given a list of words, can you determine if there is a way to arrange them in a circle such that the last character of each word matches the first character of the next word? For example, if the words are \"apple\", \"eggs\", \"snack\", \"karat\", and \"tuna\", is it possible to form a circular chain where each word connects to the next based on their characters?", "io_requirements": "Input:\n  `words` (str): A comma-separated string of words. Each word should be a valid string with at least one character.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the words can be chained in a circle such that the last character of each word matches the first character of the next word.", "refcode": "# import necessary packages\nfrom collections import defaultdict, deque\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, word, next=None):\n        self.value = word\n        self.next = next\n\nclass Solution:\n    def chainedWords(self, words):\n        l = len(words)\n        headMap = defaultdict(deque)\n        tailMap = defaultdict(deque)\n\n        # Create the linked list\n        baseNode = Node(words[0])\n        self.__registerHeadMap(headMap, baseNode)\n        self.__registerTailMap(tailMap, baseNode)\n\n        for i in range(1, l):\n            w = words[i]\n            node = Node(w)\n            firstCh = w[0]\n            lastCh = w[-1]\n            if len(tailMap[firstCh]) == 0:\n                self.__registerHeadMap(headMap, node)\n            else:\n                parentNode = tailMap[firstCh].popleft()\n                parentNode.next = node\n\n            if len(headMap[lastCh]) == 0:\n                self.__registerTailMap(tailMap, node)\n            else:\n                childNode = headMap[lastCh].popleft()\n                node.next = childNode\n\n        # Check circular\n        cnt = 1\n        isCircular = False\n        nextNode = baseNode.next\n        while nextNode is not None and cnt <= l:\n            cnt += 1\n            if nextNode == baseNode:\n                isCircular = True\n                break\n            nextNode = nextNode.next\n\n        return isCircular and cnt == l + 1\n\n    def __registerHeadMap(self, headMap, node):\n        headMap[node.value[0]].append(node)\n\n    def __registerTailMap(self, tailMap, node):\n        tailMap[node.value[-1]].append(node)\n\n# main function\ndef main_solution(words):\n    # Convert input to the required format\n    words_list = words.split(',')\n    \n    # Invoke the solution function\n    solu = Solution()\n    result = solu.chainedWords(words_list)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"words": "nvhfz,syfsqz,fzgg"}, "output": false}, {"input": {"words": "mtlinu,rcah,pgjhcqs"}, "output": false}, {"input": {"words": "phzlbkr,uqu,teatcfx,zjrrop,golig,idzr,jodqc"}, "output": false}, {"input": {"words": "vmibyw,mnib,vplaxkm,gbe,aty,igpcgv,wrf,miezppl,eqxtbjj,kmq"}, "output": false}, {"input": {"words": "zrdkl,esh,jjqycm,riyg,cwafb,bamjnxt,alvdk"}, "output": false}, {"input": {"words": "hzn,stsfox,kdt,htdkhtw,rtoi,iatzxqg"}, "output": false}, {"input": {"words": "pwfnqup,wyqrv,fna,rtkgbt,qaridq,thwvw,jzhpifm,cye,egh,muvzxzz"}, "output": false}, {"input": {"words": "ppxuzav,zvbgk,nvto,stuzuu"}, "output": false}, {"input": {"words": "gkua,jadk,sgyn"}, "output": false}, {"input": {"words": "rizni,kmgrv,dnchik,norg,rqbmid"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dexterchan/DailyChallenge", "path": "/Jan2020/CircleOfChainedWords.py", "msgidx": 5737}}
{"problem_description": "Given a binary tree represented by a list in level order traversal, where each element in the list corresponds to a node value and `None` indicates a missing node, determine whether the binary tree is symmetric. A binary tree is symmetric if it looks the same when reflected along its center axis. What is the result of checking the symmetry of the given binary tree?", "io_requirements": "Input:\n  `tree_list` (list of integers or None): A list representing the binary tree in level order traversal. Each element in the list corresponds to a node value, with `None` indicating a missing node.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetric.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Function to convert a JSON serializable list to a binary tree\ndef list_to_tree(lst):\n    if not lst:\n        return None\n    root = TreeNode(lst[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(lst):\n        node = queue.pop(0)\n        if lst[i] is not None:\n            node.left = TreeNode(lst[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(lst) and lst[i] is not None:\n            node.right = TreeNode(lst[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\n# Function to check if a binary tree is symmetric\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return self.helper(root.left, root.right)\n\n    def helper(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        return self.helper(left.left, right.right) and self.helper(left.right, right.left)\n\n# main function\ndef main_solution(tree_list):\n    # Convert the JSON serializable list to a binary tree\n    root = list_to_tree(tree_list)\n    \n    # Check if the binary tree is symmetric\n    solution = Solution()\n    result = solution.isSymmetric(root)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_list": [1, 2, 2, 3, 4, 4, 3]}, "output": true}, {"input": {"tree_list": [null, null, 47, 16, 43, 92, 62, 79, 21, 9, 53, 94, 47, 68, 20]}, "output": false}, {"input": {"tree_list": [33, 63, 61, 73, 74, null, null, 96, null, 14, 45, 44, null, 77, null]}, "output": false}, {"input": {"tree_list": [91, 65, 25, null, 5, 57, 33, 1, 33, 98, 16, null, 7, 19, 9]}, "output": false}, {"input": {"tree_list": [20, null, 14, null, null, 47, 23, 88, 2, 54, 67, 46, 50, 93, 40]}, "output": false}, {"input": {"tree_list": [39, 98, 44, 70, 81, null, 75, 8, 43, null, 54, 6, 41, 12, null]}, "output": false}, {"input": {"tree_list": [94, 88, 17, 93, 9, 34, null, 58, null, 26, 2, 43, 78, 43, 19]}, "output": false}, {"input": {"tree_list": [58, 79, 90, 34, null, 83, 91, 65, 1, 67, 98, null, 29, 36, 64]}, "output": false}, {"input": {"tree_list": [76, null, null, 78, 63, null, 59, 73, 83, 66, 55, 42, null, 8, null]}, "output": true}, {"input": {"tree_list": [94, 45, 46, null, 20, 20, null, 17, 70, null, 90, null, 68, null, null]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "buidler/LeetCode", "path": "/\u6811/\u5251\u6307 Offer 28. \u5bf9\u79f0\u7684\u4e8c\u53c9\u6811.py", "msgidx": 6281}}
{"problem_description": "Given two linked lists represented by two lists of integers, determine whether these two linked lists intersect. If they intersect, find the position of the intersection node from the start of the smaller list. What is the result of checking the intersection of the two linked lists?", "io_requirements": "Input:\n  `list1` (list of int): A list representing the first linked list. Each element in the list represents the data of a node in the linked list.\n  `list2` (list of int): A list representing the second linked list. Each element in the list represents the data of a node in the linked list.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `intersection_exists` (bool): Indicates whether the two linked lists intersect.\n    - `intersection_position` (int or None): The position of the intersection node from the start of the smaller list if an intersection exists, otherwise None.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef getSize(node):\n    count = 1\n    while node.next != None:\n        count += 1\n        node = node.next\n    return count, node\n\ndef findIntersection(node1, node2, diff):\n    while diff > 0:\n        node1 = node1.next\n        diff -= 1\n    pos = 1\n    while node1 != node2:\n        node1 = node1.next\n        node2 = node2.next\n        pos += 1\n    return node1, pos\n\ndef checkIntersection(node1, node2):\n    if node1 == None or node2 == None:\n        return None\n\n    l1, l2 = getSize(node1)[0], getSize(node2)[0]\n    diff = l1 - l2\n\n    if getSize(node1)[1] == getSize(node2)[1]:\n        if diff > 0:\n            return findIntersection(node1, node2, abs(diff))\n        else:\n            return findIntersection(node2, node1, abs(diff))\n    else:\n        return None\n\n# main function\ndef main_solution(list1, list2):\n    # Convert JSON serializable inputs to original input variables\n    def create_linked_list(data_list):\n        if not data_list:\n            return None\n        head = Node(data_list[0])\n        current = head\n        for data in data_list[1:]:\n            current.next = Node(data)\n            current = current.next\n        return head\n\n    node1 = create_linked_list(list1)\n    node2 = create_linked_list(list2)\n\n    # Invoke the original function\n    result = checkIntersection(node1, node2)\n\n    # Convert the result to JSON serializable output\n    if result:\n        intersection_node, position = result\n        return {\"intersection_exists\": True, \"intersection_position\": position}\n    else:\n        return {\"intersection_exists\": False}", "funcname": "main_solution", "ios": [{"input": {"list1": [21, 1, 78, 37, 64, 64, 81], "list2": [82, 71, 61, 37, 64, 64, 81]}, "output": {"intersection_exists": false}}, {"input": {"list1": [15, 57, 49, 13, 55, 64, 71, 29, 29], "list2": [25, 11]}, "output": {"intersection_exists": false}}, {"input": {"list1": [21, 36, 67], "list2": [16, 36, 67]}, "output": {"intersection_exists": false}}, {"input": {"list1": [49, 29, 91, 59, 82, 46, 45, 93, 66], "list2": [100, 29, 91, 59, 82, 46, 45, 93, 66]}, "output": {"intersection_exists": false}}, {"input": {"list1": [64, 22, 34, 44, 67], "list2": [64, 22, 34, 44, 67]}, "output": {"intersection_exists": false}}, {"input": {"list1": [72, 92], "list2": [12, 95, 56, 95, 43, 80, 28, 60]}, "output": {"intersection_exists": false}}, {"input": {"list1": [20, 96], "list2": [20, 96]}, "output": {"intersection_exists": false}}, {"input": {"list1": [41, 75, 78], "list2": [72, 97, 84, 77, 99, 5, 78, 28, 22]}, "output": {"intersection_exists": false}}, {"input": {"list1": [36, 26, 64, 26, 100, 44, 55, 73, 52], "list2": [10]}, "output": {"intersection_exists": false}}, {"input": {"list1": [98, 15, 6, 17, 84], "list2": [21, 15, 6, 17, 84]}, "output": {"intersection_exists": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kavya-reddy-a/CTCI-in-Python", "path": "/Chapter 2 - Linked Lists/2_7.py", "msgidx": 5557}}
{"problem_description": "Given a binary tree, determine whether it is symmetrical. A binary tree is symmetrical if the left subtree is a mirror reflection of the right subtree. What is the result of checking the symmetry of the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (list of int or None): A list representing the structure of the binary tree. Each element in the list corresponds to a node value, with `None` indicating a missing node. The list is constructed in a breadth-first manner.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical (True) or not (False).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef isSymmetrical(root):\n    return isS(root, root)\n\ndef isS(roo1, root2):\n    if roo1 is None and root2 is None:\n        return True\n    if roo1 is None or root2 is None:\n        return False\n\n    if root2.val != roo1.val:\n        return False\n\n    return isS(roo1.left, root2.right) and isS(roo1.right, root2.left)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    result = isSymmetrical(root)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [60, 7, 31]}, "output": false}, {"input": {"tree_structure": [86, 27, 60, 75, 80, null, 13, 46, null, null, null, null, 78, 36, null]}, "output": false}, {"input": {"tree_structure": [9, 12, null, 77, 57, 2, 6]}, "output": false}, {"input": {"tree_structure": [5, 13, 47]}, "output": false}, {"input": {"tree_structure": [2, 49, 38, 38, 49, 2]}, "output": false}, {"input": {"tree_structure": [88, 78, 48, 48, 78, 88]}, "output": false}, {"input": {"tree_structure": [null, 13, 62]}, "output": false}, {"input": {"tree_structure": [6, 50, 9]}, "output": false}, {"input": {"tree_structure": [42, 42]}, "output": false}, {"input": {"tree_structure": [31, 100, 23, null, 11, 95, 91, 15, 53, null, 38, 39, null, 74, 72]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Okiii-lh/to_offer_note", "path": "/python/\u5bf9\u79f0\u7684\u4e8c\u53c9\u6811.py", "msgidx": 5941}}
{"problem_description": "Given a Sudoku board represented as a 2D list of integers, determine whether the board is a valid Sudoku solution. A valid Sudoku solution must satisfy the following conditions:\n1. Each row must contain the numbers 1 through \\( N \\) exactly once.\n2. Each column must contain the numbers 1 through \\( N \\) exactly once.\n3. Each of the \\( N \\) sub-grids (or boxes) must contain the numbers 1 through \\( N \\) exactly once.\n\nWhat is the validity status of the provided Sudoku board?", "io_requirements": "Input:\n  `board` (list of lists of integers): A 2D list representing the Sudoku board. Each sublist represents a row in the Sudoku board, and each integer represents a cell value. The board should be a square matrix with dimensions \\( N \\times N \\), where \\( N \\) is a perfect square (e.g., 4, 9, 16).\n\nOutput:\n  `return` (boolean): A boolean value indicating whether the Sudoku board is valid (`True`) or invalid (`False`).", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Sudoku:\n    def __init__(self, board):\n        self.board = board\n       \n    def is_valid(self):\n        N = len(self.board[0])\n        S = int(math.sqrt(N))\n        \n        elem_ok =  all([type(el) == int for row in self.board for el in row])\n        if not elem_ok:\n            return False\n\n        valid = [i+1 for i in range(N)]    \n        rows_ok = all([sorted(row) == valid and len(row) == len(valid)  for row in self.board]) \n        cols_ok = all([sorted(col) == valid for col in zip(*self.board)])\n        if not rows_ok or not cols_ok:\n            return False\n        \n        box = [r[S*i:S*i+S] for r in self.board for i in range(S)]\n        # Seperate in sets\n        box = [box[S*i:S*i+S] for i in range(N)]\n        for k in range(N):\n            sub_box = []\n            for j in range(S):\n                sub_box += [el for el in box[j + S*(k//S)][k%S]]\n            if sorted(sub_box) != valid:\n                return False \n        return True\n\n# main function\ndef main_solution(board):\n    # Convert the input list of lists to a Sudoku object\n    sudoku = Sudoku(board)\n    # Check if the Sudoku board is valid\n    result = sudoku.is_valid()\n    # Return the result as a boolean\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 1, 3, 2], [2, 3, 2, 4], [1, 3, 4, 3], [4, 4, 1, 4]]}, "output": false}, {"input": {"board": [[3, 1, 4, 2], [4, 3, 1, 2], [3, 4, 2, 1], [1, 3, 1, 1]]}, "output": false}, {"input": {"board": [[1, 2, 3, 4], [1, 1, 4, 3], [4, 2, 2, 3], [1, 1, 2, 3]]}, "output": false}, {"input": {"board": [[2, 4, 2, 1], [3, 1, 3, 2], [4, 1, 3, 3], [2, 3, 2, 4]]}, "output": false}, {"input": {"board": [[1, 3, 3, 3], [3, 3, 3, 1], [2, 1, 2, 1], [1, 1, 3, 4]]}, "output": false}, {"input": {"board": [[2, 3, 3, 3], [4, 4, 4, 3], [1, 1, 3, 4], [1, 4, 4, 4]]}, "output": false}, {"input": {"board": [[3, 4, 3, 3], [4, 4, 3, 1], [3, 3, 1, 1], [4, 2, 3, 3]]}, "output": false}, {"input": {"board": [[2, 1, 2, 1], [4, 3, 3, 3], [4, 2, 2, 4], [4, 1, 1, 3]]}, "output": false}, {"input": {"board": [[2, 4, 2, 2], [2, 3, 2, 4], [4, 2, 4, 2], [3, 3, 1, 1]]}, "output": false}, {"input": {"board": [[1, 2, 3, 3], [2, 3, 3, 4], [4, 3, 1, 4], [4, 1, 4, 2]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dmavridis/katas", "path": "/validateSudoku.py", "msgidx": 6007}}
{"problem_description": "In a game of Nim, there are several heaps of items, and players take turns removing any number of items from any single heap. The player who removes the last item loses in a mis\u00e8re game and wins in a normal game. Given the current sizes of the heaps and whether the game is mis\u00e8re or normal, what is the optimal move for the next player? Specifically, which heap should be chosen and how many items should be removed from that heap?", "io_requirements": "Input:\n  `heaps` (list of integers): A list representing the sizes of the heaps in the Nim game. Each integer represents the number of items in a heap.\n  `misere` (boolean, optional): A boolean flag indicating whether the game is a mis\u00e8re game (True) or a normal game (False). Default is True.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `chosen_heap` (integer): The index of the heap from which items are to be removed.\n    - `nb_remove` (integer): The number of items to be removed from the chosen heap.", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef nim(heaps, misere=True):\n    \"\"\"\n    Computes next move for Nim in a normal or mis\u00e8re (default) game, returns\n    tuple (chosen_heap, nb_remove)\n    \"\"\"\n    X = reduce(lambda x,y: x ^ y, heaps)\n    if X == 0: # Will lose unless all non-empty heaps have size one\n        for i, heap in enumerate(heaps):\n            if heap > 0: # Empty any (non-empty) heap\n                chosen_heap, nb_remove = i, heap\n                break\n    else:\n        sums = [t ^ X < t for t in heaps]\n        chosen_heap = sums.index(True)\n        nb_remove = heaps[chosen_heap] - (heaps[chosen_heap] ^ X)\n        heaps_twomore = 0\n        for i, heap in enumerate(heaps):\n            n = heap-nb_remove if chosen_heap == i else heap\n            if n > 1: heaps_twomore += 1\n        # If move leaves no heap of size 2 or larger, leave an odd (mis\u00e8re) or\n        # even (normal) number of heaps of size 1\n        if heaps_twomore == 0:\n            chosen_heap = heaps.index(max(heaps))\n            heaps_one = sum(t == 1 for t in heaps)\n            # mis\u00e8re (resp. normal) strategy: if it is even (resp. odd) make it\n            # odd (resp. even), else do not change\n            nb_remove = (heaps[chosen_heap] - 1 if heaps_one % 2 != misere\n                         else heaps[chosen_heap])\n    return chosen_heap, nb_remove\n\n# main function\ndef main_solution(heaps, misere=True):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    chosen_heap, nb_remove = nim(heaps, misere)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"chosen_heap\": chosen_heap, \"nb_remove\": nb_remove}", "funcname": "main_solution", "ios": [{"input": {"heaps": [6, 6, 8], "misere": false}, "output": {"chosen_heap": 2, "nb_remove": 8}}, {"input": {"heaps": [3, 2, 9, 5, 10], "misere": true}, "output": {"chosen_heap": 3, "nb_remove": 3}}, {"input": {"heaps": [1, 1, 7, 3], "misere": false}, "output": {"chosen_heap": 2, "nb_remove": 4}}, {"input": {"heaps": [8, 1, 9, 3, 3], "misere": true}, "output": {"chosen_heap": 0, "nb_remove": 8}}, {"input": {"heaps": [6, 9, 5, 9, 4], "misere": true}, "output": {"chosen_heap": 0, "nb_remove": 5}}, {"input": {"heaps": [9, 3], "misere": false}, "output": {"chosen_heap": 0, "nb_remove": 6}}, {"input": {"heaps": [5, 8, 9, 3], "misere": true}, "output": {"chosen_heap": 0, "nb_remove": 3}}, {"input": {"heaps": [9, 10], "misere": false}, "output": {"chosen_heap": 1, "nb_remove": 1}}, {"input": {"heaps": [10, 1], "misere": true}, "output": {"chosen_heap": 0, "nb_remove": 10}}, {"input": {"heaps": [5, 6, 6], "misere": true}, "output": {"chosen_heap": 0, "nb_remove": 5}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sulami/dailyprogrammer", "path": "/006.py", "msgidx": 5571}}
{"problem_description": "Given a position in a spiral pattern, how many steps does it take to reach the center of the spiral from that position, and what is the first value in the spiral that is greater than the given position?", "io_requirements": "Input:\n  `n` (int): A positive integer representing the position in the spiral.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `steps` (int): The Manhattan distance from the center of the spiral to the position `n`.\n    - `higher_value` (int): The first value in the spiral that is greater than `n`.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    \n    # SOLUTION TO FIRST PBM\n    def spiral_memory_steps(n):\n        nsteps = 0\n        c = 1\n        found = False\n        while not found:\n            if n > c:\n                nsteps += 1\n                c += 8 * nsteps\n            else:\n                found = True\n        s = c - nsteps\n        q = 2 * nsteps\n        d = min([abs(s - i * q - n) for i in range(4)])\n        nsteps += d\n        return nsteps\n\n    # SOLUTION TO SECOND PBM\n    def spiral_additive_higher(n, niter=1000):\n        def fill_next_elem(m, addd, i, j, c):\n            d = addd[c]\n            i += d[0]\n            j += d[1]\n            next = np.sum(m[max(0, i - 1): i + 2, max(0, j - 1): j + 2])\n            m[i, j] = next\n            return m, i, j, next\n\n        def update(addv, v, c):\n            if v == addv[c] - 1:\n                c += 1\n                v = 0\n                if c == 4:\n                    c = 0\n                    addv = [av + 2 for av in addv]\n            else:\n                v += 1\n            return addv, v, c\n\n        def upsize(m, l, i, j):\n            k = m.shape[0]\n            up = np.zeros((k + 2, k + 2))\n            up[1: k + 1, 1: k + 1] = m\n            l += 2\n            i += 1\n            j += 1\n            return up, l, i, j\n\n        m = np.zeros((1, 1))\n        i = 0\n        j = 0\n        c = 0\n        v = 0\n        l = 1\n        addv = [1, 1, 2, 2]\n        addd = {0: (0, 1), 1: (-1, 0), 2: (0, -1), 3: (1, 0)}\n        m[i, j] = 1\n        for ni in range(niter):\n            if ni == l ** 2 - 1:\n                m, l, i, j = upsize(m, l, i, j)\n            m, i, j, next = fill_next_elem(m, addd, i, j, c)\n            if next > n:\n                return int(next)\n            addv, v, c = update(addv, v, c)\n\n    # Calculate the results\n    steps = spiral_memory_steps(n)\n    higher_value = spiral_additive_higher(n)\n    \n    # Return the results as a dictionary\n    return {\"steps\": steps, \"higher_value\": higher_value}", "funcname": "main_solution", "ios": [{"input": {"n": 141}, "output": {"steps": 8, "higher_value": 142}}, {"input": {"n": 381}, "output": {"steps": 20, "higher_value": 747}}, {"input": {"n": 981}, "output": {"steps": 20, "higher_value": 1968}}, {"input": {"n": 969}, "output": {"steps": 24, "higher_value": 1968}}, {"input": {"n": 663}, "output": {"steps": 14, "higher_value": 747}}, {"input": {"n": 86}, "output": {"steps": 5, "higher_value": 122}}, {"input": {"n": 548}, "output": {"steps": 19, "higher_value": 747}}, {"input": {"n": 261}, "output": {"steps": 12, "higher_value": 304}}, {"input": {"n": 375}, "output": {"steps": 14, "higher_value": 747}}, {"input": {"n": 76}, "output": {"steps": 5, "higher_value": 122}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ferretj/adventofcode2017", "path": "/puzzle03.py", "msgidx": 5601}}
{"problem_description": "In a game board of size `n x n`, there are variables represented as squares. Each variable can be assigned a color from a set of predefined colors. The board has a source variable and a target variable, each with specific positions. The source variable needs to be connected to the target variable through a path. Given the board size, the positions of the source and target variables, and the list of possible colors, what are the positions of the next variable for the source and the previous variable for the target in the path?", "io_requirements": "Input:\n  `board_size` (int): The size of the board (n x n).\n  `source_position` (tuple): The position of the source variable in the board (row, col).\n  `target_position` (tuple): The position of the target variable in the board (row, col).\n  `all_colors` (list of str): A list of all possible colors that can be assigned to variables.\n\nOutput:\n  `return` (dict): A dictionary containing the positions of the next variable for the source and the previous variable for the target.\n    - `source_next` (tuple): The position of the next variable for the source (row, col).\n    - `target_previous` (tuple): The position of the previous variable for the target (row, col).", "refcode": "# import necessary packages\nimport math\nimport itertools\n\n# class for a variable, the variable is a square in the game board\n# it will contain the variable legal values\nclass Variable:\n    \n    def __init__(self, position, color):\n        self.position = position # a tuple (row, col)\n        self.color = color # '0' if no assignment yet\n        self.domain = None\n        self.legalValues = []\n        self.isSource = False # current legal values for this variable, initialized as the domain\n        self.isTarget = False\n        self.neighbors = [] # neighbors of this variable\n        self.next = None #  the next var in the path.\n        self.previous = None # the previous variable in the path.\n        \n    '''\n    reset the variable's domain.\n    '''\n    def resetVariable(self):\n        self.legalValues = self.domain.copy()\n        if not(self.isTarget or self.isSource):\n            self.color = '0'\n        self.next = None\n        self.previous = None\n       \n\n    def setVariable(self, value):\n        if self.isSource:\n            self.next = value\n        elif self.isTarget:\n            self.previous = value\n        else :\n            self.previous = value[0]\n            self.color = value[1]\n            self.next = value[2]\n    ''' gets the variable by its original position  in board\n        static method\n    '''\n    def getVarByPos( position, variables):\n        for var in variables:\n            if var.position == position:\n                return var\n            \n    def setNeighbors(self, variables, length):\n        if self.position[1]+1 < length:\n            self.neighbors.append(Variable.getVarByPos((self.position[0],self.position[1] + 1),variables))\n            \n        if self.position[0]+1 < length:\n            self.neighbors.append(Variable.getVarByPos((self.position[0]+1,self.position[1]),variables))\n            \n        if self.position[1]-1>= 0:\n            self.neighbors.append(Variable.getVarByPos((self.position[0],self.position[1] - 1),variables))\n        \n        if self.position[0]-1 >= 0:\n            self.neighbors.append(Variable.getVarByPos((self.position[0]-1,self.position[1]),variables))\n    \n    def getNeighbors(self):\n        return self.neighbors\n    \n    def isAssigned(self):\n        if self.isTarget:\n            return self.previous != None\n        if self.isSource:\n            return self.next !=None\n        return self.color != '0'\n        \n    def NumUnassignedNeighbors(self):\n        count=0\n        for neighbor in self.getNeighbors():\n            if neighbor.isSource and neighbor.next == None:\n                count += 1\n            elif neighbor.isTarget and neighbor.previous == None:\n                count += 1\n            elif neighbor.color == '0':\n                count +=1\n        return count\n            \n    # for a regular variable , its domain is a vector , (previos, color , next)\n    #for a source we only assign what is its next variable, so its domain is the neighbors of the variable\n    # for a Target we only assign what is its previous variable, so its domain is the neighbors of the variable\n    # gets all colors\n    def setVarDomain(self, allcolors):\n        neighbors = self.getNeighbors()\n        if(self.isSource):\n            domain = neighbors # the possiblitites is only on the next neighbor to go to not the color.\n                               # the assignment is only on what is the next variable , color is already assigned, and no previous for this variable\n        elif(self.isTarget):\n            domain = neighbors # possibilities is only on the previous neighbor not color\n        else:\n            domain = list(itertools.product(neighbors, allcolors, neighbors))# cartesian product of neighborsXallcolorsXneighbors\n            domain =  [d for d in domain if d[0] != d[2]] # removing a value the has previous == next because it is meaningless\n        self.domain = domain\n    ##  get the domain of the variable.    \n    def getVarDomain(self):\n        return self.domain\n    \n    #print the domain of the variable used for debugging\n    def printDomain(self):\n        if self.isSource:\n            for val in self.legalValues:\n                print(val.position)\n            \n        elif self.isTarget:\n            for val in self.legalValues:\n                print(val.position )\n        else:\n            for val in self.legalValues:\n                print((val[0].position,val[1],val[2].position))\n                \n    # print the variable   \n    def printVar(self):\n        print(self.position)\n        if self.isSource:\n            print(self.next.position)\n        if self.isTarget:\n            print(self.previous.position)\n        else:\n            print(self.previous.position,self.color,self.next.position)\n    def getIndex(self):\n        return self.position[0]*numberOfvariables + self.position[1]\n    \n    def LegalValuesOfNeighbors(self):\n        count = 0 \n        for neighbor in self.getNeighbors():\n            count += len(neighbor.legalValues)\n        return count\n\n# main function\ndef main_solution(board_size, source_position, target_position, all_colors):\n    # Convert JSON serializable inputs to original input variables\n    variables = []\n    for i in range(board_size):\n        for j in range(board_size):\n            variables.append(Variable((i, j), '0'))\n    \n    source_var = Variable.getVarByPos(source_position, variables)\n    target_var = Variable.getVarByPos(target_position, variables)\n    source_var.isSource = True\n    target_var.isTarget = True\n    \n    for var in variables:\n        var.setNeighbors(variables, board_size)\n        var.setVarDomain(all_colors)\n    \n    # Core logic to solve the problem\n    source_var.setVariable(target_var)\n    target_var.setVariable(source_var)\n    \n    # Convert output to JSON serializable\n    result = {\n        \"source_next\": source_var.next.position,\n        \"target_previous\": target_var.previous.position\n    }\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"board_size": 6, "source_position": [1, 1], "target_position": [3, 2], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [3, 2], "target_previous": [1, 1]}}, {"input": {"board_size": 5, "source_position": [1, 3], "target_position": [3, 4], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [3, 4], "target_previous": [1, 3]}}, {"input": {"board_size": 6, "source_position": [0, 0], "target_position": [3, 3], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [3, 3], "target_previous": [0, 0]}}, {"input": {"board_size": 6, "source_position": [3, 5], "target_position": [1, 3], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [1, 3], "target_previous": [3, 5]}}, {"input": {"board_size": 4, "source_position": [2, 3], "target_position": [0, 0], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [0, 0], "target_previous": [2, 3]}}, {"input": {"board_size": 3, "source_position": [1, 2], "target_position": [0, 0], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [0, 0], "target_previous": [1, 2]}}, {"input": {"board_size": 4, "source_position": [2, 0], "target_position": [2, 3], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [2, 3], "target_previous": [2, 0]}}, {"input": {"board_size": 3, "source_position": [0, 1], "target_position": [1, 0], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [1, 0], "target_previous": [0, 1]}}, {"input": {"board_size": 3, "source_position": [2, 0], "target_position": [2, 1], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [2, 1], "target_previous": [2, 0]}}, {"input": {"board_size": 5, "source_position": [0, 3], "target_position": [3, 3], "all_colors": ["R", "G", "B", "Y"]}, "output": {"source_next": [3, 3], "target_previous": [0, 3]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "christianmtanes/Flow-Free-Project-AI-Project-", "path": "/variable.py", "msgidx": 5598}}
{"problem_description": "Given a chocolate factory that produces chocolate bars of varying dimensions, how many chocolate square pieces can be obtained from all possible chocolate bars within a specified range of lengths and widths? The dimensions range from `min_length` to `max_length` for the length and `min_width` to `max_width` for the width.", "io_requirements": "Input:\n  `min_length` (int): The minimum length of the chocolate bar.\n  `max_length` (int): The maximum length of the chocolate bar.\n  `min_width` (int): The minimum width of the chocolate bar.\n  `max_width` (int): The maximum width of the chocolate bar.\n\nOutput:\n  `return` (int): The total number of chocolate square pieces that can be obtained from all possible chocolate bars within the given dimensions.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nf_x = defaultdict(lambda: 0)\n\ndef getChocolates(width, length):\n    ''' Returns the number of chocolate square pieces that can\n    be obtained. It works recursively updating the variable f_x.\n    ############################################### '''\n    # -----base cases\n    if (f_x[(width, length)] > 0 or f_x[(length, width)] > 0):\n        return max(f_x[(width, length)], f_x[(length, width)])\n\n    if (width == 1 and length > 1) or (length == 1 and width > 1):\n       f_x[(width, length)] = max(width, length)\n       return f_x[(width, length)]\n\n    if width == length:\n        f_x[(width, length)] = 1\n        return f_x[(width, length)]\n\n    else:\n        smaller = min(width, length)\n        larger = max(width, length)\n\n        f_x[(smaller, smaller)] = 1\n\n        multiples = larger // smaller\n\n        if multiples == 1:\n            remainder = larger - smaller\n            f_x[(remainder, smaller)] = getChocolates(remainder, smaller)\n            f_x[(width, length)] = 1 + f_x[(remainder, smaller)]\n            return f_x[(width, length)]\n        else:\n            remainder = larger % smaller\n            if remainder == 0:\n                f_remainder = 0\n            else:\n                f_x[(remainder, smaller)] = getChocolates(remainder, smaller)\n                f_remainder = f_x[(remainder, smaller)]\n\n            for i in range(1, multiples + 1):\n                f_x[(smaller*i, smaller)] = i\n\n            f_x[(width, length)] = f_x[(multiples*smaller, smaller)] + f_remainder\n            return f_x[(width, length)]\n\n# main function\ndef main_solution(min_length, max_length, min_width, max_width):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    total_sum = 0\n\n    for i in range(min_length, max_length + 1):\n        for j in range(min_width, max_width + 1):\n            total_sum += getChocolates(i, j)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return total_sum", "funcname": "main_solution", "ios": [{"input": {"min_length": 3, "max_length": 15, "min_width": 6, "max_width": 20}, "output": 1228}, {"input": {"min_length": 6, "max_length": 11, "min_width": 9, "max_width": 11}, "output": 111}, {"input": {"min_length": 6, "max_length": 19, "min_width": 2, "max_width": 4}, "output": 253}, {"input": {"min_length": 7, "max_length": 17, "min_width": 4, "max_width": 18}, "output": 1102}, {"input": {"min_length": 7, "max_length": 19, "min_width": 1, "max_width": 6}, "output": 560}, {"input": {"min_length": 4, "max_length": 8, "min_width": 10, "max_width": 18}, "output": 259}, {"input": {"min_length": 1, "max_length": 8, "min_width": 10, "max_width": 17}, "output": 449}, {"input": {"min_length": 4, "max_length": 4, "min_width": 2, "max_width": 9}, "output": 28}, {"input": {"min_length": 6, "max_length": 20, "min_width": 3, "max_width": 10}, "output": 698}, {"input": {"min_length": 5, "max_length": 11, "min_width": 7, "max_width": 7}, "output": 39}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ztjona/codevita_practice_old1", "path": "/Problem3/DoleOutCadburyV2.py", "msgidx": 6082}}
{"problem_description": "Given a set of nine distinct digits from 1 to 9, what is the sum of all unique 4-digit products that can be formed by multiplying two integers formed from these digits, ensuring that each digit is used exactly once in the multiplication?", "io_requirements": "Input:\n  `digits` (list of integers): A list of integers representing the digits from 1 to 9.\n\nOutput:\n  `return` (integer): The sum of all unique 4-digit products that can be formed by multiplying two integers formed from the given digits, where the digits are used exactly once.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(digits):\n  toInt = lambda x : int(''.join(map(str, x)))\n\n  pandigitalProducts = []\n\n  for p in permutations(digits):\n    for i in range(1, 3):\n      a = toInt(p[:i])\n      b = toInt(p[i:5])\n      c = toInt(p[5:])\n      if a * b == c and c not in pandigitalProducts:\n        pandigitalProducts.append(c)\n\n  return sum(pandigitalProducts)", "funcname": "main_solution", "ios": [{"input": {"digits": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, "output": 45228}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "red3141/ProjectEuler", "path": "/P32.py", "msgidx": 6399}}
{"problem_description": "Given a sorted list of integers, what is the height of the minimal binary search tree that can be constructed from these integers?", "io_requirements": "Input:\n  `vals` (list of int): A sorted list of integers representing the values to be inserted into the binary search tree.\n\nOutput:\n  `return` (int): The height of the minimal binary search tree constructed from the input list.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass MinimalBST:\n    def buildMinimalBST(self, vals):\n        if vals is None or len(vals) < 1:\n            return 0\n        return self.build(vals, 0, len(vals) - 1)\n\n    def build(self, vals, start, end):\n        if end <= start:\n            return 1\n        mid = (start + end) // 2\n        h1 = 1 + self.build(vals, start, mid - 1)\n        h2 = 1 + self.build(vals, mid + 1, end)\n        return max(h1, h2)\n\n# main function\ndef main_solution(vals):\n    # Convert input to JSON serializable format if necessary\n    if vals is None:\n        vals = []\n    # Use the MinimalBST class to build the minimal BST\n    bst = MinimalBST()\n    height = bst.buildMinimalBST(vals)\n    # Return the height of the minimal BST\n    return height", "funcname": "main_solution", "ios": [{"input": {"vals": [9, 16, 23, 26, 27, 36, 50, 62, 66, 68, 86, 95]}, "output": 4}, {"input": {"vals": [1, 4, 27, 29, 33, 50, 86]}, "output": 3}, {"input": {"vals": [4, 14, 20, 42, 69, 88, 90]}, "output": 3}, {"input": {"vals": [12, 47, 55]}, "output": 2}, {"input": {"vals": [1, 36, 53]}, "output": 2}, {"input": {"vals": [7, 20]}, "output": 2}, {"input": {"vals": [20, 21, 22, 35, 41, 67, 94]}, "output": 3}, {"input": {"vals": [22, 23, 25, 29, 56, 90]}, "output": 3}, {"input": {"vals": [1, 4, 5, 10, 13, 23, 31, 64, 74, 77, 80, 93]}, "output": 4}, {"input": {"vals": [18, 42, 45, 78, 87, 88, 93, 98]}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jasonusaco/Leetcode-Practice", "path": "/Tree&Graphs/4.2.py", "msgidx": 6285}}
{"problem_description": "Given a sequence of integers and their doubles, what is the largest pandigital number that can be formed by concatenating the integer and its double within a specified range?", "io_requirements": "Input:\n  `start_range` (int): The starting range for the integer sequence.\n  `end_range` (int): The ending range for the integer sequence.\n\nOutput:\n  `return` (int): The largest pandigital number formed by concatenating the integer and its double within the specified range.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(start_range, end_range):\n    # Convert input arguments to appropriate types\n    start_range = int(start_range)\n    end_range = int(end_range)\n    \n    largest = 918273645\n    digits_9 = set('123456789')\n    \n    for i in range(end_range, start_range - 1, -1):\n        num = str(i) + str(2 * i)\n        if set(num) == digits_9:\n            if int(num) > largest:\n                largest = int(num)\n    \n    # Convert output to JSON serializable format\n    return largest", "funcname": "main_solution", "ios": [{"input": {"start_range": 9326, "end_range": 9530}, "output": 932718654}, {"input": {"start_range": 9511, "end_range": 9273}, "output": 918273645}, {"input": {"start_range": 9847, "end_range": 9727}, "output": 918273645}, {"input": {"start_range": 9821, "end_range": 9769}, "output": 918273645}, {"input": {"start_range": 9747, "end_range": 9252}, "output": 918273645}, {"input": {"start_range": 9661, "end_range": 9320}, "output": 918273645}, {"input": {"start_range": 9281, "end_range": 9485}, "output": 932718654}, {"input": {"start_range": 9867, "end_range": 9494}, "output": 918273645}, {"input": {"start_range": 9504, "end_range": 9378}, "output": 918273645}, {"input": {"start_range": 9571, "end_range": 9869}, "output": 918273645}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "juandarr/ProjectEuler", "path": "/38.py", "msgidx": 5849}}
{"problem_description": "Given an integer `n`, what are all the prime numbers less than `n`?", "io_requirements": "Input:\n  `n` (int): An integer representing the upper limit for finding prime numbers. The function will find all prime numbers less than `n`.\n\nOutput:\n  `return` (list of int): A list of integers representing all prime numbers less than `n`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isprime(num):\n    if num <= 3:\n        return True\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n\ndef PrimeFromN(n):\n    list_prime = [1] * n\n    for i in range(2, n):\n        if isprime(i):\n            for j in range(2 * i, n, i):\n                list_prime[j] = 0\n    list_res = []\n    for i in range(n):\n        if list_prime[i] == 1:\n            list_res.append(i)\n    return list_res\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    prime_numbers = PrimeFromN(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return prime_numbers", "funcname": "main_solution", "ios": [{"input": {"n": 19}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17]}, {"input": {"n": 61}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]}, {"input": {"n": 20}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17, 19]}, {"input": {"n": 34}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]}, {"input": {"n": 45}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]}, {"input": {"n": 30}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29]}, {"input": {"n": 48}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]}, {"input": {"n": 10}, "output": [0, 1, 2, 3, 5, 7]}, {"input": {"n": 13}, "output": [0, 1, 2, 3, 5, 7, 11]}, {"input": {"n": 49}, "output": [0, 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ljc19800331/CodePractice", "path": "/CodeAlg/A3_Math.py", "msgidx": 6162}}
{"problem_description": "Given a 2x3 sliding puzzle board, where each tile is numbered from 1 to 5 and one empty space represented by 0, how many moves are required to solve the puzzle by moving the tiles into the correct positions, with the final configuration being \"123450\"?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2x3 list of integers representing the puzzle board. The board contains integers from 0 to 5, where 0 represents the empty space.\n\nOutput:\n  `return` (int): The minimum number of moves required to solve the puzzle. If the puzzle cannot be solved, it returns -1.", "refcode": "# import necessary packages\nfrom collections import deque\nfrom typing import List\n\n# main function\ndef main_solution(board: List[List[int]]) -> int:\n    # Convert the board to a string representation\n    board_str = ''.join(str(board[i][j]) for i in range(2) for j in range(3))\n    target = \"123450\"\n    directions = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    visited = {board_str}\n    queue = deque([(board_str, 0)])\n    \n    while queue:\n        curr, move = queue.popleft()\n        if curr == target:\n            return move\n\n        idx = curr.index('0')\n        for i in directions[idx]:\n            temp = list(curr)\n            temp[i], temp[idx] = temp[idx], temp[i]\n            temp = ''.join(temp)\n            if temp not in visited:\n                visited.add(temp)\n                queue.append((temp, move + 1))\n    return -1", "funcname": "main_solution", "ios": [{"input": {"board": [[5, 2, 3], [0, 1, 4]]}, "output": 10}, {"input": {"board": [[3, 2, 0], [1, 4, 5]]}, "output": -1}, {"input": {"board": [[5, 3, 2], [4, 1, 0]]}, "output": 18}, {"input": {"board": [[2, 3, 5], [0, 4, 1]]}, "output": -1}, {"input": {"board": [[5, 1, 3], [2, 4, 0]]}, "output": -1}, {"input": {"board": [[2, 1, 4], [0, 3, 5]]}, "output": 18}, {"input": {"board": [[4, 0, 3], [1, 2, 5]]}, "output": -1}, {"input": {"board": [[5, 4, 0], [2, 1, 3]]}, "output": 13}, {"input": {"board": [[1, 0, 3], [5, 2, 4]]}, "output": -1}, {"input": {"board": [[2, 1, 3], [4, 5, 0]]}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "akauntotesuto888/Leetcode-Lintcode-Python", "path": "/773.py", "msgidx": 6262}}
{"problem_description": "Given a string that consists of a repeated pattern of characters, where one character is missing and replaced by an underscore, what is the missing character in the pattern?", "io_requirements": "Input:\n  `pattern_string` (str): A string representing the pattern with one character replaced by an underscore ('_'). The pattern is repeated at least twice, and the string may end in the middle of a repetition.\n\nOutput:\n  `return` (str): A single character string representing the missing character in the pattern.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(pattern_string):\n  # Convert the input string to the original format expected by the complete_pattern function\n  s = pattern_string\n  \n  # Call the complete_pattern function to find the missing character\n  missing_char = complete_pattern(s)\n  \n  # Return the missing character as a string\n  return missing_char\n\n# Function to find the missing character in the pattern\ndef complete_pattern(s):\n  for l in range(len(s)//2, 0, -1):\n    if all([s[i] == s[i+l] or s[i] == '_' or s[i+l] == '_' for i in range(l)]):\n      i = s.find('_')\n      return s[:l][i % l] if i >= l else s[l:][i % l]", "funcname": "main_solution", "ios": [{"input": {"pattern_string": "3(6KOy\\U~_3(6KOy\\U~}"}, "output": "}"}, {"input": {"pattern_string": "bG4Kz_G4Kz"}, "output": "b"}, {"input": {"pattern_string": "6Oad.D'(tG6Oad.D'(_G"}, "output": "t"}, {"input": {"pattern_string": "Dmv*_IDmv*)I"}, "output": ")"}, {"input": {"pattern_string": "_Wq?y?qE[\\DWq?y?qE[\\"}, "output": "D"}, {"input": {"pattern_string": "_}[[(n`}[[(n"}, "output": "`"}, {"input": {"pattern_string": "aF:'A_1XxaF:'A_1Xx"}, "output": "_"}, {"input": {"pattern_string": "dy`O$_mrUdy`O$*mrU"}, "output": "*"}, {"input": {"pattern_string": "/bUE];i=1r/b_E];i=1r"}, "output": "U"}, {"input": {"pattern_string": "J$?aAZ_9J$?aAZ^9"}, "output": "^"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/Rep3fHbrLGKDatZ2L_1.py", "msgidx": 5990}}
{"problem_description": "Given a set of data items, how can we ensure the integrity and authenticity of the data using a cryptographic technique? Specifically, what is the root hash value of a Merkle Tree constructed from a list of data items?", "io_requirements": "Input:\n  `leaves` (str): A JSON string representing a list of strings or integers, which are the leaves of the Merkle Tree.\n\nOutput:\n  `return` (str): A string representing the hash value of the root of the Merkle Tree.", "refcode": "# import necessary packages\nimport hashlib\nimport json\n\n# all class and function definitions in the code file, if any\nclass MerkleTree:\n    class __Node:\n        def __init__(self, item=None, left=None, right=None):\n            self.left = left\n            self.right = right\n            self.__value = item\n            self.parent = None\n            self.pos = -1\n\n        @property\n        def value(self):\n            return self.__value\n\n        @value.setter\n        def value(self, value):\n            self.__value = value\n\n        def __str__(self):\n            return 'Value: {0}'.format(self.value)\n        \n        def __repr__(self):\n            return self.__str__() + '\\n\\t' + self.left.__repr__() + '\\n\\t' + self.right.__repr__()\n\n    def __init__(self, iterable, digest_delegate=lambda x: str(x)):\n        if not iterable:\n            raise Exception(\"iterable cannot be empty.\")\n        self.digest = digest_delegate\n        self.__root = self.build_root(iterable)\n  \n    @property\n    def root(self):\n        return self.__root\n\n    def build_root(self, iterable):\n        if len(iterable) == 1:\n            return iterable[0]\n\n        if len(iterable) % 2 != 0:\n            iterable.append(iterable[-1])\n\n        data = [iterable[n:n+2] for n in range(0, len(iterable), 2)]\n        return self.build_root([self.join(*arg) for arg in data])\n\n    def join(self, x, y):\n        if type(x) == str or type(x) == int:\n            x = self.__Node(item=self.digest(x))\n            y = self.__Node(item=self.digest(y))\n\n        if type(x.value) == bytes:\n            value_x = x.value\n            value_y = y.value\n        else:\n            value_x = x.value\n            value_y = y.value\n\n        node = self.__Node(item=self.digest(value_x+value_y), left=x, right=y)\n        x.parent = node\n        y.parent = node\n        x.pos = 0\n        y.pos = 1\n        return node\n\n    def contains(self, value):\n        if value is None or self.root is None:\n            return False\n\n        hashed_value = self.digest(value)\n        return self.__find(self.root, hashed_value) is not None \n\n    def __find(self, node, value):\n        if node is None:\n            return None\n\n        if node.value == value:\n            return node\n        \n        return self.__find(node.left, value) or self.__find(node.right, value)\n\n    def request_proof(self, value):\n        value = self.digest(value)\n\n        def in_tree(value, node):\n            if node is None:\n                return False\n            if node.value == value:\n                return node\n            result = None\n            result = in_tree(value, node.left)\n            if not result:\n                result = in_tree(value, node.right)\n\n            if result:\n                return result\n\n            if node.left is None and node.right is None:\n                return False\n            return False\n\n        node = in_tree(value, self.root)\n\n        if not node:\n            raise Exception(\"Value not in tree\")\n\n        def traverse(value, node, _list=[]):\n            if node.pos == -1:\n                return _list\n\n            if node.value == value:\n                if node.pos == 0:\n                    if node.parent.right != value:\n                        _list.append((0, node.parent.right.value))\n\n                if node.pos == 1:\n                    if node.parent.left != value:\n                        _list.append((1, node.parent.left.value))\n                \n                if len(_list) == 1 and node.pos == 0:\n                    _list.insert(0,(1, value))\n                if len(_list) == 1 and node.pos == 1:\n                    _list.append((0, value))\n                    \n            return traverse(node.parent.value, node.parent, _list)\n\n        return traverse(value, node)\n\n# main function\ndef main_solution(leaves):\n    # Convert leaves to JSON serializable format\n    leaves = json.loads(leaves)\n    \n    # Create a Merkle Tree\n    merkle_tree = MerkleTree(leaves, digest_delegate=lambda x: hashlib.sha256(str(x).encode()).hexdigest())\n    \n    # Get the root of the Merkle Tree\n    root_value = merkle_tree.root.value\n    \n    # Return the root value as a JSON serializable string\n    return root_value", "funcname": "main_solution", "ios": [{"input": {"leaves": "[442, \"jeeqf\", \"lgzxl\", \"khxpz\"]"}, "output": "083a7a79b60d19271c33072e69233c1a5605392e74dacbbff7f9b428da101564"}, {"input": {"leaves": "[\"jzcir\", \"ozmku\", \"acctp\", \"hlqxm\", 601]"}, "output": "ca226ddc5894dcc0e3a75cbb39e3b5c0852c8a5201b2b5ceaaa78f425ef5776f"}, {"input": {"leaves": "[\"tbpgp\", 55, 849, 72, \"iuueo\", \"qpsib\", \"bejxg\"]"}, "output": "d6b10607b7d51953b019c8770af1bc8817347ab2b2b26eadcd64e45c1e352e9e"}, {"input": {"leaves": "[790, 377, \"dqwam\"]"}, "output": "dfc38151537c64c63d0795891f2d50f36637ab354c0ee9ebbf195b016faba0b9"}, {"input": {"leaves": "[577, 455, 430, 556, \"mzuir\", \"avyju\", 13]"}, "output": "d6482d55b3fd8faca29d80130ae65e24fcbe88baa408ff50562f0eb7c0c29fc2"}, {"input": {"leaves": "[731, 52, \"bpdvn\", 511, \"kynum\", \"qmtji\"]"}, "output": "4f7fdbfca4534dc2e70d0b927b4a32f72bbed1d9034b82eb4b49f93b66396978"}, {"input": {"leaves": "[85, \"vaxqw\", \"pxnpc\", 251, 454, \"xkfqv\", \"aqrge\", 507, 667]"}, "output": "a882ab6c036c2fad4c4c64d59249f8806f105a5c682f902bd52878dda21dba6c"}, {"input": {"leaves": "[723, 489, 556, \"qcszp\", \"ougzk\", \"xpyuj\"]"}, "output": "feeaffb9b7ef9d67523b70f7db37b1bf5f6f94b8d468055ded4525d129e56249"}, {"input": {"leaves": "[868, \"juobm\", \"lyxgm\"]"}, "output": "0707c554c76a205c2fa97c519b5e3256f77a794becf9f73883d0c6f8e512cd3f"}, {"input": {"leaves": "[634, 591]"}, "output": "9dbf381a2c46dae6e3c1f29ef08d424550d24d7a0103ebc98ea0bf3f8f7c4c1b"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nokusukun/PyRainbowSocks", "path": "/merkletree.py", "msgidx": 6249}}
{"problem_description": "Given two six-sided dice, each with faces numbered from 0 to 9, determine if it is possible to form all square numbers from 1 to 81 using the digits displayed on the faces of the two dice. Each square number should be formed by displaying one digit on each die. What is the result of this check for the given dice configurations?", "io_requirements": "Input:\n  `dice1` (list of int): A list of 6 integers representing the faces of the first dice.\n  `dice2` (list of int): A list of 6 integers representing the faces of the second dice.\nOutput:\n  `return` (bool): A boolean value indicating whether all square numbers (from 1 to 81) can be formed using the faces of the two dice.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(dice1, dice2):\n    # Convert lists to sets and handle 6 and 9 equivalence\n    set1 = set(dice1)\n    set2 = set(dice2)\n    if 6 in set1:\n        set1.add(9)\n    if 6 in set2:\n        set2.add(9)\n    if 9 in set1:\n        set1.add(6)\n    if 9 in set2:\n        set2.add(6)\n    \n    # Check if all square numbers can be formed\n    for x in range(1, 10):\n        sq = x * x\n        ch1 = sq // 10\n        ch2 = sq % 10\n        if not ((ch1 in set1 and ch2 in set2) or (ch2 in set1 and ch1 in set2)):\n            return False\n    return True", "funcname": "main_solution", "ios": [{"input": {"dice1": [3, 5, 6, 0, 1, 4], "dice2": [3, 9, 8, 0, 1, 6]}, "output": false}, {"input": {"dice1": [3, 2, 9, 6, 0, 5], "dice2": [2, 9, 6, 4, 0, 8]}, "output": false}, {"input": {"dice1": [3, 4, 1, 5, 9, 0], "dice2": [0, 8, 9, 2, 6, 1]}, "output": true}, {"input": {"dice1": [2, 3, 9, 4, 5, 8], "dice2": [1, 2, 9, 7, 3, 6]}, "output": false}, {"input": {"dice1": [9, 0, 7, 5, 1, 4], "dice2": [4, 6, 8, 9, 2, 3]}, "output": false}, {"input": {"dice1": [4, 5, 9, 1, 0, 8], "dice2": [4, 0, 5, 9, 7, 8]}, "output": false}, {"input": {"dice1": [1, 4, 7, 2, 9, 5], "dice2": [7, 2, 9, 5, 1, 0]}, "output": false}, {"input": {"dice1": [8, 6, 1, 3, 4, 5], "dice2": [0, 3, 4, 8, 2, 1]}, "output": true}, {"input": {"dice1": [2, 8, 9, 4, 5, 0], "dice2": [3, 2, 5, 7, 6, 4]}, "output": false}, {"input": {"dice1": [8, 1, 6, 2, 5, 0], "dice2": [1, 0, 4, 8, 9, 2]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "repoaditya/ProjectEuler", "path": "/e090.py", "msgidx": 6761}}
{"problem_description": "In a sequence of people, each person's age is 2 years more than the previous person's age. The first person is known to be 10 years old. What is the age of the person at a given position in the sequence?", "io_requirements": "Input:\n  `n` (int): The position of the person in the sequence (e.g., 1 for the first person, 2 for the second person, etc.).\n\nOutput:\n  `return` (int): The age of the person at position `n`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef Num(n):\n    if n == 1:\n        p = 10\n    else:\n        p = Num(n-1) + 2\n    return p\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    age = Num(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return age", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": 16}, {"input": {"n": 7}, "output": 22}, {"input": {"n": 3}, "output": 14}, {"input": {"n": 5}, "output": 18}, {"input": {"n": 2}, "output": 12}, {"input": {"n": 8}, "output": 24}, {"input": {"n": 6}, "output": 20}, {"input": {"n": 1}, "output": 10}, {"input": {"n": 9}, "output": 26}, {"input": {"n": 10}, "output": 28}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "huyihui004/python", "path": "/sctek/lianxi/28.py", "msgidx": 6637}}
{"problem_description": "Given an odd integer `num`, how can we construct a magic square of size `num x num` where the sum of the numbers in each row, each column, and both main diagonals are equal?", "io_requirements": "Input:\n  `num` (int): The size of the magic square matrix (an odd integer).\n\nOutput:\n  `return` (str): A JSON serialized string representing the filled magic square matrix.", "refcode": "# import necessary packages\nimport json\n\n# main function\ndef main_solution(num):\n    # Convert the input to the required format\n    num = int(num)\n    \n    # Initialize the matrix\n    matrix = [[0] * num for _ in range(num)]\n    \n    # Initialize the starting position\n    row = 1\n    col = (num + 1) // 2\n    i = 1\n    matrix[row - 1][col - 1] = i\n    \n    # Fill the matrix according to the magic square rules\n    while i < num * num:\n        i += 1\n        if i % num == 1:\n            col -= 1\n        else:\n            row -= 1\n            col -= 1\n            if row < 1:\n                row = num\n            if col < 1:\n                col = num\n        matrix[row - 1][col - 1] = i\n    \n    # Convert the matrix to a JSON serializable format\n    matrix_serializable = json.dumps(matrix)\n    \n    return matrix_serializable", "funcname": "main_solution", "ios": [{"input": {"num": 3}, "output": "[[5, 1, 9], [8, 4, 3], [2, 7, 6]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ipcoo43/algorithm", "path": "/lesson133.py", "msgidx": 6941}}
{"problem_description": "Given a set of items, each identified by a unique string, how many ways can these items be distributed into two bags such that no item appears in both bags?", "io_requirements": "Input:\n  `items` (list of strings): A list of item identifiers, where each identifier is a string.\n\nOutput:\n  `return` (int): The number of valid combinations of items that can be placed in two bags such that no item is repeated in both bags.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef powerSet(items):\n    N = len(items)\n    # enumerate the 2**N possible combinations\n    for i in range(2**N):\n        combo = []\n        for j in range(N):\n            # test bit jth of integer i            \n            if (i >> j) % 2 == 1:\n                combo.append(items[j])\n        yield combo\n\ndef bagCeat(items):\n    N = len(items)\n    # enumerate the 2**N possible combinations for bag1\n    for i in range(2**N):\n        bag1 = []\n        for j in range(N):\n            # test bit jth of integer i\n            if (i >> j) % 2 == 1:\n                bag1.append(items[j])\n        # enumerate the 2**N possible combinations for bag2\n        for k in range(2**N):\n            bag2 = []\n            for l in range(N):\n                # test bit lth of integer k\n                if (k >> l) % 2 == 1:\n                    bag2.append(items[l])                 \n            check = any(item in bag1 for item in bag2)\n            if check is False:\n                yield (bag1, bag2)\n\n# main function\ndef main_solution(items):\n    # Convert input to list if it's not already\n    items = list(items)\n    \n    # Generate all possible combinations of items in two bags\n    combinations = list(bagCeat(items))\n    \n    # Return the number of valid combinations\n    return len(combinations)", "funcname": "main_solution", "ios": [{"input": {"items": ["ddH", "BVj", "rDR", "tnx", "EYm", "ljP"]}, "output": 729}, {"input": {"items": ["ncN", "Giu", "tXO", "hJk"]}, "output": 81}, {"input": {"items": ["KDx", "RkL", "hSh", "cyO"]}, "output": 81}, {"input": {"items": ["GIG", "BLG", "MVS"]}, "output": 27}, {"input": {"items": ["TEl", "TOT", "wuo", "jDR", "Zox", "ypl"]}, "output": 729}, {"input": {"items": ["BWu", "xqy", "wFJ"]}, "output": 27}, {"input": {"items": ["EAx", "uXT", "YWP", "xFF", "ERO", "XKg"]}, "output": 729}, {"input": {"items": ["uUD", "JaE", "KGb", "kNr", "Uta", "QVO"]}, "output": 729}, {"input": {"items": ["kpt", "LLE", "zYM", "vRz", "qvf"]}, "output": 243}, {"input": {"items": ["pgp", "fxF", "HcI", "kVh", "jGX"]}, "output": 243}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "its-safi/Optimization_MIT_edX_IntroCourse", "path": "/u2_l1.py", "msgidx": 5579}}
{"problem_description": "Given a number of pairs of parentheses, how many different valid combinations of these parentheses can be generated?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n\n    def _generate(self, left, right, n, s):\n        '''\n        :param left: \u5f53\u524d\u5de6\u62ec\u53f7\u4e2a\u6570\n        :param right: \u5f53\u524d\u53f3\u62ec\u53f7\u4e2a\u6570\n        :param n: \u914d\u989d\n        :param s: \u5f53\u524d\u7684\u72b6\u6001\n        :return:\n        '''\n        if left == n and right == n:\n            self.res.append(s)\n\n        # \u5bf9\u4e0b\u4e00\u5c42\u53ef\u80fd\u7684\u72b6\u6001\u8282\u70b9\u65bd\u52a0\u5f71\u54cd\n        if left < n:\n            self._generate(left+1, right, n, s+'(')  # \u52a0\u5de6\u62ec\u53f7\u9020\u6210\u7684\u72b6\u6001\u8282\u70b9\u5f71\u54cd\n        if left > right:\n            self._generate(left, right+1, n, s+')') # \u52a0\u53f3\u62ec\u53f7\u5e26\u6765\u7684\u72b6\u6001\u8282\u70b9\u5f71\u54cd\n\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \u62bd\u8c61\u4e3a\uff1a\u67092n\u4e2a\u683c\u5b50\uff0c\u6bcf\u4e2a\u683c\u5b50\u53ef\u4ee5\u653e\u5de6\u62ec\u53f7\u6216\u8005\u53f3\u62ec\u53f7\n        \u6709\u591a\u5c11\u79cd\u53ef\u80fd\u6027\uff1b\u5148\u4e0d\u8003\u8651\u5408\u4e0d\u5408\u6cd5\u7684\u95ee\u9898\n        \u5047\u59823\u4e2a\u7684\u8bdd\uff0c\u5c31\u662f6\u5c42\u6df1\u5ea6\u7684\u9012\u5f52\n        \"\"\"\n        # \u8fd9\u91cc\u5199\u9012\u5f52\u7684\u521d\u59cb\u6761\u4ef6\n        self.res = []\n        self._generate(0, 0, n, '')\n        return self.res\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solu = Solution()\n    result = solu.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Ares-debugger/Frontend-01-Template", "path": "/week03/\u62ec\u53f7\u751f\u6210.py", "msgidx": 6429}}
{"problem_description": "Fredrick has received several credit card numbers from ABCD Bank and wants to verify their validity. A valid credit card number from ABCD Bank must start with 4, 5, or 6, contain exactly 16 digits, and may optionally have digits grouped in sets of four separated by a hyphen. Additionally, the card number must not contain any other separators and should not have four or more consecutive repeated digits. Given the list of credit card numbers, what are the validation results for each card?", "io_requirements": "Input:\n  `credit_card_numbers` (list of strings): A list of credit card numbers to be validated. Each credit card number is a string that may contain digits and hyphens.\n\nOutput:\n  `return` (list of strings): A list of validation results. Each result is either \"Valid\" or \"Invalid\", corresponding to the validation of each credit card number in the input list.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(credit_card_numbers):\n    # Define the regex pattern for valid credit card numbers\n    TESTER = re.compile(\n        r\"^\"\n        r\"(?!.*(\\d)(-?\\1){3})\"\n        r\"[456]\"\n        r\"\\d{3}\"\n        r\"(?:-?\\d{4}){3}\"\n        r\"$\")\n    \n    # Validate each credit card number\n    results = []\n    for card_number in credit_card_numbers:\n        if TESTER.search(card_number):\n            results.append(\"Valid\")\n        else:\n            results.append(\"Invalid\")\n    \n    # Return the results as a list of strings\n    return results", "funcname": "main_solution", "ios": [{"input": {"credit_card_numbers": ["5199472388579319"]}, "output": ["Valid"]}, {"input": {"credit_card_numbers": ["6687923271695859", "4304870778071008", "5632434493577215", "6411-3978-6430-5856"]}, "output": ["Valid", "Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["6565241921767470", "5390169580998006", "4672643784392459", "6187168778191524", "6709944800685061", "4701390663686954", "4915434664878921"]}, "output": ["Valid", "Valid", "Valid", "Valid", "Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["4167706478132003", "6256652412856977", "6720310483171019", "6163657890626017", "4758-6339-5702-1863", "5753-5374-0017-4478"]}, "output": ["Valid", "Valid", "Valid", "Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["4816-9391-7754-5421", "4170-3449-6218-6088", "5595-9238-4349-3086", "4776-8092-0653-7158", "5055343967018440"]}, "output": ["Valid", "Valid", "Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["5372669224768656", "6588390665383182", "4278352693449848", "4033316349932223", "6984776046497965", "5102647984983578", "6647-9447-2967-6310"]}, "output": ["Valid", "Valid", "Valid", "Valid", "Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["6994550685197761", "4247-8689-0652-4837", "6351249809303908"]}, "output": ["Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["4324078144139922", "5964-6053-2859-7724", "4811302791778917"]}, "output": ["Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["5786-5346-9592-7089", "5696-6718-9767-4381", "6510204663130157", "4931-8276-1374-8582", "4455061739404198", "4880-8276-8477-3622", "6912404529483530"]}, "output": ["Valid", "Valid", "Valid", "Valid", "Valid", "Valid", "Valid"]}, {"input": {"credit_card_numbers": ["4470-5474-4511-8912", "6144-6859-0007-4960", "4747-6226-2957-0024", "5161-0044-6267-1016"]}, "output": ["Valid", "Valid", "Valid", "Valid"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "NikolayVaklinov10/Python_Challenges", "path": "/Regex_and_Parsing/Validating_Credit_Card_Numbers.py", "msgidx": 6073}}
{"problem_description": "Given a 2x3 sliding puzzle board, where each tile is represented by an integer from 1 to 5, and an empty square is represented by 0, what is the minimum number of moves required to solve the puzzle? The puzzle is solved when the board is in the configuration [[1, 2, 3], [4, 5, 0]]. If it is impossible to solve the puzzle, return -1.", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2x3 list of integers representing the puzzle board. The integers range from 0 to 5, where 0 represents the empty tile.\n\nOutput:\n  `return` (int): The minimum number of moves required to solve the puzzle. If it is impossible to solve the puzzle, returns -1.", "refcode": "# import necessary packages\nimport collections\nimport heapq\nfrom typing import List\n\n# main function\ndef main_solution(board: List[List[int]]) -> int:\n    # Convert board to a tuple of tuples for hashable representation\n    def to_tup(arr):\n        return tuple(tuple(x) for x in arr)\n\n    # Generate neighbors of a given position (r, c)\n    def neighbors(r, c):\n        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n        for x, y in directions:\n            nr, nc = r + x, c + y\n            if 0 <= nr < R and 0 <= nc < C:\n                yield nr, nc\n\n    # Find the position of the empty tile (0)\n    def get_zero_pos():\n        for r in range(R):\n            for c in range(C):\n                if board[r][c] == 0:\n                    return r, c\n\n    # Dijkstra's algorithm to find the shortest path in the graph\n    def dijkstra(start, end):\n        q = [(0, start)]\n        seen = set()\n        while q:\n            cost, node = heapq.heappop(q)\n            if node not in seen:\n                seen.add(node)\n                if node == end:\n                    return cost\n                for nei in graph[node]:\n                    if nei not in seen:\n                        heapq.heappush(q, (cost + 1, nei))\n        return -1\n\n    # Initialize dimensions and find the initial position of the empty tile\n    R, C = len(board), len(board[0])\n    r_start, c_start = get_zero_pos()\n\n    # Convert the initial board to a tuple of tuples\n    first = to_tup(board)\n\n    # Build the graph using BFS\n    graph = collections.defaultdict(list)\n    seen = set()\n    q = [(first, r_start, c_start)]\n\n    while q:\n        node, r, c = q.pop(0)\n        if node not in seen:\n            seen.add(node)\n            for nr, nc in neighbors(r, c):\n                n_arr = list(list(x) for x in node)\n                n_arr[r][c], n_arr[nr][nc] = n_arr[nr][nc], n_arr[r][c]\n                nei = to_tup(n_arr)\n                if nei not in graph[node]:\n                    graph[node].append(nei)\n                graph[nei].append(node)\n                q.append((nei, nr, nc))\n\n    # Define the target state\n    nums = [i for i in range(1, R * C)] + [0]\n    end = to_tup([nums[i:i + C] for i in range(0, len(nums), C)])\n\n    # Use Dijkstra's algorithm to find the minimum number of moves\n    return dijkstra(first, end)", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 5, 3, 0, 4, 2], [3, 1, 4, 2, 0, 5]]}, "output": -1}, {"input": {"board": [[1, 3, 4, 2, 0, 5], [5, 3, 4, 2, 1, 0]]}, "output": -1}, {"input": {"board": [[3, 1, 4, 0, 5, 2], [4, 2, 3, 5, 0, 1]]}, "output": -1}, {"input": {"board": [[0, 1, 5, 2, 4, 3], [1, 4, 2, 5, 0, 3]]}, "output": -1}, {"input": {"board": [[0, 2, 1, 4, 5, 3], [5, 3, 2, 4, 1, 0]]}, "output": -1}, {"input": {"board": [[5, 4, 1, 0, 3, 2], [5, 4, 1, 3, 0, 2]]}, "output": -1}, {"input": {"board": [[4, 3, 0, 5, 2, 1], [0, 1, 5, 2, 3, 4]]}, "output": -1}, {"input": {"board": [[0, 2, 1, 3, 4, 5], [4, 2, 1, 5, 0, 3]]}, "output": -1}, {"input": {"board": [[2, 3, 5, 0, 1, 4], [3, 5, 1, 0, 2, 4]]}, "output": -1}, {"input": {"board": [[2, 1, 0, 3, 5, 4], [2, 3, 0, 5, 4, 1]]}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Kcheung42/Leet_Code", "path": "/0773_sliding_puzzle.py", "msgidx": 5533}}
{"problem_description": "Given a number of pairs of parentheses, how can we generate all possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate. It should be a positive integer.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of n pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def process(self, s, lis, left, right):\n        if left > right:\n            return \n        if left > 0:\n            self.process(s + '(', lis, left - 1, right)\n        if right > 0:\n            self.process(s + ')', lis, left, right - 1)\n        if left == 0 and right == 0:\n            lis.append(s)\n            return \n\n    def generateParenthesis(self, n):\n        left = n\n        right = n\n        lis = []\n        self.process('', lis, left, right)\n        return lis\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "caijie12138/Leecode", "path": "/\u62ec\u53f7\u5339\u914d.py", "msgidx": 6753}}
{"problem_description": "Given a string consisting solely of digits, how can we determine all possible valid IP address formats that can be derived from this string?", "io_requirements": "Input:\n  `input_string` (str): A string containing only digits, representing the input for which we need to find all possible valid IP addresses.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a valid IP address that can be formed from the input string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        return self.generateIpAddress([], s)\n\n    def generateIpAddress(self, ip_parts, s):\n        if len(ip_parts) == 4:\n            if not s:\n                return [\".\".join(ip_parts)]\n            return []\n        \n        valid_ips = []\n        for i in range(1, 4):\n            if i <= len(s):\n                part = s[:i]\n                if (part == '0' or not part.startswith('0')) and int(part) <= 255:\n                    valid_ips.extend(self.generateIpAddress(ip_parts + [part], s[i:]))\n        return valid_ips\n\n# main function\ndef main_solution(input_string):\n  # input_string is a string containing only digits\n  solution = Solution()\n  result = solution.restoreIpAddresses(input_string)\n  # result is a list of strings, each string is a valid IP address\n  return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "25616"}, "output": ["2.5.6.16", "2.5.61.6", "2.56.1.6", "25.6.1.6"]}, {"input": {"input_string": "142563932"}, "output": ["142.56.39.32"]}, {"input": {"input_string": "4790585"}, "output": ["47.90.5.85", "47.90.58.5"]}, {"input": {"input_string": "07914"}, "output": ["0.7.9.14", "0.7.91.4", "0.79.1.4"]}, {"input": {"input_string": "35239"}, "output": ["3.5.2.39", "3.5.23.9", "3.52.3.9", "35.2.3.9"]}, {"input": {"input_string": "060355610"}, "output": []}, {"input": {"input_string": "398379"}, "output": ["3.9.83.79", "3.98.3.79", "3.98.37.9", "39.8.3.79", "39.8.37.9", "39.83.7.9"]}, {"input": {"input_string": "24673721116"}, "output": []}, {"input": {"input_string": "465425862772"}, "output": []}, {"input": {"input_string": "041427108058"}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wumingpu/Leetcode", "path": "/algorithm/restore_ip_address.py", "msgidx": 6668}}
{"problem_description": "Sophia's drones have formed a social network where each drone can be connected to others through direct or indirect friendships. Given a list of direct connections between drones and the names of two specific drones, can you determine if these two drones are connected through any depth of friendships?", "io_requirements": "Input:\n  `network` (list of strings): A list of strings where each string represents a connection between two drones. Each string is formatted as \"drone1-drone2\".\n  `first` (string): The name of the first drone to check for a connection.\n  `second` (string): The name of the second drone to check for a connection.\n\nOutput:\n  `return` (boolean): `True` if there is a connection between the first and second drones through any depth of friends, otherwise `False`.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(network, first, second):\n    # Convert network to a list of tuples for easier processing\n    network = [tuple(pair.split('-')) for pair in network]\n    \n    # Create a dictionary to store the neighbors of each drone\n    neighbors = defaultdict(set)\n    for a, b in network:\n        neighbors[a].add(b)\n        neighbors[b].add(a)\n    \n    # Initialize sets for drones to visit and visited drones\n    to_visit, visited = {first}, set()\n    \n    # Perform a BFS to find if there's a connection between first and second\n    while to_visit:\n        current = to_visit.pop()\n        if current == second:\n            return True\n        visited.add(current)\n        to_visit.update(neighbors[current] - visited)\n    \n    return False", "funcname": "main_solution", "ios": [{"input": {"network": ["drone2-drone5", "drone4-drone1", "drone1-drone3", "drone7-drone5", "drone2-drone4", "drone5-drone6"], "first": "drone1", "second": "drone6"}, "output": true}, {"input": {"network": ["drone6-drone3", "drone5-drone4", "drone3-drone4", "drone4-drone5", "drone2-drone4"], "first": "drone3", "second": "drone1"}, "output": false}, {"input": {"network": ["drone1-drone3", "drone5-drone2", "drone6-drone2", "drone5-drone3", "drone3-drone6"], "first": "drone2", "second": "drone6"}, "output": true}, {"input": {"network": ["drone2-drone4", "drone2-drone6", "drone5-drone1", "drone4-drone1", "drone4-drone6"], "first": "drone4", "second": "drone5"}, "output": true}, {"input": {"network": ["drone3-drone1", "drone1-drone2", "drone1-drone2", "drone2-drone6", "drone3-drone5", "drone6-drone1"], "first": "drone1", "second": "drone7"}, "output": false}, {"input": {"network": ["drone7-drone4", "drone6-drone2", "drone6-drone7", "drone1-drone7", "drone3-drone1", "drone1-drone7"], "first": "drone4", "second": "drone5"}, "output": false}, {"input": {"network": ["drone5-drone3", "drone6-drone4", "drone4-drone6", "drone5-drone1", "drone4-drone7", "drone1-drone3"], "first": "drone3", "second": "drone7"}, "output": false}, {"input": {"network": ["drone5-drone4", "drone2-drone3", "drone3-drone4", "drone5-drone4", "drone6-drone3", "drone2-drone1"], "first": "drone5", "second": "drone2"}, "output": true}, {"input": {"network": ["drone1-drone7", "drone1-drone5", "drone6-drone7", "drone7-drone1", "drone1-drone4", "drone1-drone5"], "first": "drone4", "second": "drone5"}, "output": true}, {"input": {"network": ["drone3-drone6", "drone5-drone1", "drone7-drone1", "drone1-drone7", "drone4-drone5", "drone2-drone5"], "first": "drone1", "second": "drone7"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Phobosmir/checkio-home", "path": "/find-friends.py", "msgidx": 6263}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses? (The input variable is `n`.)", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def __init__(self):\n        self.results = []\n    \n    def divide2ways(self, n, tempArray: list, result: str):\n        if n == 0:\n            while len(tempArray) > 0:\n                tempArray.pop(-1)\n                result += \")\"\n            self.results.append(result)\n        else:\n            if len(tempArray) != 0:\n                tempResult = result\n                tempResult += \")\"\n                newTempArray = list(tempArray)\n                newTempArray.pop(-1)\n                self.divide2ways(n, newTempArray, tempResult)\n            tempArray.append(\"(\")\n            result += \"(\"\n            self.divide2ways(n - 1, tempArray, result)\n\n    def generateParenthesis(self, n: int):\n        self.divide2ways(n, [], \"\")\n        return self.results\n\n# main function\ndef main_solution(n: int):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return solution.generateParenthesis(n)", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["()()", "(())"]}, {"input": {"n": 3}, "output": ["()()()", "()(())", "(())()", "(()())", "((()))"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hundyoung/LeetCode", "path": "/leetcode/GenerateParentheses22.py", "msgidx": 6505}}
{"problem_description": "Given a CNF (Conjunctive Normal Form) formula represented as a list of clauses, where each clause is a list of integers (literals), determine whether the formula is satisfiable. The formula consists of `n` variables, and the clauses are provided in the `cnf` list. Additionally, an activity heuristic can be used to improve the variable ordering during the solving process. What is the result of the SAT solver for the given CNF formula?", "io_requirements": "Input:\n- `n` (int): The number of variables in the CNF formula.\n- `cnf` (List[List[int]]): The CNF formula represented as a list of clauses, where each clause is a list of integers (literals).\n- `activity_heuristic` (bool): Whether to use the activity heuristic for variable ordering. Default is True.\n\nOutput:\n- `return` (str): The result of the SAT solver, which can be \"SAT\" if the formula is satisfiable, or \"UNSAT\" if it is not.", "refcode": "# import necessary packages\nfrom collections import deque\nfrom itertools import groupby\nfrom typing import List, Union, Optional\n\n# Same type aliases\nLit = int\nVar = int\nClause = List[int]\nCNF = List[Clause]\nAssignment = List[Optional[bool]]\n\ndef preprocess(cnf: CNF) -> CNF:\n    \"\"\"Remove duplicate literals and clauses from a CNF formula.\"\"\"\n    cnf = [list(set(clause)) for clause in cnf]\n    cnf.sort()\n    return list(clause for clause, _ in groupby(cnf))\n\ndef lit(variable: Var, value: bool) -> Lit:\n    \"\"\" Accepts a variable x and a value. Returns the positive literal (`x`) if the value\n    is True, otherwise returns the negative literal (`-x`). \"\"\"\n    return variable if value else -variable\n\ndef bsign(literal: Lit, value: bool) -> Optional[bool]:\n    \"\"\"\n    Accepts a literal and a boolean value. If the literal is positive, the value is\n    returned; if the literal is negative, the negation of the value is returned.\n    If the value is None, however, the function always returns None.\n    \"\"\"\n    return None if value is None else value if literal > 0 else not value\n\nclass IterativePennSAT():\n    def __init__(self, n: int, cnf: CNF, activity_heuristic: bool = True):\n        self.n = n\n        self.cnf: CNF = preprocess(cnf)\n        self.assignment_stack: List[Assignment] = [[None] * (n + 1)]\n        if activity_heuristic:\n            self.var_ordering = self.compute_activity_ordering()\n        else:\n            self.var_ordering = list(range(1, n + 1))\n        self.decision_stack: List[Var] = []\n        self.clauses_watching: List[deque] = [deque() for i in range(2 * n + 1)]\n        self.propagation_queue: deque = deque()\n        self.decision = 0\n        self.next = 1\n        self.in_loop = 1\n        self.sat = []\n\n        for claws in self.cnf:\n            self.clauses_watching[claws[0]].append(claws)\n            if (len(claws) == 1):\n                continue\n            else:\n                self.clauses_watching[claws[1]].append(claws)\n\n    def value(self, literal: Lit) -> Optional[bool]:\n        \"\"\"Returns the value of the literal (`True`/`False`/`None`) under the current assignment.\"\"\"\n        return bsign(literal, self.assignment_stack[-1][abs(literal)])\n\n    def assume(self, literal: Lit) -> bool:\n        \"\"\"Assign the literal to `True` in the current assignment and add its negation to the\n        propagation queue. Returns False if the literal was already assigned to `False`;\n        otherwise returns True.\"\"\"\n        if self.value(literal) is False:\n            return False\n        elif self.value(literal) is True:\n            return True\n        else:\n            self.assignment_stack[-1][abs(literal)] = bsign(literal, True)\n            self.propagation_queue.append(literal * -1)\n            return True\n\n    def compute_activity_ordering(self) -> List[Var]:\n        \"\"\"Returns a list of variables [1..n] sorted by descending activity score\n        based on the stored CNF.\"\"\"\n        cnf = self.cnf\n        n = self.n\n        totals = [0 for i in range(n + 1)]\n        for clause in cnf:\n            factor = 1 / (2 ** len(clause))\n            for lit in clause:\n                totals[abs(lit)] += factor\n        original_totals = totals.copy()\n        totals = totals[1:]\n        totals = sorted(totals, reverse=True)\n        vars = []\n        for total in totals:\n            temp_index = original_totals.index(total)\n            vars.append(temp_index)\n            original_totals[temp_index] = -1\n        return vars\n\n    def pick_variable(self) -> Optional[Var]:\n        \"\"\"Returns the first unassigned variable in the stored variable ordering,\n        or `None` if all variables have been assigned.\"\"\"\n        for i in range(len(self.var_ordering)):\n            index = self.var_ordering[i]\n            if self.assignment_stack[-1][index] is None:\n                return index\n        return None\n\n    def propagate_from(self, false_literal: Lit) -> bool:\n        \"\"\"\n        Accepts as input a literal which has been assigned to `False`, and updates the\n        watched literals of every clause previously watching that literal in order to\n        maintain the 2 Watched Literals invariant, performing unit propagation as needed.\n        Returns `False` if a conflict occurs; otherwise `True`.\n        \"\"\"\n        for _ in range(len(self.clauses_watching[false_literal])):\n            clause = self.clauses_watching[false_literal].popleft()\n            if len(clause) == 1:\n                return False\n            if clause[1] != false_literal:\n                clause[0], clause[1] = clause[1], clause[0]\n            if self.value(clause[0]) is True:\n                self.clauses_watching[false_literal].append(clause)\n                continue\n            for i in range(2, len(clause)):\n                literal = clause[i]\n                if self.value(literal) is not False:\n                    clause[1], clause[i] = clause[i], clause[1]\n                    self.clauses_watching[clause[1]].append(clause)\n                    break\n            else:\n                self.clauses_watching[false_literal].append(clause)\n                if self.assume(clause[0]) is False:\n                    return False\n        return True\n\n    def unit_propagate(self) -> bool:\n        \"\"\"\n        Calls `propagate_from()` on every literal in the propagation queue\n        until the queue is empty. If we ever encounter a conflict, this\n        returns `False`; otherwise `True`.\n        \"\"\"\n        while self.propagation_queue:\n            literal = self.propagation_queue.popleft()\n            if (self.propagate_from(literal) is False):\n                return False\n        return True\n\n    def backtrack_and_assume_negation(self) -> None:\n        \"\"\"Undo the last decision and restore the previous partial assignment.\n        Then assume the negation of the last decision variable.\"\"\"\n        self.assignment_stack.pop()\n        self.propagation_queue = deque()\n        if not self.decision_stack: return\n        last_decision = self.decision_stack.pop()\n        self.assume(-1 * last_decision)\n        return\n\n    def solve(self) -> Union[str, List[Lit]]:\n        \"\"\"Return a satisfying assignment to the stored CNF, or return `'UNSAT'` if none exists.\"\"\"\n        if self.next == 1:\n            for clause in self.cnf:\n                if len(clause) == 1:\n                    if self.assume(clause[0]) is False:\n                        return \"UNSAT\"\n            self.next = 2\n            return\n\n        if self.next == 2:\n            if not self.unit_propagate():\n                return 'UNSAT'\n            self.next = 3\n            return\n\n        if self.next == 3:\n            while True:\n                if self.in_loop == 1:\n                    self.decision = self.pick_variable()\n                    if self.decision is None:\n                        break\n                    self.decision_stack.append(self.decision)\n                    new_assignment = self.assignment_stack[-1].copy()\n                    self.assignment_stack.append(new_assignment)\n                    self.in_loop = 2\n                    return\n\n                if self.in_loop == 2:\n                    self.assume(self.decision)\n                    self.in_loop = 3\n                    return\n\n                if self.in_loop == 3:\n                    if not self.unit_propagate():\n                        self.backtrack_and_assume_negation()\n                        if len(self.assignment_stack) == 0:\n                            return 'UNSAT'\n                        return\n                    self.in_loop = 1\n                    return\n            self.sat = [lit(x, self.value(x)) for x in range(1, self.n + 1)]\n            return \"SAT\"\n\n# main function\ndef main_solution(n: int, cnf: CNF, activity_heuristic: bool = True) -> str:\n    \"\"\"\n    Solves a CNF (Conjunctive Normal Form) SAT problem using the IterativePennSAT solver.\n    \n    Input:\n    - n (int): The number of variables in the CNF formula.\n    - cnf (List[List[int]]): The CNF formula represented as a list of clauses, where each clause is a list of integers (literals).\n    - activity_heuristic (bool): Whether to use the activity heuristic for variable ordering. Default is True.\n    \n    Output:\n    - return (str): The result of the SAT solver, which can be \"SAT\" if the formula is satisfiable, or \"UNSAT\" if it is not.\n    \"\"\"\n    solver = IterativePennSAT(n, cnf, activity_heuristic)\n    result = solver.solve()\n    while not (result == \"UNSAT\" or result == \"SAT\"):\n        result = solver.solve()\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3, "cnf": [[-1, -1, -2], [-1, 1, -1], [1]], "activity_heuristic": true}, "output": "SAT"}, {"input": {"n": 5, "cnf": [[5, -3, -3], [5, -1, -3, -2], [3]], "activity_heuristic": false}, "output": "SAT"}, {"input": {"n": 5, "cnf": [[-4, -3], [2, -3, 3, -5, 1], [3]], "activity_heuristic": true}, "output": "SAT"}, {"input": {"n": 8, "cnf": [[8, -1, -4], [-6, -6, 2], [-1, -1, -5, 4]], "activity_heuristic": true}, "output": "SAT"}, {"input": {"n": 3, "cnf": [[3], [1, 2], [-1]], "activity_heuristic": true}, "output": "SAT"}, {"input": {"n": 4, "cnf": [[1, 4], [3, -2], [-2, 2, -1, -1]], "activity_heuristic": true}, "output": "SAT"}, {"input": {"n": 6, "cnf": [[3], [-6, -2, 3, -2, -6], [-6, 6, -2]], "activity_heuristic": true}, "output": "SAT"}, {"input": {"n": 3, "cnf": [[-1, -1], [-1, 1, 3], [-3, 3]], "activity_heuristic": true}, "output": "SAT"}, {"input": {"n": 4, "cnf": [[-4], [-1, -1], [-4, 1, -2], [4, 1]], "activity_heuristic": true}, "output": "UNSAT"}, {"input": {"n": 3, "cnf": [[-2], [-1, 1], [2, -3, 1]], "activity_heuristic": true}, "output": "SAT"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nicotapiero/cis189FinalProject", "path": "/iterative_pennSAT.py", "msgidx": 5395}}
{"problem_description": "In a historical horse racing scenario, Qi Wang and Tian Ji each have three horses with different strengths. Qi Wang's horses are represented by a list of three integers in descending order, and Tian Ji's horses are represented by another list of three integers in descending order. What are the optimal race results that allow Tian Ji to win the majority of the races against Qi Wang?", "io_requirements": "Input:\n  `qi_wang` (list of int): A list of three integers representing the strengths of Qi Wang's horses in descending order.\n  `tian_ji` (list of int): A list of three integers representing the strengths of Tian Ji's horses in descending order.\n\nOutput:\n  `return` (list of list of tuple): A list of lists, where each inner list contains tuples representing the race results. Each tuple contains two integers, the first being the strength of Qi Wang's horse and the second being the strength of Tian Ji's horse.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(qi_wang, tian_ji):\n    \"\"\"\n    This function takes two lists representing the horses of Qi Wang and Tian Ji.\n    It returns the optimal race results that allow Tian Ji to win the race.\n    \n    Parameters:\n    qi_wang (list of int): List of integers representing the horses of Qi Wang.\n    tian_ji (list of int): List of integers representing the horses of Tian Ji.\n    \n    Returns:\n    list of list of tuple: A list of lists, where each inner list contains tuples representing the race results.\n    \"\"\"\n    match = []  # List to store the optimal race results\n    p2_l = list(itertools.permutations(tian_ji, 3))  # All possible permutations of Tian Ji's horses\n    \n    for p2 in p2_l:\n        game_win = 0\n        game = []\n        for q, t in zip(qi_wang, p2):\n            if q < t:\n                game_win += 1\n            game.append((q, t))\n        if game_win >= 2:\n            match.append(game)\n    \n    return match", "funcname": "main_solution", "ios": [{"input": {"qi_wang": [9, 6, 5], "tian_ji": [5, 2, 1]}, "output": []}, {"input": {"qi_wang": [10, 8, 7], "tian_ji": [7, 4, 1]}, "output": []}, {"input": {"qi_wang": [8, 5, 3], "tian_ji": [9, 5, 1]}, "output": [[[8, 9], [5, 1], [3, 5]], [[8, 1], [5, 9], [3, 5]]]}, {"input": {"qi_wang": [6, 6, 1], "tian_ji": [9, 6, 1]}, "output": [[[6, 9], [6, 1], [1, 6]], [[6, 1], [6, 9], [1, 6]]]}, {"input": {"qi_wang": [10, 9, 1], "tian_ji": [8, 6, 1]}, "output": []}, {"input": {"qi_wang": [8, 7, 6], "tian_ji": [6, 4, 1]}, "output": []}, {"input": {"qi_wang": [10, 3, 1], "tian_ji": [6, 4, 1]}, "output": [[[10, 1], [3, 6], [1, 4]], [[10, 1], [3, 4], [1, 6]]]}, {"input": {"qi_wang": [10, 7, 2], "tian_ji": [6, 2, 2]}, "output": []}, {"input": {"qi_wang": [8, 5, 1], "tian_ji": [5, 4, 1]}, "output": []}, {"input": {"qi_wang": [8, 6, 5], "tian_ji": [9, 6, 4]}, "output": [[[8, 9], [6, 4], [5, 6]], [[8, 4], [6, 9], [5, 6]]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sandrogaoyun/upgraded-garbanzo", "path": "/\u7530\u5fcc\u8d5b\u9a6c.py", "msgidx": 6639}}
{"problem_description": "Given a sequence of brackets, how can we determine if the sequence is balanced? A balanced sequence means that every opening bracket has a corresponding closing bracket in the correct order, and no subset of brackets within a matched pair is unbalanced.", "io_requirements": "Input:\n  `bracket_sequence` (str): A string containing only the characters '(', ')', '{', '}', '[', and ']'. This represents the sequence of brackets to be checked for balance.\n\nOutput:\n  `return` (bool): True if the bracket sequence is balanced, False otherwise.", "refcode": "# import necessary packages\nimport json\n\n# main function\ndef main_solution(bracket_sequence: str) -> bool:\n    \"\"\"\n    Determines if the given bracket sequence is balanced.\n\n    Args:\n        bracket_sequence (str): A string containing only the characters '(', ')', '{', '}', '[', and ']'.\n\n    Returns:\n        bool: True if the bracket sequence is balanced, False otherwise.\n    \"\"\"\n    # Dictionary to match opening and closing brackets\n    matching_bracket = {')': '(', '}': '{', ']': '['}\n    \n    # Stack to keep track of opening brackets\n    stack = []\n    \n    for char in bracket_sequence:\n        if char in matching_bracket.values():\n            # If the character is an opening bracket, push it onto the stack\n            stack.append(char)\n        elif char in matching_bracket.keys():\n            # If the character is a closing bracket, check if it matches the top of the stack\n            if stack == [] or matching_bracket[char] != stack.pop():\n                return False\n        else:\n            # If the character is not a bracket, return False\n            return False\n    \n    # If the stack is empty, all brackets were matched\n    return stack == []", "funcname": "main_solution", "ios": [{"input": {"bracket_sequence": "{({])((}{()["}, "output": false}, {"input": {"bracket_sequence": "{](){(){)[["}, "output": false}, {"input": {"bracket_sequence": "}"}, "output": false}, {"input": {"bracket_sequence": "]]({{}]{]{]"}, "output": false}, {"input": {"bracket_sequence": ")){][}][]}]}{]"}, "output": false}, {"input": {"bracket_sequence": "}[]{"}, "output": false}, {"input": {"bracket_sequence": "[[][]{(})](}(){(]){]"}, "output": false}, {"input": {"bracket_sequence": "[[}}}([})]"}, "output": false}, {"input": {"bracket_sequence": "})]{{){{})"}, "output": false}, {"input": {"bracket_sequence": "}[}})}[]{}"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "avinash-nonholonomy/hack_diversity_office_hours", "path": "/archive/stacks_and_queues_python/q3_balanced_brackets.py", "msgidx": 6692}}
{"problem_description": "Given a chessboard of size `n` x `n`, how can you place `n` queens on the board such that no two queens threaten each other? Each queen must be placed in a unique row and column, and no two queens can be on the same diagonal. What are all the possible configurations of the queens on the board?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (list of lists): A list of all possible solutions to the N-Queens problem for the given `n`. Each solution is represented as a list of integers where the index represents the column and the value at that index represents the row where the queen is placed. The solutions are sorted lexicographically.", "refcode": "# import necessary packages\nfrom collections import defaultdict, Counter\n\n# main function\ndef main_solution(n):\n    def has_no_diag(coord, placed):\n        i = coord[0]\n        j = coord[1]\n        while i >= 0 and j >= 0:\n            i -= 1\n            j -= 1\n            if (i, j) in placed:\n                return False\n\n        i = coord[0]\n        j = coord[1]\n        while i >= 0 and j < n:\n            i -= 1\n            j += 1\n            if (i, j) in placed:\n                return False\n        return True\n\n    stk = [((0, i), {(0, i)}, {j for j in range(n) if j != i}) for i in range(n)]\n    perms = []\n    retval = []\n    while stk:\n        curr, placed, cols = stk.pop(0)\n        if len(placed) == n:\n            if placed not in perms:\n                perms.append(placed)\n        x = curr[0]; y = curr[1]\n        if x == n-1:\n            continue\n        for j in range(n):\n            if (j < n and (j > y + 1)) or (j >= 0 and (j < y - 1)):\n                if j in cols  and has_no_diag((x+1, j), placed):\n                    new_tuple = ((x+1, j), placed.union({(x+1, j)}), cols - {j})\n                    stk.append(new_tuple)\n\n    for perm in perms:\n        ret = [0 for _ in range(n)]\n        for coord in perm:\n            col = coord[1]\n            row = coord[0]+1\n            ret[col] = row\n        retval.append(ret)\n    return sorted(retval)", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": [[1]]}, {"input": {"n": 6}, "output": [[2, 4, 6, 1, 3, 5], [3, 6, 2, 5, 1, 4], [4, 1, 5, 2, 6, 3], [5, 3, 1, 6, 4, 2]]}, {"input": {"n": 2}, "output": []}, {"input": {"n": 3}, "output": []}, {"input": {"n": 4}, "output": [[2, 4, 1, 3], [3, 1, 4, 2]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dbconfession78/interview_prep", "path": "/codefights/n_queens.py", "msgidx": 6222}}
{"problem_description": "Given a nested dictionary structure represented as a JSON string, and a specific path within this structure, what is the value associated with the key at the end of the path? The path is provided as a tuple of strings, where each string represents a key in the nested dictionary.", "io_requirements": "Input:\n  `json_structure` (str): A JSON string representing a nested dictionary structure.\n  `path` (tuple): A tuple of strings representing the path to the key whose value needs to be found.\n\nOutput:\n  `return` (str): The value of the key found at the specified path, converted to a string. If the key is not found, the return value will be an empty string.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef crawl(n, path):\n    def crawler(n, key):\n        for x in n:\n            if isinstance(x, dict):\n                for k, v in x.items():\n                    if k == key:\n                        yield v\n                    elif isinstance(v, dict):\n                        yield v\n            else:\n                try:\n                    i = iter(x)\n                    for j in i:\n                        if isinstance(j, dict):\n                            yield j\n                except:\n                    pass\n\n    p = []\n    r = n\n    value = None\n    for key in path:\n        while True:\n            for i in crawler(r, key):\n                if isinstance(i, dict):\n                    p.append(i)\n                else:\n                    value = i\n\n            if len(p) == 0:\n                break\n            else:\n                r = p\n                p = []\n\n    return value\n\n# main function\ndef main_solution(json_structure, path):\n    # Convert JSON string to dictionary\n    n = json.loads(json_structure)\n    \n    # Call the crawl function with the dictionary and path\n    result = crawl(n, path)\n    \n    # Return the result as a string\n    return str(result)", "funcname": "main_solution", "ios": [{"input": {"json_structure": "{\"key0\": 25, \"key1\": 94, \"key2\": 98.33574750898508, \"key3\": 22.908720439447222}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 39.64144637669035, \"key1\": 9.565405708209264, \"key2\": 74}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 77.22719398114664, \"key1\": 53, \"key2\": 94}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 34, \"key1\": 44, \"key2\": 17, \"key3\": 17.172290755817084}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 46.451628385154635, \"key1\": 60.27306288784213, \"key2\": 21.886308620175054}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 89, \"key1\": 28.675304633274322, \"key2\": 83.75345199656334, \"key3\": 93, \"key4\": 42}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": {\"key0\": 56, \"key1\": 84, \"key2\": 37.485229810393314, \"key3\": 95}, \"key1\": {\"key0\": 64}}", "path": ["key0", "key1"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 19, \"key1\": 10, \"key2\": 76.82332137295646, \"key3\": 95}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 43.34907368774567}", "path": ["key0"]}, "output": "None"}, {"input": {"json_structure": "{\"key0\": 90.45845142357607, \"key1\": 71, \"key2\": 93, \"key3\": 16.836462331320874}", "path": ["key0"]}, "output": "None"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yatinla/pycrawler", "path": "/pycrawler/pycrawler/crawler.py", "msgidx": 6362}}
{"problem_description": "Given a list of English words, what is the longest word that can be reduced one letter at a time, while each reduction still results in a valid English word?", "io_requirements": "Input:\n  `word_list` (str): A JSON serialized list of strings, where each string is a word that needs to be checked for reducibility.\n\nOutput:\n  `return` (str): A JSON serialized string representing the longest word that can be reduced one letter at a time while remaining a valid English word.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef is_reducible(word, word_set, memo):\n    if word in memo:\n        return memo[word]\n    if word == \"\":\n        memo[word] = True\n        return True\n    for i in range(len(word)):\n        child = word[:i] + word[i+1:]\n        if child in word_set and is_reducible(child, word_set, memo):\n            memo[word] = True\n            return True\n    memo[word] = False\n    return False\n\ndef find_longest_reducible_word(word_list):\n    word_set = set(word_list)\n    word_set.add(\"a\")\n    word_set.add(\"i\")\n    word_set.add(\"\")\n    memo = {}\n    longest_word = \"\"\n    for word in word_list:\n        if is_reducible(word, word_set, memo) and len(word) > len(longest_word):\n            longest_word = word\n    return longest_word\n\n# main function\ndef main_solution(word_list):\n    # Convert the input list of words to a JSON serializable format\n    word_list = json.loads(word_list)\n    \n    # Find the longest reducible word\n    longest_word = find_longest_reducible_word(word_list)\n    \n    # Convert the output to a JSON serializable format\n    return json.dumps(longest_word)", "funcname": "main_solution", "ios": [{"input": {"word_list": "[\"spit\", \"i\", \"a\"]"}, "output": "\"i\""}, {"input": {"word_list": "[\"a\", \"spit\", \"i\", \"pit\", \"it\"]"}, "output": "\"spit\""}, {"input": {"word_list": "[\"spite\", \"i\", \"sprite\", \"spit\", \"\", \"pit\"]"}, "output": "\"i\""}, {"input": {"word_list": "[\"it\", \"\", \"sprite\"]"}, "output": "\"it\""}, {"input": {"word_list": "[\"sprite\", \"i\", \"it\"]"}, "output": "\"it\""}, {"input": {"word_list": "[\"sprite\", \"pit\", \"spite\"]"}, "output": "\"\""}, {"input": {"word_list": "[\"\", \"sprite\", \"spite\"]"}, "output": "\"\""}, {"input": {"word_list": "[\"it\", \"a\"]"}, "output": "\"it\""}, {"input": {"word_list": "[\"it\", \"spit\", \"sprite\"]"}, "output": "\"it\""}, {"input": {"word_list": "[\"i\", \"it\", \"spit\", \"spite\", \"sprite\"]"}, "output": "\"it\""}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jessicabelfiore/python-exercises", "path": "/Chapter12/Exercise1206_UNFINISHED.py", "msgidx": 6656}}
{"problem_description": "Given a graph represented by a list of edges, where each edge connects two nodes, what is the order of nodes visited during a Depth-First Search (DFS) traversal starting from the first node in the list of edges?", "io_requirements": "Input:\n  `edgeList` (list of tuples): A list of tuples representing the edges of the graph. Each tuple contains two elements, which are the nodes connected by the edge. The nodes should be represented as strings.\n\nOutput:\n  `return` (list of strings): A list of strings representing the nodes visited during the Depth-First Search (DFS) traversal of the graph. The order of the nodes in the list reflects the order in which they were visited.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self):\n        self.graphDict = defaultdict(list)\n    \n    def addEdges(self, edgeList):\n        for edge in edgeList:\n            self.graphDict[edge[0]].append(edge[1])\n    \n    def DFS(self):\n        visitedlist = []\n        for node in list(self.graphDict.keys()):\n            visitedlist = self.visitnode(node, visitedlist)\n        return visitedlist\n    \n    def visitnode(self, node, visitedlist):\n        if node not in visitedlist:\n            visitedlist.append(node)\n            for neighbor in self.graphDict[node]:\n                visitedlist = self.visitnode(neighbor, visitedlist)\n        return visitedlist\n\n# main function\ndef main_solution(edgeList):\n    # Convert the edge list to a JSON serializable format\n    edgeList = [(str(edge[0]), str(edge[1])) for edge in edgeList]\n    \n    # Create a graph instance and add edges\n    graphInstance = Graph()\n    graphInstance.addEdges(edgeList)\n    \n    # Perform DFS and get the visited nodes list\n    visitedNodes = graphInstance.DFS()\n    \n    # Convert the visited nodes list to a JSON serializable format\n    visitedNodes = [str(node) for node in visitedNodes]\n    \n    return visitedNodes", "funcname": "main_solution", "ios": [{"input": {"edgeList": [["D", "Q"], ["B", "J"], ["J", "U"], ["S", "D"], ["B", "Q"]]}, "output": ["D", "Q", "B", "J", "U", "S"]}, {"input": {"edgeList": [["Q", "M"], ["B", "Q"], ["M", "Y"], ["B", "M"], ["W", "M"]]}, "output": ["Q", "M", "Y", "B", "W"]}, {"input": {"edgeList": [["K", "J"], ["C", "H"], ["J", "Q"], ["D", "K"], ["Q", "C"]]}, "output": ["K", "J", "Q", "C", "H", "D"]}, {"input": {"edgeList": [["J", "G"], ["M", "V"], ["G", "V"], ["S", "W"], ["G", "J"]]}, "output": ["J", "G", "V", "M", "S", "W"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Mehadisa18/Algorithms", "path": "/02_DFS.py", "msgidx": 6323}}
{"problem_description": "Given a set of digits from 1 to 9, what is the sum of all unique products that can be formed by multiplying a 2-digit number by a 3-digit number or a 1-digit number by a 4-digit number, such that the concatenated result of the multiplicand, multiplier, and product forms a 9-digit pandigital number (excluding the digit 0)?", "io_requirements": "Input:\n  `digits_set` (list of integers): A list of integers containing the digits from 1 to 9. This list represents the set of digits that will be used to form the multiplicands and multipliers.\n\nOutput:\n  `return` (integer): The sum of all unique products that are pandigital when concatenated with their multiplicands and multipliers.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(digits_set):\n    digits_set = set(digits_set)  # Convert list to set\n    unique_products = set()\n    \n    # Helper function to check if the product is pandigital\n    def check_result(multiplicand, multiplier):\n        product = multiplicand * multiplier\n        all_str = str(multiplicand) + str(multiplier) + str(product)\n        result_set = set(all_str)\n        if len(result_set) == 9 and '0' not in result_set:\n            return product\n        return 0\n    \n    # Check permutations for 2-digit multiplicand and 3-digit multiplier\n    for subset1 in itertools.permutations(digits_set, 2):\n        for subset2 in itertools.permutations(digits_set, 3):\n            multiplicand = subset1[0] * 10 + subset1[1]\n            multiplier = subset2[0] * 100 + subset2[1] * 10 + subset2[2]\n            product = check_result(multiplicand, multiplier)\n            if product > 0:\n                unique_products.add(product)\n    \n    # Check permutations for 1-digit multiplicand and 4-digit multiplier\n    for subset1 in itertools.permutations(digits_set, 1):\n        for subset2 in itertools.permutations(digits_set, 4):\n            multiplicand = subset1[0]\n            multiplier = subset2[0] * 1000 + subset2[1] * 100 + subset2[2] * 10 + subset2[3]\n            product = check_result(multiplicand, multiplier)\n            if product > 0:\n                unique_products.add(product)\n    \n    # Calculate the sum of unique products\n    sum_of_unique_products = sum(unique_products)\n    \n    return sum_of_unique_products", "funcname": "main_solution", "ios": [{"input": {"digits_set": [9, 1, 4, 5, 2, 6, 7, 8, 3]}, "output": 10415946}, {"input": {"digits_set": [5, 4, 2, 8, 1, 7, 9, 6, 3]}, "output": 10415946}, {"input": {"digits_set": [1, 9, 2, 6, 8, 4, 3, 5, 7]}, "output": 10415946}, {"input": {"digits_set": [5, 6, 9, 7, 4, 1, 3, 2, 8]}, "output": 10415946}, {"input": {"digits_set": [1, 2, 8, 3, 9, 6, 5, 7, 4]}, "output": 10415946}, {"input": {"digits_set": [1, 6, 7, 4, 3, 5, 8, 2, 9]}, "output": 10415946}, {"input": {"digits_set": [3, 6, 4, 5, 9, 2, 1, 8, 7]}, "output": 10415946}, {"input": {"digits_set": [7, 8, 4, 1, 6, 5, 9, 2, 3]}, "output": 10415946}, {"input": {"digits_set": [1, 5, 3, 7, 2, 8, 9, 4, 6]}, "output": 10415946}, {"input": {"digits_set": [8, 6, 7, 3, 2, 4, 9, 1, 5]}, "output": 10415946}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jnash67/eulerpython", "path": "/euler32.py", "msgidx": 6699}}
{"problem_description": "Given a list of parent-child pairs in the format \"(i1,i2)\", where i1 represents a child node and i2 represents its parent node, determine if these pairs can form a valid binary tree. A valid binary tree must satisfy the following conditions:\n- Each node can have at most one parent.\n- Each node can have at most two children.\n- There must be exactly one root node (a node with no parent).\n\nWhat is the result of evaluating whether the given list of pairs can form a valid binary tree?", "io_requirements": "Input:\n  `strArr` (list of str): A list of strings where each string is a pair of integers in the format \"(i1,i2)\", \n                          representing a child node i1 and its parent node i2.\n\nOutput:\n  `return` (str): \"true\" if a valid binary tree can be formed, otherwise \"false\".", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(strArr):\n    \"\"\"\n    Determines if the given list of parent-child pairs can form a valid binary tree.\n\n    Args:\n    strArr (list of str): A list of strings where each string is a pair of integers in the format \"(i1,i2)\", \n                          representing a child node i1 and its parent node i2.\n\n    Returns:\n    str: \"true\" if a valid binary tree can be formed, otherwise \"false\".\n    \"\"\"\n    parent_count = defaultdict(int)\n    child_count = defaultdict(int)\n    nodes = set()\n\n    for pair in strArr:\n        child, parent = map(int, pair.strip('()').split(','))\n        parent_count[parent] += 1\n        child_count[child] += 1\n        nodes.add(child)\n        nodes.add(parent)\n\n        # A node cannot have more than one parent\n        if child_count[child] > 1:\n            return \"false\"\n\n    # A valid binary tree should have exactly one root (a node with no parent)\n    root_count = 0\n    for node in nodes:\n        if parent_count[node] == 0:\n            root_count += 1\n        # A node cannot have more than 2 children\n        if parent_count[node] > 2:\n            return \"false\"\n\n    if root_count != 1:\n        return \"false\"\n\n    return \"true\"", "funcname": "main_solution", "ios": [{"input": {"strArr": ["(26,82)"]}, "output": "true"}, {"input": {"strArr": ["(67,43)", "(99,65)", "(33,17)", "(18,22)", "(18,88)", "(46,92)"]}, "output": "false"}, {"input": {"strArr": ["(12,83)", "(98,67)", "(10,65)", "(32,52)"]}, "output": "false"}, {"input": {"strArr": ["(24,60)", "(60,94)", "(64,37)"]}, "output": "false"}, {"input": {"strArr": ["(56,85)", "(28,3)", "(100,96)", "(33,81)"]}, "output": "false"}, {"input": {"strArr": ["(54,37)", "(25,2)", "(98,60)", "(60,88)", "(78,9)", "(7,48)", "(18,15)"]}, "output": "false"}, {"input": {"strArr": ["(98,41)", "(7,90)", "(11,48)", "(98,80)", "(2,2)", "(88,21)", "(45,70)", "(64,51)", "(52,67)", "(77,36)"]}, "output": "false"}, {"input": {"strArr": ["(49,70)", "(71,70)"]}, "output": "false"}, {"input": {"strArr": ["(18,47)", "(6,23)", "(100,88)", "(25,22)", "(47,62)", "(26,89)", "(84,4)", "(3,98)", "(4,98)", "(73,33)"]}, "output": "false"}, {"input": {"strArr": ["(54,14)", "(30,15)", "(26,98)"]}, "output": "false"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "taroserigano/coderbyte", "path": "/Trees & Graphs/TreeConstructor.py", "msgidx": 6391}}
{"problem_description": "Given a set of 8 cities with known coordinates, a salesman needs to visit each city exactly once and return to the starting city. The travel cost between any two cities is the Euclidean distance between their coordinates. Using a hill-climbing algorithm, what is the optimal order of cities to visit and the corresponding minimum travel cost?", "io_requirements": "Input:\n  `initial_path` (list of integers): A list of integers representing the initial order of cities to visit. The integers should be between 1 and 8, inclusive, and should be unique.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `shortest_path` (list of integers): A list of integers representing the optimal order of cities to visit to minimize the travel cost.\n    - `min_cost` (float): The minimum travel cost corresponding to the optimal path.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef cities():\n    distances = [[0 for i in range(8)] for j in range(8)]\n    x_y = [[2,3],[4,5],[7,3],[8,2],[2,7],[2,2],[3,7],[12,4]]\n    for i in range(len(x_y)):\n        for j in range(len(x_y)):\n            x = x_y[j][0] - x_y[i][0]\n            y = x_y[j][1] - x_y[i][1]\n            distances[i][j] = math.sqrt(x*x + y*y)\n    return distances\n\ndef cost(path):\n    l = len(path)\n    cost = 0\n    distances = cities()\n    \n    for i in range(l-1):\n        cost = cost + distances[path[i]-1][path[i+1]-1]\n    cost = cost + distances[path[l-1]-1][path[0]-1]\n    return cost\n\ndef hill_climb(path):\n    path_cost = cost(path)\n    temp_cost = path_cost\n    pathf = list(path)\n    done = 0\n    \n    while done == 0:\n        done = 1\n        \n        for i in range(len(path)-1):\n            for j in range(i+1, len(path)):\n                neighbor = list(path)\n                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]\n                cost_neighbor = cost(neighbor)\n                if cost_neighbor < temp_cost:\n                    done = 0\n                    temp_cost = cost_neighbor\n                    pathf = list(neighbor)\n                    break\n        \n        path_cost = temp_cost\n        path = list(pathf)\n    \n    return pathf, temp_cost\n\n# main function\ndef main_solution(initial_path):\n    # Convert input to the required format\n    initial_path = list(initial_path)\n    \n    # Call the hill_climb function\n    shortest_path, min_cost = hill_climb(initial_path)\n    \n    # Convert output to JSON serializable format\n    shortest_path = [int(x) for x in shortest_path]\n    min_cost = float(min_cost)\n    \n    return {\"shortest_path\": shortest_path, \"min_cost\": min_cost}", "funcname": "main_solution", "ios": [{"input": {"initial_path": [2, 5, 8, 4, 6, 7, 3, 1]}, "output": {"shortest_path": [6, 3, 4, 8, 2, 7, 5, 1], "min_cost": 27.283694756763797}}, {"input": {"initial_path": [8, 1, 7, 3, 5, 4, 2, 6]}, "output": {"shortest_path": [6, 4, 8, 3, 2, 7, 5, 1], "min_cost": 27.412774721556143}}, {"input": {"initial_path": [6, 8, 4, 2, 1, 7, 3, 5]}, "output": {"shortest_path": [3, 4, 8, 2, 7, 5, 1, 6], "min_cost": 27.2836947567638}}, {"input": {"initial_path": [4, 6, 2, 8, 3, 1, 5, 7]}, "output": {"shortest_path": [1, 6, 4, 8, 3, 2, 7, 5], "min_cost": 27.412774721556143}}, {"input": {"initial_path": [2, 1, 7, 3, 8, 5, 4, 6]}, "output": {"shortest_path": [1, 5, 7, 2, 8, 4, 3, 6], "min_cost": 27.2836947567638}}, {"input": {"initial_path": [3, 8, 4, 5, 6, 7, 2, 1]}, "output": {"shortest_path": [3, 4, 8, 2, 7, 5, 1, 6], "min_cost": 27.2836947567638}}, {"input": {"initial_path": [5, 4, 7, 6, 3, 2, 8, 1]}, "output": {"shortest_path": [5, 7, 8, 4, 3, 2, 6, 1], "min_cost": 28.58428504880579}}, {"input": {"initial_path": [4, 2, 5, 7, 1, 6, 8, 3]}, "output": {"shortest_path": [3, 2, 7, 5, 1, 6, 4, 8], "min_cost": 27.412774721556147}}, {"input": {"initial_path": [3, 1, 7, 8, 2, 5, 6, 4]}, "output": {"shortest_path": [4, 3, 6, 1, 5, 7, 2, 8], "min_cost": 27.283694756763797}}, {"input": {"initial_path": [3, 8, 7, 4, 5, 2, 6, 1]}, "output": {"shortest_path": [3, 4, 8, 2, 7, 5, 1, 6], "min_cost": 27.2836947567638}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "arpitg1304/Artificial-Intelligence", "path": "/hill_climb.py", "msgidx": 6346}}
{"problem_description": "Given the concept of left truncatable primes, which are prime numbers that remain prime when the leftmost digit is successively removed, what is the largest left truncatable prime or how many such primes exist?", "io_requirements": "Input:\n- `operation` (str): A string indicating the operation to perform. Can be either \"largest\" or \"count\".\n\nOutput:\n- `return` (int): The result of the operation. If \"largest\", returns the largest left truncatable prime. If \"count\", returns the number of left truncatable primes.", "refcode": "# import necessary packages\nfrom collections import namedtuple\nfrom sympy import isprime\n\n# main function\ndef main_solution(operation):\n    \"\"\"\n    Computes either the largest left truncatable prime or counts the number of left truncatable primes.\n\n    Args:\n    operation (str): A string indicating the operation to perform. Can be either \"largest\" or \"count\".\n\n    Returns:\n    int: The result of the operation. If \"largest\", returns the largest left truncatable prime. If \"count\", returns the number of left truncatable primes.\n    \"\"\"\n    # Prime.value is the value of the prime number\n    # Prime.k is the power of 10 needed to generate the first digit\n    Prime = namedtuple('Prime', ['value', 'k'])\n\n    # list single digit prime numbers\n    prime_list = [Prime(x, 0) for x in (2, 3, 5, 7)]\n\n    if operation == \"largest\":\n        N = max([prime.value for prime in prime_list])\n        while prime_list:\n            prime = prime_list.pop(0)\n            for t in range(1, 10):\n                n = t * 10 ** (prime.k + 1) + prime.value\n                if isprime(n):\n                    prime_list.append(Prime(n, prime.k + 1))\n                    N = max(n, N)\n        return N\n\n    elif operation == \"count\":\n        count = 0\n        while prime_list:\n            prime = prime_list.pop(0)\n            count += 1\n            for t in range(1, 10):\n                n = t * 10 ** (prime.k + 1) + prime.value\n                if isprime(n):\n                    prime_list.append(Prime(n, prime.k + 1))\n        return count\n\n    else:\n        raise ValueError(\"Invalid operation. Choose either 'largest' or 'count'.\")", "funcname": "main_solution", "ios": [{"input": {"operation": "largest"}, "output": 357686312646216567629137}, {"input": {"operation": "count"}, "output": 4260}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "harry-zuzan/trprimes", "path": "/src/trprimes/truncp.py", "msgidx": 6366}}
{"problem_description": "Given a number, what is the sum of all amicable numbers that are less than this number? Amicable numbers are pairs of numbers where each number is the sum of the proper divisors of the other, and they are not equal to each other.", "io_requirements": "Input:\n  `limit` (int): The upper limit for finding amicable numbers. It should be a positive integer.\n\nOutput:\n  `return` (int): The sum of all amicable numbers under the given limit.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef sumofdivisors(x):\n    sumDivisors = 0\n    for i in range(1, x):\n        if x % i == 0: sumDivisors += i\n    return sumDivisors\n\ndef isAmicable(x):\n    y = sumofdivisors(x)\n    if x == sumofdivisors(y) and y == sumofdivisors(x) and x != y:\n        return (x, y)\n    else: return 0\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    finalList = []\n    for i in range(1, limit + 1):\n        amicables = isAmicable(i)\n        if amicables != 0 and amicables[1] not in finalList:\n            finalList.append(amicables[0])\n            finalList.append(amicables[1])\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(finalList)", "funcname": "main_solution", "ios": [{"input": {"limit": 3417}, "output": 8442}, {"input": {"limit": 6881}, "output": 31626}, {"input": {"limit": 1464}, "output": 2898}, {"input": {"limit": 7587}, "output": 31626}, {"input": {"limit": 8665}, "output": 31626}, {"input": {"limit": 7417}, "output": 31626}, {"input": {"limit": 8778}, "output": 31626}, {"input": {"limit": 6155}, "output": 19026}, {"input": {"limit": 7767}, "output": 31626}, {"input": {"limit": 6201}, "output": 19026}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "danjpark/python-projecteuler", "path": "/021.py", "msgidx": 6626}}
{"problem_description": "Given a set of equations involving variables represented by lowercase letters, where each equation can either state that two variables are equal or not equal, determine whether it is possible to assign integers to these variables such that all the equations are satisfied. What is the result of this determination?", "io_requirements": "Input:\n  `equations` (List[str]): A list of strings where each string represents an equation. Each equation is of length 4 and can be either \"a==b\" or \"a!=b\", where 'a' and 'b' are lowercase letters representing variable names.\n\nOutput:\n  `return` (bool): A boolean value indicating whether it is possible to assign integers to the variable names such that all given equations are satisfied. Returns `True` if possible, otherwise `False`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        recoder = [[] for _ in range(26)]\n        for equa in equations:\n            if equa[1] == '=':\n                x = ord(equa[0]) - ord('a')\n                y = ord(equa[3]) - ord('a')\n                recoder[x].append(y)\n                recoder[y].append(x)\n        color = [None] * 26\n        t = 0\n        for start in range(26):\n            if color[start] is None:\n                t = t + 1\n                count = [start]\n                while count:\n                    num = count.pop()\n                    for i in recoder[num]:\n                        if color[i] is None:\n                            color[i] = t\n                            count.append(i)\n        for end in equations:\n            if end[1] == '!':\n                if end[0] == end[3]:\n                    return False\n                elif color[ord(end[0]) - ord('a')] is not None and color[ord(end[0]) - ord('a')] == color[\n                    ord(end[3]) - ord('a')]:\n                    return False\n        return True\n\n# main function\ndef main_solution(equations: List[str]) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.equationsPossible(equations)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"equations": ["m==a", "k!=q", "g==c", "c!=j", "q!=l", "x==b"]}, "output": true}, {"input": {"equations": ["m!=p", "z==r", "r!=r", "e!=w", "t==j"]}, "output": false}, {"input": {"equations": ["q!=s", "l==s", "l==b", "x!=z", "x==j", "n==s", "e==x", "f!=p", "p!=k"]}, "output": true}, {"input": {"equations": ["w==o", "d==j", "e!=x"]}, "output": true}, {"input": {"equations": ["o==m", "c==t", "m==s", "b!=o", "x!=k", "p==y", "a==j", "c==g", "s!=v"]}, "output": true}, {"input": {"equations": ["p!=p", "k!=u"]}, "output": false}, {"input": {"equations": ["f!=c", "u==q", "x!=i", "f==u"]}, "output": true}, {"input": {"equations": ["j==i", "p==s", "s!=p", "r==z", "q!=c", "w==w", "l!=z", "l==q"]}, "output": false}, {"input": {"equations": ["d!=f", "l!=c", "f!=k", "n==y"]}, "output": true}, {"input": {"equations": ["u==a"]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GuocaiL/AlgorithmExe", "path": "/leetcode/Satisfiability_of_ Equality_Equations.py", "msgidx": 6765}}
{"problem_description": "Given a partially filled Sudoku board, what is the complete and correct configuration of the board that satisfies all Sudoku rules? The input is a string representing the initial state of the Sudoku board, where each character is either a digit (1-9) or a period (.) representing an empty cell. The output should be a string representing the solved Sudoku board if a solution exists, or \"No solution found\" if no solution is possible.", "io_requirements": "Input:\n  `sudoku_string` (str): A string representing the initial state of a Sudoku board. The string should be 81 characters long, where each character is either a digit (1-9) or a period (.) representing an empty cell. The string is read row by row from top-left to bottom-right.\n\nOutput:\n  `return` (str): A string representing the solved Sudoku board if a solution exists. The string is 81 characters long, where each character is a digit (1-9). If no solution is found, the string will be \"No solution found\".", "refcode": "# import necessary packages\nimport heapq\nfrom time import time\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef blankBoard():\n    board = {}\n    for i in range(9):\n        for j in range(9):\n            board[ (i,j) ] = '.'\n    return board\n\nALL_COORDINATES = []\nfor i in range(9):\n    for j in range(9):\n        ALL_COORDINATES.append( (i,j) )\n\ndef makeBoard(string):\n    b = blankBoard()\n    for i in range(9):\n        for k in range(9):\n            sub = string[9*i+k]\n            b[(i,k)] = sub\n    return b\n\ndef findNeighbors(board, row, col):\n    nbrs = set()\n    for i in range(9):\n        if i != row: nbrs.add((i,col))\n        if i != col: nbrs.add((row, i))\n    rowQuad = row // 3\n    colQuad = col // 3\n    for i in range(3):\n        for j in range(3):\n            nR = i+rowQuad*3\n            nC = j+colQuad*3\n            if nR != row and nC != col and (nR,nC) not in nbrs: nbrs.add( (nR,nC) )\n    return nbrs\n\ndef isCorrect(board):\n    for i in range(9):\n        rows = set()\n        cols = set()\n        for j in range(9):\n            val = board[ (i, j) ]\n            if val in rows or val == '.': return False\n            rows.add(val)\n            val = board[ (j,i) ]\n            if val in cols: return False\n            cols.add(val)\n    for i in range(3):\n        for j in range(3):\n            tQuad = set()\n            for k in range(3):\n                for m in range(3):\n                    val = board[ (3*i+k,3*j+m) ]\n                    if val in tQuad: return False\n                    tQuad.add(val)\n    return True\n\ndef isWrong(board):\n    for i in range(9):\n        rows = set()\n        cols = set()\n        for j in range(9):\n            val = board[ (i, j) ]\n            if val in rows and val != '.': return True\n            rows.add(val)\n            val = board[ (j,i) ]\n            if val in cols and val != '.': return True\n            cols.add(val)\n    for i in range(3):\n        for j in range(3):\n            tQuad = set()\n            for k in range(3):\n                for m in range(3):\n                    val = board[ (3*i+k,3*j+m) ]\n                    if val in tQuad and val != '.': return True\n                    tQuad.add(val)\n    return False\n\ndef dictHelper2(b,p,nums):\n    if isCorrect(b): return (True,b)\n    if isWrong(b): return (False,b)\n    minC = (-1,-1)\n    minNum = 10\n    minSet = set()\n    for c in ALL_COORDINATES:\n        if b[c] == '.' and nums[c] < minNum: \n            minC = c\n            minNum = nums[c]\n            minSet = p[c]\n    if minNum == 10: print(\"minNum still 10\")\n    minCR,minCC = minC\n    for eachPossibility in minSet.copy():\n        rmList=[]\n        b[minC]=eachPossibility\n        for eachNeighbor in findNeighbors(b,minCR,minCC):\n            if eachNeighbor != minC and eachPossibility in p[eachNeighbor]:\n                rmList.append(eachNeighbor)\n                newSet = p[eachNeighbor]\n                newSet.remove(eachPossibility)\n                p[eachNeighbor]=newSet\n                newN = nums[eachNeighbor] \n                newN-= 1\n                nums[eachNeighbor]=newN \n        ans,bo = dictHelper2(b,p,nums)\n        if ans:return (True,bo)\n        guess=b[minC]\n        b[minC]='.'\n        for changed in rmList:\n            nSet=p[changed]\n            nSet.add(guess)\n            p[changed]=nSet\n            nN=nums[changed]\n            nN+=1\n            nums[changed]=nN\n    return (False,b)\n\ndef dictionaryAttempt2(b,p):\n    newB=b\n    nums={}\n    for c in b.keys():\n        nums[c]=len(p[c])\n    return dictHelper2(newB,p,nums)\n\ndef makePossibilities(board):\n    neighbors ={}\n    for r in range(9):\n        for c in range(9):\n            toAdd = set() \n            allTheNeighbors = findNeighbors(board,r,c)\n            neighborValues = set()\n            for i in allTheNeighbors:\n                if board[i] is not '.':neighborValues.add(board[i])\n            for j in range(1,10):\n                if str(j) not in neighborValues: toAdd.add(str(j))\n            neighbors[ (r,c) ] = toAdd\n    return neighbors\n\n# main function\ndef main_solution(sudoku_string):\n    board = makeBoard(sudoku_string)\n    possibilities = makePossibilities(board)\n    solved, solved_board = dictionaryAttempt2(board, possibilities)\n    if solved:\n        result = ''.join([solved_board[(i, j)] for i in range(9) for j in range(9)])\n    else:\n        result = \"No solution found\"\n    return result", "funcname": "main_solution", "ios": [{"input": {"sudoku_string": "39..6....1...3.7.8..8.12...5...8.3248........2.....1.............1.....6......5.."}, "output": "395867412142935768678412935569781324814329657237654189956148273421573896783296541"}, {"input": {"sudoku_string": "...5.....7.........5............3.51.2......9514.6........8..1..784....614.6....."}, "output": "381526974796314825452798163967843251823157649514962738639285417278431596145679382"}, {"input": {"sudoku_string": ".....9..3...3.72.4...4...9...........5.69...11.72....6...8...1.....3.....13......"}, "output": "724589163981367254365412798639174582258693471147258936592846317476931825813725649"}, {"input": {"sudoku_string": "9.1..537..7.1.................9...34..9.3.6.....6..........1...8...6.......2584.."}, "output": "961425378378196542542873961256987134419532687783614259695741823824369715137258496"}, {"input": {"sudoku_string": "...5....7..42..........4.1..4.1..........953...9.......859......3...5......36..58"}, "output": "691538427854217693372694815543126789168479532729853164285941376936785241417362958"}, {"input": {"sudoku_string": "1.4.68..............3.......67...3.......7...8...3..769......6.7863..2..2........"}, "output": "194768532678523491523149687467982315359617824812435976935274168786351249241896753"}, {"input": {"sudoku_string": "5.....6.12......5.9.1.........3.....3..6.2...6..............9.81.6..8..3...75..1."}, "output": "534897621267413859981265437745389162318642795629571384452136978176928543893754216"}, {"input": {"sudoku_string": "..9..7....16..4.7......2....45..3.....85....73........5......8.86.....1......8.5."}, "output": "459687132216354978783912564645273891198546327372891645531729486867435219924168753"}, {"input": {"sudoku_string": "4....3...5.1.9.4..7..4.......4.......1..7.....9.6......5.13..641.3...8..........."}, "output": "469853172531297486728461395684512937215379648397684521952138764143726859876945213"}, {"input": {"sudoku_string": "7........2..5..64....7.........1...8.....7........5.69.4..58....9....8....5.79..6"}, "output": "739642581281593647564781923356914278918267435472835169643158792197326854825479316"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jcschefer/sudoku", "path": "/sudoku_Torbert_7_2017jschefer.py", "msgidx": 5959}}
{"problem_description": "Given a deck of cards and a series of operations to be performed on the deck, what will be the final order of the cards after all operations are applied? The operations include dealing the cards into a new stack, dealing with an increment, and cutting the deck. The deck size and the operations are provided.", "io_requirements": "Input:\n  `deck_size` (int): The size of the deck, which is the number of cards in the deck.\n  `card_operations` (list of str): A list of strings where each string represents a card operation to be performed on the deck. Each string should follow the format of the operations defined in the `commands` dictionary.\n\nOutput:\n  `return` (list of int): A list representing the final order of the cards in the deck after performing all the specified operations.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ncommand_re = re.compile('([a-z ]+)([\\d-]*)')\n\ndef modulo(n, deck):\n    len_deck = len(deck)\n    stack = [i for i in range(len_deck)]\n    for i in range(len_deck):\n        stack[i*n % len_deck] = deck[i]\n    return stack\n\ncommands = {\n    'deal into new stack': lambda n: lambda deck: [deck[x] for x in range(len(deck)-1, -1, -1)],\n    'deal with increment': lambda n: lambda deck: modulo(n, deck),\n    'cut': lambda n: lambda deck: deck[n:] + deck[:n],\n}\n\ndef get_deck_operator(deck_operation):\n    m = command_re.search(deck_operation)\n    [command, argument] = [m.group(1).strip(), int('0' if m.group(2) == '' else m.group(2))]\n    return commands.get(command)(argument)\n\ndef shuffle(deck, techniques):\n    stack = deck\n    for t in techniques:\n        c = get_deck_operator(t)\n        stack = c(stack)\n    return stack\n\n# main function\ndef main_solution(deck_size, card_operations):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  deck = [i for i in range(deck_size)]\n  shuffled_deck = shuffle(deck, card_operations)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return shuffled_deck", "funcname": "main_solution", "ios": [{"input": {"deck_size": 17, "card_operations": ["deal into new stack"]}, "output": [16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]}, {"input": {"deck_size": 13, "card_operations": ["cut 4", "cut -7", "cut 3", "deal into new stack"]}, "output": [12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]}, {"input": {"deck_size": 11, "card_operations": ["cut 2", "cut 4"]}, "output": [6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5]}, {"input": {"deck_size": 12, "card_operations": ["cut -5", "cut 3", "deal into new stack"]}, "output": [9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 11, 10]}, {"input": {"deck_size": 12, "card_operations": ["deal with increment 2", "deal with increment 7"]}, "output": [6, 7, 7, 9, 8, 11, 9, 1, 10, 3, 11, 5]}, {"input": {"deck_size": 15, "card_operations": ["deal into new stack", "deal with increment 8", "cut 4", "cut -12"]}, "output": [0, 13, 11, 9, 7, 5, 3, 1, 14, 12, 10, 8, 6, 4, 2]}, {"input": {"deck_size": 12, "card_operations": ["cut -11", "deal into new stack", "deal into new stack"]}, "output": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]}, {"input": {"deck_size": 11, "card_operations": ["deal with increment 3", "cut 2"]}, "output": [8, 1, 5, 9, 2, 6, 10, 3, 7, 0, 4]}, {"input": {"deck_size": 17, "card_operations": ["deal into new stack", "cut 10"]}, "output": [6, 5, 4, 3, 2, 1, 0, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7]}, {"input": {"deck_size": 18, "card_operations": ["cut -13", "deal with increment 1", "deal into new stack", "deal into new stack"]}, "output": [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 0, 1, 2, 3, 4]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "h9h/adventofcode-2019", "path": "/22/part1.py", "msgidx": 6312}}
{"problem_description": "Given a range of indices, what is the sum of all 9-digit pandigital numbers that can be generated within this range, where each number is divisible by the first seven prime numbers (2, 3, 5, 7, 11, 13, 17) when taken as substrings of three digits starting from the second digit?", "io_requirements": "Input:\n- `start_index` (int): The starting index for generating pandigital numbers.\n- `end_index` (int): The ending index for generating pandigital numbers.\n\nOutput:\n- `return` (int): The sum of all pandigital numbers within the specified range that satisfy the super-divisibility condition.", "refcode": "# import necessary packages\nfrom math import sqrt, factorial\n\n# all class and function definitions in the code file, if any\ndef isprime(n):  # returns 1 if n is prime, 0 if n is composite\n    if n < 2:\n        return None\n    if n < 4:\n        return 1\n    t = int(sqrt(n))\n    for i in range(2, t + 1):\n        if n % i == 0:\n            return 0\n    return 1\n\ndef numtobasef(num, l):  # computes the l-\"digit\" \"base\" factorial representation of num\n    basef = [0] * l\n    for i in range(l):\n        basef[i] = num // factorial(l - i)\n        num -= basef[i] * factorial(l - i)\n    return basef\n\ndef baseftoperm(basef):  # converts a base-factorial representation to the corresponding permutation\n    basef.append(0)\n    l = len(basef)\n    perm = [0] * l\n    for i in range(l):\n        while perm[i] in perm[:i]:\n            perm[i] += 1\n        for j in range(basef[i]):\n            perm[i] += 1\n            while perm[i] in perm[:i]:\n                perm[i] += 1\n    return perm\n\ndef pandigit(n):\n    perm = map(str, baseftoperm(numtobasef(n + 362880, 9)))\n    number = ''.join(perm)\n    return number\n\ndef superdivis(p):\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    for i in range(7):\n        if int(p[1 + i:4 + i]) % primes[i] != 0:\n            return 0\n    return 1\n\n# main function\ndef main_solution(start_index, end_index):\n    total = 0\n    for i in range(start_index, end_index + 1):\n        p = pandigit(i)\n        if superdivis(p):\n            total += int(p)\n    return total", "funcname": "main_solution", "ios": [{"input": {"start_index": 125139, "end_index": 131311}, "output": 0}, {"input": {"start_index": 392176, "end_index": 400096}, "output": 0}, {"input": {"start_index": 709030, "end_index": 713089}, "output": 0}, {"input": {"start_index": 589124, "end_index": 594957}, "output": 0}, {"input": {"start_index": 379325, "end_index": 381075}, "output": 0}, {"input": {"start_index": 937342, "end_index": 945138}, "output": 0}, {"input": {"start_index": 441965, "end_index": 450396}, "output": 0}, {"input": {"start_index": 155506, "end_index": 158170}, "output": 0}, {"input": {"start_index": 977411, "end_index": 986624}, "output": 0}, {"input": {"start_index": 243044, "end_index": 244940}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "diamondstone/project-euler", "path": "/python/pe43.py", "msgidx": 6607}}
{"problem_description": "Given a number, a circular prime is defined as a prime number where all rotations of its digits are also prime numbers. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers. How many circular primes are there below a given number `limit`?", "io_requirements": "Input:\n  `limit` (int): The upper limit (exclusive) for finding circular primes. For example, if `limit` is 100, the function will find circular primes below 100.\n\nOutput:\n  `return` (int): The number of circular primes below the given `limit`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(number):\n    if number < 0:\n        return 0\n    elif number == 2 or number == 3:\n        return 1\n    elif number % 2 == 0 or number % 3 == 0 or number == 1:\n        return 0\n    else:\n        start = 5\n        while start <= int(math.sqrt(number)):\n            if number % start == 0:\n                return 0\n            if number % (start+2) == 0:\n                return 0\n            start += 6\n        return 1\n\ndef rotation(number):\n    rotations = list()\n    rotations.append(number)\n    length = len(str(number)) - 1\n\n    if length == 0:\n        return rotations\n    else:\n        for count in range(length):\n            digit = number % 10\n            number //= 10\n            number += digit*pow(10, length)\n            rotations.append(number)\n        return rotations\n\ndef is_prime_rot(numbers):\n    all_prime = 1\n    for number in numbers:\n        if not is_prime(int(number)):\n            all_prime = 0\n            break\n    return all_prime\n\n# main function\ndef main_solution(limit):\n    prime_numbers = []\n    prime_rotations = []\n    \n    for x in range(1, limit):\n        if is_prime(x):\n            prime_numbers.append(x)\n\n    for num in prime_numbers:\n        if is_prime_rot(rotation(num)):\n            prime_rotations.append(num)\n\n    return len(prime_rotations)", "funcname": "main_solution", "ios": [{"input": {"limit": 949993}, "output": 53}, {"input": {"limit": 789206}, "output": 49}, {"input": {"limit": 400712}, "output": 49}, {"input": {"limit": 267051}, "output": 45}, {"input": {"limit": 362378}, "output": 47}, {"input": {"limit": 109842}, "output": 43}, {"input": {"limit": 780347}, "output": 49}, {"input": {"limit": 746490}, "output": 49}, {"input": {"limit": 622137}, "output": 49}, {"input": {"limit": 460203}, "output": 49}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vivekpabani/projecteuler", "path": "/python/035/problem_035.py", "msgidx": 6641}}
{"problem_description": "In a system with multiple processes, each process is identified by a unique PID (Process ID) and has a parent process identified by a PPID (Parent Process ID). Given the lists of PIDs and their corresponding PPIDs, and a specific PID to be killed, which processes will be terminated as a result of this action? Note that when a process is killed, all its child processes are also killed.", "io_requirements": "Input:\n  `pid` (list of int): A list of distinct positive integers representing the PIDs of the processes.\n  `ppid` (list of int): A list of positive integers representing the PPIDs of the processes. The length of this list should be the same as `pid`.\n  `kill` (int): A positive integer representing the PID of the process to be killed. This PID is guaranteed to be in the `pid` list.\n\nOutput:\n  `return` (list of int): A list of PIDs representing the processes that will be killed as a result of killing the specified process. The order of the PIDs in the list is not important.", "refcode": "# import necessary packages\nimport collections\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def kill_process(self, pid, ppid, kill):\n        root, self.tree = self.build_tree(pid, ppid)\n        self.kill = kill\n        self.res = []\n        self.traverse(root, False)\n        return self.res\n\n    def traverse(self, node, activate=False):\n        if node == self.kill:\n            activate = True\n        if activate:\n            self.res.append(node)\n        for succ in self.tree[node]:\n            self.traverse(succ, activate)\n    \n    def build_tree(self, pid, ppid):\n        tree = collections.defaultdict(set)\n        for idx in range(len(pid)):\n            if ppid[idx] == 0:\n                root = pid[idx]\n            else:\n                tree[ppid[idx]].add(pid[idx])\n        return root, tree\n\n# main function\ndef main_solution(pid, ppid, kill):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # convert JSON serializable inputs to original input variables\n  pid = list(pid)\n  ppid = list(ppid)\n  kill = int(kill)\n  \n  # invoke the function that requires non-json serializable inputs\n  solution = Solution()\n  result = solution.kill_process(pid, ppid, kill)\n  \n  # convert the result to JSON serializable output\n  result = list(result)\n  \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"pid": [28, 89, 75, 58, 26, 50, 97, 78, 81, 57], "ppid": [0, 28, 89, 75, 28, 89, 58, 89, 97, 81], "kill": 89}, "output": [89, 50, 75, 58, 97, 81, 57, 78]}, {"input": {"pid": [8, 77, 49, 20, 35], "ppid": [0, 8, 77, 49, 49], "kill": 35}, "output": [35]}, {"input": {"pid": [64], "ppid": [0], "kill": 64}, "output": [64]}, {"input": {"pid": [16, 32, 35], "ppid": [0, 16, 32], "kill": 16}, "output": [16, 32, 35]}, {"input": {"pid": [83, 13, 59, 91], "ppid": [0, 83, 83, 83], "kill": 83}, "output": [83, 91, 59, 13]}, {"input": {"pid": [20], "ppid": [0], "kill": 20}, "output": [20]}, {"input": {"pid": [13, 21, 23, 59, 71, 29, 56], "ppid": [0, 13, 13, 21, 23, 23, 71], "kill": 59}, "output": [59]}, {"input": {"pid": [97, 17, 47, 83, 46, 99, 96, 1], "ppid": [0, 97, 17, 97, 47, 97, 97, 96], "kill": 46}, "output": [46]}, {"input": {"pid": [97, 31, 58], "ppid": [0, 97, 31], "kill": 97}, "output": [97, 31, 58]}, {"input": {"pid": [28, 4, 1, 14, 66, 48], "ppid": [0, 28, 4, 1, 1, 14], "kill": 66}, "output": [66]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mengnan1994/Surrender-to-Reality", "path": "/py/0582_kill_process.py", "msgidx": 6396}}
{"problem_description": "Given a set of four distinct digits in ascending order, what is the maximum number of consecutive positive integers that can be obtained using these digits and the four basic arithmetic operations (+, \u2212, *, /)? The digits must be used exactly once in each expression, and concatenations of the digits are not allowed.", "io_requirements": "Input:\n  `digits` (list of strings): A list of four distinct digits (each digit is a string) that are to be used in the arithmetic expressions. The digits must be in ascending order.\n\nOutput:\n  `return` (int): The maximum number of consecutive positive integers that can be obtained using the given digits and the four arithmetic operations (+, \u2212, *, /).", "refcode": "# import necessary packages\nimport operator\nfrom functools import reduce\nfrom itertools import permutations\nfrom math import inf\n\n# all class and function definitions in the code file, if any\nclass Operation(object):\n    def __init__(self, func, symbol, is_commutative):\n        self.func = func\n        self.symbol = symbol\n        self.is_commutative = is_commutative\n\n    def __call__(self, *args, **kwargs):\n        return self.func(args) if self.is_commutative else self.func(*args)\n\n    def __str__(self):\n        return self.symbol\n\n\nadd = Operation(lambda *args: sum(*args), '+', True)\nsub = Operation(lambda a, b: a - b, '-', False)\nmul = Operation(lambda *args: reduce(operator.mul, *args), '*', True)\ndiv = Operation(lambda a, b: (a / b) if b != 0 else inf, '/', False)\nall_ops = [add, sub, mul, div]\n\n\nclass Tree(object):\n    def __init__(self, op, items):\n        self.op = op\n        self.items = list(items)\n        if not op.is_commutative and len(items) != 2:\n            raise ValueError('Non-commutative operation must have two items')\n\n    def evaluate(self):\n        items = [i.evaluate() if isinstance(i, Tree) else i for i in self.items]\n        result = self.op(*items)\n        if isinstance(result, float) and result.is_integer():\n            result = int(result)\n        return result\n\n\ndef flatten(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]\n\n\ndef build_trees(items):\n    if len(items) == 1:\n        return items\n    tree_items = []\n    for a, b in permutations(items, 2):\n        for op in all_ops:\n            t = Tree(op, [a, b])\n            others = items.copy()\n            others.remove(a)\n            others.remove(b)\n            tree_items.append([t] + others)\n    trees = [build_trees(t) for t in tree_items]\n    return flatten(trees)\n\n\ndef find_biggest_range(items):\n    items = sorted(set(items))\n    size = 0\n    for i in items:\n        if i - size > 1:\n            break\n        size = i\n    return size\n\n\ndef solve(digits):\n    values = [t.evaluate() for t in build_trees(digits)]\n    values = {v for v in values if isinstance(v, int) and v > 0}\n    return find_biggest_range(values)\n\n# main function\ndef main_solution(digits):\n    # Convert the input list of digits to a list of integers\n    digits = list(map(int, digits))\n    # Solve the problem using the provided functions\n    result = solve(digits)\n    # Return the result as an integer\n    return result", "funcname": "main_solution", "ios": [{"input": {"digits": ["2", "3", "4", "6"]}, "output": 26}, {"input": {"digits": ["4", "5", "7", "9"]}, "output": 4}, {"input": {"digits": ["1", "4", "7", "8"]}, "output": 0}, {"input": {"digits": ["1", "2", "6", "9"]}, "output": 33}, {"input": {"digits": ["1", "2", "5", "8"]}, "output": 51}, {"input": {"digits": ["1", "2", "7", "9"]}, "output": 28}, {"input": {"digits": ["4", "6", "7", "9"]}, "output": 14}, {"input": {"digits": ["3", "5", "6", "7"]}, "output": 12}, {"input": {"digits": ["3", "4", "5", "9"]}, "output": 8}, {"input": {"digits": ["1", "3", "8", "9"]}, "output": 7}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GlenHaber/euler", "path": "/problem93.py", "msgidx": 6970}}
{"problem_description": "Given a number, what is the largest palindrome that can be formed by rearranging its digits in base-3 representation?", "io_requirements": "Input:\n  `n` (int): An integer representing the number to be converted and processed to find the largest base-3 palindrome.\n\nOutput:\n  `return` (int): An integer representing the largest base-3 palindrome derived from the input number `n`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef lta(n):\n    '''\n    examples:\n    200 -> 2\n    202 -> 202\n    102 -> 2\n    110022 -> 210012\n    111000222 -> 2102012\n    '''\n    tri_str = base10toN(n, 3)\n\n    # count numerals\n    zeros = tri_str.count('0')\n    ones = tri_str.count('1')\n    twos = tri_str.count('2')\n\n    pal = \"\"\n\n    # determine if a digit should be placed in the middle of the palindrome\n    if twos % 2 == 1:  # if there are an odd number of 2's, place a 2 in the middle of the palindrome\n        pal = \"2\"\n        twos -= 1\n    elif ones % 2 == 1:\n        pal = \"1\"\n        ones -= 1\n    elif zeros % 2 == 1:\n        pal = \"0\"\n        zeros -= 1\n\n    # place remaining digits around the center of the palindrome\n\n    # if there are enough 1's or 2's to cap the ends of the palindrome (since the palindrome cannot have leading zeros)\n    if ones >= 2 or twos >= 2:\n        # place remaining 0's on either side of the palindrome\n        while zeros - 2 >= 0:\n            pal = \"0\" + pal + \"0\"\n            zeros -= 2\n\n    # place remaining 1's on either side of the palindrome\n    while ones - 2 >= 0:\n        pal = \"1\" + pal + \"1\"\n        ones -= 2\n\n    # place remaining 2's on either side of the palindrome\n    while twos - 2 >= 0:\n        pal = \"2\" + pal + \"2\"\n        twos -= 2\n\n    return int(pal, 3)\n\ndef base10toN(num, base):\n    \"\"\"Change ``num'' to given base\n    Upto base 36 is supported.\"\"\"\n\n    converted_string, modstring = \"\", \"\"\n    currentnum = num\n    if not 1 < base < 37:\n        raise ValueError(\"base must be between 2 and 36\")\n    if not num:\n        return '0'\n    while currentnum:\n        mod = currentnum % base\n        currentnum = currentnum // base\n        converted_string = chr(48 + mod + 7 * (mod > 10)) + converted_string\n    return converted_string\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = lta(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 166781}, "output": 164285}, {"input": {"n": 954155}, "output": 1496681}, {"input": {"n": 242924}, "output": 433040}, {"input": {"n": 973132}, "output": 1564082}, {"input": {"n": 488525}, "output": 166499}, {"input": {"n": 615272}, "output": 1561652}, {"input": {"n": 992529}, "output": 147056}, {"input": {"n": 564393}, "output": 1299821}, {"input": {"n": 692146}, "output": 1318802}, {"input": {"n": 366671}, "output": 173069}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sinoftheta/oeis-stuff", "path": "/lta.py", "msgidx": 6844}}
{"problem_description": "You are given a set of rules for ticket fields and a list of nearby tickets. Each ticket contains a series of numbers, and each number corresponds to a specific field. The rules specify valid ranges for each field. Your task is to determine the ticket scanning error rate, which is the sum of all values on the nearby tickets that do not fall within the valid ranges for any field. What is the ticket scanning error rate for the given set of rules and nearby tickets?", "io_requirements": "Input:\n  `fields_and_ranges` (str): A JSON string representing a dictionary where keys are field names and values are lists of tuples representing valid ranges for each field.\n  `my_ticket` (str): A JSON string representing a list of integers, each integer being a value on the ticket.\n  `other_tickets` (str): A JSON string representing a list of lists of integers, each inner list being a ticket with values in the same order as `my_ticket`.\n\nOutput:\n  `return` (str): A JSON string representing an integer, which is the sum of all invalid values across all nearby tickets.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef parse_ticket(raw_ticket):\n    return [int(value) for value in raw_ticket.rstrip().split(\",\")]\n\ndef sum_invalid_ticket_values(tickets, fields_and_ranges):\n    all_valid_values = build_valid_value_list(fields_and_ranges)\n    invalid_values_sum = 0\n    for ticket in tickets:\n        for value in ticket:\n            if not value in all_valid_values:\n                invalid_values_sum += value\n                break\n    return invalid_values_sum\n\ndef build_valid_value_list(fields_and_ranges):\n    valid_values = []\n    for valid_ranges in fields_and_ranges.values():\n        for valid_range in valid_ranges:\n            for i in range(valid_range[0], valid_range[1]):\n                valid_values.append(i)\n    return set(valid_values)\n\n# main function\ndef main_solution(fields_and_ranges, my_ticket, other_tickets):\n    # Convert JSON serializable inputs to original input variables\n    fields_and_ranges = json.loads(fields_and_ranges)\n    my_ticket = json.loads(my_ticket)\n    other_tickets = json.loads(other_tickets)\n    \n    # Calculate the ticket scanning error rate\n    error_rate = sum_invalid_ticket_values(other_tickets, fields_and_ranges)\n    \n    # Convert the output to JSON serializable format\n    return json.dumps(error_rate)", "funcname": "main_solution", "ios": [{"input": {"fields_and_ranges": "{\"field_0\": [[8, 17], [24, 37]], \"field_1\": [[6, 13], [25, 35]], \"field_2\": [[2, 4], [21, 38]]}", "my_ticket": "[41, 46, 50]", "other_tickets": "[[49, 2, 1], [3, 10, 2], [30, 28, 37], [50, 19, 13], [39, 21, 23]]"}, "output": "138"}, {"input": {"fields_and_ranges": "{\"field_0\": [[8, 13], [25, 28]], \"field_1\": [[10, 19], [23, 31]], \"field_2\": [[6, 18], [27, 34]]}", "my_ticket": "[48, 9, 10]", "other_tickets": "[[22, 23, 38], [41, 40, 29], [31, 23, 5], [7, 50, 34], [45, 50, 41]]"}, "output": "163"}, {"input": {"fields_and_ranges": "{\"field_0\": [[5, 11], [25, 32]], \"field_1\": [[4, 19], [29, 31]], \"field_2\": [[3, 19], [24, 38]]}", "my_ticket": "[9, 35, 27]", "other_tickets": "[[42, 31, 35], [8, 14, 2], [28, 3, 3], [43, 28, 14], [3, 3, 48]]"}, "output": "135"}, {"input": {"fields_and_ranges": "{\"field_0\": [[7, 20], [27, 37]], \"field_1\": [[7, 15], [22, 27]], \"field_2\": [[6, 17], [29, 37]]}", "my_ticket": "[40, 45, 46]", "other_tickets": "[[5, 49, 34], [14, 1, 24], [25, 40, 16], [15, 36, 22], [43, 46, 44]]"}, "output": "89"}, {"input": {"fields_and_ranges": "{\"field_0\": [[2, 14], [24, 39]], \"field_1\": [[2, 10], [26, 28]], \"field_2\": [[10, 17], [26, 36]]}", "my_ticket": "[4, 22, 43]", "other_tickets": "[[9, 19, 43], [4, 7, 7], [49, 44, 14], [47, 1, 12], [20, 30, 17]]"}, "output": "135"}, {"input": {"fields_and_ranges": "{\"field_0\": [[8, 17], [21, 36]], \"field_1\": [[9, 20], [30, 31]], \"field_2\": [[3, 15], [27, 35]]}", "my_ticket": "[36, 4, 40]", "other_tickets": "[[32, 49, 11], [37, 43, 46], [42, 13, 34], [35, 7, 13], [4, 49, 16]]"}, "output": "177"}, {"input": {"fields_and_ranges": "{\"field_0\": [[2, 15], [30, 33]], \"field_1\": [[5, 20], [27, 35]], \"field_2\": [[1, 16], [22, 28]]}", "my_ticket": "[22, 8, 20]", "other_tickets": "[[28, 3, 29], [33, 21, 34], [25, 6, 31], [48, 6, 47], [31, 15, 3]]"}, "output": "69"}, {"input": {"fields_and_ranges": "{\"field_0\": [[1, 13], [26, 27]], \"field_1\": [[9, 15], [21, 25]], \"field_2\": [[8, 20], [27, 30]]}", "my_ticket": "[26, 2, 18]", "other_tickets": "[[14, 21, 22], [12, 49, 44], [34, 4, 50], [14, 43, 1], [4, 14, 12]]"}, "output": "126"}, {"input": {"fields_and_ranges": "{\"field_0\": [[1, 6], [22, 38]], \"field_1\": [[3, 16], [24, 29]], \"field_2\": [[8, 18], [29, 33]]}", "my_ticket": "[46, 44, 28]", "other_tickets": "[[17, 28, 23], [25, 20, 22], [30, 34, 4], [41, 8, 31], [23, 38, 38]]"}, "output": "99"}, {"input": {"fields_and_ranges": "{\"field_0\": [[5, 14], [26, 32]], \"field_1\": [[10, 14], [24, 32]], \"field_2\": [[5, 9], [28, 37]]}", "my_ticket": "[7, 11, 22]", "other_tickets": "[[37, 47, 27], [37, 43, 17], [43, 7, 24], [10, 8, 21], [2, 40, 1]]"}, "output": "140"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "anmapie/advent-of-code", "path": "/2020/day16/day16.py", "msgidx": 6933}}
{"problem_description": "In a futuristic world, humanity's last hope lies in a grid-based system where nodes ('0') represent critical points. Each node needs to be connected to its nearest right and bottom neighbors to ensure the system's stability. Given the dimensions of the grid and the positions of the nodes, what are the coordinates of each node along with its right and bottom neighbors? If a neighbor does not exist, indicate it with \"-1 -1\".", "io_requirements": "Input:\n  `width` (int): The number of cells on the X axis of the grid.\n  `height` (int): The number of cells on the Y axis of the grid.\n  `grid` (list of lists of str): A 2D list representing the grid, where each element is either '0' (node) or '.' (empty space).\n\nOutput:\n  `return` (list of str): A list of strings where each string represents the coordinates of a node and its right and bottom neighbors. Each string is formatted as \"x1 y1 x2 y2 x3 y3\", where (x1, y1) is the node's coordinates, (x2, y2) is the coordinates of the right neighbor, and (x3, y3) is the coordinates of the bottom neighbor. If a neighbor does not exist, the coordinates are \"-1 -1\".", "refcode": "# import necessary packages\nimport sys\nimport math\n\n# all class and function definitions in the code file, if any\ndef search_neighbor_right(grid_line, i, j):\n    idx_i = str(i)\n    idx_j = None\n    isNeighborFound = False\n    dim = len(grid_line)\n    for d in range(j+1,dim):\n        if grid_line[d] == '0':\n            isNeighborFound = True\n            idx_j = str(d)\n            break\n        else:\n            continue\n    if (not isNeighborFound):\n        idx_i = '-1'\n        idx_j = '-1'\n    \n    return idx_i, idx_j\n\n\ndef search_neighbor_bottom(grid_column, i, j):\n    idx_i = None\n    idx_j = str(j)\n    isNeighborFound = False\n    dim = len(grid_column)\n    for d in range(i+1,dim):\n        if grid_column[d] == '0':\n            isNeighborFound = True\n            idx_i = str(d)\n            break\n        else:\n            continue\n    if (not isNeighborFound):\n        idx_i = '-1'\n        idx_j = '-1'\n\n    return idx_i, idx_j\n\n# main function\ndef main_solution(width, height, grid):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    output_list = []\n    for i in range(height):\n        for j in range(width):\n            output = ''\n            if grid[i][j] == '0':\n                output += str(j) + ' ' + str(i) + ' '\n\n                if (j != width-1):\n                    # find neighbor right\n                    idx_i, idx_j = search_neighbor_right(grid[i], i,j)\n                    output += idx_j + ' ' + idx_i + ' '\n                else:\n                    output += '-1 -1 '\n                if (i != height-1):\n                    # find neighbor bottom\n                    column = [row[j] for row in grid]\n                    idx_i, idx_j= search_neighbor_bottom(column, i,j)\n                    output += idx_j + ' ' + idx_i\n                else:\n                    output += '-1 -1'\n                output_list.append(output)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return output_list", "funcname": "main_solution", "ios": [{"input": {"width": 4, "height": 4, "grid": [[".", ".", "0", "."], [".", ".", ".", "."], [".", ".", ".", "0"], [".", ".", ".", "."]]}, "output": ["2 0 -1 -1 -1 -1", "3 2 -1 -1 -1 -1"]}, {"input": {"width": 4, "height": 4, "grid": [[".", ".", ".", "0"], ["0", ".", ".", "0"], [".", ".", ".", "."], ["0", ".", ".", "."]]}, "output": ["3 0 -1 -1 3 1", "0 1 3 1 0 3", "3 1 -1 -1 -1 -1", "0 3 -1 -1 -1 -1"]}, {"input": {"width": 8, "height": 3, "grid": [["0", ".", "0", ".", ".", ".", "0", "."], ["0", ".", ".", ".", "0", ".", "0", "."], [".", ".", ".", ".", "0", ".", ".", "."]]}, "output": ["0 0 2 0 0 1", "2 0 6 0 -1 -1", "6 0 -1 -1 6 1", "0 1 4 1 -1 -1", "4 1 6 1 4 2", "6 1 -1 -1 -1 -1", "4 2 -1 -1 -1 -1"]}, {"input": {"width": 3, "height": 4, "grid": [["0", ".", "."], [".", ".", "."], ["0", "0", "0"], [".", ".", "0"]]}, "output": ["0 0 -1 -1 0 2", "0 2 1 2 -1 -1", "1 2 2 2 -1 -1", "2 2 -1 -1 2 3", "2 3 -1 -1 -1 -1"]}, {"input": {"width": 4, "height": 3, "grid": [[".", ".", "0", "0"], ["0", ".", ".", "0"], [".", ".", "0", "."]]}, "output": ["2 0 3 0 2 2", "3 0 -1 -1 3 1", "0 1 3 1 -1 -1", "3 1 -1 -1 -1 -1", "2 2 -1 -1 -1 -1"]}, {"input": {"width": 7, "height": 3, "grid": [[".", "0", ".", ".", ".", ".", "."], ["0", ".", ".", ".", ".", ".", "."], [".", ".", ".", "0", "0", ".", "0"]]}, "output": ["1 0 -1 -1 -1 -1", "0 1 -1 -1 -1 -1", "3 2 4 2 -1 -1", "4 2 6 2 -1 -1", "6 2 -1 -1 -1 -1"]}, {"input": {"width": 4, "height": 4, "grid": [[".", ".", ".", "."], ["0", ".", ".", "."], [".", ".", ".", "."], [".", ".", ".", "."]]}, "output": ["0 1 -1 -1 -1 -1"]}, {"input": {"width": 3, "height": 4, "grid": [["0", ".", "."], [".", ".", "."], [".", ".", "."], [".", ".", "."]]}, "output": ["0 0 -1 -1 -1 -1"]}, {"input": {"width": 4, "height": 3, "grid": [["0", "0", ".", "."], ["0", ".", "0", "0"], [".", "0", ".", "."]]}, "output": ["0 0 1 0 0 1", "1 0 -1 -1 1 2", "0 1 2 1 -1 -1", "2 1 3 1 -1 -1", "3 1 -1 -1 -1 -1", "1 2 -1 -1 -1 -1"]}, {"input": {"width": 7, "height": 3, "grid": [[".", ".", ".", "0", ".", ".", "0"], ["0", ".", ".", ".", ".", "0", "0"], [".", ".", ".", ".", ".", ".", "0"]]}, "output": ["3 0 6 0 -1 -1", "6 0 -1 -1 6 1", "0 1 5 1 -1 -1", "5 1 6 1 -1 -1", "6 1 -1 -1 6 2", "6 2 -1 -1 -1 -1"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "SamAstro/codingame", "path": "/training/medium/there_is_no_spoon_episode1/there_is_no_spoon_ep1.py", "msgidx": 5847}}
{"problem_description": "Given a string consisting of lowercase letters, what are all the possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    perm_list = [''.join(p) for p in permutations(char_list)]\n    \n    # Return the list of permutations as a JSON serializable output\n    return perm_list", "funcname": "main_solution", "ios": [{"input": {"input_string": "dme"}, "output": ["dme", "dem", "mde", "med", "edm", "emd"]}, {"input": {"input_string": "azz"}, "output": ["azz", "azz", "zaz", "zza", "zaz", "zza"]}, {"input": {"input_string": "tvy"}, "output": ["tvy", "tyv", "vty", "vyt", "ytv", "yvt"]}, {"input": {"input_string": "zzf"}, "output": ["zzf", "zfz", "zzf", "zfz", "fzz", "fzz"]}, {"input": {"input_string": "lpx"}, "output": ["lpx", "lxp", "plx", "pxl", "xlp", "xpl"]}, {"input": {"input_string": "ays"}, "output": ["ays", "asy", "yas", "ysa", "say", "sya"]}, {"input": {"input_string": "snl"}, "output": ["snl", "sln", "nsl", "nls", "lsn", "lns"]}, {"input": {"input_string": "qpc"}, "output": ["qpc", "qcp", "pqc", "pcq", "cqp", "cpq"]}, {"input": {"input_string": "esi"}, "output": ["esi", "eis", "sei", "sie", "ies", "ise"]}, {"input": {"input_string": "rhx"}, "output": ["rhx", "rxh", "hrx", "hxr", "xrh", "xhr"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DerekDongSir/Algorithms", "path": "/all_permutation.py", "msgidx": 6994}}
{"problem_description": "Given a starting number, what is the smallest number greater than or equal to this starting number that leaves a remainder of 2 when divided by 3, a remainder of 3 when divided by 5, and a remainder of 2 when divided by 7?", "io_requirements": "Input:\n  `start_number` (int): The initial number from which the search for the solution starts.\n\nOutput:\n  `return` (int): The smallest number greater than or equal to `start_number` that satisfies the conditions: it leaves a remainder of 2 when divided by 3, a remainder of 3 when divided by 5, and a remainder of 2 when divided by 7.", "refcode": "# main function\ndef main_solution(start_number):\n    number = start_number\n    while True:\n        if number % 3 == 2 and number % 5 == 3 and number % 7 == 2:\n            return number\n        else:\n            number += 1", "funcname": "main_solution", "ios": [{"input": {"start_number": 90}, "output": 128}, {"input": {"start_number": 60}, "output": 128}, {"input": {"start_number": 16}, "output": 23}, {"input": {"start_number": 79}, "output": 128}, {"input": {"start_number": 2}, "output": 23}, {"input": {"start_number": 38}, "output": 128}, {"input": {"start_number": 89}, "output": 128}, {"input": {"start_number": 86}, "output": 128}, {"input": {"start_number": 59}, "output": 128}, {"input": {"start_number": 10}, "output": 23}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "liuqianjin/python_exercise", "path": "/\u7a0b\u5e8f\u63a7\u5236\u8bed\u53e5/\u52a9\u529b\u745b\u59d1(1)\uff1awhile\u5faa\u73af\u7248\u89e3\u9898\u6cd5.py", "msgidx": 7211}}
{"problem_description": "In a game of poker, two players are dealt five cards each. Given the cards held by Player 1 and Player 2, who has the stronger hand?", "io_requirements": "Input:\n  `player1_cards` (str): A string representing the 5 cards held by Player 1. Each card is represented by a 2-character code (e.g., \"5H\" for 5 of Hearts). Cards are separated by spaces.\n  `player2_cards` (str): A string representing the 5 cards held by Player 2. Each card is represented by a 2-character code (e.g., \"6S\" for 6 of Spades). Cards are separated by spaces.\n\nOutput:\n  `return` (str): A string indicating the winner of the poker hand comparison. Possible values are \"Player 1\", \"Player 2\", or \"Tie\".", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef rankValue2(cards):\n    #cards is string of 5 x 2 chars card code like 5H 6S 7S KD AC (6)\n    is_flush = [suite for suite in \"CDHS\" if cards.count(suite) == 5]\n    \n    #test Royal Flush: Ten, Jack, Queen, King, Ace, in same suit. value 10.\n    if is_flush and sum([1 for val in \"TJQKA\" if val+is_flush[0] in cards]) == 5:\n        return [10,[]]\n\n    #prepare variables that will be used multiple times in subsequent test\n    vals = [cards[i] for i in range(0,12+1,3)]\n    valsnum = []\n    for val in vals:\n        #   replace T,J,Q,K,A with 10,11,12,13,14\n        for i,j in dict(T=10,J=11,Q=12,K=13,A=14).items():\n            if val == i:\n                val = j\n                break\n        valsnum.append(int(val))\n    valsnum.sort(reverse=True)\n    #   setup list of unique values, with its number. e.g. [[4,10],[1,6]] for four 10 over 6.\n    unique_values = [[valsnum.count(val),val] for val in dict.fromkeys(valsnum)]\n    unique_values.sort(reverse=True)\n\n    #test straight (5)\n    max_straight = max(valsnum)\n    is_straight = (math.prod(valsnum) == math.factorial(max_straight)/math.factorial(max_straight-5))\n    # if ace and 2 exist, ace can be considered as \"1\" and form a straight. So I will check this directly.\n    if not is_straight and valsnum == [14,5,4,3,2]:\n        is_straight = True\n        max_straight = 5\n    \n    #test straight flush (9)\n    if is_straight and is_flush:\n        return [9, unique_values]\n\n    #test four of a kind (8)\n    if len(unique_values) == 2 and unique_values[0][0] == 4:\n        return [8, unique_values]\n\n    #test full house (7)\n    if len(unique_values) == 2 and unique_values[0][0] == 3:\n        return [7, unique_values]\n\n    #test flush (6)\n    if is_flush:\n        return [6, unique_values]\n\n    #test straight (5)\n    if is_straight:\n        return [5, unique_values]\n\n    #test three of a kind (4)\n    if len(unique_values) == 3 and unique_values[0][0] == 3:\n        return [4, unique_values]\n\n    #test two pairs (3)\n    if len(unique_values) == 3 and unique_values[0][0] == 2:\n        return [3, unique_values]\n\n    #test pair (2)\n    if len(unique_values) == 4:\n        return [2, unique_values]\n\n    #high card\n    return [1, unique_values]\n\n# main function\ndef main_solution(player1_cards, player2_cards):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert JSON serializable inputs to the original input variables\n    player1_rank = rankValue2(player1_cards)\n    player2_rank = rankValue2(player2_cards)\n    \n    # determine the winner\n    if player1_rank > player2_rank:\n        return \"Player 1\"\n    elif player1_rank < player2_rank:\n        return \"Player 2\"\n    else:\n        return \"Tie\"", "funcname": "main_solution", "ios": [{"input": {"player1_cards": "AH 7S TC JC 2S", "player2_cards": "KD 4H 4S TC 7H"}, "output": "Player 2"}, {"input": {"player1_cards": "8D 2D 8H AS 7C", "player2_cards": "4D 6S KD 2S AS"}, "output": "Player 1"}, {"input": {"player1_cards": "JH QD TS AH 4D", "player2_cards": "AH 3H 3D 9H 7D"}, "output": "Player 2"}, {"input": {"player1_cards": "3C 2S 4H 7C 9H", "player2_cards": "AC KC QH 2H 6S"}, "output": "Player 2"}, {"input": {"player1_cards": "5D 8C 6S 7S AC", "player2_cards": "5S 8S 7D 2H 6H"}, "output": "Player 1"}, {"input": {"player1_cards": "KD 9S 4S 3S 6D", "player2_cards": "TH QH TC 6D 8S"}, "output": "Player 2"}, {"input": {"player1_cards": "JD 8S TS QC 5H", "player2_cards": "4C 5C 6H JH AC"}, "output": "Player 2"}, {"input": {"player1_cards": "KD 2D AC 6H QH", "player2_cards": "3H 3S KS 8D 7S"}, "output": "Player 2"}, {"input": {"player1_cards": "7S 4S JH 7D JH", "player2_cards": "JS JS 8D 5C 2H"}, "output": "Player 1"}, {"input": {"player1_cards": "4S 6S JC 5C TH", "player2_cards": "QH 9D 2H 8C QS"}, "output": "Player 2"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "soedjais/dodysw-hg", "path": "/ProjectEuler/Problem54.py", "msgidx": 6489}}
{"problem_description": "Given a Tower of Hanoi puzzle with `n` disks, what is the sequence of moves required to transfer all disks from peg 'A' to peg 'C' using peg 'B' as an auxiliary peg?", "io_requirements": "Input:\n  `n` (int): The number of disks in the Tower of Hanoi problem.\n\nOutput:\n  `return` (str): A string representing the sequence of moves to solve the Tower of Hanoi problem with `n` disks. Each move is formatted as \"A --> C\" where A is the source peg, and C is the destination peg.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef fact(n):\n    if n == 1:\n        return 1\n    return n * fact(n - 1)\n\ndef fact_iter(n, result):\n    if n == 1:\n        return result\n    return fact_iter(n - 1, result * n)\n\ndef hanoi(n, a, b, c):\n    if n == 1:\n        return f\"{a} --> {c}\"\n    else:\n        return hanoi(n - 1, a, c, b) + f\"\\n{a} --> {c}\\n\" + hanoi(n - 1, b, a, c)\n\n# main function\ndef main_solution(n):\n    # Convert the output of hanoi function to a JSON serializable string\n    hanoi_result = hanoi(n, 'A', 'B', 'C')\n    return hanoi_result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": "A --> C\nA --> B\nC --> B\nA --> C\nB --> A\nB --> C\nA --> C"}, {"input": {"n": 2}, "output": "A --> B\nA --> C\nB --> C"}, {"input": {"n": 1}, "output": "A --> C"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JacobsonWu/Python3Study", "path": "/First/Function.py", "msgidx": 6845}}
{"problem_description": "Given a range of numbers and specific lengths for keys and total numbers, what is the sum of the cyclical numbers that can be formed by connecting numbers from different polygonal sequences (triangle, square, pentagonal, hexagonal, heptagonal, and octagonal) such that the last two digits of one number match the first two digits of the next number, and the sequence forms a cycle?", "io_requirements": "Input:\n  `minVal` (int): The minimum value for the range of numbers to be considered.\n  `maxVal` (int): The maximum value for the range of numbers to be considered.\n  `keyLen` (int): The length of the key used for grouping numbers.\n  `totalLen` (int): The total length of the numbers to be considered.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `sum` (int): The sum of the cyclical numbers found.\n    - `result` (list of int): The list of cyclical numbers found.", "refcode": "# import necessary packages\nimport copy\nfrom math import sqrt, ceil, floor\n\n# all class and function definitions in the code file, if any\ndef triangle(x):\n    return (x * (x + 1)) / 2\n\ndef getNFromTriangle(x):\n    return (sqrt(float(8 * x + 1)) - 1) / 2\n\ndef square(x):\n    return x ** 2\n\ndef getNFromSquare(x):\n    return sqrt(x)\n\ndef pentagonal(x):\n    return (x * (3 * x - 1)) / 2\n\ndef getNFromPentagonal(x):\n    return (sqrt(float(24 * x + 1)) + 1) / 6\n\ndef hexagonal(x):\n    return x * (2 * x - 1)\n\ndef getNFromHexagonal(x):\n    return (sqrt(float(8 * x + 1)) + 1) / 4\n\ndef heptagonal(x):\n    return (x * (5 * x - 3)) / 2\n\ndef getNFromHeptagonal(x):\n    return (sqrt(float(40 * x + 9)) + 3) / 10\n\ndef octagonal(x):\n    return x * (3 * x - 2)\n\ndef getNFromOctagonal(x):\n    return (sqrt(float(12 * x + 4)) + 2) / 6\n\ndef getCyclicalNums(nums, skipList, depth, goal, key, startKey, result):\n    for i in range(len(nums)):\n        if i in skipList:\n            continue\n        if key not in nums[i]:\n            return False\n\n        newList = copy.copy(skipList)\n        newList.append(i)\n\n        for val in nums[i][key]:\n            if val in result:\n                continue\n            result.append(val)\n            nextKey = str(val)[keyLen:]\n            if depth == goal and nextKey == startKey:\n                return True\n            if not getCyclicalNums(nums, newList, depth + 1, goal, nextKey, startKey, result):\n                result.pop()\n            else:\n                return True\n\n# main function\ndef main_solution(minVal, maxVal, keyLen, totalLen):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    restLen = totalLen - keyLen\n\n    triangles = {}\n    squares = {}\n    pentagonals = {}\n    hexagonals = {}\n    heptagonals = {}\n    octagonals = {}\n\n    num = [triangle, square, pentagonal, hexagonal, heptagonal, octagonal]\n    getN = [getNFromTriangle, getNFromSquare, getNFromPentagonal, getNFromHexagonal, getNFromHeptagonal, getNFromOctagonal]\n    nums = [triangles, squares, pentagonals, hexagonals, heptagonals, octagonals]\n    goalDepth = len(num) - 1\n\n    for i in range(len(nums)):\n        lowN = int(ceil(getN[i](minVal)))\n        highN = int(floor(getN[i](maxVal)))\n        for n in range(lowN, highN + 1):\n            val = num[i](n)\n            strVal = str(val)\n            key = strVal[:keyLen]\n            nums[i].setdefault(key, [])\n            nums[i][key].append(val)\n\n    result = []\n    found = False\n    skipList = [0]\n    for key in nums[0]:\n        for val in nums[0][key]:\n            result.append(val)\n            nextKey = str(val)[keyLen:]\n            found = getCyclicalNums(nums, skipList, 1, goalDepth, nextKey, key, result)\n            if found:\n                break\n            result.pop()\n        if found:\n            break\n\n    total = sum(result)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"sum\": total, \"result\": result}", "funcname": "main_solution", "ios": [{"input": {"minVal": 3544, "maxVal": 8120, "keyLen": 3, "totalLen": 5}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 2004, "maxVal": 7240, "keyLen": 3, "totalLen": 7}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 4984, "maxVal": 8837, "keyLen": 3, "totalLen": 7}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 2180, "maxVal": 8396, "keyLen": 2, "totalLen": 5}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 3246, "maxVal": 5633, "keyLen": 3, "totalLen": 5}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 3455, "maxVal": 8636, "keyLen": 3, "totalLen": 6}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 3279, "maxVal": 4608, "keyLen": 2, "totalLen": 4}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 2428, "maxVal": 9598, "keyLen": 2, "totalLen": 5}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 2912, "maxVal": 5651, "keyLen": 3, "totalLen": 7}, "output": {"sum": 0, "result": []}}, {"input": {"minVal": 4004, "maxVal": 7146, "keyLen": 3, "totalLen": 5}, "output": {"sum": 0, "result": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jacobhanshaw/ProjectEuler", "path": "/euler61.py", "msgidx": 5729}}
{"problem_description": "In a traditional white elephant gift exchange game, participants take turns stealing gifts from each other. Given the number of participants, what are the positions of the last remaining participant in two different variations of the game?", "io_requirements": "Input:\n  `n` (int): The number of participants in the white elephant game.\n\nOutput:\n  `return` (dict): A dictionary containing the results for two parts of the game.\n    - `part1` (int): The position of the last remaining participant in Part 1 of the game.\n    - `part2` (int): The position of the last remaining participant in Part 2 of the game.", "refcode": "# import necessary packages\nfrom math import floor\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer\n    n = int(n)\n    \n    # Calculate the result for Part 1\n    mod_A = 1\n    while mod_A <= n / 2:\n        mod_A *= 2\n    result_A = int(1 + 2 * (n % mod_A))\n    \n    # Calculate the result for Part 2\n    mod_B = 1\n    while mod_B <= n / 3:\n        mod_B *= 3\n    if n == mod_B:\n        result_B = n\n    elif n < 2 * mod_B:\n        result_B = int(n % mod_B)\n    else:\n        result_B = int(mod_B + 2 * (n % mod_B))\n    \n    # Return the results as a dictionary\n    return {\"part1\": result_A, \"part2\": result_B}", "funcname": "main_solution", "ios": [{"input": {"n": 5141}, "output": {"part1": 2091, "part2": 3721}}, {"input": {"n": 9444}, "output": {"part1": 2505, "part2": 2883}}, {"input": {"n": 9347}, "output": {"part1": 2311, "part2": 2786}}, {"input": {"n": 2416}, "output": {"part1": 737, "part2": 229}}, {"input": {"n": 9294}, "output": {"part1": 2205, "part2": 2733}}, {"input": {"n": 8031}, "output": {"part1": 7871, "part2": 1470}}, {"input": {"n": 460}, "output": {"part1": 409, "part2": 217}}, {"input": {"n": 7212}, "output": {"part1": 6233, "part2": 651}}, {"input": {"n": 9896}, "output": {"part1": 3409, "part2": 3335}}, {"input": {"n": 2389}, "output": {"part1": 683, "part2": 202}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "madman2/Advent2016", "path": "/day19.py", "msgidx": 6594}}
{"problem_description": "Given a set of discs on a peg, how can you move all the discs to another peg following the rules of the Tower of Hanoi puzzle, and what is the confirmation message after executing the solution?", "io_requirements": "Input:\n  `n` (int): The number of discs to be moved.\n  `f` (str): The name of the source peg.\n  `h` (str): The name of the auxiliary peg.\n  `t` (str): The name of the target peg.\n\nOutput:\n  `return` (str): A confirmation message indicating that the solution has been executed.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef move(f, t):\n    pass  # This function will be used internally and does not need to be modified\n\ndef movieVia(f, v, t):\n    move(f, v)\n    move(v, t)\n\n# main function\ndef main_solution(n, f, h, t):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    def hanoi(n, f, h, t):\n        if n == 0:\n            return\n        hanoi(n-1, f, t, h)\n        move(f, t)\n        hanoi(n-1, h, f, t)\n    \n    # Call the hanoi function to solve the problem\n    hanoi(n, f, h, t)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return \"Solution executed\"", "funcname": "main_solution", "ios": [{"input": {"n": 9, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 7, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 3, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 1, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 8, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 2, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 10, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 4, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 6, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}, {"input": {"n": 5, "f": "A", "h": "B", "t": "C"}, "output": "Solution executed"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "joaosvictor/practice", "path": "/puzzles/hanoitowerSolver.py", "msgidx": 6613}}
{"problem_description": "Given a square matrix of size `matrix_size`, how can we fill it in a spiral pattern starting from the top-left corner and moving towards the center? The matrix should be filled with consecutive integers starting from 1. What will be the final filled matrix?", "io_requirements": "Input:\n  `matrix_size` (int): The size of the square matrix (number of rows and columns).\n\nOutput:\n  `return` (list of lists of int): A 2D list representing the filled matrix where each element is an integer.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef Recursion(x, y, num, length, array):\n    if length <= 0:\n        return\n    L = length \n    while L > 0:\n        L -= 1\n        y += 1\n        num += 1\n        array[x][y] = num\n    L = length - 1\n    while L > 0:\n        L -= 1\n        num += 1\n        x += 1\n        y -= 1\n        array[x][y] = num\n    L = length - 2\n    while L > 0:\n        L -= 1\n        num += 1\n        x -= 1\n        array[x][y] = num\n    Recursion(x, y, num, length - 3, array)  \n\n# main function\ndef main_solution(matrix_size):\n    # Convert the input to the required format\n    num = int(matrix_size)\n    array = np.zeros((num, num), dtype=np.int16)\n    \n    # Call the recursive function\n    Recursion(0, -1, 0, num, array)\n    \n    # Convert the output to a JSON serializable format\n    result = array.tolist()\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"matrix_size": 3}, "output": [[1, 2, 3], [6, 4, 0], [5, 0, 0]]}, {"input": {"matrix_size": 4}, "output": [[1, 2, 3, 4], [9, 10, 5, 0], [8, 6, 0, 0], [7, 0, 0, 0]]}, {"input": {"matrix_size": 1}, "output": [[1]]}, {"input": {"matrix_size": 2}, "output": [[1, 2], [3, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "scathachcs/Python", "path": "/Py_course/test1.py", "msgidx": 6359}}
{"problem_description": "Given a starting number, what is the smallest positive integer `x` such that `2x`, `3x`, `4x`, `5x`, and `6x` contain exactly the same digits, starting from the given `start_number`?", "io_requirements": "Input:\n  `start_number` (int): The starting number from which to begin the search for the smallest positive integer `x` such that `2x`, `3x`, `4x`, `5x`, and `6x` contain the same digits.\n\nOutput:\n  `return` (int): The smallest positive integer `x` such that `2x`, `3x`, `4x`, `5x`, and `6x` contain the same digits, starting from the given `start_number`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef hasSameDigits(n):\n    numStrings = [str(n), str(2*n), str(3*n), str(4*n), str(5*n), str(6*n)]\n    lengths = [len(num) for num in numStrings]\n    if len(lengths) != lengths.count(lengths[0]):\n        return False\n    digits = set([digit for digit in numStrings[0]])\n    for i in range(1, len(numStrings)):\n        otherDigits = set([digit for digit in numStrings[i]])\n        if digits != otherDigits:\n            return False\n    return True\n\n# main function\ndef main_solution(start_number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    answer = start_number\n    while not hasSameDigits(answer):\n        answer += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return answer", "funcname": "main_solution", "ios": [{"input": {"start_number": 56712}, "output": 142857}, {"input": {"start_number": 78776}, "output": 142857}, {"input": {"start_number": 74016}, "output": 142857}, {"input": {"start_number": 82130}, "output": 142857}, {"input": {"start_number": 99102}, "output": 142857}, {"input": {"start_number": 7282}, "output": 142857}, {"input": {"start_number": 2285}, "output": 142857}, {"input": {"start_number": 82815}, "output": 142857}, {"input": {"start_number": 33090}, "output": 142857}, {"input": {"start_number": 58261}, "output": 142857}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "csaden/euler", "path": "/0052euler_PermutedMultiples.py", "msgidx": 7113}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate. It should be a positive integer.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of parentheses. Each string will have exactly `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        self.list = []\n        self._gen(0, 0, n, \"\")\n        return self.list\n\n    def _gen(self, left, right, n, result):\n        '''\n        :param left: \u7528\u5b8c\uff08 \u7684\u6b21\u6570\n        :param right: \u7528\u5b8c \uff09\u7684\u6b21\u6570\n        :param n:\n        :param result:\n        :return: \u526a\u679d\u601d\u60f3\n        '''\n        if left == n and right == n:  # \u5de6\u62ec\u53f7\u548c\u53f3\u62ec\u53f7\u90fd\u7528\u5b8c\u5373\u7ed3\u675f\u6761\u4ef6\n            self.list.append(result)\n            return\n        if left < n:  # \u5de6\u62ec\u53f7\u6ca1\u7528\u5b8c\n            self._gen(left + 1, right, n, result + \"(\")\n        if left > right and right < n:  # \u53f3\u62ec\u53f7\u6ca1\u7528\u5b8c\u5e76\u4e14\u53f3\u62ec\u53f7\u5fc5\u987b\u6bd4\u5de6\u62ec\u53f7\u5c11\n            self._gen(left, right + 1, n, result + \")\")\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RichieSong/algorithm", "path": "/\u7b97\u6cd5/\u62ec\u53f7\u751f\u6210.py", "msgidx": 6546}}
{"problem_description": "Given a standard 8x8 chessboard, how many distinct ways can you place 8 queens such that no two queens threaten each other, and what are the positions of the queens in each solution?", "io_requirements": "Input:\n  No input arguments are required for this function.\nOutput:\n  `return` (list of lists of strings): Each inner list represents a solution to the 8-queens problem. Each string in the inner list represents the position of a queen on the chessboard in the format \"A1\", \"B2\", etc.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef list_queen(queen_list=list(), place_list=None):\n    if place_list is None:\n        place_list = list(itertools.product([1, 2, 3, 4, 5, 6, 7, 8], repeat=2))\n    main_list = []\n    if len(queen_list) == 8:\n        main_list.append(queen_list[:])\n        return True\n    elif not place_list:\n        return False\n    x_act = len(queen_list) + 1\n    for y in range(1, 9):\n        if (x_act, y) in place_list:\n            new_place_list = []\n            for (xp, yp) in place_list:\n                # \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043a\u043b\u0435\u0442\u043e\u043a: \u0432\u0435\u0440\u0442, \u0433\u043e\u0440\u0438\u0437, 1\u0430\u044f \u0438 2\u0430\u044f \u0434\u0438\u0430\u0433\u043e\u043d\u0430\u043b\u044c\n                if xp != x_act and yp != y and abs(x_act - xp) != abs(y - yp):\n                    new_place_list.append((xp, yp))\n            list_queen(queen_list[:] + [(x_act, y)], new_place_list)\n    return main_list\n\n# main function\ndef main_solution():\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = list_queen()\n  # Convert the result to a JSON serializable format\n  serializable_result = [[' ABCDEFGH'[x] + str(y) for (x, y) in el] for el in result]\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return serializable_result", "funcname": "main_solution", "ios": [{"input": {}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "NikeSP/Portfolio", "path": "/MathTasks/queens_8.py", "msgidx": 6576}}
{"problem_description": "Imagine you are exploring the philosophical concept of skepticism, particularly concerning the possibility of being a brain in a vat (BIV). Given a belief about the external world, what can you deduce about your knowledge or lack thereof regarding the BIV scenario?", "io_requirements": "Input:\n  `belief` (str): A string representing the belief to be checked. It can be either \"biv\" or any other string representing a belief about the external world.\n\nOutput:\n  `return` (str): A string describing the knowledge or lack thereof based on the belief provided. It will either confirm knowledge about not being a brain in a vat or express uncertainty.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nknowledge = [\"P\"]  # what we know\n\ndef simplenotbiv():\n    \"\"\"\n    Logical architecture for a simple brain in a vat argument and its effect\n    on whether we have hands.\n    \"\"\"\n    if \"biv\" not in knowledge:  # If I don't know I'm not a biv\n        return \"I don't know that I have hands.\"\n    return \"I know that I have hands.\"\n\ndef knowP(P):\n    \"\"\"\n    Skeptical argument for some belief or claim p on the external world. \n    If you can't be sure that you are not a brain in a vat,\n    then you can't rule out the possibility all your beliefs about the external \n    world are false.\n \n    Descartes outlined this method of reasoning, and this line\n    of reasoning was the premise for the movie \"The Matrix.\" \n    \"\"\"\n    if P in knowledge:  # if we know P. Here we're using Python's \n        return \"I know I'm not a brain in a vat.\"\n    return \"I don't know that P. I don't know that I'm not a brain in a vat.\"\n\n# main function\ndef main_solution(belief):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    if belief == \"biv\":\n        result = simplenotbiv()\n    else:\n        result = knowP(belief)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"belief": "R"}, "output": "I don't know that P. I don't know that I'm not a brain in a vat."}, {"input": {"belief": "P"}, "output": "I know I'm not a brain in a vat."}, {"input": {"belief": "Q"}, "output": "I don't know that P. I don't know that I'm not a brain in a vat."}, {"input": {"belief": "biv"}, "output": "I don't know that I have hands."}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "krishnakatyal/philosophy", "path": "/epist/braininvat.py", "msgidx": 6239}}
{"problem_description": "Given a grid of dimensions `width` x `height`, how many unique paths are there from the top-left corner to the bottom-right corner, moving only right or down?", "io_requirements": "Input:\n  `width` (int): The width of the grid.\n  `height` (int): The height of the grid.\n\nOutput:\n  `return` (int): The number of possible routes from the top-left corner to the bottom-right corner of the grid.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass LatticeRoute:\n    def __init__(self, width, height):\n        self.w = width\n        self.h = height\n        \n        self.points = {}    # \u0442\u0430\u0431\u043b\u0438\u0446\u044f \u0456\u0437 \u0442\u043e\u0447\u043a\u0430\u043c\u0438, \u0441\u043b\u043e\u0432\u043d\u0438\u043a \u0443 \u0444\u043e\u0440\u043c\u0430\u0442\u0456 {(x,y): \u043a-\u0441\u0442\u044c \u0448\u043b\u044f\u0445\u0456\u0432 \u0434\u043e \u0446\u0456\u0454\u0457 \u0442\u043e\u0447\u043a\u0438, ...}\n        \n        for i in range(self.w + 1): self.points.setdefault((i, 0), 1)   # \u0456\u043d\u0456\u0446\u0456\u0430\u043b\u0456\u0437\u0430\u0446\u0456\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u0456 \u0456\u0437 \u0442\u043e\u0447\u043a\u0430\u043c\u0438\n        for j in range(self.h + 1): self.points.setdefault((0, j), 1)   # \u043f\u0435\u0440\u0448\u0438\u0439 \u0440\u044f\u0434\u043e\u043a \u0456 \u0441\u0442\u043e\u0432\u043f\u0447\u0438\u043a \u0437\u0430\u043f\u043e\u0432\u043d\u044e\u0454\u0442\u044c\u0441\u044f \u043e\u0434\u0438\u043d\u0438\u0446\u044f\u043c\u0438 \n                                                                        # (\u0434\u043e \u043a\u043e\u0436\u043d\u043e\u0457 \u0442\u043e\u0447\u043a\u0438 \u043c\u043e\u0436\u043b\u0438\u0432\u0438\u0439 \u0442\u0456\u043b\u044c\u043a\u0438 1 \u0448\u043b\u044f\u0445)\n\n        self.makeRoutes() \n        \n    def makeRoutes(self): \n        \n        for x in range(1, self.w + 1):\n            for y in range(1, self.h + 1):\n                \n                self.points[x, y] = self.points[x-1, y] + self.points[x, y-1]\n\n    def get_routes_count(self):\n        return self.points[self.w, self.h]\n\n# main function\ndef main_solution(width, height):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    lattice = LatticeRoute(width, height)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return lattice.get_routes_count()", "funcname": "main_solution", "ios": [{"input": {"width": 10, "height": 1}, "output": 11}, {"input": {"width": 7, "height": 10}, "output": 19448}, {"input": {"width": 7, "height": 6}, "output": 1716}, {"input": {"width": 8, "height": 1}, "output": 9}, {"input": {"width": 2, "height": 6}, "output": 28}, {"input": {"width": 7, "height": 1}, "output": 8}, {"input": {"width": 10, "height": 9}, "output": 92378}, {"input": {"width": 4, "height": 8}, "output": 495}, {"input": {"width": 3, "height": 6}, "output": 84}, {"input": {"width": 1, "height": 1}, "output": 2}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bodik10/EulerSolving", "path": "/euler 015/euler15_lattice_points.py", "msgidx": 6601}}
{"problem_description": "In a grid of size `m` by `n`, a robot starts at the top-left corner (0, 0). The robot can move to the right or down, but it cannot move to a cell where the sum of the digits of its row and column indices exceeds `k`. How many cells can the robot reach?", "io_requirements": "Input:\n  `m` (int): The number of rows in the grid.\n  `n` (int): The number of columns in the grid.\n  `k` (int): The maximum sum of the digits of the row and column indices that the robot can move to.\n\nOutput:\n  `return` (int): The number of cells the robot can reach in the grid.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    '''\n    BFS\n    '''\n\n    def movingCount(self, m: int, n: int, k: int) -> int:\n        def add_coor(a, b):\n            ans = 0\n            for _ in (a, b):\n                while _ > 0:\n                    ans += _ % 10\n                    _ //= 10\n            return ans\n\n        marked = set()  # \u5c06\u8bbf\u95ee\u8fc7\u7684\u70b9\u6dfb\u52a0\u5230\u96c6\u5408marked\u4e2d,\u4ece(0,0)\u5f00\u59cb\n        queue = deque()\n        queue.append((0, 0))\n        while queue:\n            x, y = queue.popleft()\n            if (x, y) not in marked and add_coor(x, y) <= k:\n                marked.add((x, y))\n                for dx, dy in [(1, 0), (0, 1)]:  # \u4ec5\u8003\u8651\u5411\u53f3\u548c\u5411\u4e0b\u5373\u53ef\n                    if 0 <= x + dx < m and 0 <= y + dy < n:\n                        queue.append((x + dx, y + dy))\n\n        return len(marked)\n\n# main function\ndef main_solution(m: int, n: int, k: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.movingCount(m, n, k)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"m": 34, "n": 72, "k": 10}, "output": 309}, {"input": {"m": 7, "n": 30, "k": 3}, "output": 10}, {"input": {"m": 37, "n": 70, "k": 9}, "output": 145}, {"input": {"m": 73, "n": 43, "k": 16}, "output": 2201}, {"input": {"m": 82, "n": 43, "k": 6}, "output": 28}, {"input": {"m": 77, "n": 96, "k": 15}, "output": 2331}, {"input": {"m": 27, "n": 36, "k": 4}, "output": 15}, {"input": {"m": 51, "n": 1, "k": 0}, "output": 1}, {"input": {"m": 60, "n": 63, "k": 20}, "output": 3456}, {"input": {"m": 22, "n": 41, "k": 10}, "output": 281}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "guzhi-zxy/leetCodeLearning", "path": "/example/movingCount.py", "msgidx": 6904}}
{"problem_description": "Given a partially filled truth table for a logical function \ud835\udc39, which is defined as (y\u2192z)/\\\u00ac((y\\/\ud835\udc64)\u2192(z/\\\ud835\udc65)), determine which column in the table corresponds to each of the variables \ud835\udc64, \ud835\udc65, \ud835\udc66, and \ud835\udc67. The table contains rows with values for the variables and the result of the function \ud835\udc39. What is the mapping of each variable to its respective column index?", "io_requirements": "Input:\n  `partial_truth_table` (list of lists): A partially filled truth table where each inner list represents a row in the truth table. Each row contains 5 elements: the values of the variables (w, x, y, z) and the result of the logical function F. The values of the variables are either 0 or 1.\n\nOutput:\n  `return` (dict): A dictionary mapping each variable (w, x, y, z) to its corresponding column index in the truth table. The keys are 'w', 'x', 'y', 'z' and the values are integers representing the column indices (0, 1, 2, 3).", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(partial_truth_table):\n    \"\"\"\n    This function takes a partially filled truth table and determines which column corresponds to each variable (w, x, y, z).\n    The function returns a dictionary mapping each variable to its corresponding column index.\n    \"\"\"\n    # Convert the partial truth table to a list of tuples\n    partial_truth_table = [tuple(row) for row in partial_truth_table]\n    \n    # Generate all possible permutations of the columns (w, x, y, z)\n    for perm in itertools.permutations(range(4)):\n        # Check if the permutation satisfies the logical expression\n        valid = True\n        for row in partial_truth_table:\n            x, y, z, w = [row[i] for i in perm]\n            F = (y <= z) and not((y or w) <= (z and x))\n            if F != row[4]:\n                valid = False\n                break\n        if valid:\n            # Return the mapping of variables to column indices\n            return {\n                'w': perm[0],\n                'x': perm[1],\n                'y': perm[2],\n                'z': perm[3]\n            }\n    return None", "funcname": "main_solution", "ios": [{"input": {"partial_truth_table": [[1, 1, 0, 1, 1], [0, 0, 0, 1, 0], [1, 0, 0, 1, 1]]}, "output": {"w": 2, "x": 0, "y": 3, "z": 1}}, {"input": {"partial_truth_table": [[0, 0, 0, 0, 0], [1, 0, 0, 1, 0], [1, 0, 1, 0, 1], [1, 1, 0, 1, 1]]}, "output": {"w": 2, "x": 3, "y": 1, "z": 0}}, {"input": {"partial_truth_table": [[1, 1, 1, 0, 1], [0, 1, 0, 1, 1], [0, 0, 0, 1, 0], [1, 0, 1, 1, 0]]}, "output": {"w": 3, "x": 0, "y": 2, "z": 1}}, {"input": {"partial_truth_table": [[0, 0, 1, 0, 0], [1, 0, 1, 1, 0]]}, "output": {"w": 0, "x": 1, "y": 2, "z": 3}}, {"input": {"partial_truth_table": [[1, 0, 0, 1, 1], [1, 1, 1, 0, 0]]}, "output": {"w": 0, "x": 1, "y": 2, "z": 3}}, {"input": {"partial_truth_table": [[1, 0, 0, 1, 1], [0, 0, 0, 1, 0]]}, "output": {"w": 1, "x": 0, "y": 3, "z": 2}}, {"input": {"partial_truth_table": [[0, 1, 1, 1, 1], [1, 1, 0, 0, 0], [0, 0, 1, 1, 1]]}, "output": {"w": 0, "x": 1, "y": 2, "z": 3}}, {"input": {"partial_truth_table": [[1, 0, 1, 1, 1], [1, 0, 1, 1, 1]]}, "output": {"w": 1, "x": 0, "y": 2, "z": 3}}, {"input": {"partial_truth_table": [[0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]}, "output": {"w": 1, "x": 2, "y": 3, "z": 0}}, {"input": {"partial_truth_table": [[1, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 1, 0, 1], [1, 0, 1, 1, 0]]}, "output": {"w": 3, "x": 0, "y": 1, "z": 2}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "htmlprogrammist/kege-2021", "path": "/Bariants/statgrad-ov-03-21/task_2.py", "msgidx": 7022}}
{"problem_description": "In a room, there are `n` bulbs that are initially off. You start by turning on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). This process continues until the nth round, where you only toggle the last bulb. How many bulbs remain on after `n` rounds?", "io_requirements": "Input:\n  `n` (int): The number of bulbs.\n\nOutput:\n  `return` (int): The number of bulbs that remain on after n rounds.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    This function calculates the number of bulbs that remain on after n rounds of toggling.\n    Only bulbs with index being a perfect square number will remain on.\n    \n    :param n: int, the number of bulbs.\n    :return: int, the number of bulbs that remain on after n rounds.\n    \"\"\"\n    cnt = int(math.sqrt(n))\n    return cnt", "funcname": "main_solution", "ios": [{"input": {"n": 727}, "output": 26}, {"input": {"n": 792}, "output": 28}, {"input": {"n": 748}, "output": 27}, {"input": {"n": 560}, "output": 23}, {"input": {"n": 213}, "output": 14}, {"input": {"n": 456}, "output": 21}, {"input": {"n": 979}, "output": 31}, {"input": {"n": 794}, "output": 28}, {"input": {"n": 368}, "output": 19}, {"input": {"n": 948}, "output": 30}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "syurskyi/Python_Topics", "path": "/125_algorithms/_exercises/templates/_algorithms_challenges/leetcode/LeetCode_with_solution/319 Bulb Switcher.py", "msgidx": 6417}}
{"problem_description": "Given a linked list represented by a sequence of integers, where the last node may point to an earlier node to form a loop, determine the value of the node where the loop starts. If there is no loop, return `None`. What is the value of the entry node of the loop in the given linked list?", "io_requirements": "Input:\n  `linked_list_json` (str): A JSON string representing a list of integers. The list represents the values of a linked list. The last node in the list may point to an earlier node to create a loop.\n\nOutput:\n  `return` (int or None): The value of the entry node of the loop in the linked list. If there is no loop, returns `None`.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def hasCycle(self, head):\n        if head is None or head.next is None:\n            return False\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n\n    def EntryNodeOfLoop(self, pHead):\n        if pHead is None or pHead.next is None:\n            return None\n        fast = slow = pHead\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                fast = pHead\n                while fast != slow:\n                    fast = fast.next\n                    slow = slow.next\n                return fast\n        return None\n\n# main function\ndef main_solution(linked_list_json):\n    # Convert JSON string to list of nodes\n    linked_list = json.loads(linked_list_json)\n    \n    # Create linked list from list of values\n    head = ListNode(linked_list[0])\n    current = head\n    for val in linked_list[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    \n    # Create a loop if the last node points to the second node\n    if len(linked_list) > 1:\n        current.next = head.next\n    \n    # Find the entry node of the loop\n    solution = Solution()\n    entry_node = solution.EntryNodeOfLoop(head)\n    \n    # Return the value of the entry node or None if no loop\n    return entry_node.val if entry_node else None", "funcname": "main_solution", "ios": [{"input": {"linked_list_json": "[28, 49, 12]"}, "output": 49}, {"input": {"linked_list_json": "[68, 25, 53, 72, 24, 77, 2, 81, 66, 93, 2]"}, "output": 25}, {"input": {"linked_list_json": "[75, 95, 59, 21, 66, 7, 61, 69, 5]"}, "output": 95}, {"input": {"linked_list_json": "[37, 33, 79, 54, 9]"}, "output": 33}, {"input": {"linked_list_json": "[88, 21, 65, 84, 43, 34, 8, 23, 16]"}, "output": 21}, {"input": {"linked_list_json": "[38, 65, 57, 23, 42, 32]"}, "output": 65}, {"input": {"linked_list_json": "[89, 60, 59, 1]"}, "output": 60}, {"input": {"linked_list_json": "[60, 67, 69, 30, 91, 69, 43, 2, 6, 39, 8]"}, "output": 67}, {"input": {"linked_list_json": "[46, 37, 29, 20, 56, 6, 95, 22, 63, 3]"}, "output": 37}, {"input": {"linked_list_json": "[12, 63, 55, 49, 67, 70, 86, 89, 73, 1]"}, "output": 63}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DrBugKiller/offer", "path": "/\u5251\u6307offer/\u7b2c\u4e09\u7ae0\u9ad8\u8d28\u91cf\u7684\u4ee3\u7801/23-\u5bfb\u627e\u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u7ed3\u70b9.py", "msgidx": 7180}}
{"problem_description": "In a social network, friends can be connected through other friends, forming a network of relationships. Given a set of friendships and two friends, determine if one friend is a distant friend of the other. A distant friend is defined as someone who is connected through one or more intermediate friends. For example, if A is a friend of B, and B is a friend of C, then A is a distant friend of C.\n\nGiven the list of friendships and two friends, is the first friend a distant friend of the second friend?", "io_requirements": "Input:\n  `edges` (list of tuples): A list of tuples where each tuple represents a friendship between two friends. Each tuple contains two strings representing the parent and child vertices.\n  `start` (string): A string representing the starting vertex (friend) for the search.\n  `target` (string): A string representing the target vertex (friend) to check if it is a distant friend of the start vertex.\n\nOutput:\n  `return` (string): A string that is either 'Yes' or 'No', indicating whether the start vertex is a distant friend of the target vertex.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    # default dictionary to store graph\n    graph = defaultdict(list)\n\n    # function to add an edge to graph\n    def addEdge(self, parent, child):\n        self.graph[parent].append(child)\n\n    def is_friend_of_friend(self, vertex, visited, target):\n        visited.add(vertex)\n        for neighbour in self.graph[vertex]:\n            if neighbour not in visited:\n                self.is_friend_of_friend(neighbour, visited, target)\n                if target in visited:\n                    return True\n        return False\n\n    def DepthFirstSearch(self, start, target):\n        # Create a set to store visited vertices\n        visited = set()\n        # Call the recursive helper function to print DepthFirstSearch traversal\n        return self.is_friend_of_friend(start, visited, target)\n\n# main function\ndef main_solution(edges, start, target):\n    # edges: list of tuples representing the friendships (parent, child)\n    # start: string representing the starting vertex\n    # target: string representing the target vertex\n    \n    # Create a graph instance\n    friendships = Graph()\n    \n    # Add edges to the graph\n    for parent, child in edges:\n        friendships.addEdge(parent, child)\n    \n    # Perform DepthFirstSearch to check if start is a friend of target\n    is_friend = friendships.DepthFirstSearch(start=start, target=target)\n    \n    # Convert the result to a JSON serializable output\n    return 'Yes' if is_friend else 'No'", "funcname": "main_solution", "ios": [{"input": {"edges": [["D", "C"], ["C", "C"], ["A", "E"], ["D", "E"], ["E", "E"]], "start": "E", "target": "A"}, "output": "No"}, {"input": {"edges": [["E", "B"], ["C", "E"], ["C", "B"], ["C", "C"], ["D", "B"]], "start": "D", "target": "C"}, "output": "Yes"}, {"input": {"edges": [["A", "B"], ["D", "B"], ["A", "D"], ["C", "C"], ["A", "D"]], "start": "B", "target": "A"}, "output": "No"}, {"input": {"edges": [["C", "D"], ["A", "A"], ["D", "D"], ["B", "A"], ["B", "A"]], "start": "C", "target": "B"}, "output": "Yes"}, {"input": {"edges": [["E", "E"], ["B", "D"], ["B", "C"], ["D", "D"], ["D", "B"]], "start": "D", "target": "D"}, "output": "Yes"}, {"input": {"edges": [["B", "E"], ["A", "B"], ["A", "A"], ["C", "E"], ["B", "E"]], "start": "A", "target": "E"}, "output": "Yes"}, {"input": {"edges": [["C", "D"], ["E", "B"], ["E", "B"], ["B", "B"], ["B", "D"]], "start": "B", "target": "B"}, "output": "Yes"}, {"input": {"edges": [["B", "C"], ["C", "A"], ["C", "E"], ["E", "B"], ["A", "E"]], "start": "E", "target": "A"}, "output": "Yes"}, {"input": {"edges": [["D", "D"], ["A", "C"], ["D", "C"], ["E", "E"], ["A", "E"]], "start": "D", "target": "C"}, "output": "Yes"}, {"input": {"edges": [["E", "D"], ["A", "A"], ["D", "A"], ["E", "E"], ["D", "E"]], "start": "A", "target": "E"}, "output": "Yes"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "julzhk/codekata", "path": "/depth_first_graph.py", "msgidx": 6922}}
{"problem_description": "Given a binary tree where each node has a key and pointers to its left child, right child, and a random node within the tree, how can you clone this binary tree such that the cloned tree has the same structure and random pointers as the original tree?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys:\n    - `val` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as a dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as a dictionary or None if there is no right child.\n    - `random` (dict or None): The random pointer of the node, represented as a dictionary or None if there is no random pointer.\n\nOutput:\n  `return` (dict): A dictionary representing the structure of the cloned binary tree. The structure is the same as the input `tree_structure`.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.random = None\n\nclass Solution:\n    def cloneRandomTree(self, tree: 'Node') -> 'Node':\n        visited_dict = {}\n        \n        def compute(old_node):\n            if old_node == None:\n                return None\n            \n            if old_node in visited_dict:\n                return visited_dict[old_node]\n\n            new_node = Node(old_node.val)\n            visited_dict[old_node] = new_node\n\n            new_node.left = compute(old_node.left)\n            new_node.right = compute(old_node.right)\n            new_node.random = compute(old_node.random)\n            return new_node\n\n        return compute(tree)\n\n# main function\ndef main_solution(tree_structure: dict) -> dict:\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(structure):\n        if not structure:\n            return None\n        node = Node(structure['val'])\n        node.left = build_tree(structure['left'])\n        node.right = build_tree(structure['right'])\n        node.random = build_tree(structure['random'])\n        return node\n\n    tree = build_tree(tree_structure)\n    \n    # Clone the tree\n    cloned_tree = Solution().cloneRandomTree(tree)\n    \n    # Convert the output to JSON serializable format\n    def serialize_tree(node):\n        if not node:\n            return None\n        return {\n            'val': node.val,\n            'left': serialize_tree(node.left),\n            'right': serialize_tree(node.right),\n            'random': serialize_tree(node.random)\n        }\n    \n    serialized_cloned_tree = serialize_tree(cloned_tree)\n    \n    return serialized_cloned_tree", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 72, "left": null, "right": null, "random": null}}, "output": {"val": 72, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 82, "left": null, "right": null, "random": null}}, "output": {"val": 82, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 29, "left": null, "right": null, "random": null}}, "output": {"val": 29, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 23, "left": null, "right": null, "random": null}}, "output": {"val": 23, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 64, "left": null, "right": null, "random": null}}, "output": {"val": 64, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 40, "left": null, "right": null, "random": null}}, "output": {"val": 40, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 80, "left": null, "right": null, "random": null}}, "output": {"val": 80, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 57, "left": null, "right": null, "random": null}}, "output": {"val": 57, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 95, "left": null, "right": null, "random": null}}, "output": {"val": 95, "left": null, "right": null, "random": null}}, {"input": {"tree_structure": {"val": 30, "left": null, "right": null, "random": null}}, "output": {"val": 30, "left": null, "right": null, "random": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sagarneeli/coding-challenges", "path": "/Trees/clone_binary_tree_random_pointers.py", "msgidx": 7150}}
{"problem_description": "Given a starting point and an ending point on a plane, how can we generate a Koch curve with a specified number of iterations, and what are the coordinates of the points that form the curve?", "io_requirements": "Input:\n  `n` (int): The number of iterations for the Koch curve generation.\n  `p1` (list of float): A list containing the x and y coordinates of the starting point of the Koch curve.\n  `p2` (list of float): A list containing the x and y coordinates of the ending point of the Koch curve.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `PointX` (list of float): A list of x-coordinates of the points generated by the Koch curve.\n    - `PointY` (list of float): A list of y-coordinates of the points generated by the Koch curve.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef addplt(point, PointX, PointY):\n    PointX.append(point[0])\n    PointY.append(point[1])\n\ndef koch_curve(n, p1, p2, PointX, PointY):\n    if n == 0:\n        return\n    else:\n        sx = (2 * p1[0] + p2[0]) / 3\n        sy = (2 * p1[1] + p2[1]) / 3\n        tx = (p1[0] + 2 * p2[0]) / 3\n        ty = (p1[1] + 2 * p2[1]) / 3\n\n        theta = math.radians(60)\n        ux = (tx - sx) * math.cos(theta) - (ty - sy) * math.sin(theta) + sx\n        uy = (tx - sx) * math.sin(theta) + (ty - sy) * math.cos(theta) + sy\n\n        s = [sx, sy]\n        t = [tx, ty]\n        u = [ux, uy]\n\n        koch_curve(n - 1, p1, s, PointX, PointY)\n        addplt(s, PointX, PointY)\n        \n        koch_curve(n - 1, s, u, PointX, PointY)\n        addplt(u, PointX, PointY)\n\n        koch_curve(n - 1, u, t, PointX, PointY)\n        addplt(t, PointX, PointY)\n\n        koch_curve(n - 1, t, p2, PointX, PointY)\n\n# main function\ndef main_solution(n, p1, p2):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    PointX = []\n    PointY = []\n    \n    # Convert JSON serializable inputs to original input variables\n    p1 = [float(p1[0]), float(p1[1])]\n    p2 = [float(p2[0]), float(p2[1])]\n    \n    # Call the koch_curve function\n    koch_curve(n, p1, p2, PointX, PointY)\n    \n    # Convert the output to JSON serializable format\n    output = {\n        \"PointX\": PointX,\n        \"PointY\": PointY\n    }\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return output", "funcname": "main_solution", "ios": [{"input": {"n": 1, "p1": [27.28606468988416, 47.477420954936164], "p2": [22.67432866961888, 97.05410190873077]}, "output": {"PointX": [25.748819349795735, 10.668641632650766, 24.211574009707306], "PointY": [64.0029812728677, 70.93446791546764, 80.52854159079924]}}, {"input": {"n": 1, "p1": [6.7512231528665145, 79.0685844801897], "p2": [57.545498654753736, 14.234087109582571]}, "output": {"PointX": [23.682648320162254, 50.864468158657175, 40.61407348745799], "PointY": [57.457085356653984, 61.31438011203943, 35.845586233118276]}}, {"input": {"n": 1, "p1": [76.0784025495982, 45.595451392738674], "p2": [39.74670132802258, 2.9700209067838657]}, "output": {"PointX": [63.96783547573966, 70.21745382150523, 51.85726840188112], "PointY": [31.38697456408707, 13.794677409564397, 17.178497735435467]}}, {"input": {"n": 1, "p1": [54.74705174521347, 84.93445053493053], "p2": [90.02169845744352, 73.1901189009973]}, "output": {"PointX": [66.50526731595681, 75.77467161648029, 78.26348288670017], "PointY": [81.01967332361946, 89.24519810540141, 77.10489611230838]}}, {"input": {"n": 1, "p1": [17.88790015360393, 61.27343948772134], "p2": [88.64653796678735, 13.56136574919372]}, "output": {"PointX": [41.474112757998405, 67.04050836846272, 65.06032536239287], "PointY": [45.36941490821213, 57.843661912923864, 29.465390328702927]}}, {"input": {"n": 1, "p1": [2.7406782823564235, 45.13228528452922], "p2": [45.96440727856028, 48.851231423095086]}, "output": {"PointX": [17.148587947757708, 23.278975503356996, 31.556497613158996], "PointY": [46.37193399738451, 59.46937413948102, 47.611582710239794]}}, {"input": {"n": 1, "p1": [27.73485200429191, 62.07848989032145], "p2": [36.28587670341226, 81.82959419007172]}, "output": {"PointX": [30.585193570665357, 26.308711661725503, 33.435535137038805], "PointY": [68.66219132357155, 74.42251024613871, 75.24589275682162]}}, {"input": {"n": 1, "p1": [46.43796939168829, 17.358642433525016], "p2": [72.59498889363091, 77.45901476434604]}, "output": {"PointX": [55.15697589233583, 42.16699607086147, 63.87598239298337], "PointY": [37.39209987713202, 54.95970972425795, 57.425557320739024]}}, {"input": {"n": 1, "p1": [83.20168452612673, 97.94771891072342], "p2": [18.03376564478325, 97.81159438412332]}, "output": {"PointX": [61.47904489901223, 50.65702085149292, 39.75640527189774], "PointY": [97.90234406852339, 79.0672988930877, 97.85696922632336]}}, {"input": {"n": 1, "p1": [45.54337741070523, 1.535406905928527], "p2": [4.1713131828585714, 49.87978577953185]}, "output": {"PointX": [31.752689334756344, 10.901525218541835, 17.962001258807458], "PointY": [17.650199863796303, 13.764510133291314, 33.76499282166407]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Hiromitsu4676/algorithm", "path": "/koch_curve.py", "msgidx": 6892}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses? (The input variable is `n`.)", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n  def addParenthesis(self, x: List[str], s: str, nl: int, nr: int) -> None:\n    if nl == 0 and nr == 0:\n      x.append(s)\n      return None\n    if nl > 0:\n      self.addParenthesis(x, s + \"(\", nl - 1, nr + 1)\n    if nr > 0:\n      self.addParenthesis(x, s + \")\", nl, nr - 1)\n  def generateParenthesis(self, n: int) -> List[str]:\n    x = []\n    self.addParenthesis(x, \"\", n, 0)\n    return x\n\n# main function\ndef main_solution(n: int) -> List[str]:\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solver = Solution()\n  result = solver.generateParenthesis(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gyang274/leetcode", "path": "/src/0000-0099/0022.generate.parentheses.py", "msgidx": 6846}}
{"problem_description": "Given a labyrinth with a certain width and height, where some cells are walkable paths, some are walls, and some are holes, an agent is placed in a random walkable cell. The agent can move in four directions: up, down, left, and right. What will be the final position of the agent after performing a series of moves within the labyrinth?", "io_requirements": "Input:\n- `width` (int): The width of the labyrinth.\n- `height` (int): The height of the labyrinth.\n- `pathwall_ratio` (float): The ratio between walkable and not walkable cells.\n- `n_holes` (int): The number of holes in the labyrinth.\n- `moves` (list of strings): Each string represents a move direction ('up', 'down', 'left', 'right').\n\nOutput:\n- `return` (tuple of ints): The final position of the agent in the labyrinth, represented as a tuple `(x, y)`.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Labyrinth:\n    \"\"\"Create a labyrinth given by a boolean array where the paths are True, and the walls are False\"\"\"\n\n    def __init__(self, width, height, pathwall_ratio, n_holes):\n        \"\"\"\n        :param width: width of the labyrinth\n        :param height: height of the labyrinth\n        :param pathwall_ratio: ratio between walkable and not walkable cells\n        \"\"\"\n        self.cell_type = {'Wall': 'W',\n                          'Path': 'P',\n                          'Hole': 'H',\n                          'Exit': 'E'}\n        self.labyrinth = self.create_labyrinth(width, height, pathwall_ratio, n_holes)\n        self.paths = np.zeros(self.labyrinth.shape)\n        self.path_num = 0\n        self.last_path_label = 1\n\n    def create_labyrinth(self, width, height, pathwall_ratio, n_holes):\n        labyrinth = np.random.uniform(0, 1, (width, height))\n        labyrinth = labyrinth > pathwall_ratio\n        labyrinth = np.where(labyrinth == True, self.cell_type['Path'], self.cell_type['Wall'])\n        labyrinth[(np.random.randint(0, width, n_holes), np.random.randint(0, height, n_holes))] = \\\n            self.cell_type['Hole']\n        labyrinth[(np.random.randint(0, width), np.random.randint(0, height))] = self.cell_type['Exit']\n        return labyrinth\n\n    def check_path_connection(self):\n        \"Check that the Path cells are all connected\"\n        self.paths = np.zeros(self.labyrinth.shape)\n        self.path_num = 0\n        self.last_path_label = 1\n        for i in range(self.labyrinth.shape[0]):\n            for j in range(self.labyrinth.shape[1]):\n                self.scan(i, j)\n\n    def scan(self, ix, iy):\n        if self.labyrinth[ix, iy] == 'P':\n            if self.paths[ix, iy] == 0:\n                self.paths[ix, iy] = self.last_path_label\n                self.path_num += 1\n                self.last_path_label += 1\n            self.set_adjacent(ix + 1, iy, self.paths[ix, iy])\n            self.set_adjacent(ix, iy + 1, self.paths[ix, iy])\n\n    def set_adjacent(self, ix, iy, path_label):\n        if ix < 0 or ix >= self.labyrinth.shape[0] or iy < 0 or iy >= self.labyrinth.shape[1]:\n            return\n        if self.labyrinth[ix, iy] == 'P':\n            if self.paths[ix, iy] == 0:\n                self.paths[ix, iy] = path_label\n            elif self.paths[ix, iy] != path_label:\n                self.paths[np.where(self.paths == self.paths[ix, iy])] = path_label\n                self.path_num -= 1\n\n\nclass Agent:\n\n    def __init__(self, labyrinth):\n        self.labyrinth = labyrinth\n        self.width, self.height = self.labyrinth.shape\n        self._position = None\n\n    @property\n    def position(self):\n        while self._position is None or self.labyrinth[self._position] == False:\n            self._position = (np.random.randint(0, self.width), np.random.randint(0, self.height))\n        return self._position\n\n    @position.setter\n    def position(self, coord_pair):\n        self._position = coord_pair\n\n    def move_up(self):\n        ix, iy = self.position\n        if ix > 0 and self.labyrinth[ix - 1, iy]:\n            self.position = (ix - 1, iy)\n\n    def move_down(self):\n        ix, iy = self.position\n        if ix < self.height - 1 and self.labyrinth[ix + 1, iy]:\n            self.position = (ix + 1, iy)\n\n    def move_left(self):\n        ix, iy = self.position\n        if iy > 0 and self.labyrinth[ix, iy - 1]:\n            self.position = (ix, iy - 1)\n\n    def move_right(self):\n        ix, iy = self.position\n        if iy < self.width - 1 and self.labyrinth[ix, iy + 1]:\n            self.position = (ix, iy + 1)\n\n# main function\ndef main_solution(width, height, pathwall_ratio, n_holes, moves):\n    \"\"\"\n    :param width: int, width of the labyrinth\n    :param height: int, height of the labyrinth\n    :param pathwall_ratio: float, ratio between walkable and not walkable cells\n    :param n_holes: int, number of holes in the labyrinth\n    :param moves: list of strings, each string represents a move direction ('up', 'down', 'left', 'right')\n    :return: tuple, final position of the agent in the labyrinth\n    \"\"\"\n    labyrinth = Labyrinth(width, height, pathwall_ratio, n_holes)\n    agent = Agent(labyrinth.labyrinth)\n    for move in moves:\n        if move == 'up':\n            agent.move_up()\n        elif move == 'down':\n            agent.move_down()\n        elif move == 'left':\n            agent.move_left()\n        elif move == 'right':\n            agent.move_right()\n    return agent.position", "funcname": "main_solution", "ios": [{"input": {"width": 6, "height": 7, "pathwall_ratio": 0.49229993627261315, "n_holes": 2, "moves": ["up", "left", "right", "down", "left"]}, "output": [4, 3]}, {"input": {"width": 7, "height": 7, "pathwall_ratio": 0.6579326590937005, "n_holes": 4, "moves": ["up", "down", "down", "right", "right"]}, "output": [4, 6]}, {"input": {"width": 9, "height": 9, "pathwall_ratio": 0.3852699996595057, "n_holes": 4, "moves": ["up", "right", "up", "left", "right", "up"]}, "output": [2, 3]}, {"input": {"width": 5, "height": 7, "pathwall_ratio": 0.5284718140656395, "n_holes": 1, "moves": ["right", "down", "right", "up", "right"]}, "output": [3, 3]}, {"input": {"width": 6, "height": 9, "pathwall_ratio": 0.6614316091865825, "n_holes": 3, "moves": ["down", "left", "left", "right", "up"]}, "output": [1, 1]}, {"input": {"width": 9, "height": 5, "pathwall_ratio": 0.3213610890378781, "n_holes": 1, "moves": ["up", "right", "right", "down", "down"]}, "output": [7, 4]}, {"input": {"width": 7, "height": 7, "pathwall_ratio": 0.36180895535390367, "n_holes": 1, "moves": ["down", "right", "right", "up", "right"]}, "output": [3, 4]}, {"input": {"width": 9, "height": 9, "pathwall_ratio": 0.6097460284472513, "n_holes": 3, "moves": ["left", "down", "right", "up", "left"]}, "output": [5, 5]}, {"input": {"width": 9, "height": 8, "pathwall_ratio": 0.33947234324939224, "n_holes": 2, "moves": ["up", "right", "down", "left", "up"]}, "output": [4, 2]}, {"input": {"width": 8, "height": 6, "pathwall_ratio": 0.5890205567740197, "n_holes": 1, "moves": ["down", "up", "right", "up", "right"]}, "output": [0, 5]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AndreaCaliandro/ReinforcementLearning", "path": "/Games/Minotauros/labyrinth.py", "msgidx": 6737}}
{"problem_description": "Given a list of IP addresses, each containing random characters and possibly square brackets `[]`, how many of these IP addresses support Transport Layer Security (TLS) based on the presence of the ABBA pattern outside of any square brackets? The ABBA pattern is defined as a sequence of four characters where the first and fourth characters are the same, the second and third characters are the same, and all four characters are distinct.", "io_requirements": "Input:\n  `ip_list` (list of str): A list of IP addresses, where each IP address is a string. Each string may contain square brackets `[]` to denote sections that should not contain the TLS pattern.\n\nOutput:\n  `return` (int): The count of IP addresses that support TLS based on the presence of the ABBA pattern outside of any square brackets.", "refcode": "# import necessary packages\nimport re\nfrom collections import Counter\n\n# main function\ndef main_solution(ip_list):\n    \"\"\"\n    This function checks for the presence of Transport Layer Security (TLS) support in a list of IP addresses.\n    It counts the number of IP addresses that support TLS based on the presence of specific patterns.\n\n    Parameters:\n    ip_list (list of str): A list of IP addresses, where each IP address is a string.\n\n    Returns:\n    int: The count of IP addresses that support TLS.\n    \"\"\"\n    \n    def check_abba(ip, i, j):\n        if j - i <= 3:\n            return False\n        for k in range(0, j - i - 3, 1):\n            if (ip[i + k] == ip[i + k + 3]) and (ip[i + k + 1] == ip[i + k + 2]) and (ip[i + k] != ip[i + k + 1]):\n                return True\n        return False\n\n    def find_tls(full_input):\n        tls_count = 0\n        for ip in full_input:\n            aib = False\n            aob = False\n            obl = [pos for pos, char in enumerate(ip) if char == '[']\n            cbl = [pos for pos, char in enumerate(ip) if char == ']']\n            if not obl or not cbl:\n                continue\n            if (obl[0] == 0) or (cbl[-1] == (len(ip) - 2)):\n                continue\n            if len(obl) != len(cbl):\n                continue\n\n            # check all strings within brackets\n            for i in range(0, len(obl)):\n                if check_abba(ip, obl[i] + 1, cbl[i]):\n                    aib = True\n                    break\n            if aib:\n                continue\n\n            obl.insert(0, -1)\n            obl.insert(len(obl), len(ip) - 1)\n            cbl.insert(0, -1)\n            cbl.insert(len(cbl), len(ip) - 1)\n\n            # check strings out of brackets\n            for i in range(0, len(obl) - 1):\n                lptr = cbl[i] + 1\n                rptr = obl[i + 1]\n                if check_abba(ip, lptr, rptr):\n                    aob = True\n                if aob:\n                    tls_count += 1\n                    break\n        return tls_count\n\n    return find_tls(ip_list)", "funcname": "main_solution", "ios": [{"input": {"ip_list": ["V[RwCvuMEEiuKCJN[]]ioM[B]N", "gYHGIM[LRLW][Q[SY]]Q", "JAtYWjUnyWA", "ZedDDibxjDES[]Khy", "iHlp[[]KxeBaG[J]u]A", "PGCEM[]oSg[X]pe", "KENgxNrygrF", "wsUrOoxvyPU[]fmTkDK"]}, "output": 0}, {"input": {"ip_list": ["Qq[GVQCa]tpglfqwxrWm", "sKXiNSur[d]QZ[C]JU", "cvfeyrTfMFuzbQL", "osvhotbgIVdomdHLof", "qifieIrKpfzaWudJXxSS", "o[q]tlMDYQK[H]dt", "LwHAb[hUfYaXO]YMDjS"]}, "output": 0}, {"input": {"ip_list": ["fMoTwG[PKbAvTvP[]]HDJ", "N[QddNfVarvmZP]HGueEe", "KlVZVUHF[niG[g[JA]g]m]P", "jV[[[fy]]ovBMBDLtd]jpu", "MlkMEwN[[[]MmXkXCTSH]pmX]R", "l[[]Bbb[FZnt]]Yr"]}, "output": 0}, {"input": {"ip_list": ["lEbZD[u[k]]EhHg", "BAlhoHF[[][GOpRfJ]]W", "ovBxKoRymO[[o]W]y[h]dyoEKv", "JHZDQpTpwXRydtvG", "FUR[l]pdrQvU", "Q[KrzIjR]gbYXBB", "XE[Aqg]CMYvW"]}, "output": 0}, {"input": {"ip_list": ["dR[neXD]mRuaFsYn[ntu]s", "nvotRxqYuDJYkFK[eL]TW", "QHdKvyZxZdQtBaVtsGP", "iFyPbcGO[xfD]Kw[[]pqX]d", "jPBPL[Vy[]U[Xzkp]u]ijE", "uHKE[oQquPSlxhZgt[[D]]]g", "DJgujsC[Ik[l]]yTNfC"]}, "output": 0}, {"input": {"ip_list": ["RpMNN[sHM][j]l", "GgSW[HlrK][S]OX[TEV]Iy", "qPQZqMvJqGT[]UUjO", "oK[G]dpHTKaS", "kHZqYcx[jr]D"]}, "output": 0}, {"input": {"ip_list": ["AJKNv[hV[h]ZPFR[n]XW]Xo", "ghizEKLgWeKgelxaiflM", "GeKJ[AUuv[S]]H[N]hMdNka", "R[TVgGZYXvXsthax[[YV]]]k", "Ed[PVuhGex[n]cgdu]wmLYLJ", "FuJSg[k][RI[A]lBsG]Gckc"]}, "output": 0}, {"input": {"ip_list": ["CqTZtpWgHf[l]p", "OHTe[iF]LaRwJ", "pIOAUHzXBdFowbf[[C]K]PD", "dMXyA[Kn]dW[[b]]o", "YaDYxba[]YEvfYEk[]bV"]}, "output": 0}, {"input": {"ip_list": ["XqS[yeLz[][PDbc]o]k", "AIjxYYHnzJ[Z[MhDJ]]H[Dw]R", "JsZ[]DuZuftTUo[Z]cN", "WIUApJabDwNh[]sZ[L[ro]G]Wu", "i[YWWtYNQ[]OgH]FC", "KiwaLagetBWOoYQULrhD", "VKslz[]WUeq[cm]maeV", "BQfbloHgRu"]}, "output": 0}, {"input": {"ip_list": ["zZ[gbiuhfU]SNBqiY", "S[bL[]EDFEoKMa]FVV[]GZt", "EvCbwdFFMULSxK", "UrhDQYzLLEPLUveH[i][am]E", "UgbcNrwBssxvPeRFRsY", "jGUMAXS[dGuaBafsMhyy]W"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gauravk1001/AdventOfCode", "path": "/2016/Day7/Day7Part1.py", "msgidx": 6976}}
{"problem_description": "Given a set of four distinct digits in ascending order, what is the length of the longest set of consecutive positive integers that can be obtained using these digits and the four arithmetic operations (+, -, *, /) without any digit concatenation?", "io_requirements": "Input:\n  `digits` (str): A string of four distinct digits in ascending order, e.g., \"1234\".\n\nOutput:\n  `return` (int): The length of the longest set of consecutive positive integers that can be obtained using the given digits and the four arithmetic operations.", "refcode": "# import necessary packages\nimport operator\nfrom itertools import combinations, product\nfrom sympy.utilities.iterables import kbins\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# This will generate all binary trees with the given leaves.\ndef generate_trees(leaves):\n    # Iterate over all possible groups of 2 bins.\n    for these_bins in kbins(leaves, 2, ordered=0):\n        # If any of the bins have length greater than 2, then that bin must be broken up into bins\n        if any(len(kbin) > 2 for kbin in these_bins):\n            single = [x for x in these_bins if len(x) == 1][0][0]\n            multiple = [x for x in these_bins if len(x) != 1][0]\n\n            # All possible groups of 2 bins of the child bin.\n            for new_bins in generate_trees(multiple):\n                yield [single, new_bins]\n        else:\n            # For all the bins with length 1, extract the singular leaf.\n            yield [x[0] if len(x) == 1 else x for x in these_bins]\n\n# This will take in a binary tree of values and a list of operators to apply at the nodes\ndef compute_tree_value(operators, values):\n    this_op = operators[0]\n    operators = operators[1:]\n    left_val = values[0]\n    right_val = values[1]\n\n    if type(left_val) is not float:\n        left_vals = list(compute_tree_value(operators, left_val))\n    else:\n        left_vals = [left_val]\n\n    if type(right_val) is not float:\n        right_vals = list(compute_tree_value(operators, right_val))\n    else:\n        right_vals = [right_val]\n\n    for right_val in right_vals:\n        for left_val in left_vals:\n            if not (this_op == operator.truediv and right_val == 0):\n                yield this_op(left_val, right_val)\n\n            if not (this_op == operator.truediv and left_val == 0) and this_op in [operator.sub, operator.truediv]:\n                yield this_op(right_val, left_val)\n\n# This will take in a list of values and possible operators, and compute all the possible expressions with them.\ndef generate_expression_tree_values(operators, values):\n    for tree in generate_trees(values):\n        for operator_perm in product(operators, repeat=3):\n            for value in compute_tree_value(operator_perm, tree):\n                yield value\n\n# main function\ndef main_solution(digits):\n    # Convert the input string to a list of floats\n    val_perm = [float(x) for x in digits]\n    \n    values_expressed = {}\n    for val in generate_expression_tree_values(\n            [operator.add, operator.sub, operator.mul, operator.truediv], val_perm):\n        if not val.is_integer() or val <= 0:\n            continue\n\n        values_expressed[val] = None\n\n    for i in range(1, len(values_expressed) + 1):\n        if i not in values_expressed:\n            break\n\n    n = i - 1\n\n    return n", "funcname": "main_solution", "ios": [{"input": {"digits": "5689"}, "output": 14}, {"input": {"digits": "1389"}, "output": 7}, {"input": {"digits": "1235"}, "output": 18}, {"input": {"digits": "1257"}, "output": 26}, {"input": {"digits": "3479"}, "output": 12}, {"input": {"digits": "6789"}, "output": 5}, {"input": {"digits": "2358"}, "output": 25}, {"input": {"digits": "1259"}, "output": 30}, {"input": {"digits": "4679"}, "output": 14}, {"input": {"digits": "2678"}, "output": 29}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rheard/ProjectEuler", "path": "/p093.py", "msgidx": 7012}}
{"problem_description": "Given a 2D grid of letters, can you determine if a specific word can be found within the grid by moving right, down, or diagonally? The word must be formed by connecting adjacent letters in the grid without skipping any cells. What is the result of searching for the word in the given puzzle?", "io_requirements": "Input:\n  `puzzle` (str): A JSON string representing a 2D list of characters. Each sublist represents a row in the puzzle.\n  `word` (str): A string representing the word to be searched in the puzzle.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the word is found in the puzzle. `True` if the word is found, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef isSame(x, y, idx, word, puzzle):\n    if y > len(puzzle[0]) - 1:\n        return False\n    elif x > len(puzzle) - 1:\n        return False\n    elif len(word) - 1 == idx:\n        return puzzle[x][y] == word[idx]\n    else:\n        isThisLetterSame = puzzle[x][y] == word[idx]\n        right = isSame(x, y + 1, idx + 1, word, puzzle)\n        down = isSame(x + 1, y, idx + 1, word, puzzle)\n        diag = isSame(x + 1, y + 1, idx + 1, word, puzzle)\n        \n        return (isThisLetterSame and down) or (isThisLetterSame and right) or (isThisLetterSame and diag)\n\ndef findWord(puzzle, word):\n    numOfRows = len(puzzle)\n    numOfCols = len(puzzle[0])\n    found = False\n    for x in range(numOfRows):\n        for y in range(numOfCols):\n            if puzzle[x][y] == word[0]:  # found first letter\n                found = True and isSame(x, y, 0, word, puzzle)\n    return found\n\n# main function\ndef main_solution(puzzle, word):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert the JSON serializable inputs to the original input variables\n    puzzle = json.loads(puzzle)\n    word = str(word)\n    \n    # call the original function with the converted inputs\n    result = findWord(puzzle, word)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"puzzle": "[[\"M\", \"K\", \"V\"], [\"E\", \"F\", \"E\"], [\"P\", \"Y\", \"X\"], [\"H\", \"N\", \"U\"]]", "word": "WGYBJ"}, "output": false}, {"input": {"puzzle": "[[\"S\", \"N\", \"B\"], [\"F\", \"R\", \"C\"], [\"M\", \"T\", \"L\"], [\"S\", \"Z\", \"A\"]]", "word": "FTW"}, "output": false}, {"input": {"puzzle": "[[\"V\", \"A\", \"Z\", \"G\", \"R\"], [\"S\", \"H\", \"Q\", \"L\", \"H\"], [\"A\", \"Z\", \"Z\", \"F\", \"U\"]]", "word": "ZLO"}, "output": false}, {"input": {"puzzle": "[[\"Q\", \"R\", \"M\"], [\"L\", \"Y\", \"G\"], [\"E\", \"V\", \"T\"], [\"T\", \"F\", \"G\"], [\"V\", \"I\", \"P\"]]", "word": "TW"}, "output": false}, {"input": {"puzzle": "[[\"W\", \"Q\", \"L\"], [\"G\", \"T\", \"T\"], [\"H\", \"L\", \"T\"], [\"F\", \"Z\", \"K\"], [\"X\", \"I\", \"U\"]]", "word": "RA"}, "output": false}, {"input": {"puzzle": "[[\"P\", \"X\", \"V\", \"I\"], [\"J\", \"E\", \"T\", \"U\"], [\"A\", \"F\", \"W\", \"V\"], [\"G\", \"P\", \"F\", \"Z\"]]", "word": "MT"}, "output": false}, {"input": {"puzzle": "[[\"R\", \"F\", \"F\"], [\"X\", \"S\", \"R\"], [\"H\", \"L\", \"P\"], [\"K\", \"X\", \"I\"]]", "word": "ETWBS"}, "output": false}, {"input": {"puzzle": "[[\"P\", \"Y\", \"Q\"], [\"H\", \"X\", \"F\"], [\"Y\", \"C\", \"E\"], [\"W\", \"F\", \"B\"], [\"A\", \"D\", \"N\"]]", "word": "JC"}, "output": false}, {"input": {"puzzle": "[[\"U\", \"J\", \"U\"], [\"U\", \"I\", \"N\"], [\"D\", \"V\", \"U\"]]", "word": "QQRB"}, "output": false}, {"input": {"puzzle": "[[\"U\", \"D\", \"K\"], [\"X\", \"Z\", \"J\"], [\"S\", \"I\", \"T\"]]", "word": "FDT"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ayesandarmoe/miscellaneous", "path": "/puzzle.py", "msgidx": 7269}}
{"problem_description": "Given a range of four-digit numbers, find all sets of three numbers that form an arithmetic progression where each number is a prime and all three numbers are permutations of each other. What are the concatenated 12-digit numbers formed by joining these three numbers in each set?", "io_requirements": "Input:\n  `start_range` (int): The starting range for the search of prime permutations. Must be a four-digit number.\n  `end_range` (int): The ending range for the search of prime permutations. Must be a four-digit number and greater than or equal to `start_range`.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a concatenated 12-digit number formed by joining three members of an arithmetic progression of prime numbers that are permutations of each other.", "refcode": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef is_permutation(i1, i2):\n    A = []\n    B = []\n    while i1 > 0:\n        A.append(i1 % 10)\n        i1 //= 10\n    while i2 > 0:\n        B.append(i2 % 10)\n        i2 //= 10\n    A.sort()\n    B.sort()\n    if A == B:\n        return True\n    return False\n\ndef is_simple(number):\n    for i in range(2, int(sqrt(number) // 1 + 1)):\n        if (number % i) == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(start_range, end_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = []\n    for i in range(start_range, end_range + 1):\n        for n in range(1, (end_range - i) // 2 + 1):\n            if i + n * 2 <= end_range:\n                if is_simple(i) and is_simple(i + n) and is_simple(i + 2 * n) and is_permutation(i, i + n) and is_permutation(i, i + n * 2):\n                    result.append(f\"{i}{i + n}{i + n * 2}\")\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"start_range": 6532, "end_range": 7900}, "output": []}, {"input": {"start_range": 6570, "end_range": 9049}, "output": []}, {"input": {"start_range": 9458, "end_range": 9568}, "output": []}, {"input": {"start_range": 5655, "end_range": 6876}, "output": []}, {"input": {"start_range": 2939, "end_range": 5168}, "output": []}, {"input": {"start_range": 2881, "end_range": 6524}, "output": []}, {"input": {"start_range": 9011, "end_range": 9139}, "output": []}, {"input": {"start_range": 6354, "end_range": 8990}, "output": []}, {"input": {"start_range": 2955, "end_range": 4428}, "output": []}, {"input": {"start_range": 5137, "end_range": 9981}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AlexStudent84/Eller", "path": "/Eller49.py", "msgidx": 6721}}
{"problem_description": "Given a graph represented by its adjacency list and a starting vertex, determine whether the graph is bipartite and find the start and finish times of each vertex during a Depth-First Search (DFS) traversal starting from the given vertex. What are the start and finish times of each vertex, and is the graph bipartite?", "io_requirements": "Input:\n  `graph_list` (list of lists of integers): A list of lists where each inner list represents the adjacency list of a vertex in the graph. Each integer in the inner list represents a connected vertex.\n  `source_vertex` (integer): The starting vertex for BFS and DFS operations.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `is_bipartite` (boolean): Indicates whether the graph is bipartite.\n    - `start_times` (list of integers): A list of integers representing the start times of each vertex during DFS traversal.\n    - `finish_times` (list of integers): A list of integers representing the finish times of each vertex during DFS traversal.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass graph:\n    def __init__(self, G):\n        self.list = G\n        self.visited = [0 for _ in range(len(self.list))]\n        self.color = [-1 for _ in range(len(self.list))]\n        self.ad_matrix = [[0 for _ in range(len(self.list))] for _ in range(len(self.list))]\n        self.dist = [0 for _ in range(len(self.list))]\n        self.vis = [0 for _ in range(len(self.list))]\n        self.start = [0 for _ in range(len(self.list))]\n        self.finish = [0 for _ in range(len(self.list))]\n        self.time = 0\n        self.conn = [0 for _ in range(len(self.list))]\n        self.temp = 0\n\n    def listing(self):\n        for i in range(len(self.list)):\n            for j in self.list[i]:\n                self.ad_matrix[i][j] = 1\n\n    def bfs(self, s):\n        queue = deque([])\n        queue.append(s)\n        self.dist[s] = 0\n        self.visited[s] = 1\n        while queue:\n            sp = queue.popleft()\n            for i in self.list[sp]:\n                if self.visited[i] == 0:\n                    self.dist[i] = self.dist[sp] + 1\n                    queue.append(i)\n                    self.visited[i] = 1\n\n    def bipartite(self, s):\n        queue = deque([])\n        queue.append(s)\n        self.color[s] = 0\n        while queue:\n            s = queue.popleft()\n            for i in range(len(self.list)):\n                if self.ad_matrix[s][i] == 1 and self.color[s] != self.color[i]:\n                    self.color[i] = 1 - self.color[s]\n                    queue.append(i)\n                elif self.ad_matrix[s][i] == 1 and self.color[s] == self.color[i]:\n                    return False\n        return True\n\n    def dfs(self, s):\n        self.vis[s] = 1\n        self.start[s] = self.time\n        self.time += 1\n        for i in self.list[s]:\n            if self.vis[i] == 0:\n                self.dfs(i)\n        self.finish[s] = self.time\n        self.time += 1\n\n# main function\ndef main_solution(graph_list, source_vertex):\n    # Convert JSON serializable inputs to original input variables\n    G = graph_list\n    s = source_vertex\n\n    # Create graph object\n    g = graph(G)\n\n    # Perform BFS and check if the graph is bipartite\n    g.bfs(s)\n    g.listing()\n    is_bipartite = g.bipartite(0)\n\n    # Perform DFS to get start and finish times\n    g.dfs(s)\n\n    # Prepare JSON serializable output\n    output = {\n        \"is_bipartite\": is_bipartite,\n        \"start_times\": g.start,\n        \"finish_times\": g.finish\n    }\n\n    return output", "funcname": "main_solution", "ios": [{"input": {"graph_list": [[0], [0], [2, 1]], "source_vertex": 2}, "output": {"is_bipartite": false, "start_times": [2, 1, 0], "finish_times": [3, 4, 5]}}, {"input": {"graph_list": [[1, 3], [2, 0, 1], [0, 1, 3], [2]], "source_vertex": 1}, "output": {"is_bipartite": false, "start_times": [2, 0, 1, 3], "finish_times": [5, 7, 6, 4]}}, {"input": {"graph_list": [[2], [1, 0, 2], [0, 2], [3]], "source_vertex": 1}, "output": {"is_bipartite": false, "start_times": [1, 0, 2, 0], "finish_times": [4, 5, 3, 0]}}, {"input": {"graph_list": [[1], [4, 1, 0], [2, 3, 0], [1, 3, 2, 0], [2]], "source_vertex": 4}, "output": {"is_bipartite": false, "start_times": [4, 3, 1, 2, 0], "finish_times": [5, 6, 8, 7, 9]}}, {"input": {"graph_list": [[3, 4, 0], [1, 3, 2, 0], [0, 4, 3, 1], [0], [1]], "source_vertex": 4}, "output": {"is_bipartite": false, "start_times": [3, 1, 6, 2, 0], "finish_times": [4, 8, 7, 5, 9]}}, {"input": {"graph_list": [[2, 3, 4], [4], [1], [3, 1], [3]], "source_vertex": 4}, "output": {"is_bipartite": false, "start_times": [0, 2, 0, 1, 0], "finish_times": [0, 3, 0, 4, 5]}}, {"input": {"graph_list": [[1], [3], [1, 3], [2, 3], [3, 0]], "source_vertex": 3}, "output": {"is_bipartite": false, "start_times": [0, 2, 1, 0, 0], "finish_times": [0, 3, 4, 5, 0]}}, {"input": {"graph_list": [[4, 2, 0, 3], [2, 3], [1, 4, 3, 0], [4, 0, 1, 2], [1, 2]], "source_vertex": 1}, "output": {"is_bipartite": false, "start_times": [5, 0, 1, 4, 2], "finish_times": [6, 9, 8, 7, 3]}}, {"input": {"graph_list": [[0, 4, 2, 3], [0, 1, 3, 2], [1], [2, 1], [1]], "source_vertex": 0}, "output": {"is_bipartite": false, "start_times": [0, 2, 4, 3, 1], "finish_times": [9, 7, 5, 6, 8]}}, {"input": {"graph_list": [[3, 0, 2], [0], [2], [2]], "source_vertex": 1}, "output": {"is_bipartite": false, "start_times": [1, 0, 3, 2], "finish_times": [6, 7, 4, 5]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Namanvijay/dsa-lab", "path": "/graph-basics.py", "msgidx": 7170}}
{"problem_description": "In a secure system, passwords must follow specific rules to ensure they are strong and easy to remember. Given a current password, what is the next valid password that meets the following criteria:\n1. It does not contain the letters 'i', 'o', or 'l'.\n2. It contains at least two different, non-overlapping pairs of letters, like \"aa\", \"bb\", or \"zz\".\n3. It contains at least one sequence of three consecutive letters, like \"abc\", \"bcd\", etc., but not \"zab\" or \"yza\".\n\nWhat is the next valid password for the given current password?", "io_requirements": "Input:\n  `current_password` (str): A string representing the current password that needs to be incremented to the next valid password. The string should only contain lowercase letters and should not contain the letters 'i', 'o', or 'l'.\n\nOutput:\n  `return` (str): A string representing the next valid password that meets the following criteria:\n  1. It does not contain the letters 'i', 'o', or 'l'.\n  2. It contains at least two different, non-overlapping pairs of letters, like \"aa\", \"bb\", or \"zz\".\n  3. It contains at least one sequence of three consecutive letters, like \"abc\", \"bcd\", etc., but not \"zab\" or \"yza\".", "refcode": "# import necessary packages\nimport re\nimport string\n\n# all class and function definitions in the code file, if any\nalphabet = list(string.ascii_lowercase)\n\ndef letter_gen(letter):\n    index = alphabet.index(letter)\n    index = index if index + 1 < len(alphabet) else -1\n    new_letter = alphabet[index + 1]\n    return new_letter\n\ndef free_from_spec_symbol(word):\n    indexes = [m.start() for m in re.finditer('i|o|l', word)]\n    if len(indexes) > 0:\n        index = indexes[0]\n        word = word[:index] + letter_gen(word[index]) + 'a' * (len(word) - index-1)\n    return word\n\ndef increase_sequence(word):\n    if len(word) > 0:\n        word = free_from_spec_symbol(word)\n        letter = letter_gen(word[-1])\n        if letter == 'a':\n            string = increase_sequence(word[:-1])\n        else:\n            string = word[:-1]\n        return string + letter\n    return ''\n\ndef contains_three_straight(word):\n    for index, letter in enumerate(word):\n        if index <= len(word) - 3 \\\n                and word[index + 1] == letter_gen(letter) \\\n                and word[index + 2] == letter_gen(word[index + 1]) \\\n                and word[index:index + 3] not in ['zab', 'yza']:\n            return True\n    return False\n\ndef contains_2_pairs(word):\n    return len([m.group(0) for m in re.finditer(r\"(.)\\1+\", word) if len(m.group(0)) == 2]) >= 2\n\ndef doesnt_contain_specific_symbols(word):\n    return not bool(re.findall('i|o|l', word))\n\ndef is_acceptable(word):\n    return  doesnt_contain_specific_symbols(word) \\\n        and \\\n        contains_2_pairs(word) \\\n        and \\\n        contains_three_straight(word)\n\n# main function\ndef main_solution(current_password):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    new_pass = increase_sequence(current_password)\n    while (not is_acceptable(new_pass)):\n        new_pass = increase_sequence(new_pass)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return new_pass", "funcname": "main_solution", "ios": [{"input": {"current_password": "avufwwdccqk"}, "output": "avufwwdcdee"}, {"input": {"current_password": "vqjkjsuvp"}, "output": "vqjkkaabc"}, {"input": {"current_password": "ecaasbep"}, "output": "ecaasstu"}, {"input": {"current_password": "ztkszxbqzak"}, "output": "ztkszxccdee"}, {"input": {"current_password": "mavpthqpjjmw"}, "output": "mavpthqppqrr"}, {"input": {"current_password": "zxbkbhct"}, "output": "zxbppqrr"}, {"input": {"current_password": "nbqxqdmk"}, "output": "nbqxxyzz"}, {"input": {"current_password": "pskmwwuadtq"}, "output": "pskmwwubbcd"}, {"input": {"current_password": "zjeubmryjsw"}, "output": "zjeubmsstuu"}, {"input": {"current_password": "uwpjdgqn"}, "output": "uwppaabc"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "elendili/advent-of-code-2015-python", "path": "/day11.py", "msgidx": 6516}}
{"problem_description": "In a short corridor environment, an agent navigates through a series of states with actions that can either move left or right. The corridor has a specific state where the direction of movement is inverted. Given a probability `eps` of choosing the left action and a number of episodes `NUM_EPISODES`, what is the average number of steps required for the agent to reach the terminal state over the specified number of episodes?", "io_requirements": "Input:\n  `eps` (float): The probability of choosing the left action in the action space. It should be between 0 and 1.\n  `NUM_EPISODES` (int): The number of episodes to run the simulation. It should be a positive integer.\n\nOutput:\n  `return` (float): The average number of steps taken to reach the terminal state over the specified number of episodes.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass ShortCorridor():\n    \"\"\"Short corridor with switched actions\"\"\"\n    \n    def __init__(self):\n        self.num_states = 4\n        \n        self.states = self.state_space()\n        self.actions = self.action_space()\n        \n        self.initial_state = self.states[0]\n        self.terminal_state = self.states[-1]\n        \n        self.switch_state = self.states[1]\n        \n        \n    def reset(self):\n        \"\"\"Initialize state\"\"\"\n        state = self.initial_state\n        return state\n    \n    def step(self, state, action):\n        \"\"\"Agent takes action in given state\"\"\"\n        done = False\n        \n        if state == self.switch_state:# invert moving direction\n            action = -action\n        \n        next_state = state + action\n        \n        if next_state < self.initial_state:\n            next_state = self.initial_state\n            \n        if next_state == self.terminal_state:\n            done = True\n            \n        reward = -1\n            \n        return next_state, reward, done\n    \n    def state_space(self):\n        \"\"\"Define state space\"\"\"\n        states = np.array([state for state in range(self.num_states)])\n        return states\n        \n    def action_space(self):\n        \"\"\"\n        Define action space\n\n        Returns\n        -------\n        actions : ndarray\n            actions in short corridor: -1: go left; 1: go right.\n\n        \"\"\"\n        actions = np.array([-1, 1])\n        return actions\n        \nclass FeatureVectors(ShortCorridor):\n    \"\"\"Feature vector for short corridor with switched actions.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.states = self.state_space()\n        self.actions = self.action_space()\n        \n        self.x_vec = self.feat_vec()\n        \n    def feat_vec(self):\n        \"\"\"Define feature vectors for state action pairs (Important: The agent\n        cannot distinguish between the states from the given observations)\"\"\"\n        x_vec = {}\n        for state in self.states:\n            x_vec[(state, self.actions[0])] = np.array([0,1])\n            x_vec[(state, self.actions[1])] = np.array([1,0])\n            \n        return x_vec\n\n# main function\ndef main_solution(eps, NUM_EPISODES):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  SC = ShortCorridor()\n  FV = FeatureVectors()\n  \n  avg_steps = 0\n  for episode in range(NUM_EPISODES):\n      steps = 0\n      state = SC.reset()\n      done = False\n      while not done:\n          steps += 1\n          action = np.random.choice(SC.action_space(), p=[eps/2, 1-eps/2])\n          state, reward, done = SC.step(state, action)\n\n      avg_steps = avg_steps + 1/(episode+1)*(steps - avg_steps)\n  \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return avg_steps", "funcname": "main_solution", "ios": [{"input": {"eps": 0.48470039803780063, "NUM_EPISODES": 385}, "output": 14.522077922077917}, {"input": {"eps": 0.25248042717071073, "NUM_EPISODES": 270}, "output": 20.929629629629606}, {"input": {"eps": 0.3239189150421401, "NUM_EPISODES": 167}, "output": 16.56886227544911}, {"input": {"eps": 0.8612558499864483, "NUM_EPISODES": 930}, "output": 11.370967741935482}, {"input": {"eps": 0.4266911380578068, "NUM_EPISODES": 443}, "output": 14.37697516930022}, {"input": {"eps": 0.6382001177195983, "NUM_EPISODES": 317}, "output": 11.946372239747625}, {"input": {"eps": 0.6966317994155147, "NUM_EPISODES": 428}, "output": 12.191588785046724}, {"input": {"eps": 0.3784219466985478, "NUM_EPISODES": 998}, "output": 15.694388777555112}, {"input": {"eps": 0.3802320785680545, "NUM_EPISODES": 687}, "output": 15.714701601164485}, {"input": {"eps": 0.7857383598965114, "NUM_EPISODES": 264}, "output": 11.522727272727268}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "c-boe/Reinforcement-learning", "path": "/13 Policy Gradient Methods/Short Corridor/shortcorridor.py", "msgidx": 6860}}
{"problem_description": "Given a number, determine if it is a special prime. A special prime is defined as a prime number that is equal to the sum of two consecutive prime numbers and 1. For example, 19 is a special prime because it is equal to 11 + 7 + 1. What is the classification of the given number?", "io_requirements": "Input:\n  `n` (int): An integer representing the number to be checked for being a special prime.\n\nOutput:\n  `return` (str): A string indicating whether the number is a \"special_prime\", \"not special prime\", or \"not prime\".", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef prime(n):\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return None\n    return n\n\ndef nearest_prime(n):\n    i = n - 1\n    while True:\n        if prime(i):\n            return i\n        else:\n            i -= 1\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if prime(n) == n:\n        a = nearest_prime(n)\n        b = nearest_prime(a)\n        while True:\n            if a + b + 1 == n:\n                return \"special_prime\"\n            else:\n                a = b\n                b = nearest_prime(a)\n            if a == 2 or b == 2:\n                return \"not special prime\"\n    else:\n        return \"not prime\"", "funcname": "main_solution", "ios": [{"input": {"n": 883}, "output": "special_prime"}, {"input": {"n": 287}, "output": "not prime"}, {"input": {"n": 91}, "output": "not prime"}, {"input": {"n": 234}, "output": "not prime"}, {"input": {"n": 120}, "output": "not prime"}, {"input": {"n": 790}, "output": "not prime"}, {"input": {"n": 668}, "output": "not prime"}, {"input": {"n": 613}, "output": "not special prime"}, {"input": {"n": 718}, "output": "not prime"}, {"input": {"n": 767}, "output": "not prime"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "saisaranyaatti/100_days-coding-challenge", "path": "/15.special_prime.py", "msgidx": 7021}}
{"problem_description": "Given a board configuration for a game where players 'x' and 'o' take turns to drop pebbles or rotate columns, what is the best move for the current player to make? The board is represented as a string where each character corresponds to a cell in the board. The current player can either drop a pebble in an empty column or rotate a column. What move should the current player make to maximize their chances of winning?", "io_requirements": "Input:\n- `board_string` (str): A string representing the board state. The string should be of length `(n + 3) * n` where `n` is the size of the board. Each character represents a cell in the board, and the string is read row by row.\n- `current_player` (str): A string representing the current player, either 'x' or 'o'.\n\nOutput:\n- `return` (tuple): A tuple containing:\n  - `best_move` (int): An integer representing the best move. If positive, it indicates a drop move in the corresponding column. If negative, it indicates a rotation of the corresponding column.\n  - `best_board` (str): A string representing the board state after the best move is applied.", "refcode": "import numpy as np\nimport copy\n\n# Constants\nn = 4  # Example size of the board\navail_pieces = int((n / 2) * (n + 3))\n\n# Helper functions\ndef switch_player(current_player):\n    return 'o' if current_player == 'x' else 'x'\n\ndef is_goal(board, player):\n    potential_wins = []\n    for row in board[0:n]:\n        potential_wins.append(set(row))\n    for i in range(n):\n        potential_wins.append(set([board[k][i] for k in range(n)]))\n    potential_wins.append(set([board[i][i] for i in range(n)]))\n    potential_wins.append(set([board[i][(n-1) - i] for i in range(n)]))\n    for group in potential_wins:\n        if group == set([player]):\n            return True\n    return False\n\ndef is_last_empty_spot(a, r, c):\n    col_to_inspect = [row[c] for row in a]\n    last_index = 0\n    for i in range(len(col_to_inspect)):\n        if col_to_inspect[i] == '.':\n            last_index += 1\n    return r == last_index - 1\n\ndef successors(board, current_player):\n    states = []\n    symbol = 'x' if current_player == 'x' else 'o'\n    piece_count = count_pieces(board, current_player)\n    if piece_count < avail_pieces:\n        for row in range(n + 3):\n            for col in range(n):\n                if board[row][col] == '.' and is_last_empty_spot(board, row, col):\n                    states.append(copy.deepcopy(board))\n                    states[-1][row][col] = symbol\n    npboard = np.array(board)\n    for i in range(n):\n        if set(npboard[:, i]) != {'.'}:\n            spot = max(np.where(npboard[:, i] == '.')[0].tolist()) + 1 if np.where(npboard[:, i] == '.')[0].size > 0 else 0\n            npboard[spot:, i] = np.roll(npboard[spot:, i], 1)\n            if npboard.tolist() not in states and npboard.tolist() != board:\n                states.append(npboard.tolist())\n            npboard = np.array(board)\n    return states\n\ndef evaluate(board, current_player, goal_or_not):\n    current_player_ways = count_ways(board, current_player)\n    opponent_ways = count_ways(board, switch_player(current_player))\n    current_player_adj = count_adjacents(board, current_player)\n    opponent_adj = count_adjacents(board, switch_player(current_player))\n    heuristic_val = 2 * (current_player_ways - opponent_ways) + 0.5 * (find_empty_spots_in_top_nrows(board)) + 3 * (current_player_adj - opponent_adj)\n    if goal_or_not:\n        return heuristic_val + 30\n    else:\n        return heuristic_val\n\ndef count_ways(board, current_player):\n    a = np.array(board[:n])\n    row_set = []\n    count = 0\n    for i in a:\n        row_set.append(list(set(i)))\n    for i in range(n):\n        t = [board[j][i] for j in range(n)]\n        row_set.append(list(set(t)))\n    row_set.append(list(set(a.diagonal())))\n    row_set.append(list(set(np.fliplr(a).diagonal())))\n    player_wins = [[current_player, '.'], ['.'], ['.', current_player]]\n    for win_scene in row_set:\n        if win_scene in player_wins:\n            count += 1\n    return count\n\ndef count_adjacents(a, current_player):\n    h, v, d = [], [], []\n    for i in range(n + 3):\n        for j in range(n):\n            h.append(hori_neighbours(a, i, j, current_player))\n            v.append(vert_neighbours(a, i, j, current_player))\n    d.append(diag_neighbours(a, current_player))\n    return sum(h) + sum(v) + sum(d)\n\ndef diag_neighbours(a, current_player):\n    count = 0\n    a = np.array(a)\n    main_d = a.diagonal()\n    minor_d = np.fliplr(a).diagonal()\n    for x, y in zip(main_d, main_d[1:]):\n        if x == y == current_player:\n            count += 1\n    for x, y in zip(minor_d, minor_d[1:]):\n        if x == y == current_player:\n            count += 1\n    return count\n\ndef vert_neighbours(a, i, j, current_player):\n    count = 0\n    if a[i][j] != '.':\n        try:\n            if a[i][j] == a[i + 1][j] == current_player:\n                count += 1\n        except:\n            pass\n        try:\n            if i - 1 >= 0:\n                if a[i][j] == a[i - 1][j] == current_player:\n                    count += 1\n        except:\n            pass\n        return count\n    else:\n        return 0\n\ndef hori_neighbours(a, i, j, current_player):\n    count = 0\n    if a[i][j] != '.':\n        try:\n            if a[i][j] == a[i][j + 1] == current_player:\n                count += 1\n        except:\n            pass\n        try:\n            if j - 1 >= 0:\n                if a[i][j] == a[i][j - 1] == current_player:\n                    count += 1\n        except:\n            pass\n        return count\n    else:\n        return 0\n\ndef find_empty_spots_in_top_nrows(board):\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                count += 1\n    return count\n\ndef count_pieces(board, piece_to_count):\n    count = 0\n    for i in range(n + 3):\n        for j in range(n):\n            if board[i][j] == piece_to_count:\n                count += 1\n    return count\n\ndef minimax(board, depth, isMaximizingPlayer, alpha, beta):\n    if isMaximizingPlayer:\n        current_player = 'x'\n    else:\n        current_player = 'o'\n    goal_or_not = is_goal(board, current_player)\n    if goal_or_not or depth == 5:\n        score = evaluate(board, current_player, goal_or_not)\n        return score\n    if isMaximizingPlayer:\n        bestVal = -1000000\n        children = successors(board, current_player)\n        for child in children:\n            value = minimax(child, depth + 1, False, alpha, beta)\n            bestVal = max(bestVal, value)\n            alpha = max(alpha, bestVal)\n            if beta <= alpha:\n                break\n        return bestVal\n    else:\n        bestVal = 1000000\n        children = successors(board, current_player)\n        for child in children:\n            value = minimax(child, depth + 1, True, alpha, beta)\n            bestVal = min(bestVal, value)\n            beta = min(beta, bestVal)\n            if beta <= alpha:\n                break\n        return bestVal\n\ndef which_col_changed(changed, initial):\n    for i in range(len(initial)):\n        if changed[i] != initial[i]:\n            return i + 1\n\ndef check_which_move_best(move_dict):\n    best_state_after_move = move_dict[max(move_dict.keys())]\n    diff = []\n    for i in range(len(best_state_after_move)):\n        if best_state_after_move[i] != initial_board[i]:\n            diff.append((best_state_after_move[i], initial_board[i]))\n    if len(diff) == 1:\n        return which_col_changed(diff[0][1], diff[0][0]), best_state_after_move\n    else:\n        return -which_col_changed(diff[0][1], diff[0][0]), best_state_after_move\n\ndef solve(initialBoard, current_player):\n    alpha = -1000000\n    beta = 1000000\n    children = successors(initialBoard, current_player)\n    values = []\n    for child in children:\n        move = minimax(child, 0, False, alpha, beta)\n        values.append(move)\n    move_dict = dict(zip(values, children))\n    best_move, best_board = check_which_move_best(move_dict)\n    return best_move, best_board\n\n# Main function\ndef main_solution(board_string, current_player):\n    global initial_board\n    initial_board = [list(board_string[i:i + n]) for i in range(0, len(board_string), n)]\n    best_move, best_board = solve(initial_board, current_player)\n    return best_move, ''.join([''.join(row) for row in best_board])", "funcname": "main_solution", "ios": [{"input": {"board_string": "............................", "current_player": "x"}, "output": [4, "...........................x"]}, {"input": {"board_string": "............................", "current_player": "o"}, "output": [4, "...........................o"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sanket-11/Games-and-Bayes", "path": "/part1/betsy.py", "msgidx": 6610}}
{"problem_description": "In a festive game, a group of elves are arranged in a circle. Each elf has a present, and they take turns stealing presents from their neighbors. There are two different rules for stealing:\n1. Each elf steals from the next elf in the circle.\n2. Each elf steals from the elf directly across the circle.\n\nGiven the number of elves participating in the game, which elf will remain with a present after all other elves have had their presents stolen?", "io_requirements": "Input:\n  `no_elves` (int): The number of elves in the circle.\n\nOutput:\n  `return` (dict): A dictionary containing the remaining elf for each scenario:\n    - `remaining_next` (int): The remaining elf when elves steal from the next elf.\n    - `remaining_across` (int): The remaining elf when elves steal from the elf across the circle.", "refcode": "# import necessary packages\nfrom math import log\n\n# main function\ndef main_solution(no_elves):\n    \"\"\"\n    Determines the remaining elf in two different scenarios:\n    1. Elves steal from the next elf.\n    2. Elves steal from the elf across the circle.\n    \n    :param no_elves: Number of elves in the circle.\n    :return: A dictionary with the remaining elf for each scenario.\n    \"\"\"\n    # Calculate the remaining elf when elves steal from the next elf\n    pow2 = 2 ** int(log(no_elves, 2))\n    remaining_next = (no_elves - pow2) * 2 + 1\n    \n    # Calculate the remaining elf when elves steal from the elf across the circle\n    pow3 = 3 ** int(log(no_elves, 3))\n    twice_pow3 = 2 * pow3\n    if no_elves == pow3:\n        remaining_across = pow3\n    elif no_elves > twice_pow3:\n        remaining_across = pow3 + 2 * (no_elves - twice_pow3)\n    else:\n        remaining_across = no_elves - pow3\n    \n    # Return the results as a dictionary\n    return {\n        \"remaining_next\": remaining_next,\n        \"remaining_across\": remaining_across\n    }", "funcname": "main_solution", "ios": [{"input": {"no_elves": 291}, "output": {"remaining_next": 71, "remaining_across": 48}}, {"input": {"no_elves": 360}, "output": {"remaining_next": 209, "remaining_across": 117}}, {"input": {"no_elves": 6}, "output": {"remaining_next": 5, "remaining_across": 3}}, {"input": {"no_elves": 695}, "output": {"remaining_next": 367, "remaining_across": 661}}, {"input": {"no_elves": 146}, "output": {"remaining_next": 37, "remaining_across": 65}}, {"input": {"no_elves": 563}, "output": {"remaining_next": 103, "remaining_across": 397}}, {"input": {"no_elves": 807}, "output": {"remaining_next": 591, "remaining_across": 78}}, {"input": {"no_elves": 837}, "output": {"remaining_next": 651, "remaining_across": 108}}, {"input": {"no_elves": 828}, "output": {"remaining_next": 633, "remaining_across": 99}}, {"input": {"no_elves": 283}, "output": {"remaining_next": 55, "remaining_across": 40}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "prositen/advent-of-code", "path": "/python/src/y2016/dec19.py", "msgidx": 7115}}
{"problem_description": "Given a nested list of integers, how can we determine the frequency of a specific integer element at each level of nesting?", "io_requirements": "Input:\n  `nested_list` (list): A nested list of integers where each sublist can contain further nested sublists.\n  `element` (int): The integer element whose frequency by nested level needs to be counted.\n\nOutput:\n  `return` (list of lists): A list of lists where each sublist contains two elements: the first element is the nested level (starting from 0) and the second element is the frequency of the `element` at that level.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef freq_count(list1, key):\n    x = -1\n    dict1 = {}\n    list2 = []\n\n    def freq_count_2(lst, ky):\n        nonlocal x\n        nonlocal dict1\n        x += 1\n        total = 0\n        for item in lst:\n            if type(item) == list:\n                freq_count_2(item, ky)\n            elif item == ky:\n                total += 1\n        try:\n            dict1[x] += total\n        except:\n            dict1[x] = total\n        x -= 1\n    freq_count_2(list1, key)\n    for i in sorted(dict1.keys()):\n        list2.append([i, dict1[i]])\n    return list2\n\n# main function\ndef main_solution(nested_list, element):\n    # Convert the nested list and element to JSON serializable types\n    nested_list = list(nested_list)\n    element = element\n    \n    # Call the original function with the converted inputs\n    result = freq_count(nested_list, element)\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"nested_list": [3, 1, 3], "element": 3}, "output": [[0, 2]]}, {"input": {"nested_list": [[3, 3], [2, 1], [4, 5]], "element": 5}, "output": [[0, 0], [1, 1]]}, {"input": {"nested_list": [4, 5, 4], "element": 2}, "output": [[0, 0]]}, {"input": {"nested_list": [[2, 5]], "element": 1}, "output": [[0, 0], [1, 0]]}, {"input": {"nested_list": [3, 4, 5], "element": 5}, "output": [[0, 1]]}, {"input": {"nested_list": [[[5, 4]], [[1]], [1]], "element": 3}, "output": [[0, 0], [1, 0], [2, 0]]}, {"input": {"nested_list": [[1, 1, 2]], "element": 3}, "output": [[0, 0], [1, 0]]}, {"input": {"nested_list": [[1, 3]], "element": 4}, "output": [[0, 0], [1, 0]]}, {"input": {"nested_list": [5], "element": 1}, "output": [[0, 0]]}, {"input": {"nested_list": [4], "element": 3}, "output": [[0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/Yp8crKmgxZ3HiSBAZ_11.py", "msgidx": 7428}}
{"problem_description": "Given a database row represented as a dictionary and a logical condition expressed as a string, determine whether the row meets the specified condition. The condition may involve logical operators (`AND`, `OR`), comparison operators (`=`, `<`, `>`, `<=`, `>=`, `<>`), and parentheses for grouping. What is the result of evaluating the condition on the given row?", "io_requirements": "Input:\n  `row` (dict): A dictionary representing a row of data where keys are column names and values are the corresponding data values. Values must be integers.\n  `condition` (str): A string representing a logical condition to be evaluated on the row. The condition can include logical operators (`AND`, `OR`), comparison operators (`=`, `<`, `>`, `<=`, `>=`, `<>`), and parentheses for grouping. The condition should be in the form of `COLNAME OPERATOR VALUE` where `COLNAME` is a key in the `row` dictionary, `OPERATOR` is one of the supported comparison operators, and `VALUE` is an integer.\n\nOutput:\n  `return` (str): A string representing the result of the condition evaluation. The result will be either `'True'` or `'False'`.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\nclass ConditionEvaluator(object):\n\n    def __init__(self):\n        self.str_to_token = {'True':True,\n                'False':False,\n                'AND':lambda left, right: left and right,\n                'OR':lambda left, right: left or right,\n                '=':lambda left, right: left == right,\n                '<>':lambda left, right: left != right,\n                '<':lambda left, right: left < right,\n                '>':lambda left, right: left > right,\n                '<=':lambda left, right: left <= right,\n                '>=':lambda left, right: left >= right,\n                '(':'(',\n                ')':')'}\n    # end __init__\n\n    def evaluate_condition(self, row, condition):\n        '''\n        use regex to find all simple expressions and evaluate them on the row in question\n        replace each one with 'True' or 'False' STRINGS, then evaluate resulting string \n        with nested_bool_eval\n        '''\n        simple_exprs = re.findall(r\"\\(?\\w+\\s?[=<>]+\\s?\\d+\\)?\", condition)\n\n        for expr in simple_exprs:\n            if \"(\" in expr:\n                trimmed_expr = expr.replace(\"(\", \"\")\n                trimmed_expr = trimmed_expr.replace(\")\", \"\")\n            else:\n                trimmed_expr = expr\n\n            if (\"(\" in expr) and not (\")\" in expr):\n                expr = expr.replace(\"(\", \"\")\n            if (\")\" in expr) and not (\"(\" in expr):\n                expr = expr.replace(\")\", \"\")\n\n            result = self.simple_eval(row, trimmed_expr)\n\n            condition = condition.replace(expr, result)\n\n        return self.eval_bool_expr(condition)\n    # end evaluate_condition\n\n    def simple_eval(self, row, expression):\n        '''\n        given a simple expression of the form COLNAME OPERATOR VALUE,\n        we return a string 'True'/'False' result\n        '''\n\n        match = re.search(r\"(\\w+)\\s?([=<>]+)\\s?(\\d+)\", expression)\n\n        if not match:\n            raise Exception(\"found unexpected expression: {0}\".format(match.group()))\n  \n        col_name = match.group(1).strip()\n        op = match.group(2).strip()\n        val = int(match.group(3).strip())\n\n        if (col_name not in row.keys()):\n            raise Exception(\"Invalid column name in: {}\".format(expression))\n\n        # convert the string operator into a real Python operator\n        real_op = self.str_to_token[op]\n        col_val = int(row[col_name])\n\n        # since we converted the operator to a Python operator,\n        # we can call it like a function to evaluate the condition now\n        if (real_op(col_val, val)):\n            return 'True'\n        else:\n            return 'False'\n    # end simple_eval\n\n    def build_token_list(self, expr_string):\n        '''\n        space things out nicely, then convert plain old strings\n        into real Python tokens (True, False, or, and, etc)\n        '''\n        expr_string = expr_string.replace('(', ' ( ')\n        expr_string = expr_string.replace(')', ' ) ')\n        token_list = [self.str_to_token[item] for item in expr_string.split()]\n\n        return token_list\n   # end build_token_list\n\n    def find(self, token_list, token, start=0):\n        '''\n        given a token, return the indices at which that \n        token first appears in the given token list\n        '''\n        return [i for i, item in enumerate(token_list) if item == token and i >= start]\n    # end find\n\n    def find_parens(self, token_list):\n        '''\n        returns:\n        (bool)parens_exist, left_paren_pos, right_paren_pos\n        '''\n        left_list = self.find(token_list, '(')\n\n        if not left_list:\n            return False, -1, -1\n\n        # take the last open paren\n        left = left_list[-1]\n\n        # find the corresponding close paren\n        # cannot occur earlier, hence there are args and op.\n        right = self.find(token_list, ')', left + 2)[0]\n\n        return True, left, right\n    # end find_parens\n\n    def eval_simple_expr(self, token_list):\n        '''\n        token_list[1] will be either AND or OR, which we can evaluate\n        as a function on the two operands, which will each be either True or False\n        '''\n        return token_list[1](token_list[0], token_list[2])\n    # end eval_simple_expr\n\n    def eval_formatted_expr(self, token_list, emp_res=True):\n        '''\n        this recursively evaluates an expression that has been properly formatted\n        '''\n        if not token_list:\n            return emp_res\n\n        if len(token_list) == 1:\n            return token_list[0]\n\n        has_parens, l_paren, r_paren = self.find_parens(token_list)\n\n        if not has_parens:\n            return self.eval_simple_expr(token_list)\n\n        token_list[l_paren:r_paren + 1] = [self.eval_simple_expr(token_list[l_paren+1:r_paren])]\n\n        return self.eval_formatted_expr(token_list, self.eval_simple_expr)\n    # end formatted_bool_eval\n\n    def eval_bool_expr(self, s):\n        '''\n        the function that evaluates a logical expression string\n        '''\n        return self.eval_formatted_expr(self.build_token_list(s))\n    # end nested_bool_eval\n\n# main function\ndef main_solution(row, condition):\n    evaluator = ConditionEvaluator()\n    result = evaluator.evaluate_condition(row, condition)\n    return result", "funcname": "main_solution", "ios": [{"input": {"row": {"col1": 14, "col2": 12, "col3": 54}, "condition": "col2 > 79"}, "output": false}, {"input": {"row": {"col1": 77, "col2": 83, "col3": 77}, "condition": "col1 < 51"}, "output": false}, {"input": {"row": {"col1": 82, "col2": 28, "col3": 74}, "condition": "col3 > 8"}, "output": true}, {"input": {"row": {"col1": 76, "col2": 63, "col3": 17}, "condition": "col1 >= 88"}, "output": false}, {"input": {"row": {"col1": 68, "col2": 63, "col3": 37}, "condition": "col2 <= 14"}, "output": false}, {"input": {"row": {"col1": 87, "col2": 40, "col3": 97}, "condition": "col1 <= 56"}, "output": false}, {"input": {"row": {"col1": 44, "col2": 88, "col3": 62}, "condition": "col2 = 59"}, "output": false}, {"input": {"row": {"col1": 83, "col2": 9, "col3": 47}, "condition": "col3 < 74"}, "output": true}, {"input": {"row": {"col1": 50, "col2": 2, "col3": 24}, "condition": "col2 < 47"}, "output": true}, {"input": {"row": {"col1": 13, "col2": 4, "col3": 69}, "condition": "col1 >= 21"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "danielmklein/dmkdb", "path": "/ConditionEvaluator.py", "msgidx": 6937}}
{"problem_description": "Given a range of integers, what are the super primes within that range? A super prime is a prime number that remains prime when the leftmost digit is successively removed. For example, 233 is a super prime because 233, 33, and 3 are all prime numbers.", "io_requirements": "Input:\n  `lower` (int): The lower bound of the range within which to search for super primes.\n  `upper` (int): The upper bound of the range within which to search for super primes.\n\nOutput:\n  `return` (list of int): A list of integers representing the super primes found within the specified range.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(number):\n    for i in range(2, int(math.sqrt(number)) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef is_super_prime(n):\n    if n < 10:\n        return is_prime(n)\n\n    if is_super_prime(n // 10):\n        return is_prime(n)\n\ndef list_of_super_primes(lower, upper):\n    return filter(is_super_prime, range(lower, upper))\n\n# main function\ndef main_solution(lower, upper):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  super_primes = list(list_of_super_primes(lower, upper))\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return super_primes", "funcname": "main_solution", "ios": [{"input": {"lower": 7579, "upper": 28362}, "output": [13997, 13999, 17333, 19139, 19319, 19333, 19739, 19793, 19937, 19973, 19979, 19991, 19993, 19997, 23333, 23339, 23399, 23993]}, {"input": {"lower": 8203, "upper": 9985}, "output": []}, {"input": {"lower": 8258, "upper": 18020}, "output": [13997, 13999, 17333]}, {"input": {"lower": 7733, "upper": 19680}, "output": [13997, 13999, 17333, 19139, 19319, 19333]}, {"input": {"lower": 3060, "upper": 15423}, "output": [3119, 3137, 3733, 3739, 3793, 3797, 5939, 7193, 7331, 7333, 7393, 13997, 13999]}, {"input": {"lower": 7062, "upper": 21312}, "output": [7193, 7331, 7333, 7393, 13997, 13999, 17333, 19139, 19319, 19333, 19739, 19793, 19937, 19973, 19979, 19991, 19993, 19997]}, {"input": {"lower": 2962, "upper": 6795}, "output": [3119, 3137, 3733, 3739, 3793, 3797, 5939]}, {"input": {"lower": 9602, "upper": 18684}, "output": [13997, 13999, 17333]}, {"input": {"lower": 8572, "upper": 22844}, "output": [13997, 13999, 17333, 19139, 19319, 19333, 19739, 19793, 19937, 19973, 19979, 19991, 19993, 19997]}, {"input": {"lower": 4629, "upper": 19655}, "output": [5939, 7193, 7331, 7333, 7393, 13997, 13999, 17333, 19139, 19319, 19333]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ZahraNaddaf/class-1", "path": "/session_12/super_prime.py", "msgidx": 7226}}
{"problem_description": "Given a 2D plain represented by a matrix where 0 represents empty land and positive integers represent parts of islands, how many distinct islands are there in the plain? An island is defined as a group of connected cells (in the North, South, East, or West directions) with the same positive integer value.", "io_requirements": "Input:\n  `matrix` (list of lists of integers): A 2D matrix representing the plain. Each element is either 0 (empty land) or a positive integer (part of an island).\n\nOutput:\n  `return` (integer): The number of distinct islands in the matrix.", "refcode": "# import necessary packages\nimport numpy as np\n\n# Function to find the number of islands in the matrix\ndef count_islands(matrix):\n    def dfs(i, j):\n        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0:\n            return\n        matrix[i][j] = 0  # Mark the cell as visited\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n\n    count = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] != 0:\n                dfs(i, j)\n                count += 1\n    return count\n\n# main function\ndef main_solution(matrix):\n    # Convert the input list to a numpy array for easier manipulation\n    matrix = np.array(matrix)\n    \n    # Count the number of islands\n    num_islands = count_islands(matrix)\n    \n    # Return the number of islands as an integer\n    return num_islands", "funcname": "main_solution", "ios": [{"input": {"matrix": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 9], [0, 0, 0, 0]]}, "output": 1}, {"input": {"matrix": [[2, 0, 0, 0, 2], [0, 0, 0, 0, 0], [5, 0, 0, 0, 0]]}, "output": 3}, {"input": {"matrix": [[0, 0, 0], [0, 4, 0], [7, 0, 0], [0, 0, 0], [0, 0, 0], [4, 0, 0]]}, "output": 3}, {"input": {"matrix": [[0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0]]}, "output": 2}, {"input": {"matrix": [[2, 0, 8, 2, 0, 0, 0, 0], [0, 8, 0, 0, 2, 2, 0, 0], [0, 0, 4, 0, 0, 0, 0, 2]]}, "output": 6}, {"input": {"matrix": [[0, 0, 6, 8, 0, 0], [0, 0, 6, 0, 0, 0], [0, 0, 0, 3, 8, 0]]}, "output": 2}, {"input": {"matrix": [[0, 0, 0, 3], [0, 0, 3, 0], [0, 0, 3, 0], [0, 0, 0, 0]]}, "output": 2}, {"input": {"matrix": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0]]}, "output": 1}, {"input": {"matrix": [[0, 0, 0, 1, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1]]}, "output": 5}, {"input": {"matrix": [[2, 6, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0]]}, "output": 2}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "codeAligned/coding-practice", "path": "/Friends/Dustin/disjoint-islands.py", "msgidx": 6893}}
{"problem_description": "Given a puzzle board where each cell contains a number indicating the number of steps that can be taken from that cell, and a starting position on the board, determine if it is possible to reach the end of the board from the starting position by following the step rules. Is the puzzle solvable from the given starting position?", "io_requirements": "Input:\n  `start` (int): The starting position of the agent on the board. It should be a non-negative integer.\n  `board` (list of int): A list representing the puzzle board. Each element in the list represents the number of steps that can be taken from that position. The length of the list should be at least 1.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the puzzle is solvable from the given starting position. `True` if solvable, `False` otherwise.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_solvable(start, board):\n    '''takes a starting position of the agent, and a puzzle board (list).\n    We can \"bounce\" specific steps between cells according to the value in it.\n    The function will return true if it is possible to solve the puzzle\n    from the configuration specified in the parameters (get to the end),\n    and should return false if it is impossible.'''\n    newBoard = board[:]\n    #check start index is on board\n    if start < 0 or start >= len(newBoard):\n        return False\n    #check if we not visited this cell\n    elif newBoard[start] == None:\n        return False\n    #check if we go to the end of the line\n    elif start == len(newBoard) -1:\n        return True\n\n    else:\n        step = newBoard[start]\n        #None mean we visited this cell\n        newBoard[start] = None\n        #go right the num of step in cell\n        right = is_solvable(start + step,newBoard)\n        #go left the num of step in cell\n        left = is_solvable(start - step,newBoard)\n        #if either left or right get me to the end,\n        #that's great! we solved this!\n        if right or left: return True\n        else:\n            return False\n\n# main function\ndef main_solution(start, board):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = is_solvable(start, board)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"start": 1, "board": [5, 4, 5]}, "output": false}, {"input": {"start": 0, "board": [1]}, "output": true}, {"input": {"start": 2, "board": [1, 4, 4, 1, 4, 5, 3]}, "output": true}, {"input": {"start": 0, "board": [1, 4, 1, 4, 3, 1, 1]}, "output": true}, {"input": {"start": 3, "board": [1, 5, 2, 2, 3, 5, 4]}, "output": true}, {"input": {"start": 1, "board": [4, 5, 2, 2, 3, 1]}, "output": false}, {"input": {"start": 0, "board": [5]}, "output": true}, {"input": {"start": 0, "board": [2, 4]}, "output": false}, {"input": {"start": 0, "board": [5, 2, 3, 3, 5, 3, 2, 3]}, "output": false}, {"input": {"start": 2, "board": [4, 4, 1, 4, 5, 3, 5, 1, 1]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "aviadlevy/Intro2cs-huji-2014", "path": "/ex5/GetToTheZero.py", "msgidx": 7032}}
{"problem_description": "Given a list of processed words or sentences, how can we construct a graph where each word or sentence is represented as a node in the graph? Specifically, what is the resulting graph structure when these nodes are connected based on their similarity?", "io_requirements": "Input:\n  `unproc_nodes` (list of strings): A list of processed words or sentences needed to build the graph. Each element in the list represents a node in the graph.\n\nOutput:\n  `return` (dictionary): A dictionary representing the graph. The keys are the nodes (strings) and the values are lists of arcs (neighbors) which are initially empty lists.", "refcode": "# import necessary packages\nfrom abc import ABC, abstractmethod\n\n# all class and function definitions in the code file, if any\nclass Graph(ABC):\n\n    def __init__(self, unproc_nodes=[], dict_graph={}):\n        if unproc_nodes and dict_graph:\n            raise ValueError(\"Cannot have both a list of nodes and a graph of nodes as arguments for the Graph Constructor\")\n\n        if dict_graph:\n            self._graph = dict_graph\n            self._num_nodes = len(self._graph)\n        else:\n            self._graph = self.build_graph(unproc_nodes)\n\n    @property\n    def graph(self):\n        return self._graph\n\n    @property\n    def size(self):\n        return self._num_nodes\n\n    @abstractmethod\n    def build_graph(self, nodes_list=[]):\n        pass\n\n    @abstractmethod\n    def add_node(self, node, arc):\n        pass\n\n    @abstractmethod\n    def del_node(self, node):\n        pass\n\nclass UndirGraph(Graph):\n\n    def __init__(self, unproc_nodes=[], graph_dict={}):\n        super().__init__(unproc_nodes)\n\n    def build_graph(self, node_list):\n        graph = {}\n        self._num_nodes = 0\n\n        for vertex in node_list:\n            self._num_nodes += 1\n            graph[vertex] = []\n\n        return graph\n\n    def add_node(self, node, arc=[]):\n        if node in self._graph:\n            self._graph[node].extend(arc)\n        else:\n            self._graph[node] = arc\n            self._num_nodes += 1\n\n    def del_node(self, node):\n        if node in self._graph:\n            del self._graph[node]\n            self._num_nodes -= 1\n\n# main function\ndef main_solution(unproc_nodes):\n    # Convert input to a list if it's not already\n    if not isinstance(unproc_nodes, list):\n        unproc_nodes = [unproc_nodes]\n\n    # Create an instance of UndirGraph and build the graph\n    graph = UndirGraph(unproc_nodes)\n    graph_dict = graph.graph\n\n    # Return the graph dictionary\n    return graph_dict", "funcname": "main_solution", "ios": [{"input": {"unproc_nodes": ["lIEVY", "uCASo", "hNYUN", "dwcPc", "yHZoG", "GDxLj"]}, "output": {"lIEVY": [], "uCASo": [], "hNYUN": [], "dwcPc": [], "yHZoG": [], "GDxLj": []}}, {"input": {"unproc_nodes": ["xvVCy", "RPGjL", "gVzjE", "VSeip", "tRBls"]}, "output": {"xvVCy": [], "RPGjL": [], "gVzjE": [], "VSeip": [], "tRBls": []}}, {"input": {"unproc_nodes": ["ulrPB", "hwric", "clYcJ", "eqigU", "yKevu"]}, "output": {"ulrPB": [], "hwric": [], "clYcJ": [], "eqigU": [], "yKevu": []}}, {"input": {"unproc_nodes": ["hdhMq", "iFEay", "gWUaF", "XyEIH", "jITaR", "aBoSU"]}, "output": {"hdhMq": [], "iFEay": [], "gWUaF": [], "XyEIH": [], "jITaR": [], "aBoSU": []}}, {"input": {"unproc_nodes": ["Xhpoj", "PpDzS", "odfvg", "YhhjM", "GtMhg"]}, "output": {"Xhpoj": [], "PpDzS": [], "odfvg": [], "YhhjM": [], "GtMhg": []}}, {"input": {"unproc_nodes": ["BuXBJ", "LlLqu", "xeENy", "FrFOC"]}, "output": {"BuXBJ": [], "LlLqu": [], "xeENy": [], "FrFOC": []}}, {"input": {"unproc_nodes": ["zCBtz", "fNYyD", "RETJJ", "zhzCs", "QZNES", "WmpRw"]}, "output": {"zCBtz": [], "fNYyD": [], "RETJJ": [], "zhzCs": [], "QZNES": [], "WmpRw": []}}, {"input": {"unproc_nodes": ["IkZnG", "HeRsn", "SDxUM", "uOsge"]}, "output": {"IkZnG": [], "HeRsn": [], "SDxUM": [], "uOsge": []}}, {"input": {"unproc_nodes": ["NxyRN", "OtGfZ", "MnRml", "ZRGnx"]}, "output": {"NxyRN": [], "OtGfZ": [], "MnRml": [], "ZRGnx": []}}, {"input": {"unproc_nodes": ["kECMn", "aqOgf", "jyhzm", "jvQEN", "oMGDq", "HGQtl"]}, "output": {"kECMn": [], "aqOgf": [], "jyhzm": [], "jvQEN": [], "oMGDq": [], "HGQtl": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "abiraja2004/sumpy-1", "path": "/sumpy/graph/graph.py", "msgidx": 7248}}
{"problem_description": "Devvie, a small robot, is placed at the origin of a 2D grid facing north. Devvie can move forward ('F'), turn right ('R'), or turn left ('L'). Given a sequence of movements and turns, how many steps will it take for Devvie to return to the starting position after completing the sequence?", "io_requirements": "Input:\n  `input_string` (str): A string representing the sequence of movements and turns made by Devvie. Each character in the string can be one of the following:\n    - 'F': Move forward.\n    - 'R': Turn right.\n    - 'L': Turn left.\n\nOutput:\n  `return` (int): The number of steps required for Devvie to return to the starting position after following the given sequence of movements and turns.", "refcode": "# import necessary packages\nimport numpy as np\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\nclass Direction:\n    '''\n    Class for a datatype 'Direction' which can be only\n    'N', 'E', 'S', W'\n\n    Has a method 'turn' which takes only +90 or -90 degrees\n    as it is the only I needed at the moment\n    '''\n    _registry = []\n\n    def __init__(self, pos, defVal = 'N', start = False, finish = False):\n        self._registry.append(self)\n\n        self.default = ['N','E','S','W']\n        self.dir = self.default[self.default.index(str(defVal))]\n        self.start = start\n        self.finish = finish \n        self.pos = pos\n\n    def turn(self,val):\n        currentIndex = self.default.index(self.dir)\n        if(val == 90):\n            self.dir = self.default[(currentIndex + 1) % 4]\n        elif(val == -90):\n            self.dir = self.default[(currentIndex - 1) % 4]\n        return self\n\n    def __str__(self):\n        return str(self.dir)\n\n    def __repr__(self):\n        return self.dir\n\nclass LastInput:\n    '''\n    Class for a datatype LastInput, which I created to have\n    a object with 'x' and 'y' properties, so I don't need to have\n    separate variables\n    '''\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return '[' + str(self.x) + ',' + str(self.y) +']'\n\ndef addBorder(arr, symbol, lastInput, initInput, lastDir):\n    '''\n    This function was made so when Devvie moves on the map,\n    the 2D numpy array indexes never run out of range.\n    It adds a row of free spaces to whichever direction\n    Devvie moves\n\n    @attributes\n    arr - 2D array\n    symbol - symbol that represents free spaces\n    lastInput - lastInput object \n    lastDir - Direction object which holds the last direction Devvie went\n    '''\n    if(str(lastDir) == 'N'):\n        arr = np.insert(arr,0,symbol,axis=0)\n        lastInput.x += 1\n        initInput.x += 1\n    if(str(lastDir) == 'S'):\n        arr = np.insert(arr,len(arr)-1,symbol,axis=0)\n    if(str(lastDir) == 'E'):\n        arr = np.insert(arr,0,symbol,axis=1)\n        lastInput.y += 1\n        initInput.y += 1\n    if(str(lastDir) == 'W'):\n        arr = np.append(arr, [[symbol] for x in range(len(arr))], axis=1)\n\n    return arr, lastInput, initInput\n\n# main function\ndef main_solution(input_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # initialize variables\n    initInput = LastInput(0,0)\n    initDir = Direction(pos = initInput, start = True) \n    map = np.array([[initDir,'.'],['.','.']])\n    lastInput = deepcopy(initInput)\n\n    for x in input_string:\n        # this for loop is for building the map with Devvies directions\n        if (x == 'R'):\n            # turning right and changing on map\n            map[lastInput.x, lastInput.y] = map[lastInput.x, lastInput.y].turn(-90)\n        elif (x == 'L'):\n            # turning left and changing on map\n            map[lastInput.x, lastInput.y] = map[lastInput.x, lastInput.y].turn(90)\n        elif (x == 'F'):\n            # going forward\n            map, lastInput, initInput = addBorder(map,'.',lastInput, initInput, map[lastInput.x, lastInput.y])\n            lastDir = map[lastInput.x, lastInput.y]\n\n            # based on the Devvie's direction makes the move forward on the map\n            if(str(lastDir) == 'N'):\n                lastInput.x -= 1\n                map[lastInput.x, lastInput.y] = Direction(defVal = lastDir, pos = deepcopy(lastInput))\n            if(str(lastDir) == 'S'):\n                lastInput.x += 1\n                map[lastInput.x, lastInput.y] = Direction(defVal = lastDir, pos = deepcopy(lastInput))\n            if(str(lastDir) == 'E'):\n                lastInput.y -= 1\n                map[lastInput.x, lastInput.y] = Direction(defVal = lastDir, pos = deepcopy(lastInput))\n            if(str(lastDir) == 'W'):\n                lastInput.y += 1\n                map[lastInput.x, lastInput.y] = Direction(defVal = lastDir, pos = deepcopy(lastInput))\n    \n    # Label last input on the map as the finish location and save as a new obj\n    map[lastInput.x, lastInput.y].finish = True\n    finishObj = map[lastInput.x, lastInput.y]\n\n    for obj in Direction._registry:\n        # find start object and save it\n        if (obj.start):\n            startObj = obj\n\n    # this will be the returned value with the number of steps made\n    countBack = 0\n\n    while not (startObj.pos.x == finishObj.pos.x and startObj.pos.y == finishObj.pos.y):\n        # loop for going back to the starting position\n        if (startObj.pos.y < finishObj.pos.y and str(finishObj) != 'E'):\n            if (str(finishObj) == 'N'):\n                finishObj.turn(90)\n            else:\n                finishObj.turn(-90)\n            countBack += 1\n        elif (startObj.pos.y < finishObj.pos.y and str(finishObj) == 'E'):\n            finishObj.pos.y -= 1\n            countBack += 1\n\n        elif (startObj.pos.y > finishObj.pos.y and str(finishObj) != 'W'):\n            if (str(finishObj) == 'N'):\n                finishObj.turn(-90)\n            else:\n                finishObj.turn(90)\n            countBack += 1\n        elif (startObj.pos.y > finishObj.pos.y and str(finishObj) == 'W'):\n            finishObj.pos.y += 1\n            countBack += 1\n\n        if (startObj.pos.y == finishObj.pos.y and startObj.pos.x < finishObj.pos.x and str(finishObj) != 'N'):\n            if (str(finishObj) == 'W'):\n                finishObj.turn(90)\n            else:\n                finishObj.turn(-90)\n            countBack += 1\n        elif (startObj.pos.y == finishObj.pos.y and startObj.pos.x < finishObj.pos.x and str(finishObj) == 'N'):\n            finishObj.pos.x -= 1\n            countBack += 1\n\n        elif (startObj.pos.y == finishObj.pos.y and startObj.pos.x > finishObj.pos.x and str(finishObj) != 'S'):\n            if (str(finishObj) == 'W'):\n                finishObj.turn(-90)\n            else:\n                finishObj.turn(90)\n            countBack += 1\n        elif (startObj.pos.y == finishObj.pos.y and startObj.pos.x > finishObj.pos.x and str(finishObj) == 'S'):\n            finishObj.pos.x += 1\n            countBack += 1        \n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return countBack", "funcname": "main_solution", "ios": [{"input": {"input_string": "FRRLLFRRRRFRFRFLRL"}, "output": 6}, {"input": {"input_string": "FLRRLRLFFFR"}, "output": 5}, {"input": {"input_string": "FF"}, "output": 4}, {"input": {"input_string": "LFRFR"}, "output": 3}, {"input": {"input_string": "LFLRFFRLRRRL"}, "output": 3}, {"input": {"input_string": "FFRRR"}, "output": 3}, {"input": {"input_string": "F"}, "output": 3}, {"input": {"input_string": "FFLRLFFLFF"}, "output": 3}, {"input": {"input_string": "RLRFFFRLF"}, "output": 6}, {"input": {"input_string": "RFLLFRLFFFFRFRFFFR"}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Andycko/UniCode-20-21", "path": "/2_Devvie/solution.py", "msgidx": 6918}}
{"problem_description": "Given a complete binary tree, which is a binary tree where all levels are completely filled except possibly the last level and all nodes in the last level are as far left as possible, what is the value of the last node in the tree? The tree is represented by a dictionary where each node has a value and may have left and right children, also represented as dictionaries.", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each key-value pair represents a node in the tree. The keys are:\n    - `val` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as another dictionary or None if there is no right child.\n\nOutput:\n  `return` (int or None): The value of the last node in the binary tree, or None if the tree is empty.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def printlastnode(self, root):\n        if not root:\n            return None\n        depth = 0\n        tmp = root\n        while tmp:        # \u8ba1\u7b97\u4e8c\u53c9\u6811\u7684\u9ad8\u5ea6\n            depth += 1\n            tmp = tmp.left\n\n        level = 0\n        tempdepth = 0\n        while root:\n            level += 1\n            if level == depth:\n                break\n            curnode = root\n            if curnode.right:    # \u5148\u904d\u5386\u53f3\u5b69\u5b50\uff0c\u82e5\u65e0\u53f3\u5b69\u5b50\uff0c\u5219line59\n                parent = curnode\n                curnode = curnode.right\n                tempdepth = level + 1   # \u8bbe\u7f6e\u4e34\u65f6\u9ad8\u5ea6\n                while curnode.left:    # \u4ece\u6839\u8282\u70b9\u53f3\u6811\u8d77\u4e00\u76f4\u5faa\u73af\u5f80\u5176\u5de6\u5b69\u5b50\u904d\u5386\n                    tempdepth += 1\n                    parent = curnode\n                    curnode = curnode.left\n                # \u82e5\u4e34\u65f6\u7edf\u8ba1\u9ad8\u5ea6\u5c0f\u4e8e\u4e8c\u53c9\u6811\u9ad8\u5ea6\uff0c\u8bc1\u660e\u53f3\u8fb9\u7684\u6811\u66f4\u77ed\uff0c\u5219root=root.left\n                # \u5f97\u53bb\u6839\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u90a3\u8fb9\u627e\u6700\u540e\u7684\u8282\u70b9\n                if tempdepth < depth:\n                    root = root.left\n\n                # tempdepth == depth, \u4e14\u65e0\u53f3\u5b69\u5b50\n                elif not curnode.right or parent.right == curnode:\n                    return curnode\n                else:  # \u9ad8\u5ea6\u662f\u76f8\u7b49\u7684\uff0c\u4f46curnode\u8fd8\u6709\u53f3\u5b69\u5b50\n                    root = root.right   # \u90a3\u5c31\u628a\u6839\u8282\u70b9\u7684\u53f3\u8282\u70b9\u5f53\u4f5c\u6839\u8282\u70b9\u518d\u6765\u4e00\u904d\n\n            else:   # \u6839\u8282\u70b9\u6ca1\u6709\u53f3\u5b69\u5b50\uff1f\u597d\u5427\u90a3\u5c31\u904d\u5386\u5de6\u5b69\u5b50\n                root = root.left\n\n        return root\n\n# main function\ndef main_solution(tree_structure):\n    # Convert JSON serializable input to TreeNode objects\n    def build_tree(node_dict):\n        if not node_dict:\n            return None\n        root = TreeNode(node_dict['val'])\n        root.left = build_tree(node_dict['left'])\n        root.right = build_tree(node_dict['right'])\n        return root\n\n    root = build_tree(tree_structure)\n    sol = Solution()\n    last_node = sol.printlastnode(root)\n    \n    # Convert the result to a JSON serializable output\n    return last_node.val if last_node else None", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 65, "left": null, "right": null}}, "output": 65}, {"input": {"tree_structure": {"val": 80, "left": null, "right": null}}, "output": 80}, {"input": {"tree_structure": {"val": 84, "left": null, "right": null}}, "output": 84}, {"input": {"tree_structure": {"val": 43, "left": null, "right": null}}, "output": 43}, {"input": {"tree_structure": {"val": 47, "left": null, "right": null}}, "output": 47}, {"input": {"tree_structure": {"val": 70, "left": null, "right": {"val": 31, "left": null, "right": null}}}, "output": 70}, {"input": {"tree_structure": {"val": 70, "left": null, "right": null}}, "output": 70}, {"input": {"tree_structure": {"val": 68, "left": null, "right": {"val": 25, "left": null, "right": null}}}, "output": 68}, {"input": {"tree_structure": {"val": 89, "left": null, "right": {"val": 20, "left": null, "right": null}}}, "output": 89}, {"input": {"tree_structure": {"val": 57, "left": null, "right": {"val": 33, "left": null, "right": null}}}, "output": 57}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yxx94/2020-", "path": "/jianzhioffer/\u4e8c\u53c9\u6811/\u5b8c\u5168\u4e8c\u53c9\u6811\u6700\u540e\u7ed3\u70b9.py", "msgidx": 7015}}
{"problem_description": "Imagine you have a special Cartesian plane where numbers are arranged in a spiral pattern starting from 1 at the origin (0, 0). The spiral wraps around counterclockwise, and each number has a unique position on this plane. Given a number, what are its coordinates on this plane? Alternatively, given a specific coordinate, what number is located at that position?", "io_requirements": "Input:\n  `operation` (str): The operation to perform, either \"find_position\" or \"find_number\".\n  `number` (int, optional): The number to find the position for. Required if `operation` is \"find_position\".\n  `x` (int, optional): The x-coordinate of the position. Required if `operation` is \"find_number\".\n  `y` (int, optional): The y-coordinate of the position. Required if `operation` is \"find_number\".\n\nOutput:\n  `return` (dict): A dictionary containing the result. If `operation` is \"find_position\", it contains the key \"position\" with the value being a tuple (x, y). If `operation` is \"find_number\", it contains the key \"number\" with the value being an integer. If the operation is invalid, it contains the key \"error\" with a corresponding message.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef find_position_of_number(number):\n    if (number <= 0):\n        return None\n\n    root = math.floor(math.sqrt(number))\n    largest_odd_smaller = root if (root % 2 == 1) else (root-1)\n    n = math.floor((largest_odd_smaller - 1) / 2)\n    L = largest_odd_smaller * largest_odd_smaller\n\n    if number < L:\n        return None\n\n    x = n\n    y = -n\n\n    if number > L:\n        L += 1\n        x += 1\n\n    for _ in range(largest_odd_smaller):\n        if L >= number:\n            break\n        L += 1\n        y += 1\n\n    for _ in range(largest_odd_smaller+1):\n        if L >= number:\n            break\n        L += 1\n        x -= 1\n\n    for _ in range(largest_odd_smaller+1):\n        if L >= number:\n            break\n        L += 1\n        y -= 1\n\n    for _ in range(largest_odd_smaller):\n        if L >= number:\n            break\n        L += 1\n        x += 1\n\n    return (x, y)\n\n\ndef find_number_at_position(x, y):\n    n = max(abs(x), abs(y))\n\n    if n == 0:\n        return 1\n\n    small = 2*n - 1\n    large = 2*n + 1\n    smaller_square = small ** 2\n    larger_square  = large ** 2\n\n    L = smaller_square\n    x_try = n - 1\n    y_try = -x_try\n\n    L += 1\n    x_try += 1\n    if (x_try, y_try) == (x, y):\n        return L\n\n    for _ in range(small):\n        if (x_try, y_try) == (x, y):\n            return L\n        L += 1\n        y_try += 1\n\n    for _ in range(small + 1):\n        if (x_try, y_try) == (x, y):\n            return L\n        L += 1\n        x_try -= 1\n\n    for _ in range(small + 1):\n        if (x_try, y_try) == (x, y):\n            return L\n        L += 1\n        y_try -= 1\n\n    for _ in range(small + 1):\n        if (x_try, y_try) == (x, y):\n            return L\n        L += 1\n        x_try += 1\n\n    return L\n\n# main function\ndef main_solution(operation, number=None, x=None, y=None):\n    if operation == \"find_position\":\n        position = find_position_of_number(number)\n        return {\"position\": position}\n    elif operation == \"find_number\":\n        number_at_position = find_number_at_position(x, y)\n        return {\"number\": number_at_position}\n    else:\n        return {\"error\": \"Invalid operation\"}", "funcname": "main_solution", "ios": [{"input": {"operation": "find_number", "x": -8, "y": 5}, "output": {"number": 260}}, {"input": {"operation": "find_position", "number": 334}, "output": {"position": [-9, 0]}}, {"input": {"operation": "find_number", "x": 0, "y": 8}, "output": {"number": 249}}, {"input": {"operation": "find_number", "x": 10, "y": 0}, "output": {"number": 371}}, {"input": {"operation": "find_position", "number": 859}, "output": {"position": [15, 3]}}, {"input": {"operation": "find_number", "x": 3, "y": -1}, "output": {"number": 27}}, {"input": {"operation": "find_number", "x": -8, "y": -7}, "output": {"number": 272}}, {"input": {"operation": "find_number", "x": 8, "y": 0}, "output": {"number": 233}}, {"input": {"operation": "find_number", "x": 1, "y": -5}, "output": {"number": 117}}, {"input": {"operation": "find_number", "x": 9, "y": -10}, "output": {"number": 440}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lmachadopolettivalle/trapped-knight", "path": "/EntirePlane/board_utils.py", "msgidx": 6913}}
{"problem_description": "Given an upper limit for generating pentagonal numbers, what is the pair of pentagonal numbers such that their sum and absolute difference are also pentagonal numbers?", "io_requirements": "Input:\n  `big_number` (int): The upper limit for generating pentagonal numbers. It should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `a` (float): The first pentagonal number in the pair.\n    - `b` (float): The second pentagonal number in the pair.\n    - `a_minus_b` (float): The absolute difference between the two pentagonal numbers.\n  If no such pair is found, the function returns `None`.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(big_number):\n    # Convert the input to the required format\n    big_number = int(big_number)\n    \n    # Generate the set of pentagonal numbers\n    pentagonal = set()\n    i = 1\n    while (i * (3 * i - 1) / 2 < big_number):\n        pentagonal.add(i * (3 * i - 1) / 2)\n        i += 1\n    \n    # Find the pair of pentagonal numbers that meet the criteria\n    for a in pentagonal:\n        for b in pentagonal:\n            if ((a + b in pentagonal) and (abs(a - b) in pentagonal)):\n                return {\"a\": a, \"b\": b, \"a_minus_b\": abs(a - b)}\n    \n    # If no such pair is found, return None\n    return None", "funcname": "main_solution", "ios": [{"input": {"big_number": 27794199}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 85097140}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 61558885}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 94910969}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 36476831}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 38132798}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 11831069}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 41390751}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 42380679}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}, {"input": {"big_number": 76161605}, "output": {"a": 1560090.0, "b": 7042750.0, "a_minus_b": 5482660.0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "halucinka/projectEuler", "path": "/p44.py", "msgidx": 6985}}
{"problem_description": "Given a number in a spiral pattern where the numbers increase sequentially from the center, what is the Manhattan distance from the given number to the center of the spiral? For example, in the spiral pattern:\n\n```\n17  16  15  14  13\n18   5   4   3  12\n19   6   1   2  11\n20   7   8   9  10\n21  22  23---> ...\n```\n\nThe center is `1`. What is the Manhattan distance from the given number to the center?", "io_requirements": "Input:\n  `number` (str): A string representation of an integer number for which the Manhattan distance to the center in a spiral pattern needs to be calculated. The number should be a positive integer.\n\nOutput:\n  `return` (int): The Manhattan distance from the given number to the center of the spiral pattern.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(number):\n    # Convert the input number to an integer\n    x = int(number)\n    \n    # Calculate the Manhattan distance to the center from the given number\n    d = 0\n    while (2*d+1)**2 < x:\n        d += 1\n\n    first = (2*d-1)**2 + 1\n\n    sides = [first + d-1 + 2*d*i for i in range(4)]\n\n    distance_to_closest_side = min(abs(side-x) for side in sides)\n\n    # Return the Manhattan distance as an integer\n    return distance_to_closest_side + d", "funcname": "main_solution", "ios": [{"input": {"number": "100878"}, "output": 247}, {"input": {"number": "627083"}, "output": 610}, {"input": {"number": "659552"}, "output": 605}, {"input": {"number": "216134"}, "output": 373}, {"input": {"number": "819497"}, "output": 472}, {"input": {"number": "28370"}, "output": 145}, {"input": {"number": "214775"}, "output": 406}, {"input": {"number": "320453"}, "output": 470}, {"input": {"number": "805667"}, "output": 738}, {"input": {"number": "324513"}, "output": 388}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sw561/AdventOfCode2015-17", "path": "/2017/03/spiral.py", "msgidx": 7419}}
{"problem_description": "Given a natural number \\( N \\), find all possible combinations of three natural numbers \\( a \\), \\( b \\), and \\( c \\) such that their sum is \\( N \\) and the equation \\( a^2 + b^2 = c^2 \\) holds true. What are the combinations of \\( a \\), \\( b \\), and \\( c \\) that satisfy these conditions?", "io_requirements": "Input:\n  `N` (int): The sum of the three natural numbers a, b, and c should be equal to N.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple contains three integers (a, b, c) that satisfy the conditions a + b + c = N and a^2 + b^2 = c^2.", "refcode": "# import necessary packages\nimport time\n\n# main function\ndef main_solution(N):\n    # N (int): The sum of a, b, and c should be equal to N.\n    results = []\n    for a in range(0, N + 1):\n        for b in range(0, N + 1):\n            c = N - a - b\n            if c >= 0 and a**2 + b**2 == c**2:\n                results.append((a, b, c))\n    return results", "funcname": "main_solution", "ios": [{"input": {"N": 932}, "output": [[0, 466, 466], [466, 0, 466]]}, {"input": {"N": 583}, "output": []}, {"input": {"N": 556}, "output": [[0, 278, 278], [278, 0, 278]]}, {"input": {"N": 105}, "output": []}, {"input": {"N": 585}, "output": []}, {"input": {"N": 653}, "output": []}, {"input": {"N": 355}, "output": []}, {"input": {"N": 161}, "output": []}, {"input": {"N": 793}, "output": []}, {"input": {"N": 241}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JayceCaiUMD/XCumd", "path": "/Data Structure/Algorithmchar1.py", "msgidx": 7680}}
{"problem_description": "Given a mathematical expression in prefix notation, where operators precede their operands, what is the result of evaluating this expression? The expression consists of numbers and operators \"+\", \"*\", and each token is separated by a space.", "io_requirements": "Input:\n  `prefix_expression` (str): A string representing a mathematical expression in prefix notation. Each token in the expression is separated by a space. For example, \"+ * + 5 4 6 3\".\n\nOutput:\n  `return` (float): The result of evaluating the prefix expression.", "refcode": "# import necessary packages\nimport queue\n\n# all class and function definitions in the code file, if any\nclass TimesNode:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n    def eval(self):\n        return self.left.eval() * self.right.eval()\n\n    def inorder(self):\n        return \"(\" + self.left.inorder() + \" * \" + self.right.inorder() + \")\"\n\nclass PlusNode:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n    def eval(self):\n        return self.left.eval() + self.right.eval()\n\n    def inorder(self):\n        return \"(\" + self.left.inorder() + \" + \" + self.right.inorder() + \")\"\n\nclass NumNode:\n    def __init__(self, num):\n        self.num = num\n\n    def eval(self):\n        return self.num\n\n    def inorder(self):\n        return str(self.num)\n\ndef E(q):\n    if q.empty():\n        raise ValueError(\"Invalid Prefix Expression\")\n\n    token = q.get()\n\n    if token == \"+\":\n        return PlusNode(E(q), E(q))\n\n    if token == \"*\":\n        return TimesNode(E(q), E(q))\n\n    return NumNode(float(token))\n\n# main function\ndef main_solution(prefix_expression):\n    # Convert the prefix expression string to a list of tokens\n    lst = prefix_expression.split()\n    q = queue.Queue()\n\n    for token in lst:\n        q.put(token)\n\n    # Parse the prefix expression and evaluate it\n    root = E(q)\n    result = root.eval()\n\n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"prefix_expression": "2 * 8 4 6"}, "output": 2.0}, {"input": {"prefix_expression": "8 8 * 1 7"}, "output": 8.0}, {"input": {"prefix_expression": "5 4 7 + 9"}, "output": 5.0}, {"input": {"prefix_expression": "+ 1 1 6 8"}, "output": 2.0}, {"input": {"prefix_expression": "* 2 7 6 8"}, "output": 14.0}, {"input": {"prefix_expression": "3 9 7 4 *"}, "output": 3.0}, {"input": {"prefix_expression": "7 10 7 + 3"}, "output": 7.0}, {"input": {"prefix_expression": "9 4 7 2 *"}, "output": 9.0}, {"input": {"prefix_expression": "4 5 6 + 8"}, "output": 4.0}, {"input": {"prefix_expression": "5 5 1 * 9"}, "output": 5.0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "xiaoruijiang/algorithm", "path": "/06-tree/tree/chapter8_tree.py", "msgidx": 7051}}
{"problem_description": "Given a binary tree, determine whether it is balanced. A balanced binary tree is defined as a tree in which the heights of the two subtrees of any node never differ by more than one. What is the result of checking if the provided binary tree structure is balanced?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each key in the dictionary represents a node, and its value is another dictionary with keys 'left' and 'right', which can either be another node dictionary or `None`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is balanced. `True` if the tree is balanced, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self):\n        self.left = None\n        self.right = None\n\ndef calc_height(node):\n    if node is None:\n        return 0\n    left = calc_height(node.left)\n    if left == -1:\n        return -1\n    right = calc_height(node.right)\n    if right == -1:\n        return -1\n    if abs(left - right) > 1:\n        return -1\n    return max(left, right) + 1\n\ndef is_balanced(node):\n    if calc_height(node) == -1:\n        return False\n    return True\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(structure):\n        if not structure:\n            return None\n        node = Node()\n        node.left = build_tree(structure.get('left'))\n        node.right = build_tree(structure.get('right'))\n        return node\n\n    root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    result = is_balanced(root)\n    \n    # Return the JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"left": {"left": null, "right": null}, "right": null}}, "output": true}, {"input": {"tree_structure": {"left": null, "right": {"left": null, "right": null}}}, "output": true}, {"input": {"tree_structure": {"left": null, "right": {"left": {"left": null, "right": null}, "right": null}}}, "output": false}, {"input": {"tree_structure": {"left": {"left": null, "right": null}, "right": {"left": null, "right": null}}}, "output": true}, {"input": {"tree_structure": {"left": null, "right": {"left": null, "right": {"left": null, "right": null}}}}, "output": false}, {"input": {"tree_structure": {"left": {"left": null, "right": {"left": null, "right": null}}, "right": null}}, "output": false}, {"input": {"tree_structure": {"left": {"left": {"left": null, "right": null}, "right": null}, "right": null}}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gareth-ferneyhough/practice", "path": "/is_balanced.py", "msgidx": 7466}}
{"problem_description": "Given a binary tree, determine whether it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its central axis. What is the result of checking if the given binary tree is symmetrical?", "io_requirements": "Input:\n  `tree_structure` (list of int or None): A list representing the structure of the binary tree. Each element in the list corresponds to a node value, with `None` indicating a missing node. The list is constructed in a level-order traversal manner.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        return self.helper(pRoot, pRoot)\n\n    def helper(self, pRoot1, pRoot2):\n        if pRoot1 is None and pRoot2 is None:\n            return True\n        if pRoot1 is None or pRoot2 is None:\n            return False\n        if pRoot1.val == pRoot2.val:\n            return self.helper(pRoot1.left, pRoot2.right) and self.helper(pRoot1.right, pRoot2.left)\n        return False\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    pRoot = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetrical(pRoot)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [33, 33, 1, 45, 18, null, 49, 76, 56, null, 5, null, 18, null, 51]}, "output": false}, {"input": {"tree_structure": [50, 94, 66, null, 4, null, null, 80, null, null, 8, null, 90, null, 51]}, "output": false}, {"input": {"tree_structure": [14, null, null, 11, null, null, 32]}, "output": true}, {"input": {"tree_structure": [42, null, 17, 23, null, null, null, null, 23, 98, null, null, 39, 89, null]}, "output": false}, {"input": {"tree_structure": [18, null, null, 28, 28, null, 44, 87, 18, null, null, 37, 9, 49, null]}, "output": true}, {"input": {"tree_structure": [83, null, 19]}, "output": false}, {"input": {"tree_structure": [16]}, "output": true}, {"input": {"tree_structure": [57, null, 50, null, null, null, null, 18, 40, 55, 83, null, 69, null, 21]}, "output": false}, {"input": {"tree_structure": [59, 5, 45]}, "output": false}, {"input": {"tree_structure": [39, 4, null, null, 89, null, null]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhangrong1722/interview", "path": "/code/at_offer/binary_tree/coding_interview28.py", "msgidx": 7473}}
{"problem_description": "You have a stack of pancakes, each of which can be either happy side up ('+') or blank side up ('-'). To serve the pancakes, you need to flip them so that all of them are happy side up. Flipping involves taking the top part of the stack and reversing it, which also changes the orientation of each pancake in that part. Given a stack of pancakes, how many flips are required to make all pancakes happy side up?", "io_requirements": "Input:\n  `stack` (str): A string representing the pancake stack, where each character is either '+' (indicating a happy side up) or '-' (indicating a blank side up). The length of the string should be reasonable (less than 1KB).\n\nOutput:\n  `return` (int): The minimum number of flips required to make all pancakes happy side up ('+').", "refcode": "# import necessary packages\nimport queue\n\n# Function to flip the stack\ndef flipped(stack):\n    result = []\n    for i in stack:\n        if i == \"-\":\n            result.append(\"+\")\n        else:\n            result.append(\"-\")\n    return result\n\n# main function\ndef main_solution(stack):\n    # Convert the input stack to a list of characters\n    n = list(stack)\n    ways = []\n    frontier = queue.PriorityQueue()\n    height = len(n)\n    explored = []\n    \n    # Check if the stack is already all '+'\n    if len(n) == n.count(\"+\"):\n        ways.append(0)\n    \n    # Find the length of the initial segment of the stack that is uniform\n    top = n[0]\n    stacklen = 1\n    for i in range(0, height):\n        if n[i] == n[0]:\n            stacklen = i + 1\n        else:\n            break\n    \n    # Flip the initial segment and concatenate with the rest of the stack\n    flip = flipped(n[0:stacklen])\n    save = flip[::-1] + n[stacklen:]\n    \n    # Check if the stack is all '+' after the first flip\n    if len(save) == save.count(\"+\"):\n        ways.append(1)\n    else:\n        frontier.put((save, 1))\n    \n    # Continue flipping until the stack is all '+'\n    while frontier.qsize() > 0:\n        start, cost = frontier.get()\n        for i in range(0, height):\n            if start[i] == start[0]:\n                stacklen = i + 1\n            else:\n                break\n        flip = flipped(start[0:stacklen])\n        save = flip[::-1] + start[stacklen:]\n        \n        # Check if the stack is all '+' after the current flip\n        if len(save) == save.count(\"+\"):\n            ways.append(cost + 1)\n        else:\n            if save not in explored:\n                explored.append(save)\n                frontier.put((save, cost + 1))\n    \n    # Return the minimum number of flips needed\n    return min(ways)", "funcname": "main_solution", "ios": [{"input": {"stack": "+-+++-++++-"}, "output": 6}, {"input": {"stack": "-----+-+++----+--+++-+-++---+--+--+++----++++"}, "output": 19}, {"input": {"stack": "+--+++--++-++-+-+-+-+--+--+++++-+--+++++--+--"}, "output": 26}, {"input": {"stack": "--++-+--+-+-+-++++-+--++-+-++-+-------+-+---+-+--+----+-+-+--+++-+"}, "output": 41}, {"input": {"stack": "-+++--+--+-++---+--+---++--++-----++++---+++-+++-----++--+"}, "output": 25}, {"input": {"stack": "-++++++++-+-+-+++++--++++--------++--+++++----++---+---+--+--++--+-++--+"}, "output": 29}, {"input": {"stack": "++-----++++-+-++-++++++----++-+--+++-++++--+-+++--+-++++"}, "output": 24}, {"input": {"stack": "--+-----+---++-+-+-----+-+--++++-+--+-+-+++-+-++---"}, "output": 29}, {"input": {"stack": "+----+-++-+--++++---++-+---++-++-+-++++--+--++-+-+-+--+-++-+---+-+--+-+++++"}, "output": 44}, {"input": {"stack": "+++++--+"}, "output": 2}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "harshp8l/deep-learning-lang-detection", "path": "/data/test/python/2c880c1c28ba4d5294c16825909db23ab08d309fPancakes.py", "msgidx": 6749}}
{"problem_description": "Given the definitions of polygonal numbers (triangle, square, pentagonal, hexagonal, heptagonal, and octagonal), what is the sum of the smallest set of six cyclic 4-digit numbers where each type of polygonal number is represented by a different number in the set?", "io_requirements": "Input:\n  `limit` (int): The upper limit for generating polygonal numbers. This should be a reasonable integer value, typically around 10000.\n\nOutput:\n  `return` (int or None): The sum of the smallest cyclic set of six 4-digit polygonal numbers if such a set exists, otherwise `None`.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef generate_polygonal_numbers(n, limit):\n    \"\"\"Generate polygonal numbers of type n up to the given limit.\"\"\"\n    if n == 3:\n        return list(filter(lambda x: x >= 1000 and x < 10000, map(lambda n: n * (n + 1) // 2, range(1, limit))))\n    elif n == 4:\n        return list(filter(lambda x: x >= 1000 and x < 10000, map(lambda n: n * n, range(1, limit))))\n    elif n == 5:\n        return list(filter(lambda x: x >= 1000 and x < 10000, map(lambda n: n * (3 * n - 1) // 2, range(1, limit))))\n    elif n == 6:\n        return list(filter(lambda x: x >= 1000 and x < 10000, map(lambda n: n * (2 * n - 1), range(1, limit))))\n    elif n == 7:\n        return list(filter(lambda x: x >= 1000 and x < 10000, map(lambda n: n * (5 * n - 3) // 2, range(1, limit))))\n    elif n == 8:\n        return list(filter(lambda x: x >= 1000 and x < 10000, map(lambda n: n * (3 * n - 2), range(1, limit))))\n    else:\n        return []\n\ndef dfs(results, ps, indexLeft, currentResult):\n    \"\"\"Depth-first search to find cyclic sets of polygonal numbers.\"\"\"\n    currentP = currentResult[-1]\n    for idx in indexLeft:\n        for nextP in ps[idx]:\n            if currentP % 100 == nextP // 100:\n                _currentResult = currentResult + [nextP]\n                if len(_currentResult) == 6:\n                    if nextP % 100 == _currentResult[0] // 100:\n                        results.append(_currentResult)\n                else:\n                    _indexLeft = indexLeft[:]\n                    _indexLeft.remove(idx)\n                    dfs(results, ps, _indexLeft, _currentResult)\n\n# main function\ndef main_solution(limit):\n    # Generate polygonal numbers for each type\n    ps = [generate_polygonal_numbers(n, limit) for n in range(3, 9)]\n    \n    results = []\n    indexLeft = list(range(6))\n    \n    # Start DFS from octagonal numbers\n    for p1 in ps[5]:\n        _indexLeft = indexLeft[:]\n        _indexLeft.remove(5)\n        dfs(results, ps, _indexLeft, [p1])\n    \n    # Find the sum of the smallest cyclic set\n    if results:\n        return min(map(sum, results))\n    else:\n        return None", "funcname": "main_solution", "ios": [{"input": {"limit": 3252}, "output": 28684}, {"input": {"limit": 3433}, "output": 28684}, {"input": {"limit": 5523}, "output": 28684}, {"input": {"limit": 7726}, "output": 28684}, {"input": {"limit": 4297}, "output": 28684}, {"input": {"limit": 4871}, "output": 28684}, {"input": {"limit": 3490}, "output": 28684}, {"input": {"limit": 9250}, "output": 28684}, {"input": {"limit": 5712}, "output": 28684}, {"input": {"limit": 1353}, "output": 28684}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "luocanfeng/projecteuler", "path": "/src051_100/P061.py", "msgidx": 7600}}
{"problem_description": "Given a mathematical expression defined by the Backus-Naur Form (BNF), which includes digits, addition, multiplication, and parentheses, what is the result of evaluating the expression according to the rules of operator precedence and parentheses?", "io_requirements": "Input:\n  `expression` (str): A string representing a mathematical expression in the format defined by the Backus-Naur Form (BNF). The expression can include digits (0-9), addition (+), multiplication (*), and parentheses ().\n\nOutput:\n  `return` (str): A string representing the result of the evaluated mathematical expression.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef resolver_parenteses(expressao):\n    expressao_resolvida = expressao\n\n    while re.findall(r'[(]{1}[^\\(\\)]+[)]{1}', expressao_resolvida):\n        lista_parenteses = re.findall(r'[(]{1}[^\\(\\)]+[)]{1}', expressao_resolvida)\n        parenteses_interno = lista_parenteses[0]\n        expressao_parenteses_interno = parenteses_interno[1:-1]\n        resultado_parenteses_interno = resolver_expressao(expressao_parenteses_interno)\n        expressao_resolvida = expressao_resolvida.replace(parenteses_interno, str(resultado_parenteses_interno), 1)\n    return expressao_resolvida\n\ndef resolver_multiplicacao(expressao):\n    expressao_resolvida = expressao\n    \n    while re.findall(r'\\d+\\*\\d+', expressao_resolvida):\n        multiplicacoes = re.findall(r'\\d+\\*\\d+', expressao_resolvida)\n        operacao_multiplicacao = multiplicacoes[0]\n        resultado_multiplicacao = eval(operacao_multiplicacao)\n        expressao_resolvida = expressao_resolvida.replace(operacao_multiplicacao, str(resultado_multiplicacao), 1)\n    return expressao_resolvida\n\ndef resolver_soma(expressao):\n    expressao_resolvida = expressao\n\n    while re.findall(r'\\d+\\+\\d+', expressao_resolvida):\n        somas = re.findall(r'\\d+\\+\\d+', expressao_resolvida)\n        operacao_soma = somas[0]\n        resultado_soma = eval(operacao_soma)\n        expressao_resolvida = expressao_resolvida.replace(operacao_soma, str(resultado_soma), 1)\n    return expressao_resolvida\n\ndef resolver_expressao(expressao):\n    resultado_parenteses = resolver_parenteses(expressao)\n    resultado_multiplicacao = resolver_multiplicacao(resultado_parenteses)\n    resultado_soma = resolver_soma(resultado_multiplicacao)\n    resultado_final = resultado_soma\n    return resultado_final\n\n# main function\ndef main_solution(expression):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = resolver_expressao(expression)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"expression": "4+4(4*)"}, "output": "48*"}, {"input": {"expression": "(((0*9+8*)))+"}, "output": "8*+"}, {"input": {"expression": "4(9*1)8+"}, "output": "498+"}, {"input": {"expression": "((45)(0*)+(1*2*4))(8*(00*3))+"}, "output": "450*+80+"}, {"input": {"expression": "((3))3*"}, "output": "33*"}, {"input": {"expression": "7"}, "output": "7"}, {"input": {"expression": "(5(5+5*)*(68+1*)+)*((1*)*5)2"}, "output": "510**69*+*1**52"}, {"input": {"expression": "27"}, "output": "27"}, {"input": {"expression": "2+1+(2*8*)+"}, "output": "19*+"}, {"input": {"expression": "99+"}, "output": "99+"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EnusNata/faculdade", "path": "/modelos de linguagem de programa\u00e7\u00e3o/Avalicao2/questao_quatro.py", "msgidx": 7354}}
{"problem_description": "You are organizing a team of eSportsmen, and you want to ensure that the team's name announcement sounds cool. A team is considered cool if the names of its members can be arranged such that the first letter of one player's name is the same as the last letter in the name of the player before them. Given a list of team members' names, can you determine if the team is cool?", "io_requirements": "Input:\n  `team` (list of strings): A list of team members' names, where each name is a string consisting of English characters. The length of each name is between 2 and 20 characters, and the total number of names is between 1 and 100.\n\nOutput:\n  `return` (boolean): `True` if the team is cool (i.e., the names can be arranged such that the first letter of one player's name is the same as the last letter in the name of the player before them), `False` otherwise.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\nclass Team(object):\n    def __init__(self, names):\n        self.names = names\n\n    def __bool__(self):\n        return self.isTeamCool3()\n\n    def isTeamCool3(self):\n        namesLow = [i.lower() for i in self.names]\n        \n        letters = \"abcdefghijklmnopqrstuvwxyz\"\n        FROM  = {i: [] for i in letters}\n        TO    = {i: [] for i in letters}\n        \n        for i in letters:\n            for j in namesLow:\n                if i == j[-1]:\n                    FROM[i].append(j) # Find names that lead to current letter\n                if i == j[0]:\n                    TO[i].append(j) # Find names that letter can lead to \n        \n        # Quick rule out impossible cases\n        start = False\n        end   = False\n        for i in letters:\n            if len(FROM[i]) + 1 == len(TO[i]):\n                # Found the start!\n                if start:\n                    return False # Whoops, too many starts!\n                start = True\n            elif len(FROM[i]) == len(TO[i]) + 1:\n                # Found the end!\n                if end:\n                    return False # Whoops, too many ends!\n                end = True\n            elif len(FROM[i]) != len(TO[i]):\n                return False\n        \n        # Check if graph is connected\n        visited = {0}\n        queue = [0]\n        \n        while queue:\n            name = queue.pop(0)\n            for ind, teammate in enumerate(namesLow):\n                if ind in visited:\n                    continue\n                if namesLow[name][0] == teammate[-1]:\n                    visited.add(ind)\n                    queue.append(ind)\n                elif namesLow[name][-1] == teammate[0]:\n                    visited.add(ind)\n                    queue.append(ind)\n        \n        return len(visited) == len(self.names) # Is everyone found?\n\n# main function\ndef main_solution(team):\n    # Convert the input list of names to a Team object\n    team_obj = Team(team)\n    # Check if the team is cool and return the result\n    return bool(team_obj)", "funcname": "main_solution", "ios": [{"input": {"team": ["VexKffBEQJtfLo", "WRHXjEEjqxsQhBu", "ZtjHsUkzR", "fGlDxNkVk"]}, "output": false}, {"input": {"team": ["PLdJKTA", "XLZnBdC", "FRCTBDLrAJRDPxP", "TUYwS"]}, "output": false}, {"input": {"team": ["LObNZYgRgdOshT", "xXXfGQZQqZFCok", "mWsG", "hsiVGAJOajaqDEhUnH", "HbRIEVDITpcrJywsbidf"]}, "output": false}, {"input": {"team": ["BtlBMwHLbw", "jOibpVAbsGTizPcL", "tExMNowb", "omXuFHSdNoWjlmea", "btj", "teEHmJeTIrdGcEp"]}, "output": false}, {"input": {"team": ["zkedzaIiDzfMEJAjLkiM"]}, "output": true}, {"input": {"team": ["BoPEQzKrtVPLc", "nEdVwWYvoYF", "nWHgGvQw", "BatfUyLVnKavbpzqTU"]}, "output": false}, {"input": {"team": ["FpYieqbdWlh"]}, "output": true}, {"input": {"team": ["LZNNkjNc", "fbGlx", "jYIqeEQcr", "SghgHWgumKUuMPEOrQeo", "fxEYBfKn", "siX", "xMzaNQo", "hzwxL"]}, "output": false}, {"input": {"team": ["VypJDRlLhhhn", "dTGhffIeVBhWd", "BLyNfWBzAiN"]}, "output": false}, {"input": {"team": ["MIWkneZJPRtIeHM", "xzgFdntxb"]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Vagacoder/Codesignal", "path": "/python/Arcade/Python/P83IsCoolTeam.py", "msgidx": 7502}}
{"problem_description": "Given a range of numbers from 2 to a certain upper limit, we are interested in finding the prime numbers within this range. The task is to divide these prime numbers into two subsets such that the absolute difference between the sums of these two subsets is minimized. What is the minimum absolute difference, and what are the two subsets of prime numbers that achieve this difference?", "io_requirements": "Input:\n  `num` (int): The upper limit for generating prime numbers. The function will generate all prime numbers between 2 and `num`.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `ans` (int): The minimum absolute difference between the sum of two subsets of prime numbers.\n    - `S_A` (list of int): The first subset of prime numbers that achieves the minimum difference.\n    - `S_B` (list of int): The second subset of prime numbers that achieves the minimum difference.", "refcode": "# import necessary packages\nfrom itertools import combinations\n\n# all class and function definitions in the code file, if any\ndef GET_PRIME(num):\n    prime_list = []\n    for i in range(2, num):\n        flag = 0\n        for j in range(2, i//2+1):\n            if i % j == 0:\n                flag = 1\n                break\n        if flag == 0:\n            prime_list.append(i)\n    return prime_list\n\n# main function\ndef main_solution(num):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    S = GET_PRIME(num)\n    sum_S = sum(S)\n    ans = sum_S\n    for i in range(1, len(S)//2+1):\n        for S_sub in combinations(S, i):\n            sum_Sa = sum(S_sub)\n            if ans > abs(sum_S-2*sum_Sa):\n                ans = abs(sum_S-2*sum_Sa)\n                S_A = list(S_sub)\n                S_B = list(set(S) ^ set(S_sub))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"ans\": ans, \"S_A\": S_A, \"S_B\": S_B}", "funcname": "main_solution", "ios": [{"input": {"num": 18}, "output": {"ans": 0, "S_A": [5, 7, 17], "S_B": [2, 3, 11, 13]}}, {"input": {"num": 13}, "output": {"ans": 0, "S_A": [3, 11], "S_B": [2, 5, 7]}}, {"input": {"num": 32}, "output": {"ans": 0, "S_A": [3, 17, 29, 31], "S_B": [2, 5, 7, 11, 13, 19, 23]}}, {"input": {"num": 16}, "output": {"ans": 1, "S_A": [7, 13], "S_B": [2, 3, 5, 11]}}, {"input": {"num": 33}, "output": {"ans": 0, "S_A": [3, 17, 29, 31], "S_B": [2, 5, 7, 11, 13, 19, 23]}}, {"input": {"num": 34}, "output": {"ans": 0, "S_A": [3, 17, 29, 31], "S_B": [2, 5, 7, 11, 13, 19, 23]}}, {"input": {"num": 25}, "output": {"ans": 0, "S_A": [3, 5, 19, 23], "S_B": [2, 7, 11, 13, 17]}}, {"input": {"num": 24}, "output": {"ans": 0, "S_A": [3, 5, 19, 23], "S_B": [2, 7, 11, 13, 17]}}, {"input": {"num": 39}, "output": {"ans": 1, "S_A": [2, 29, 31, 37], "S_B": [3, 5, 7, 11, 13, 17, 19, 23]}}, {"input": {"num": 30}, "output": {"ans": 1, "S_A": [13, 23, 29], "S_B": [2, 3, 5, 7, 11, 17, 19]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "YTsuchimoto/EC21", "path": "/0527/2210104040/problem1.py", "msgidx": 7650}}
{"problem_description": "Given a list of integers, how can we generate all possible permutations of the list?", "io_requirements": "Input:\n  `N` (int): The number of elements in the list to be permuted.\n  `to_be_choice` (list of int): A list of integers that need to be permuted.\n\nOutput:\n  `return` (list of list of int): A list containing all possible permutations of the input list `to_be_choice`. Each permutation is represented as a list of integers.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(N, to_be_choice):\n    # Convert the input list to a sorted list of integers\n    sorted_list = sorted(to_be_choice)\n    \n    # Generate all permutations of the sorted list\n    permutations = list(itertools.permutations(sorted_list))\n    \n    # Convert each permutation tuple to a list\n    result = [list(perm) for perm in permutations]\n    \n    # Return the list of permutations\n    return result", "funcname": "main_solution", "ios": [{"input": {"N": 1, "to_be_choice": [10]}, "output": [[10]]}, {"input": {"N": 1, "to_be_choice": [3]}, "output": [[3]]}, {"input": {"N": 3, "to_be_choice": [8, 9, 5]}, "output": [[5, 8, 9], [5, 9, 8], [8, 5, 9], [8, 9, 5], [9, 5, 8], [9, 8, 5]]}, {"input": {"N": 2, "to_be_choice": [9, 3]}, "output": [[3, 9], [9, 3]]}, {"input": {"N": 2, "to_be_choice": [4, 7]}, "output": [[4, 7], [7, 4]]}, {"input": {"N": 3, "to_be_choice": [3, 5, 4]}, "output": [[3, 4, 5], [3, 5, 4], [4, 3, 5], [4, 5, 3], [5, 3, 4], [5, 4, 3]]}, {"input": {"N": 3, "to_be_choice": [3, 8, 2]}, "output": [[2, 3, 8], [2, 8, 3], [3, 2, 8], [3, 8, 2], [8, 2, 3], [8, 3, 2]]}, {"input": {"N": 3, "to_be_choice": [9, 6, 4]}, "output": [[4, 6, 9], [4, 9, 6], [6, 4, 9], [6, 9, 4], [9, 4, 6], [9, 6, 4]]}, {"input": {"N": 2, "to_be_choice": [5, 10]}, "output": [[5, 10], [10, 5]]}, {"input": {"N": 3, "to_be_choice": [10, 9, 6]}, "output": [[6, 9, 10], [6, 10, 9], [9, 6, 10], [9, 10, 6], [10, 6, 9], [10, 9, 6]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "YCCHIU861116/2020CSIEprog", "path": "/hw7/myanswer_1.py", "msgidx": 7749}}
{"problem_description": "Given a set of 100 cards numbered from 1 to 100, initially all face down, a series of operations are performed where each operation involves flipping every nth card starting from the nth card. After all possible operations are completed, which cards remain face down?", "io_requirements": "Input:\n  `m` (int): The number of cards, ranging from 1 to m.\n\nOutput:\n  `return` (list of int): A list of integers representing the numbers of the cards that are face down after all operations.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(m):\n    # m (int): The number of cards, ranging from 1 to m.\n    \n    # Initialize an empty list to store the numbers of cards that are face down.\n    cards = []\n    \n    # Iterate over each card number from 1 to m.\n    for n in range(1, m + 1):\n        # Check if the number is a perfect square.\n        if math.isqrt(n) ** 2 == n:\n            cards.append(n)\n    \n    # Return the list of card numbers that are face down.\n    return cards", "funcname": "main_solution", "ios": [{"input": {"m": 95}, "output": [1, 4, 9, 16, 25, 36, 49, 64, 81]}, {"input": {"m": 94}, "output": [1, 4, 9, 16, 25, 36, 49, 64, 81]}, {"input": {"m": 38}, "output": [1, 4, 9, 16, 25, 36]}, {"input": {"m": 77}, "output": [1, 4, 9, 16, 25, 36, 49, 64]}, {"input": {"m": 12}, "output": [1, 4, 9]}, {"input": {"m": 46}, "output": [1, 4, 9, 16, 25, 36]}, {"input": {"m": 65}, "output": [1, 4, 9, 16, 25, 36, 49, 64]}, {"input": {"m": 24}, "output": [1, 4, 9, 16]}, {"input": {"m": 40}, "output": [1, 4, 9, 16, 25, 36]}, {"input": {"m": 21}, "output": [1, 4, 9, 16]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "17181370591/-", "path": "/Q03\u7ffb\u724c.py", "msgidx": 7183}}
{"problem_description": "In a game where people stand in a circle and eliminate every second person, starting from the first person, what is the position of the last person standing given the number of people in the circle?", "io_requirements": "Input:\n  `n` (int): The number of people standing in a circle.\n\nOutput:\n  `return` (int): The position of the survivor in the circle.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer\n    n = int(n)\n    \n    # Find the closest power of 2 less than or equal to n\n    p = int(math.log(n, 2))\n    k = int(pow(2, p))\n    \n    # Calculate the survivor\n    s = 2 * (n - k) + 1\n    \n    # Return the survivor\n    return s", "funcname": "main_solution", "ios": [{"input": {"n": 466}, "output": 421}, {"input": {"n": 98}, "output": 69}, {"input": {"n": 719}, "output": 415}, {"input": {"n": 730}, "output": 437}, {"input": {"n": 16}, "output": 1}, {"input": {"n": 449}, "output": 387}, {"input": {"n": 939}, "output": 855}, {"input": {"n": 224}, "output": 193}, {"input": {"n": 788}, "output": 553}, {"input": {"n": 404}, "output": 297}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ChiragSukhala/ShootCrowd", "path": "/ShootCrowd.py", "msgidx": 7491}}
{"problem_description": "Given a string consisting of lowercase alphabetic characters, what are all the possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which the permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of all possible permutations of the input string. Each permutation is represented as a string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef arrangement(s):\n    arr_s = list(s)\n    if len(arr_s) == 0:\n        return [[]]\n    else:\n        result = []\n        for i in arr_s:\n            temp = arr_s[:]\n            temp.remove(i)\n            for j in arrangement(temp):\n                result.append([i] + j)\n    return result\n\n# main function\ndef main_solution(input_string):\n    # Convert the result to a list of strings\n    result = arrangement(input_string)\n    output = [''.join(x) for x in result]\n    return output", "funcname": "main_solution", "ios": [{"input": {"input_string": "fwu"}, "output": ["fwu", "fuw", "wfu", "wuf", "ufw", "uwf"]}, {"input": {"input_string": "sgk"}, "output": ["sgk", "skg", "gsk", "gks", "ksg", "kgs"]}, {"input": {"input_string": "lti"}, "output": ["lti", "lit", "tli", "til", "ilt", "itl"]}, {"input": {"input_string": "cry"}, "output": ["cry", "cyr", "rcy", "ryc", "ycr", "yrc"]}, {"input": {"input_string": "jrc"}, "output": ["jrc", "jcr", "rjc", "rcj", "cjr", "crj"]}, {"input": {"input_string": "csg"}, "output": ["csg", "cgs", "scg", "sgc", "gcs", "gsc"]}, {"input": {"input_string": "xeo"}, "output": ["xeo", "xoe", "exo", "eox", "oxe", "oex"]}, {"input": {"input_string": "qac"}, "output": ["qac", "qca", "aqc", "acq", "cqa", "caq"]}, {"input": {"input_string": "amq"}, "output": ["amq", "aqm", "maq", "mqa", "qam", "qma"]}, {"input": {"input_string": "gcx"}, "output": ["gcx", "gxc", "cgx", "cxg", "xgc", "xcg"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rockdam/deep-learning-", "path": "/exam/fully_arrangement.py", "msgidx": 7692}}
{"problem_description": "Five people, A, B, C, D, and E, went fishing one night and caught a certain number of fish. After a tiring night, they all went to sleep. The next morning, A woke up first and divided the fish into five equal parts, discarding one extra fish and taking his share. B woke up next and did the same, followed by C, D, and E. Each person found that the remaining fish could be divided into five equal parts after discarding one extra fish. What is the minimum number of fish they could have caught?", "io_requirements": "Input:\n  No input arguments are required.\n\nOutput:\n  `return` (int): The minimum number of fish caught by A, B, C, D, and E, which satisfies the condition that each person can divide the remaining fish into five parts, discard one, and take their share.", "refcode": "# main function\ndef main_solution():\n    # Function to determine the minimum number of fish caught\n    def how_many_fishes():\n        fish = 1\n        while True:\n            total = fish\n            is_enough = True\n            for i in range(5):\n                if (total - 1) % 5 == 0:\n                    total = (total - 1) // 5 * 4\n                else:\n                    is_enough = False\n                    break\n            if is_enough:\n                return fish\n            else:\n                fish += 1\n    \n    # Call the function and return the result\n    return how_many_fishes()", "funcname": "main_solution", "ios": [{"input": {}, "output": 3121}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "amath0312/py100", "path": "/day16/algo_enum.py", "msgidx": 7536}}
{"problem_description": "Given a number of digits `n`, where `n` ranges from 1 to 9, what is the largest prime number that can be formed using all the digits from 1 to `n` exactly once?", "io_requirements": "Input:\n  `n` (int): The number of digits for the pandigital number (1 <= n <= 9)\n\nOutput:\n  `return` (int): The largest n-digit pandigital prime number, or -1 if no such prime exists.", "refcode": "# import necessary packages\nimport math\nfrom itertools import permutations\n\n# Function to check if a number is prime\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n# Function to generate all pandigital numbers of length n\ndef generate_pandigitals(n):\n    digits = ''.join(str(i) for i in range(1, n + 1))\n    pandigitals = [int(''.join(p)) for p in permutations(digits)]\n    return pandigitals\n\n# main function\ndef main_solution(n):\n    # n (int): The number of digits for the pandigital number (1 <= n <= 9)\n    pandigitals = generate_pandigitals(n)\n    largest_prime = -1\n    for num in pandigitals:\n        if is_prime(num):\n            largest_prime = max(largest_prime, num)\n    return largest_prime", "funcname": "main_solution", "ios": [{"input": {"n": 8}, "output": -1}, {"input": {"n": 1}, "output": -1}, {"input": {"n": 3}, "output": -1}, {"input": {"n": 4}, "output": 4231}, {"input": {"n": 7}, "output": 7652413}, {"input": {"n": 6}, "output": -1}, {"input": {"n": 2}, "output": -1}, {"input": {"n": 9}, "output": -1}, {"input": {"n": 5}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "CT-Clark/Project-Euler", "path": "/Project-Euler/Q41-Pandigital-Prime/Q41.py", "msgidx": 7579}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\nfrom typing import List\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def resolve(self, n: int) -> List[str]:\n        def parentheses(cur: str) -> None:\n            left = cur.count(\"(\")\n            right = cur.count(\")\")\n            if left + right == 2*n and left == right:\n                result.append(cur)\n                return None\n            if (left > n) or (right > n) or (right > left):\n                return None\n            parentheses(cur+\"(\")\n            parentheses(cur+\")\")\n        result = []\n        parentheses(\"(\")\n        return result\n\n# main function\ndef main_solution(n: int) -> List[str]:\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.resolve(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hwwwi/codingtest", "path": "/leetcode/Generate_Parentheses/main.py", "msgidx": 7599}}
{"problem_description": "Given a range of products, what is the sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital, considering the maximum product value as `max_product`?", "io_requirements": "Input:\n  `max_product` (int): The maximum product value to consider for finding pandigital products.\n\nOutput:\n  `return` (int): The sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_pandigital(arr):\n    string_num = ''.join(str(char) for char in arr)\n    string_num = ''.join(sorted([char for char in string_num]))\n    return string_num == '123456789'\n\ndef find_multiplicands(product, stack):\n    for n in range(1, int(math.sqrt(product)) + 1):\n        if product % n == 0 and is_pandigital([n, (product // n), product]):\n            stack.append([n, (product // n), product])\n\n# main function\ndef main_solution(max_product):\n    pans = []\n    for i in range(1, max_product + 1):\n        find_multiplicands(i, pans)\n    unique_products = set([arr[-1] for arr in pans])\n    return sum(unique_products)", "funcname": "main_solution", "ios": [{"input": {"max_product": 9993}, "output": 45228}, {"input": {"max_product": 5295}, "output": 4396}, {"input": {"max_product": 5176}, "output": 4396}, {"input": {"max_product": 7275}, "output": 29744}, {"input": {"max_product": 1527}, "output": 0}, {"input": {"max_product": 8263}, "output": 45228}, {"input": {"max_product": 3172}, "output": 0}, {"input": {"max_product": 6485}, "output": 15538}, {"input": {"max_product": 8056}, "output": 45228}, {"input": {"max_product": 9823}, "output": 45228}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zacharytwhite/project-euler-solutions", "path": "/project_euler_py/problem_032.py", "msgidx": 7712}}
{"problem_description": "Given a set of integer sequences, each containing unique integers ranging from 1 to 100, what are the consecutive distance ratings for each sequence? The consecutive distance rating is defined as the sum of the distances between consecutive integers in the sequence.", "io_requirements": "Input:\n  `sequences` (list of strings): A list where each element is a string representing a sequence of integers separated by spaces.\n\nOutput:\n  `return` (list of integers): A list where each element is the consecutive distance rating for the corresponding sequence in the input list.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(sequences):\n    results = []\n    for nums in sequences:\n        nums = re.findall('\\d+', nums)\n        num_list = [int(item) for item in nums]\n\n        # index each number then reverse for reference.\n        enum = list(enumerate(num_list))\n        lst = []\n        for tup in enum:\n            # reverse the tuple\n            tup = tup[::-1]\n            lst.append(tup)\n\n        lst = sorted(lst)\n        n = 0\n        for x in range(0, len(lst) - 1):\n            if lst[x + 1][0] == lst[x][0] + 1:\n                m = lst[x + 1][1] - lst[x][1]\n                n += abs(m)\n\n        results.append(n)\n\n    return results", "funcname": "main_solution", "ios": [{"input": {"sequences": ["74 26 28 72 80 16 6 27 31 81 36 66 84 76 67 39"]}, "output": [19]}, {"input": {"sequences": ["29 7 57 7 95 51 12 76 71 21 40 87 100 17 32 41 83 66 72"]}, "output": [15]}, {"input": {"sequences": ["44 77 35 96 21 6 68 54 20 1", "67 69 51 4 62 24 52 10 4 99", "73 53 28 96 45 81 80 82 60 79", "74 15 19 39 77 18 26 53 85 61", "38 94 18 23 23 22 89 28 37 77", "58 58 60 43 92 7 68 38 18 39", "39 96 54 42 53 6 49 10 38 32", "22 29 56 96 54 41 58 63 33 23"]}, "output": [4, 4, 6, 3, 10, 2, 10, 9]}, {"input": {"sequences": ["79 68 96 49 22 94 90 30 81 27 2 45 95 14 92 10 14", "77 88 87 24 64 60 61 56 40 36 68 9 27 26 18 8 93", "76 46 26 32 27 44 66 77 29 77 15 25 39 57 60 74 21"]}, "output": [17, 7, 18]}, {"input": {"sequences": ["18 54 91 34 43 59 26 38 27 52 1 73 6", "85 14 100 77 64 14 2 91 34 36 89 69 68", "88 80 85 31 34 38 32 91 28 42 83 58 95", "45 33 81 72 48 93 61 90 3 62 62 21 24"]}, "output": [2, 1, 3, 3]}, {"input": {"sequences": ["32 10 64 69 41 87 5 46 18 20 21 48 47 41 10 69 6"]}, "output": [17]}, {"input": {"sequences": ["30 16 7 74 97 29 59 53 52 54 79 46 84"]}, "output": [8]}, {"input": {"sequences": ["43 91 84 75 16 35 13 85 35 8 74 44 8 33 18"]}, "output": [23]}, {"input": {"sequences": ["3 89 45 86 99 27 55 19 56 16 20 96 45 3 17 32 4", "47 100 92 75 66 16 48 74 60 64 57 73 86 75 5 93 82", "84 99 18 71 58 3 49 100 29 35 12 43 19 54 86 44 84", "19 30 16 85 70 66 95 81 19 56 29 3 78 17 73 32 82"]}, "output": [13, 27, 20, 29]}, {"input": {"sequences": ["98 73 23 16 75 12 97 2 57 66 28 57 81 92 49 11 20 93", "3 77 31 54 10 88 79 51 92 24 12 10 16 34 55 26 7 87", "2 29 84 47 32 54 37 84 50 87 80 5 43 17 73 35 6 22", "22 9 47 17 89 26 36 66 65 95 60 46 82 73 82 54 58 25", "42 26 92 46 74 52 87 13 97 98 67 67 56 92 36 9 28 64", "27 60 1 65 64 89 22 21 97 60 61 12 48 38 19 14 81 44"]}, "output": [20, 23, 5, 22, 1, 3]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Rich43/rog", "path": "/albums/3/challenge335_easy/code.py", "msgidx": 7852}}
{"problem_description": "\u0418\u043d\u043d\u043e\u043a\u0435\u043d\u0442\u0438\u0439 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u043c\u0438\u0431\u0443\u043a\u0432\u0435\u043d\u043d\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 \u0438\u0437 \u0431\u0443\u043a\u0432 \u0415, \u0418, \u0419, \u041a, \u041d, \u041e, \u0422. \u0421\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u043b\u043e\u0432 \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0418\u043d\u043d\u043e\u043a\u0435\u043d\u0442\u0438\u0439, \u0435\u0441\u043b\u0438 \u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e, \u0447\u0442\u043e \u0432 \u043a\u0430\u0436\u0434\u043e\u043c \u0438\u0437 \u043d\u0438\u0445 \u0435\u0441\u0442\u044c \u043a\u043e\u043c\u0431\u0438\u043d\u0430\u0446\u0438\u044f \u041a\u041e\u0422?", "io_requirements": "Input:\n  `letters` (str): A string containing the set of letters from which words are formed.\n  `word_length` (int): The length of the words to be formed.\n  `target_sequence` (str): The target sequence that must be present in the words.\n\nOutput:\n  `return` (int): The number of words that contain the target sequence.", "refcode": "# import necessary packages\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef isKot(s):\n    flag = False\n    for k in range(len(s)-2):\n        if s[k] == '\u041a' and s[k + 1] == '\u041e' and s[k + 2] == '\u0422':\n            flag = True\n    return flag\n\n# main function\ndef main_solution(letters, word_length, target_sequence):\n    counter = 0\n    for i in product(letters, repeat=word_length):\n        if isKot(''.join(i)):\n            counter += 1\n    return counter", "funcname": "main_solution", "ios": [{"input": {"letters": "\u0415\u0418\u0419\u041a\u041d\u041e\u0422", "word_length": 7, "target_sequence": "\u041a\u041e\u0422"}, "output": 11984}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "htmlprogrammist/kege-2021", "path": "/tasks_8/task_8_3.py", "msgidx": 8260}}
{"problem_description": "Given a chessboard of size `n x n`, how many distinct ways can you place `n` queens on the board such that no two queens can attack each other?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be an integer between 1 and 9 inclusive.\n\nOutput:\n  `return` (int): The number of distinct solutions to the n-queens puzzle for the given `n`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        board = [-1] * n\n        res = 0\n\n        def helper(board, row):\n            if row == len(board):\n                nonlocal res\n                res += 1\n                return\n            for col in range(n):\n                board[row] = col\n                if self.is_valid(board, row, col):\n                    helper(board, row + 1)\n                board[row] = -1\n\n        helper(board, 0)\n        return res\n\n    def is_valid(self, board, row, col):\n        for pre_row in range(row):\n            if board[pre_row] == -1 or board[pre_row] == col or abs(pre_row - row) == abs(board[pre_row] - col):\n                return False\n        return True\n\n# main function\ndef main_solution(n: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.totalNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 5}, "output": 10}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 8}, "output": 92}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tainenko/Leetcode2019", "path": "/leetcode/editor/en/[52]N-Queens II.py", "msgidx": 7392}}
{"problem_description": "Given a sequence of integers that may contain duplicates, what are all the unique permutations of this sequence?", "io_requirements": "Input:\n  `nums` (list of integers): A list of integers that may contain duplicates.\n\nOutput:\n  `return` (list of lists of integers): A list of all unique permutations of the input list `nums`. Each permutation is represented as a list of integers.", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# main function\ndef main_solution(nums):\n    # Convert the input list to a JSON serializable format\n    nums = list(nums)\n    \n    # Helper function to generate permutations\n    def helper(res, tmplist, counter, nums, length):\n        if len(tmplist) == length:  # \u56de\u6eaf\u70b9\n            res.append(tmplist[:])\n        else:\n            for i in nums:  # \u6a2a\u5411\u904d\u5386\n                if counter[i] == 0:  # \u5206\u652f\u9650\u754c\n                    continue\n\n                counter[i] -= 1\n                tmplist.append(i)\n                helper(res, tmplist, counter, nums, length)  # \u7eb5\u5411\u904d\u5386\n                counter[i] += 1\n                tmplist.pop()\n\n    # Initialize variables\n    res, tmplist, counter = [], [], Counter(nums)\n    length = len(nums)\n    \n    # Generate permutations\n    helper(res, tmplist, counter, list(set(nums)), length)\n    \n    # Convert the result to a JSON serializable format\n    return res", "funcname": "main_solution", "ios": [{"input": {"nums": [3, 3, 2]}, "output": [[2, 3, 3], [3, 2, 3], [3, 3, 2]]}, {"input": {"nums": [3, 3, 1]}, "output": [[1, 3, 3], [3, 1, 3], [3, 3, 1]]}, {"input": {"nums": [3, 1, 1]}, "output": [[1, 1, 3], [1, 3, 1], [3, 1, 1]]}, {"input": {"nums": [3, 1, 2]}, "output": [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]}, {"input": {"nums": [2, 1, 3]}, "output": [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]}, {"input": {"nums": [1, 2, 1]}, "output": [[1, 1, 2], [1, 2, 1], [2, 1, 1]]}, {"input": {"nums": [2, 3, 3]}, "output": [[2, 3, 3], [3, 2, 3], [3, 3, 2]]}, {"input": {"nums": [1, 3, 2]}, "output": [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]}, {"input": {"nums": [1, 2, 2]}, "output": [[1, 2, 2], [2, 1, 2], [2, 2, 1]]}, {"input": {"nums": [1, 3, 3]}, "output": [[1, 3, 3], [3, 1, 3], [3, 3, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ny1103/USTC", "path": "/leetcode-plugin/cn/[47]\u5168\u6392\u5217 II.py", "msgidx": 8171}}
{"problem_description": "Given a string that consists of a repeated pattern of characters, where one character has been replaced by an underscore, what is the missing character that should replace the underscore to complete the pattern?", "io_requirements": "Input:\n  `pattern_string` (str): A string containing a repeated pattern of characters with one character replaced by an underscore (`_`). The string may end in the middle of a repetition of the pattern.\n\nOutput:\n  `return` (str): The missing character that was replaced by the underscore in the `pattern_string`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef complete_pattern(s):\n    index = s.find(\"_\")\n    for item in set(s) - {'_'}:\n        complete_string = s.replace(\"_\", item)\n        for k in range(1, len(s)//2+1):\n            if all(complete_string[i:i+k] == complete_string[0:k] for i in range(0, len(s), k) if i + k <= len(s)):\n                if k-1 >= index:\n                    return item\n                else:\n                    return s[index % k]\n\n# main function\ndef main_solution(pattern_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    missing_character = complete_pattern(pattern_string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return missing_character", "funcname": "main_solution", "ios": [{"input": {"pattern_string": "DTZQNYEJAADTZ_NYEJAA"}, "output": "Q"}, {"input": {"pattern_string": "BKGCUKB_GCUKBKGCUK"}, "output": "K"}, {"input": {"pattern_string": "BLZBGQSIQSBLZBGQSIQSBLZBGQS_QSBLZBGQSIQS"}, "output": "I"}, {"input": {"pattern_string": "JEPU_JEPUO"}, "output": "O"}, {"input": {"pattern_string": "VOMMALW_OMMALWVOMMALW"}, "output": "V"}, {"input": {"pattern_string": "LWUGGFGCNLWUGGFGCNLWUGGFGCNL_UGGFGCN"}, "output": "W"}, {"input": {"pattern_string": "TPFEFM_QTPFEFMTQTPFEFMTQTPFEFMTQ"}, "output": "T"}, {"input": {"pattern_string": "XVBBWXVB_WXVBBW"}, "output": "B"}, {"input": {"pattern_string": "RDIILARRDIILARRDIILA_"}, "output": "R"}, {"input": {"pattern_string": "KFYOPNPFEKFYOPNPFEKFY_PNPFE"}, "output": "O"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/Rep3fHbrLGKDatZ2L_10.py", "msgidx": 7441}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses that can be generated?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings, where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(n: int) -> List[str]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Initialize the Solution class and call the generateParenthesis method\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        track = []\n        ans = []\n\n        def backtrack(left, right):\n            if len(track) == 2 * n:\n                ans.append(\"\".join(track))\n            else:\n                if left < n:\n                    track.append('(')\n                    backtrack(left + 1, right)\n                    track.pop()\n                if right < left:\n                    track.append(')')\n                    backtrack(left, right + 1)\n                    track.pop()\n\n        backtrack(0, 0)\n        return ans", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JasmineRain/Algorithm", "path": "/Python/Back Track/22_Medium_\u62ec\u53f7\u751f\u6210.py", "msgidx": 7199}}
{"problem_description": "Given a list of integers, we want to determine all possible subsets of this list. There are two methods to achieve this: one using inductive logic and the other using combinatorial logic. How can we generate the powerset of a list using both methods and what are the resulting subsets for a given number of items?", "io_requirements": "Input:\n  `num_items` (int): The number of items in the list for which the powerset is to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `\"powerset_add\"` (list of lists): The powerset calculated using the inductive method.\n    - `\"powerset_comb\"` (list of lists): The powerset calculated using the combinatorial method.", "refcode": "# import necessary packages\nimport time\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef powerset_add(l):\n    pset = [[]]\n    for item in l:\n        new_subset = deepcopy(pset)\n        for subset in new_subset:\n            subset.append(item)\n        pset.extend(new_subset)\n    return pset\n\ndef get_bin_str(n, up_to):\n    code = bin(n).split('b')[-1]\n    if len(code) > up_to:\n        raise ValueError('not enough')\n    code = '0' * (up_to - len(code)) + code\n    return code\n\ndef powerset_comb(l):\n    pset = []\n    total_items = len(l)\n    for i in range(2 ** total_items):\n        is_in = get_bin_str(i, total_items)\n        subset = []\n        for j in range(total_items):\n            if is_in[j] == '1':\n                subset.append(l[j])\n        pset.append(subset)\n    return pset\n\n# main function\ndef main_solution(num_items):\n    # Convert input to a list of integers\n    my_list = list(range(num_items))\n    \n    # Calculate the powerset using both methods\n    pset_add = powerset_add(my_list)\n    pset_comb = powerset_comb(my_list)\n    \n    # Return the results as a dictionary\n    return {\n        \"powerset_add\": pset_add,\n        \"powerset_comb\": pset_comb\n    }", "funcname": "main_solution", "ios": [{"input": {"num_items": 1}, "output": {"powerset_add": [[], [0]], "powerset_comb": [[], [0]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zzhang-cn/ICS-NYUSH", "path": "/lectures/Week5/powerset.py", "msgidx": 7582}}
{"problem_description": "Given a number `k`, what are the first `k` prime numbers and the first `k` round numbers?", "io_requirements": "Input:\n  `k` (int): The number of prime and round numbers to generate.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `prime_numbers` (list of int): A list of the first `k` prime numbers.\n    - `round_numbers` (list of int): A list of the first `k` round numbers.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef createList():\n    i = 1\n    while True:\n        i = i + 2\n        yield i\n\ndef primeFilter(num):\n    return lambda x: x % num != 0\n\ndef primeFunc():\n    yield 2\n    primeList = createList()\n    while True:\n        prime = next(primeList)\n        yield prime\n        primeList = filter(primeFilter(prime), primeList)\n\ndef roundNum(num):\n    strNum = str(num)\n    k = len(strNum)\n    for i in range(k // 2):\n        if strNum[i] != strNum[k - 1 - i]:\n            return False\n    return True\n\ndef createRoundList():\n    i = 10\n    while True:\n        i += 1\n        yield i\n\ndef judgeRound():\n    numList = createRoundList()\n    while True:\n        num = next(numList)\n        if roundNum(num):\n            yield num\n\n# main function\ndef main_solution(k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    prime_generator = primeFunc()\n    round_generator = judgeRound()\n    \n    prime_numbers = [next(prime_generator) for _ in range(k)]\n    round_numbers = [next(round_generator) for _ in range(k)]\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"prime_numbers\": prime_numbers, \"round_numbers\": round_numbers}", "funcname": "main_solution", "ios": [{"input": {"k": 2}, "output": {"prime_numbers": [2, 3], "round_numbers": [11, 22]}}, {"input": {"k": 7}, "output": {"prime_numbers": [2, 3, 5, 7, 11, 13, 17], "round_numbers": [11, 22, 33, 44, 55, 66, 77]}}, {"input": {"k": 4}, "output": {"prime_numbers": [2, 3, 5, 7], "round_numbers": [11, 22, 33, 44]}}, {"input": {"k": 1}, "output": {"prime_numbers": [2], "round_numbers": [11]}}, {"input": {"k": 6}, "output": {"prime_numbers": [2, 3, 5, 7, 11, 13], "round_numbers": [11, 22, 33, 44, 55, 66]}}, {"input": {"k": 5}, "output": {"prime_numbers": [2, 3, 5, 7, 11], "round_numbers": [11, 22, 33, 44, 55]}}, {"input": {"k": 3}, "output": {"prime_numbers": [2, 3, 5], "round_numbers": [11, 22, 33]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AlexWanlol/python-basis", "path": "/ep3/ep3_3_filter.py", "msgidx": 7257}}
{"problem_description": "Given a binary tree represented by a list where each element in the list corresponds to a node value, and `None` indicates a missing node, determine whether the binary tree is balanced. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. What is the result of checking if the given binary tree is balanced?", "io_requirements": "Input:\n  `tree_structure` (list of integers or None): A list representing the structure of the binary tree. Each element in the list represents a node value, with `None` indicating a missing node. The list is constructed in a breadth-first manner, starting from the root.\n\nOutput:\n  `return` (boolean): A boolean value indicating whether the binary tree is balanced. `True` if the tree is balanced, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x=None):\n        self.x = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def depth(self, node):\n        if node is None:\n            return 0\n        else:\n            return max(self.depth(node.left), self.depth(node.right)) + 1\n    \n    def is_balanced(self, node):\n        if not node:\n            return True\n        else:\n            l_depth = self.depth(node.left)\n            r_depth = self.depth(node.right)\n            if abs(l_depth - r_depth) > 1:\n                return False\n            else:\n                return self.is_balanced(node.left) and self.is_balanced(node.right)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        root = TreeNode(data[0])\n        queue = [root]\n        index = 1\n        while queue:\n            node = queue.pop(0)\n            if index < len(data):\n                if data[index] is not None:\n                    node.left = TreeNode(data[index])\n                    queue.append(node.left)\n                index += 1\n                if index < len(data):\n                    if data[index] is not None:\n                        node.right = TreeNode(data[index])\n                        queue.append(node.right)\n                    index += 1\n        return root\n    \n    tree_root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.is_balanced(tree_root)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [31, 11, 86, 54, 12, 27, null]}, "output": true}, {"input": {"tree_structure": [26]}, "output": true}, {"input": {"tree_structure": [95, 7, 52]}, "output": true}, {"input": {"tree_structure": [96, 36, 95, 96, null, null, null]}, "output": true}, {"input": {"tree_structure": [null, null, 64]}, "output": true}, {"input": {"tree_structure": [null]}, "output": true}, {"input": {"tree_structure": [2, 71, 9, 74, 17, 84, 84, 62, 17, null, null, 97, null, 16, 4]}, "output": true}, {"input": {"tree_structure": [85, 80, 72, 92, 54, 67, 42, 57, 16, 88, null, 22, null, 23, null]}, "output": true}, {"input": {"tree_structure": [37]}, "output": true}, {"input": {"tree_structure": [89, 7, 78, 37, 98, 60, 86, 32, null, 23, 31, 81, 42, 88, null]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "johnnylecy/Target-Offer-python", "path": "/\u5e73\u8861\u4e8c\u53c9\u6811.py", "msgidx": 8051}}
{"problem_description": "Given a grid of size \\( N \\times N \\) where \\( N \\) is a power of 3, you are tasked with filling the grid with stars according to a specific pattern. The pattern is such that a smaller version of the pattern is repeated in different parts of the grid, creating a fractal-like structure. What is the resulting grid after applying this pattern?", "io_requirements": "Input:\n  `N` (int): The size of the grid. It should be a power of 3, such as 3, 9, 27, etc.\n\nOutput:\n  `return` (str): A JSON-serialized string representing the 2D list (grid) where each cell is either a space (' ') or a star ('*').", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef star(n, x, y, maps):\n    if n // 3 == 1:\n        for i in range(x, x + n):\n            for j in range(y, y + n):\n                if i == x + 1 and j == y + 1:\n                    continue\n                maps[i][j] = '*'\n        return\n\n    nxtN = n // 3\n    star(nxtN, x, y, maps)\n    star(nxtN, x, y + nxtN, maps)\n    star(nxtN, x, y + (nxtN * 2), maps)\n    star(nxtN, x + nxtN, y, maps)\n    star(nxtN, x + nxtN, y + (nxtN * 2), maps)\n    star(nxtN, x + (nxtN * 2), y, maps)\n    star(nxtN, x + (nxtN * 2), y + nxtN, maps)\n    star(nxtN, x + (nxtN * 2), y + (nxtN * 2), maps)\n\n# main function\ndef main_solution(N):\n    # Convert input to the required format\n    N = int(N)\n    maps = [[' ' for _ in range(N)] for _ in range(N)]\n    \n    # Call the star function\n    star(N, 0, 0, maps)\n    \n    # Convert the result to a JSON serializable format\n    result = json.dumps(maps)\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"N": 3}, "output": "[[\"*\", \"*\", \"*\"], [\"*\", \" \", \"*\"], [\"*\", \"*\", \"*\"]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "y2sec/Algorithm", "path": "/Baekjoon/2447_Problem.py", "msgidx": 7468}}
{"problem_description": "In a week, five people\u2014Wilkes, Hamming, Minsky, Knuth, and Simon\u2014arrive on different days. Each person has a specific role: programmer, writer, manager, designer, and buyer of different items (laptop, droid, tablet, iphone). Given the following clues:\n\n1. The person who arrived on Wednesday bought the laptop.\n2. The programmer is not Wilkes.\n3. Of the programmer and the person who bought the droid, one is Wilkes and the other is Hamming.\n4. The writer is not Minsky.\n5. Neither Knuth nor the person who bought the tablet is the manager.\n6. Knuth arrived the day after Simon.\n7. The person who arrived on Thursday is not the designer.\n8. The person who arrived on Friday didn't buy the tablet.\n9. The designer didn't buy the droid.\n10. Knuth arrived the day after the manager.\n11. Of the person who bought the laptop and Wilkes, one arrived on Monday and the other is the writer.\n12. Either the person who bought the iphone or the person who bought the tablet arrived on Tuesday.\n\nWhat is the order of their arrivals if the days of the week are given in a specific order?", "io_requirements": "Input:\n  `days_order` (list of str): A list of days in the order they appear in the week, e.g., ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].\n\nOutput:\n  `return` (list of str): A list of names in the order they arrive.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(days_order):\n    \"\"\"\n    Solves the logic puzzle based on the given order of days.\n    \n    Args:\n    days_order (list of str): A list of days in the order they appear in the week, e.g., ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].\n    \n    Returns:\n    list of str: A list of names in the order they arrive.\n    \"\"\"\n    days = {day: idx + 1 for idx, day in enumerate(days_order)}\n    possible_days = list(itertools.permutations(days.values()))\n    \n    for (Wilkes, Hamming, Minsky, Knuth, Simon) in possible_days:\n        if Knuth == Simon + 1:  # 6\n            for (programmer, writer, manager, designer, _) in possible_days:\n                if Knuth == manager + 1 and days['Thursday'] != designer and programmer != Wilkes and writer != Minsky:  # 10, 7, 2, 4\n                    for (laptop, droid, tablet, iphone, _) in possible_days:\n                        if set([laptop, Wilkes]) == set([days['Monday'], writer]) and set([programmer, droid]) == set([Wilkes, Hamming]) and (iphone == days['Tuesday'] or tablet == days['Tuesday']) and designer != droid and Knuth != manager and tablet != manager and days['Wednesday'] == laptop and days['Friday'] != tablet:  # 11, 3, 12, 9, 5, 1, 8\n                            return answer(Wilkes=Wilkes, Hamming=Hamming, Minsky=Minsky, Knuth=Knuth, Simon=Simon)\n\ndef answer(**names):\n    \"Given a dict of {name:day}, return a list of names sorted by day.\"\n    return sorted(names, key=lambda name: names[name])", "funcname": "main_solution", "ios": [{"input": {"days_order": ["Thursday", "Tuesday", "Monday", "Friday", "Wednesday"]}, "output": ["Hamming", "Minsky", "Wilkes", "Simon", "Knuth"]}, {"input": {"days_order": ["Friday", "Monday", "Thursday", "Tuesday", "Wednesday"]}, "output": ["Minsky", "Wilkes", "Hamming", "Simon", "Knuth"]}, {"input": {"days_order": ["Tuesday", "Wednesday", "Thursday", "Friday", "Monday"]}, "output": ["Simon", "Knuth", "Hamming", "Minsky", "Wilkes"]}, {"input": {"days_order": ["Monday", "Friday", "Wednesday", "Tuesday", "Thursday"]}, "output": ["Wilkes", "Simon", "Knuth", "Minsky", "Hamming"]}, {"input": {"days_order": ["Monday", "Thursday", "Friday", "Tuesday", "Wednesday"]}, "output": ["Wilkes", "Hamming", "Minsky", "Simon", "Knuth"]}, {"input": {"days_order": ["Thursday", "Wednesday", "Tuesday", "Friday", "Monday"]}, "output": ["Simon", "Knuth", "Hamming", "Minsky", "Wilkes"]}, {"input": {"days_order": ["Thursday", "Wednesday", "Monday", "Friday", "Tuesday"]}, "output": ["Simon", "Knuth", "Wilkes", "Hamming", "Minsky"]}, {"input": {"days_order": ["Monday", "Friday", "Thursday", "Wednesday", "Tuesday"]}, "output": ["Wilkes", "Hamming", "Simon", "Knuth", "Minsky"]}, {"input": {"days_order": ["Thursday", "Friday", "Monday", "Tuesday", "Wednesday"]}, "output": ["Hamming", "Minsky", "Wilkes", "Simon", "Knuth"]}, {"input": {"days_order": ["Tuesday", "Thursday", "Wednesday", "Monday", "Friday"]}, "output": ["Hamming", "Simon", "Knuth", "Wilkes", "Minsky"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Yueleng/design_of_computer_programs", "path": "/lesson7/2logic_puzzle.py", "msgidx": 7635}}
{"problem_description": "In a certain bag-packing system, each bag can contain multiple other bags, each with a specific count. Given a set of rules that describe the contents of each bag type, how many bags can eventually contain a specific type of bag, and how many bags are required inside that specific bag?", "io_requirements": "Input:\n  `rules_json` (str): A JSON string representing a nested dictionary structure where each key is a bag type and the value is another dictionary containing the bags it can contain, with their respective counts.\n  `search_bag` (str): A string representing the bag type to search for in the rules.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `part1_answer` (int): The number of bags that can eventually contain the `search_bag`.\n    - `part2_answer` (int): The total number of bags required inside the `search_bag`.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef parse_description(description):\n    # parse description of input file\n    if description == \"no other bags\":\n        return {}\n    else:\n        return {r[2:]: int(r[0]) for r in\n                [de.replace('bags', '').replace('bag', '').strip()\n                for de in description.split(',')]}\n\ndef find_bag(rules, curr_bag, search_bag):\n    # recursively search for a given bag\n    if len(rules[curr_bag].keys()) == 0:\n        return False\n    else:\n        bag_found = False\n        bag_found = search_bag in rules[curr_bag].keys()\n        if not bag_found:\n            for bag in rules[curr_bag].keys():\n                bag_found = bag_found or find_bag(rules, bag, search_bag)\n\n        return bag_found\n\ndef search_all_bags(rules, search_bag):\n    # search for a given bag in all paths\n    all_bags = []\n    for r in rules.keys():\n        all_bags.append(find_bag(rules, r, search_bag))\n    return sum(all_bags)\n\ndef calc_bag(rules, curr_bag):\n    # recursively call calc_bag to find number of bags\n    if len(curr_bag.keys()) == 0:\n        return 0\n    else:\n        counter = 0\n        for bag in curr_bag.keys():\n            add_val = curr_bag[bag]\n            counter += add_val + add_val * calc_bag(rules, rules[bag])\n        return counter\n\n# main function\ndef main_solution(rules_json, search_bag):\n    # Convert JSON string to dictionary\n    rules = json.loads(rules_json)\n    \n    # Part 1: Search for the given bag in all paths\n    part1_answer = search_all_bags(rules, search_bag)\n    \n    # Part 2: Calculate the number of bags inside the given bag\n    part2_answer = calc_bag(rules, rules[search_bag])\n    \n    # Return the results as a dictionary\n    return {\"part1_answer\": part1_answer, \"part2_answer\": part2_answer}", "funcname": "main_solution", "ios": [{"input": {"rules_json": "{\"shiny gold\": {}, \"dark olive\": {}, \"vibrant plum\": {}, \"faded blue\": {}, \"dotted black\": {}}", "search_bag": "dotted black"}, "output": {"part1_answer": 0, "part2_answer": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "murphm54/aoc2020", "path": "/day7/solutions.py", "msgidx": 7400}}
{"problem_description": "In an experimental memory system, data is stored in an infinite two-dimensional grid in a spiral pattern starting from square 1. Each square is allocated a value based on the sum of the values in all adjacent squares, including diagonals. Given a square identifier in this spiral memory grid, what is the first value written that is larger than the given square identifier?", "io_requirements": "Input:\n  `puzzle_input` (int): The puzzle input, which is an integer representing the square identifier in the spiral memory grid.\n\nOutput:\n  `return` (int): The first value written in the spiral memory grid that is larger than the `puzzle_input`.", "refcode": "# import necessary packages\nimport math\nimport operator\n\n# all class and function definitions in the code file, if any\ndef manhattan_distance(x, y):\n    return sum(abs(a-b) for a, b in zip(x, y))\n\ndef closest_perfect_sqr(n):\n    odd = False\n    while not odd:\n        if n % n**0.5 == 0:\n            power = math.pow((math.sqrt(n)), 2)\n            odd = power % 2 == 1\n        n += 1\n    return power\n\ndef add_tuple(a, b):\n    return tuple(map(operator.add, a, b))\n\nN, SOUTH, W, E = (0, -1), (0, 1), (-1, 0), (1, 0) # directions\nturn_left = {SOUTH: E, E: N, N: W, W: SOUTH} # old -> new direction\nALL_DIRS = [N, SOUTH, W, E, add_tuple(N, E), add_tuple(N, W),\n            add_tuple(SOUTH, E), add_tuple(SOUTH, W)]\n\ndef sum_neighbors(matrix, loc):\n    length = len(matrix[0])\n    neighbors = [add_tuple(loc, direction) for direction in ALL_DIRS]\n    neighbors = [(x, y) for x, y in neighbors if (x < length and\n                                                  y < length and\n                                                  x >= 0 and y >= 0)]\n    out = [matrix[y][x] if matrix[y][x] is not None else 0\n           for x, y in neighbors]\n    return max(sum(out), 1)\n\ndef spiral2(width, height, goal):\n    if width < 1 or height < 1:\n        raise ValueError\n    x, y = width // 2, height // 2 # start near the center\n    dx, dy = SOUTH # initial direction\n    matrix = [[None] * width for _ in range(height)]\n    count = 0\n    while True:\n        count = sum_neighbors(matrix, (x, y))\n        if goal < count:\n            return count\n        matrix[y][x] = count # visit\n        # try to turn right\n        new_dx, new_dy = turn_left[dx,dy]\n        new_x, new_y = x + new_dx, y + new_dy\n        if (0 <= new_x < width and 0 <= new_y < height and\n            matrix[new_y][new_x] is None): # can turn right\n            x, y = new_x, new_y\n            dx, dy = new_dx, new_dy\n        else: # try to move straight\n            x, y = x + dx, y + dy\n            if not (0 <= x < width and 0 <= y < height):\n                return matrix # nowhere to go\n\n# main function\ndef main_solution(puzzle_input):\n    # Convert the input to an integer\n    goal = int(puzzle_input)\n    \n    # Find the closest perfect square\n    power = closest_perfect_sqr(goal)\n    side = int(math.sqrt(power))\n    \n    # Run the spiral2 function to find the first value larger than the goal\n    result = spiral2(side, side, goal)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"puzzle_input": 611155}, "output": 752688}, {"input": {"puzzle_input": 606752}, "output": 752688}, {"input": {"puzzle_input": 781667}, "output": 787032}, {"input": {"puzzle_input": 553967}, "output": 752688}, {"input": {"puzzle_input": 7328}, "output": 13486}, {"input": {"puzzle_input": 835675}, "output": 875851}, {"input": {"puzzle_input": 551129}, "output": 752688}, {"input": {"puzzle_input": 214154}, "output": 266330}, {"input": {"puzzle_input": 102281}, "output": 103128}, {"input": {"puzzle_input": 3588}, "output": 5022}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "VenturaFranklin/puzzles", "path": "/src/Advent17/Day03/Puzzle.py", "msgidx": 7683}}
{"problem_description": "In a complex web of interconnected nodes, a spider is trying to find all possible paths to reach a fly. Given the starting node, how many unique paths can the spider take to reach the fly?", "io_requirements": "Input:\n  `start_node` (str): The starting node in the graph.\n  `end_node` (str): The destination node in the graph.\n\nOutput:\n  `return` (int): The total number of unique paths from the `start_node` to the `end_node`.", "refcode": "# import necessary packages\nfrom collections import defaultdict\nimport networkx as nx\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Adding edges to the graph\nG.add_edge('Spider', 'A', weight=1.0)\nG.add_edge('Spider', 'H', weight=1.0)\nG.add_edge('Spider', 'J', weight=1.0)\n\nG.add_edge('H', 'G', weight=1.0)\nG.add_edge('H', 'K', weight=1.0)\n\nG.add_edge('G', 'L', weight=1.0)\nG.add_edge('G', 'F', weight=1.0)\n\nG.add_edge('F', 'E', weight=1.0)\n\nG.add_edge('E', 'Fly', weight=1.0)\n\nG.add_edge('J', 'S', weight=1.0)\nG.add_edge('J', 'K', weight=1.0)\n\nG.add_edge('K', 'L', weight=1.0)\nG.add_edge('L', 'M', weight=1.0)\nG.add_edge('M', 'N', weight=1.0)\nG.add_edge('M', 'F', weight=1.0)\n\nG.add_edge('N', 'O', weight=1.0)\nG.add_edge('N', 'E', weight=1.0)\n\nG.add_edge('O', 'Fly', weight=1.0)\n\nG.add_edge('A', 'S', weight=1.0)\nG.add_edge('A', 'B', weight=1.0)\n\nG.add_edge('B', 'R', weight=1.0)\nG.add_edge('B', 'C', weight=1.0)\n\nG.add_edge('S', 'R', weight=1.0)\nG.add_edge('R', 'Q', weight=1.0)\n\nG.add_edge('Q', 'C', weight=1.0)\nG.add_edge('Q', 'P', weight=1.0)\n\nG.add_edge('C', 'D', weight=1.0)\nG.add_edge('D', 'Fly', weight=1.0)\nG.add_edge('P', 'D', weight=1.0)\nG.add_edge('P', 'O', weight=1.0)\nG.add_edge('O', 'Fly', weight=1.0)\n\nG.add_edge('T', 'Q', weight=1.0)\nG.add_edge('T', 'P', weight=1.0)\nG.add_edge('T', 'O', weight=1.0)\nG.add_edge('T', 'N', weight=1.0)\nG.add_edge('T', 'M', weight=1.0)\n\nG.add_edge('R', 'T', weight=1.0)\nG.add_edge('S', 'T', weight=1.0)\nG.add_edge('J', 'T', weight=1.0)\nG.add_edge('K', 'T', weight=1.0)\nG.add_edge('L', 'T', weight=1.0)\n\n# Define the BFS function to count paths\ndef bfs(graph, current, dest, path):\n    total = 0\n    edges = list(graph.successors(current))\n    path.append(current)\n    for x in edges:\n        if x == dest:\n            total += 1\n            path.append('Fly')\n            path.pop()\n        else:\n            total += bfs(graph, x, dest, path)\n    path.pop()\n    return total\n\n# Main function\ndef main_solution(start_node, end_node):\n    path = []\n    total_paths = bfs(G, start_node, end_node, path)\n    return total_paths", "funcname": "main_solution", "ios": [{"input": {"start_node": "S", "end_node": "Fly"}, "output": 25}, {"input": {"start_node": "K", "end_node": "Fly"}, "output": 25}, {"input": {"start_node": "E", "end_node": "Fly"}, "output": 1}, {"input": {"start_node": "T", "end_node": "Fly"}, "output": 11}, {"input": {"start_node": "P", "end_node": "Fly"}, "output": 2}, {"input": {"start_node": "A", "end_node": "Fly"}, "output": 40}, {"input": {"start_node": "H", "end_node": "Fly"}, "output": 40}, {"input": {"start_node": "Q", "end_node": "Fly"}, "output": 3}, {"input": {"start_node": "Spider", "end_node": "Fly"}, "output": 141}, {"input": {"start_node": "O", "end_node": "Fly"}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mual3154/Final", "path": "/PROBLEM4.py", "msgidx": 7772}}
{"problem_description": "Given a binary tree represented by a tuple, what are the properties of the tree, including its in-order traversal, height, size, minimum depth, diameter, and whether it is a binary search tree?", "io_requirements": "Input:\n  `tree_tuple` (tuple): A tuple representing the binary tree structure. Each element of the tuple can be either another tuple representing a subtree, `None` representing a null node, or an integer representing a node's key.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n  - `in_order_traversal` (list of int): A list of integers representing the in-order traversal of the tree.\n  - `height` (int): The height of the tree.\n  - `size` (int): The number of nodes in the tree.\n  - `min_depth` (int): The minimum depth of the tree.\n  - `diameter` (int): The diameter of the tree.\n  - `is_bst` (bool): A boolean indicating whether the tree is a binary search tree.\n  - `min_key` (int): The minimum key value in the tree.\n  - `max_key` (int): The maximum key value in the tree.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef parse_tuple(data):\n    if isinstance(data, tuple) and len(data) == 3:\n        node = TreeNode(data[1])\n        node.left = parse_tuple(data[0])\n        node.right = parse_tuple(data[2])\n    elif data is None:\n        node = None\n    else:\n        node = TreeNode(data)\n    return node\n\ndef traverse_in_order(node):\n    if node is None:\n        return []\n    return (traverse_in_order(node.left) + [node.key] + traverse_in_order(node.right))\n\ndef tree_height(node):\n    if node is None:\n        return 0\n    return 1 + max(tree_height(node.left), tree_height(node.right))\n\ndef tree_size(node):\n    if node is None:\n        return 0\n    return 1 + tree_size(node.left) + tree_size(node.right)\n\ndef min_depth(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    left_depth = min_depth(node.left) if node.left is not None else math.inf\n    right_depth = min_depth(node.right) if node.right is not None else math.inf\n    return 1 + min(left_depth, right_depth)\n\ndef diameter_of_binary_tree(node):\n    res = [0]\n    def dfs(node):\n        if node is None:\n            return -1\n        left = dfs(node.left)\n        right = dfs(node.right)\n        res[0] = max(res[0], 2 + left + right)\n        return 1 + max(left, right)\n    dfs(node)\n    return res[0]\n\ndef remove_none(nums):\n    return [x for x in nums if x is not None]\n\ndef is_bst(node):\n    if node is None:\n        return True, None, None\n    \n    is_bst_l, min_l, max_l = is_bst(node.left)\n    is_bst_r, min_r, max_r = is_bst(node.right)\n    \n    is_bst_node = (is_bst_l and is_bst_r and \n                   (max_l is None or node.key > max_l) and \n                   (min_r is None or node.key < min_r))\n    \n    min_key = min(remove_none([min_l, node.key, min_r]))\n    max_key = max(remove_none([max_l, node.key, max_r]))\n    \n    return is_bst_node, min_key, max_key\n\n# main function\ndef main_solution(tree_tuple):\n    # Convert the tuple to a tree\n    tree = parse_tuple(tree_tuple)\n    \n    # Calculate the required properties\n    in_order_traversal = traverse_in_order(tree)\n    height = tree_height(tree)\n    size = tree_size(tree)\n    min_depth_value = min_depth(tree)\n    diameter = diameter_of_binary_tree(tree)\n    is_binary_search_tree, min_key, max_key = is_bst(tree)\n    \n    # Return the results as a dictionary\n    return {\n        \"in_order_traversal\": in_order_traversal,\n        \"height\": height,\n        \"size\": size,\n        \"min_depth\": min_depth_value,\n        \"diameter\": diameter,\n        \"is_bst\": is_binary_search_tree,\n        \"min_key\": min_key,\n        \"max_key\": max_key\n    }", "funcname": "main_solution", "ios": [{"input": {"tree_tuple": [null, 19, null]}, "output": {"in_order_traversal": [19], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 19, "max_key": 19}}, {"input": {"tree_tuple": [null, 25, null]}, "output": {"in_order_traversal": [25], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 25, "max_key": 25}}, {"input": {"tree_tuple": [null, 30, null]}, "output": {"in_order_traversal": [30], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 30, "max_key": 30}}, {"input": {"tree_tuple": [null, 97, null]}, "output": {"in_order_traversal": [97], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 97, "max_key": 97}}, {"input": {"tree_tuple": [[null, 24, null], 88, [null, 3, null]]}, "output": {"in_order_traversal": [24, 88, 3], "height": 2, "size": 3, "min_depth": 2, "diameter": 2, "is_bst": false, "min_key": 3, "max_key": 88}}, {"input": {"tree_tuple": [null, 5, null]}, "output": {"in_order_traversal": [5], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 5, "max_key": 5}}, {"input": {"tree_tuple": [null, 91, null]}, "output": {"in_order_traversal": [91], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 91, "max_key": 91}}, {"input": {"tree_tuple": [null, 43, null]}, "output": {"in_order_traversal": [43], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 43, "max_key": 43}}, {"input": {"tree_tuple": [null, 87, null]}, "output": {"in_order_traversal": [87], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 87, "max_key": 87}}, {"input": {"tree_tuple": [null, 14, null]}, "output": {"in_order_traversal": [14], "height": 1, "size": 1, "min_depth": 1, "diameter": 0, "is_bst": true, "min_key": 14, "max_key": 14}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "NOY10/pyproject", "path": "/myalgo/Binary Tree.py", "msgidx": 7362}}
{"problem_description": "Given a coordinate system defined by multiple axes, each with a specific number of values centered around zero, determine the coordinates that match a given set of specifications. The specifications can include wildcards ('*') to match any value on the corresponding axis, or specific values to match exactly. What are the coordinates that match the provided specifications?", "io_requirements": "Input:\n  `axis_symbols` (list of str): A list of symbols representing the axes (e.g., ['x', 'y']).\n  `num_vals_list` (list of int): A list of integers representing the number of values for each axis.\n  `spec` (list of str): A list of strings representing the specifications for matching coordinates (e.g., ['*', '0']).\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the coordinates that match the given specifications. Each tuple corresponds to a coordinate in the coordinate system.", "refcode": "# import necessary packages\nfrom collections import namedtuple\nfrom itertools import product\nimport math\n\n# all class and function definitions in the code file, if any\nclass CenteredOriginAxis:\n    def __init__(self, symbol, num_vals):\n        self.symbol = symbol\n        self.num_vals = num_vals\n\n    def __len__(self):\n        return self.num_vals\n\n    def __getitem__(self, i):\n        if not 0 <= i < self.num_vals:\n            raise IndexError()\n        abs_max = self.num_vals // 2\n        if i < abs_max:\n            return -abs_max + i\n        i -= abs_max\n        if 0 in self:\n            if i == 0:\n                return 0\n            i -= 1\n        if i < abs_max:\n            return i + 1\n\n    def __contains__(self, val):\n        if val == 0:\n            return self.num_vals % 2 != 0\n        abs_max = self.num_vals // 2\n        return val in range(-abs_max, abs_max + 1)\n\n    def index(self, val):\n        if val not in self:\n            raise ValueError()\n        abs_max = self.num_vals // 2\n        if val == 0:\n            return abs_max\n        elif val < 0:\n            return abs_max + val\n        else:\n            ret = abs_max + val\n            if 0 not in self:\n                ret -= 1\n            return ret\n\n    def match(self, matchval):\n        return (component for component in self if component == matchval)\n\n    def original_and_reflection(self, val):\n        if val not in self:\n            raise ValueError()\n        if val == 0:\n            return (val,)\n        else:\n            return val, -val\n\n    def reflection(self, val):\n        if val not in self:\n            raise ValueError()\n        if val == 0:\n            return (val,)\n        else:\n            return (-val,)\n\nclass CoordinateSystem:\n    def __init__(self, *axes):\n        self.axes = axes\n        self.Coord = coordtuple('Coord', axes)\n        for axis in axes:\n            setattr(self, axis.symbol, axis)\n\n    def __contains__(self, coord):\n        return all(component in axis for component, axis in zip(coord, self.axes))\n\n    def coords_matching(self, *spec):\n        matches = (axis.match(axis_range) for axis, axis_range in zip(self.axes, spec))\n        return (self.Coord(*match) for match in product(*matches))\n\n    def map_coord_components(self, coords, **maps):\n        def component_values(coord):\n            for axis, component in zip(self.axes, coord):\n                if axis.symbol in maps:\n                    yield maps[axis.symbol](axis, component)\n                else:\n                    yield (component,)\n\n        for coord in coords:\n            for new_coord in product(*component_values(coord)):\n                try:\n                    yield self.Coord(*new_coord)\n                except ValueError:\n                    pass\n\n    def map_coord_components_separately(self, coords, **maps):\n        for symbol in maps:\n            for coord in self.map_coord_components(coords, **{symbol: maps[symbol]}):\n                yield coord\n\ndef coordtuple(name, axes):\n    fields = [axis.symbol for axis in axes]\n\n    class T(namedtuple(name, fields)):\n        def __new__(cls, *args):\n            for axis, component in zip(axes, args):\n                if component not in axis:\n                    raise ValueError()\n            return super(T, cls).__new__(cls, *args)\n\n        def _map_vals(self, func):\n            return T(*map(func, self))\n\n        def __abs__(self):\n            return self._map_vals(lambda val: abs(val))\n\n        def __neg__(self):\n            return self._map_vals(lambda val: -val)\n\n        def distance(self, other):\n            return math.sqrt(sum((a - b)**2 for a, b in zip(self, other)))\n\n    T.__name__ = name\n    return T\n\n# main function\ndef main_solution(axis_symbols, num_vals_list, spec):\n    axes = [CenteredOriginAxis(symbol, num_vals) for symbol, num_vals in zip(axis_symbols, num_vals_list)]\n    system = CoordinateSystem(*axes)\n    matching_coords = list(system.coords_matching(*spec))\n    return [tuple(coord) for coord in matching_coords]", "funcname": "main_solution", "ios": [{"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [8, 4, 4], "spec": ["1", "*", "1"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [5, 9, 3], "spec": ["0", "1", "1"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [9, 9, 8], "spec": ["0", "0", "1"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [4, 10, 6], "spec": ["1", "1", "0"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [10, 10, 9], "spec": ["1", "*", "*"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [5, 10, 7], "spec": ["-1", "*", "-1"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [10, 5, 6], "spec": ["-1", "-1", "0"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [4, 9, 9], "spec": ["*", "1", "1"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [10, 4, 9], "spec": ["-1", "-1", "-1"]}, "output": []}, {"input": {"axis_symbols": ["x", "y", "z"], "num_vals_list": [3, 7, 8], "spec": ["*", "-1", "-1"]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "atrigent/luzhanqi", "path": "/coordinates.py", "msgidx": 7568}}
{"problem_description": "Given a string consisting of unique characters, what are all the possible unique anagrams of this string, sorted in alphabetical order?", "io_requirements": "Input:\n  `input_string` (str): A string containing unique characters for which all anagrams need to be generated.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique anagram of the input string, sorted in lexicographical order.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all unique permutations of the characters\n    unique_anagrams = set(''.join(p) for p in itertools.permutations(char_list))\n    \n    # Convert the set of unique anagrams to a sorted list\n    sorted_anagrams = sorted(unique_anagrams)\n    \n    # Return the sorted list of unique anagrams\n    return sorted_anagrams", "funcname": "main_solution", "ios": [{"input": {"input_string": "GCX"}, "output": ["CGX", "CXG", "GCX", "GXC", "XCG", "XGC"]}, {"input": {"input_string": "IMC"}, "output": ["CIM", "CMI", "ICM", "IMC", "MCI", "MIC"]}, {"input": {"input_string": "QJA"}, "output": ["AJQ", "AQJ", "JAQ", "JQA", "QAJ", "QJA"]}, {"input": {"input_string": "ANS"}, "output": ["ANS", "ASN", "NAS", "NSA", "SAN", "SNA"]}, {"input": {"input_string": "CSR"}, "output": ["CRS", "CSR", "RCS", "RSC", "SCR", "SRC"]}, {"input": {"input_string": "STK"}, "output": ["KST", "KTS", "SKT", "STK", "TKS", "TSK"]}, {"input": {"input_string": "MGU"}, "output": ["GMU", "GUM", "MGU", "MUG", "UGM", "UMG"]}, {"input": {"input_string": "FWE"}, "output": ["EFW", "EWF", "FEW", "FWE", "WEF", "WFE"]}, {"input": {"input_string": "ISQ"}, "output": ["IQS", "ISQ", "QIS", "QSI", "SIQ", "SQI"]}, {"input": {"input_string": "NAZ"}, "output": ["ANZ", "AZN", "NAZ", "NZA", "ZAN", "ZNA"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "coderjelly/pythonscripts", "path": "/string_manipulation/Anagrams.py", "msgidx": 8259}}
{"problem_description": "Given a partially filled Sudoku board, can you determine the complete and correct configuration of the board? The board is represented as a string of 81 characters, where each character is either a digit from '1' to '9' or a '.' to indicate an empty cell. The string is read row by row from top to bottom. What is the complete and correct configuration of the board?", "io_requirements": "Input:\n  `sudoku_string` (str): A string of length 81 representing the Sudoku board. Each character can be a digit from '1' to '9' or a '.' to represent an empty cell. The string is read row by row from top to bottom.\n\nOutput:\n  `return` (str): A string of length 81 representing the solved Sudoku board. Each character is a digit from '1' to '9'. The string is read row by row from top to bottom. If no solution is found, the string \"No solution found\" is returned.", "refcode": "# import necessary packages\nimport heapq\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef blankBoard():\n    board = {}\n    for i in range(9):\n        for j in range(9):\n            board[(i, j)] = '.'\n    return board\n\ndef makeBoard(string):\n    b = blankBoard()\n    for i in range(9):\n        for k in range(9):\n            sub = string[9 * i + k]\n            b[(i, k)] = sub\n    return b\n\ndef findNeighbors(board, row, col):\n    nbrs = set()\n    for i in range(9):\n        if i != row:\n            nbrs.add((i, col))\n        if i != col:\n            nbrs.add((row, i))\n    rowQuad = row // 3\n    colQuad = col // 3\n    for i in range(3):\n        for j in range(3):\n            nR = i + rowQuad * 3\n            nC = j + colQuad * 3\n            if nR != row and nC != col and (nR, nC) not in nbrs:\n                nbrs.add((nR, nC))\n    return nbrs\n\ndef isCorrect(board):\n    for i in range(9):\n        rows = set()\n        cols = set()\n        for j in range(9):\n            val = board[(i, j)]\n            if val in rows or val == '.':\n                return False\n            rows.add(val)\n            val = board[(j, i)]\n            if val in cols:\n                return False\n            cols.add(val)\n    for i in range(3):\n        for j in range(3):\n            tQuad = set()\n            for k in range(3):\n                for m in range(3):\n                    val = board[(3 * i + k, 3 * j + m)]\n                    if val in tQuad:\n                        return False\n                    tQuad.add(val)\n    return True\n\ndef isWrong(board):\n    for i in range(9):\n        rows = set()\n        cols = set()\n        for j in range(9):\n            val = board[(i, j)]\n            if val in rows and val != '.':\n                return True\n            rows.add(val)\n            val = board[(j, i)]\n            if val in cols and val != '.':\n                return True\n            cols.add(val)\n    for i in range(3):\n        for j in range(3):\n            tQuad = set()\n            for k in range(3):\n                for m in range(3):\n                    val = board[(3 * i + k, 3 * j + m)]\n                    if val in tQuad and val != '.':\n                        return True\n                    tQuad.add(val)\n    return False\n\ndef makePossibilities(board):\n    neighbors = {}\n    for r in range(9):\n        for c in range(9):\n            toAdd = set()\n            allTheNeighbors = findNeighbors(board, r, c)\n            neighborValues = set()\n            for i in allTheNeighbors:\n                if board[i] != '.':\n                    neighborValues.add(board[i])\n            for j in range(1, 10):\n                if str(j) not in neighborValues:\n                    toAdd.add(str(j))\n            neighbors[(r, c)] = toAdd\n    return neighbors\n\ndef dictHelper2(b, p, nums):\n    if isCorrect(b):\n        return (True, b)\n    if isWrong(b):\n        return (False, b)\n    minC = (-1, -1)\n    minNum = 10\n    minSet = set()\n    for c in ALL_COORDINATES:\n        if b[c] == '.' and nums[c] < minNum:\n            minC = c\n            minNum = nums[c]\n            minSet = p[c]\n    if minNum == 10:\n        print(\"minNum still 10\")\n    minCR, minCC = minC\n    for eachPossibility in minSet.copy():\n        rmList = []\n        b[minC] = eachPossibility\n        for eachNeighbor in findNeighbors(b, minCR, minCC):\n            if eachNeighbor != minC and eachPossibility in p[eachNeighbor]:\n                rmList.append(eachNeighbor)\n                newSet = p[eachNeighbor]\n                newSet.remove(eachPossibility)\n                p[eachNeighbor] = newSet\n                newN = nums[eachNeighbor]\n                newN -= 1\n                nums[eachNeighbor] = newN\n        ans, bo = dictHelper2(b, p, nums)\n        if ans:\n            return (True, bo)\n        guess = b[minC]\n        b[minC] = '.'\n        for changed in rmList:\n            nSet = p[changed]\n            nSet.add(guess)\n            p[changed] = nSet\n            nN = nums[changed]\n            nN += 1\n            nums[changed] = nN\n    return (False, b)\n\ndef dictionaryAttempt2(b, p):\n    newB = b\n    nums = {}\n    for c in b.keys():\n        nums[c] = len(p[c])\n    return dictHelper2(newB, p, nums)\n\n# main function\ndef main_solution(sudoku_string):\n    board = makeBoard(sudoku_string)\n    possibilities = makePossibilities(board)\n    solved, solved_board = dictionaryAttempt2(board, possibilities)\n    if solved:\n        return ''.join([solved_board[(i, j)] for i in range(9) for j in range(9)])\n    else:\n        return \"No solution found\"", "funcname": "main_solution", "ios": [{"input": {"sudoku_string": ".323622.5.984776139.5848564223149.4897416132.596758827276.953414765945484117.8.82"}, "output": "No solution found"}, {"input": {"sudoku_string": "768769..289858.6.6998.9.569843278.8.58252.9626899588371547..68598897.4944689.1567"}, "output": "No solution found"}, {"input": {"sudoku_string": "67398126442247718198317853946761588.71628639688.16.6241.3895926.123965212.6968935"}, "output": "No solution found"}, {"input": {"sudoku_string": "763.338347.376543341.2861713375533595517388468634.94857.22552715797347575834633.5"}, "output": "No solution found"}, {"input": {"sudoku_string": "438744533115545144644.79156515128.67442476613.619253373315..252.85.83785434431645"}, "output": "No solution found"}, {"input": {"sudoku_string": "87.46472354956221112..16..8774339.89992582129551516673.628.11.631..79713336981837"}, "output": "No solution found"}, {"input": {"sudoku_string": "6292742.4543428192.1479814888945675928139681587947141527439197533..5576.795623543"}, "output": "No solution found"}, {"input": {"sudoku_string": "7841633.997746929.966899188537871369279.34377773773421355962816725579172897226672"}, "output": "No solution found"}, {"input": {"sudoku_string": "7947419.41668813195827726716396795.47635.849525.7619723446237.213.518821917.15.89"}, "output": "No solution found"}, {"input": {"sudoku_string": ".29336862.418363939565656.9222313.8671145244574463.961212615.4.3748213248.9375254"}, "output": "No solution found"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jcschefer/sudoku", "path": "/sudoku.py", "msgidx": 7408}}
{"problem_description": "Hawk and his little brother, Stone, are playing a game where they need to construct a sequence of numbers from 8 given integers. The sequence must follow specific rules: to the right of each even number must be either an odd number or the same even number, and to the right of each odd number must be either a larger even number or a strictly smaller odd number. Stone claims he can construct a legal sequence using all 8 numbers. Is Stone telling the truth?", "io_requirements": "Input:\n  `numbers` (list of int): A list of 8 integers, each integer is in the range from 1 to 100.\n\nOutput:\n  `return` (bool): Returns `True` if it is possible to construct a legal sequence from the 8 integers according to the game rules, otherwise returns `False`.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list to a tuple for permutations\n    lis = tuple(numbers)\n    \n    for perm in permutations(lis):\n        valid = True\n        for i in range(len(lis) - 1):\n            if perm[i] % 2 == 0:\n                if not (perm[i + 1] % 2 != 0 or perm[i] == perm[i + 1]):\n                    valid = False\n                    break\n            if perm[i] % 2 != 0:\n                if not ((perm[i + 1] > perm[i] and perm[i + 1] % 2 == 0) or (perm[i + 1] < perm[i] and perm[i + 1] % 2 != 0)):\n                    valid = False\n                    break\n\n        if valid:\n            return True\n    return False", "funcname": "main_solution", "ios": [{"input": {"numbers": [62, 3, 21, 44, 85, 67, 96, 56]}, "output": true}, {"input": {"numbers": [62, 66, 71, 51, 26, 25, 10, 25]}, "output": true}, {"input": {"numbers": [97, 29, 99, 83, 51, 26, 70, 10]}, "output": false}, {"input": {"numbers": [50, 32, 20, 99, 93, 64, 28, 6]}, "output": false}, {"input": {"numbers": [18, 90, 32, 87, 19, 98, 41, 34]}, "output": false}, {"input": {"numbers": [5, 36, 12, 30, 78, 93, 2, 52]}, "output": false}, {"input": {"numbers": [66, 2, 50, 38, 66, 37, 48, 81]}, "output": false}, {"input": {"numbers": [41, 4, 21, 16, 46, 55, 15, 18]}, "output": false}, {"input": {"numbers": [33, 100, 56, 48, 69, 31, 26, 86]}, "output": false}, {"input": {"numbers": [97, 2, 86, 51, 84, 35, 78, 49]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Kallehz/Python", "path": "/Pr\u00f3f1/NumbersGame.py", "msgidx": 8047}}
{"problem_description": "Given a chessboard of size `n` by `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of distinct solutions to the N-Queens problem for the given board size `n`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef isAblePlace(board, row, col, size):\n    for i in range(row):\n        if board[i][col] == 'Q':\n            return False\n        if col - i - 1 >= 0 and board[row - i - 1][col - i - 1] == 'Q':\n            return False\n        if col + i + 1 < size and board[row - i - 1][col + i + 1] == 'Q':\n            return False\n    return True\n\ndef findAllPositions(total, board, row, size):\n    if row == size:\n        total[0] += 1\n        return\n    for col in range(size):\n        if isAblePlace(board, row, col, size):\n            board[row][col] = 'Q'\n            findAllPositions(total, board, row + 1, size)\n            board[row][col] = '.'\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    board = [['.'] * n for i in range(n)]\n    total = [0]\n    findAllPositions(total, board, 0, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return total[0]", "funcname": "main_solution", "ios": [{"input": {"n": 6}, "output": 4}, {"input": {"n": 5}, "output": 10}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 2}, "output": 0}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 10}, "output": 724}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kongtianyi/cabbird", "path": "/leetcode/n_queens_II.py", "msgidx": 7469}}
{"problem_description": "On a mysterious island, there are creatures known as Quxes which come in three colors: red, green, and blue. One power of the Qux is that if two of them are standing next to each other, they can transform into a single creature of the third color. Given a sequence of Quxes standing in a line, what is the smallest number of Quxes remaining after any possible sequence of such transformations?", "io_requirements": "Input:\n  `quxes` (str): A string representing the sequence of Quxes standing in a line. Each character in the string can be 'R', 'G', or 'B'.\n\nOutput:\n  `return` (str): A string representing the smallest number of Quxes remaining after any possible sequence of transformations. Each character in the string can be 'R', 'G', or 'B'.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n\n# main function\ndef main_solution(quxes):\n    # Convert the input list of strings to a list of characters\n    qux = list(quxes)\n    \n    stack = [qux[0]]\n    for i in qux[1:]:\n        if stack[-1] == i:\n            stack.append(i)\n        else:\n            a = stack.pop()\n            if a != 'R' and i != 'R':\n                stack.append('R')\n            elif a != 'G' and i != 'G':\n                stack.append('G')\n            else:\n                stack.append('B')\n    \n    if len(stack) > 1 and stack[-1] != stack[-2]:\n        a = stack.pop()\n        i = stack.pop()\n        if a != 'R' and i != 'R':\n            stack.append('R')\n        elif a != 'G' and i != 'G':\n            stack.append('G')\n        else:\n            stack.append('B')\n    \n    # Convert the stack back to a JSON serializable list of strings\n    return ''.join(stack)", "funcname": "main_solution", "ios": [{"input": {"quxes": "BBGBR"}, "output": "BB"}, {"input": {"quxes": "RBGBBBRBGG"}, "output": "GRGGG"}, {"input": {"quxes": "BRBBB"}, "output": "R"}, {"input": {"quxes": "GBRBGRRGBG"}, "output": "RGR"}, {"input": {"quxes": "BRR"}, "output": "B"}, {"input": {"quxes": "G"}, "output": "G"}, {"input": {"quxes": "RBBBRRBGBG"}, "output": "G"}, {"input": {"quxes": "BBB"}, "output": "BBB"}, {"input": {"quxes": "GBBBGGGG"}, "output": "R"}, {"input": {"quxes": "B"}, "output": "B"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "LokiGadd/Python", "path": "/16.py", "msgidx": 8410}}
{"problem_description": "Given a number, what are the pairs of twin primes that are less than this number?", "io_requirements": "Input:\n  `limit` (int): An integer representing the upper limit for finding twin primes. The value should be greater than 2 and less than 1000.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple represents a pair of twin primes. Each tuple contains two integers.", "refcode": "# import necessary packages\nfrom itertools import cycle\n\n# Function to check if a number is prime\ndef is_prime(n):\n    prime_range = []\n    for x in range(1, n + 1):\n        if n % x == 0:\n            prime_range.append(x)\n    return [1, n] == prime_range\n\n# main function\ndef main_solution(limit):\n    # Find all primes less than the given limit\n    all_primes = [prime for prime in range(1, limit) if is_prime(prime)]\n    \n    # Use cycle to find twin primes\n    lc = cycle(all_primes)\n    _next = next(lc)\n    twin_primes = []\n    for i in all_primes:\n        _this, _next = _next, next(lc)\n        if _next - _this == 2:\n            twin_primes.append((_this, _next))\n    \n    # Return the list of twin primes as a JSON serializable output\n    return twin_primes", "funcname": "main_solution", "ios": [{"input": {"limit": 43}, "output": [[3, 5], [5, 7], [11, 13], [17, 19], [29, 31]]}, {"input": {"limit": 6}, "output": [[3, 5]]}, {"input": {"limit": 68}, "output": [[3, 5], [5, 7], [11, 13], [17, 19], [29, 31], [41, 43], [59, 61]]}, {"input": {"limit": 15}, "output": [[3, 5], [5, 7], [11, 13]]}, {"input": {"limit": 24}, "output": [[3, 5], [5, 7], [11, 13], [17, 19]]}, {"input": {"limit": 46}, "output": [[3, 5], [5, 7], [11, 13], [17, 19], [29, 31], [41, 43]]}, {"input": {"limit": 13}, "output": [[3, 5], [5, 7]]}, {"input": {"limit": 26}, "output": [[3, 5], [5, 7], [11, 13], [17, 19]]}, {"input": {"limit": 67}, "output": [[3, 5], [5, 7], [11, 13], [17, 19], [29, 31], [41, 43], [59, 61]]}, {"input": {"limit": 31}, "output": [[3, 5], [5, 7], [11, 13], [17, 19]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Anarcroth/daily-code-challenges", "path": "/py/twin_primes.py", "msgidx": 8209}}
{"problem_description": "Given a polymer sequence composed of various units represented by different letters, certain units can react and eliminate each other if they are the same type but different polarities (e.g., 'a' and 'A'). What is the final size of the polymer after all possible reactions have occurred?", "io_requirements": "Input:\n  `polymer_string` (str): A string representing the polymer sequence where each character is a unit of the polymer.\n\nOutput:\n  `return` (int): The final size of the polymer after all possible reactions have occurred.", "refcode": "# import necessary packages\nimport sys\n\n# all class and function definitions in the code file, if any\nclass Elem(object):\n    def __init__(self, unit, prev, next):\n        self.unit = unit\n        self.prev = prev\n        if prev is not None:\n            prev.next = self\n        self.next = next\n        if next is not None:\n            next.prev = self\n\ndef reacts(u1, u2):\n    if u1 != u2 and u1.lower() == u2.lower():\n        return True\n    return False\n\n# main function\ndef main_solution(polymer_string):\n    # Convert the input string to a linked list of Elem objects\n    first = None\n    size = 0\n    prev = None\n    for c in polymer_string:\n        e = Elem(c, prev, None)\n        prev = e\n        size += 1\n        if first is None:\n            first = e\n\n    # React the polymer\n    shrunk = True\n    while shrunk:\n        shrunk = False\n        curr = first\n        while curr.next is not None:\n            if reacts(curr.unit, curr.next.unit):\n                if curr.prev is None:\n                    curr = curr.next.next\n                    first = curr\n                    if curr is not None:\n                        curr.prev = None\n                elif curr.next.next is None:\n                    curr.prev.next = None\n                    curr = curr.prev\n                else:\n                    curr.prev.next = curr.next.next\n                    curr.next.next.prev = curr.prev\n                    curr = curr.next.next\n                shrunk = True\n                size -= 2\n            else:\n                curr = curr.next\n\n    # Return the final size of the polymer\n    return size", "funcname": "main_solution", "ios": [{"input": {"polymer_string": "BPJlMDPCzucFDaEoJOvzdGpzhWrrHDMgDFzzReozJIkOSAc"}, "output": 47}, {"input": {"polymer_string": "cpCsZBhztbtJvoBqpAlHIsJvwRMjfyuvECGoEdVRQh"}, "output": 42}, {"input": {"polymer_string": "eiQVHSMzjMHmGjOqoTrETTsTRds"}, "output": 27}, {"input": {"polymer_string": "fRVAXCmfvVQBxqGZTswKOMDlefNBMry"}, "output": 29}, {"input": {"polymer_string": "QiNQjMEgfefZhyxyzvbDBbekcypVmebd"}, "output": 30}, {"input": {"polymer_string": "TryyvnDLVCaKoBHDOadeCfsjMnudULXzUXBrbPclKGGO"}, "output": 44}, {"input": {"polymer_string": "mtlObeIdXiroCvfnrVlHjTHwPXi"}, "output": 27}, {"input": {"polymer_string": "cfsDRhBzOftVCtLDWJNJoRoJNIADNaAhrjwAs"}, "output": 35}, {"input": {"polymer_string": "vevZKLKZeVcIFVWmiOzgEoPFmsDgPhaahpK"}, "output": 35}, {"input": {"polymer_string": "nDDIAGzRlrWtKOOMtwPvHAOPQoZErSgoYMufDdMGnYRe"}, "output": 42}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zkutasi/adventofcode-2018", "path": "/day05/1.py", "msgidx": 7995}}
{"problem_description": "In a distributed computing system, each node needs to generate a unique password based on a given index. The passwords are encoded using Base62, which includes all lowercase and uppercase letters and digits. Given a password index, what is the corresponding password in Base62 encoding?", "io_requirements": "Input:\n  `password_index` (int): The index of the password to be generated. It should be a non-negative integer.\n\nOutput:\n  `return` (str): The generated password in Base62 encoding. The length of the password is determined by the constant `PASSWORD_SIZE`.", "refcode": "# import necessary packages\nimport string\n\n# Constants\nBASE62 = string.ascii_lowercase + string.ascii_uppercase + string.digits\nPASSWORD_SIZE = 6  # Assuming a default password size for simplicity\n\n# Function definitions from the original code file\ndef encode(num, alphabet):\n    \"\"\"Encode a positive number into Base X and return the string.\"\"\"\n    if num == 0:\n        return alphabet[0]\n    arr = []\n    base = len(alphabet)\n    while num:\n        num, rem = divmod(num, base)\n        arr.append(alphabet[rem])\n    arr.reverse()\n    return ''.join(arr)\n\ndef decode(password, alphabet=BASE62):\n    \"\"\"Decode a Base X encoded password into the number.\"\"\"\n    base = len(alphabet)\n    strlen = len(password)\n    num = 0\n    for idx, char in enumerate(password):\n        power = (strlen - (idx + 1))\n        num += alphabet.index(char) * (base ** power)\n    return num\n\ndef getPWfromIDX(idx, size=PASSWORD_SIZE):\n    \"\"\"Get password from index.\"\"\"\n    if 0 > idx or idx >= (62**size):\n        return \"a\" * size\n    str_encoded = encode(idx, BASE62)\n    if len(str_encoded) < size:\n        str_encoded = (BASE62[0] * (size - len(str_encoded))) + str_encoded\n    return str_encoded\n\n# main function\ndef main_solution(password_index):\n    \"\"\"\n    Converts a password index to its corresponding password in Base62 encoding.\n    \n    Args:\n    - password_index (int): The index of the password to be generated.\n    \n    Returns:\n    - str: The generated password.\n    \"\"\"\n    return getPWfromIDX(password_index)", "funcname": "main_solution", "ios": [{"input": {"password_index": 40054660682}, "output": "RSTrao"}, {"input": {"password_index": 28512925400}, "output": "FhNuzI"}, {"input": {"password_index": 35961015505}, "output": "NpQU3h"}, {"input": {"password_index": 34012275949}, "output": "LhYcR7"}, {"input": {"password_index": 37208010918}, "output": "OMfbww"}, {"input": {"password_index": 54758502782}, "output": "7VZgbW"}, {"input": {"password_index": 51266221764}, "output": "37D0mK"}, {"input": {"password_index": 42748173046}, "output": "UPa8Mc"}, {"input": {"password_index": 4456827699}, "output": "e1MyDT"}, {"input": {"password_index": 24023661880}, "output": "AnYZ3A"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "detiuaveiro/cd2021-final-97880_100055", "path": "/slave.py", "msgidx": 8006}}
{"problem_description": "Given a 4-digit number, how many iterations are required to transform it into the Kaprekar constant (6174) by repeatedly rearranging its digits to form the largest and smallest possible numbers and then subtracting the smaller number from the larger one?", "io_requirements": "Input:\n  `n` (int): A 4-digit integer for which the Kaprekar iterations are to be calculated.\n\nOutput:\n  `return` (int): The number of iterations required to reach the Kaprekar constant (6174) from the input number `n`.", "refcode": "# import necessary packages\nimport math\n\n# Constants\nKAPREKAR_CONSTANT = 6174\n\n# Function to convert the number into an array of digits\ndef convert_to_array(n):\n    number = str(n)\n    arr = []\n    for digits in number:\n        arr.append(digits)\n    return arr\n\n# Function to sort the number into a number with digits in descending order (largest possible)\ndef getLarger(n):\n    arr = convert_to_array(n)\n    arr.sort(reverse=True)\n    numStr = ''.join(arr)\n    return int(numStr)\n\n# Function to sort the number into a number with digits in ascending order (smallest possible)\ndef getSmaller(n):\n    arr = convert_to_array(n)\n    arr.sort()\n    numStr = ''.join(arr)\n    return int(numStr)\n\n# Main function\ndef main_solution(n):\n    # Ensure the input is a 4-digit number\n    if n < 1000 or n > 9999:\n        raise ValueError(\"Input must be a 4-digit number.\")\n    \n    # Initialize variables\n    counter = 0\n    result = n\n    \n    # Loop until the result equals the Kaprekar constant\n    while result != KAPREKAR_CONSTANT:\n        large = getLarger(result)\n        small = getSmaller(result)\n        result = large - small\n        counter += 1\n    \n    # Return the number of iterations\n    return counter", "funcname": "main_solution", "ios": [{"input": {"n": 2295}, "output": 6}, {"input": {"n": 7722}, "output": 5}, {"input": {"n": 5702}, "output": 6}, {"input": {"n": 2921}, "output": 6}, {"input": {"n": 2735}, "output": 7}, {"input": {"n": 6897}, "output": 3}, {"input": {"n": 4999}, "output": 6}, {"input": {"n": 2324}, "output": 3}, {"input": {"n": 1424}, "output": 5}, {"input": {"n": 8274}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "FilipLe/DailyInterviewPro-Unsolved", "path": "/Kaprekars Constant (SOLVED)/kaprekars.py", "msgidx": 8108}}
{"problem_description": "Given a target number and a set of terms, how can the target number be split into the terms such that the quality of the split is minimized? The quality of a split is defined as the standard deviation of the terms used in the split. What is the best split and its corresponding quality?", "io_requirements": "Input:\n  `number` (int): The target number to be split into terms.\n  `terms_of_sum` (list of int): A list of integers that can be used as terms to split the number.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `best_split` (list of int): The list of terms that form the best split of the number.\n    - `quality` (float): The quality value of the best split.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef quality_function(intArray):\n    mean = sum(intArray) / len(intArray)\n    quality = 0.\n    for n in intArray:\n        quality += (n - mean) ** 2\n    quality = math.sqrt(quality)\n    return quality\n\ndef split_number_rec(terms_of_sum, best_split, remain, terms_idx, l):\n    if remain == 0:\n        l.append(terms_of_sum[terms_idx])\n        if best_split[1] is None or quality_function(l) < best_split[1]:\n            best_split[0] = l[:]\n            best_split[1] = quality_function(l)\n    elif remain > terms_of_sum[terms_idx]:\n        remain -= terms_of_sum[terms_idx]\n        l.append(terms_of_sum[terms_idx])\n        split_number_rec(terms_of_sum, best_split, remain, terms_idx, l)\n\ndef split_number(number, terms_of_sum):\n    best_split = [None, None]\n    for i in range(len(terms_of_sum)):\n        split_number_rec(terms_of_sum, best_split, number, i, [])\n    return best_split\n\n# main function\ndef main_solution(number, terms_of_sum):\n    # Convert input to appropriate types if necessary\n    number = int(number)\n    terms_of_sum = list(map(int, terms_of_sum))\n    \n    # Call the core function\n    result = split_number(number, terms_of_sum)\n    \n    # Convert output to JSON serializable format\n    return {\"best_split\": result[0], \"quality\": result[1]}", "funcname": "main_solution", "ios": [{"input": {"number": 71, "terms_of_sum": [9, 8, 10, 5, 6]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 22, "terms_of_sum": [4, 5, 7]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 92, "terms_of_sum": [3, 5, 1, 8]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 20, "terms_of_sum": [7, 1, 8]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 82, "terms_of_sum": [8, 5, 10, 1]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 44, "terms_of_sum": [7, 3, 10, 9, 6]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 54, "terms_of_sum": [9, 2, 5, 10, 6]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 18, "terms_of_sum": [7, 10, 2, 5, 1]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 80, "terms_of_sum": [5, 8, 10]}, "output": {"best_split": null, "quality": null}}, {"input": {"number": 86, "terms_of_sum": [5, 1, 8]}, "output": {"best_split": null, "quality": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AndrejLehmann/my_pfn_2019", "path": "/Uebungen/Blatt08.Harkov.Lehmann.Music/Aufgabe1/Splitnumber/splitnumber.py", "msgidx": 7966}}
{"problem_description": "Given a set of digits, what is the largest prime number that can be formed by using each of the digits exactly once?", "io_requirements": "Input:\n  `digits` (str): A string of digits from which to generate pandigital numbers. The length of the string determines the number of digits in the pandigital numbers.\n\nOutput:\n  `return` (int or None): The largest pandigital prime number formed from the given digits. If no such prime number exists, returns `None`.", "refcode": "# import necessary packages\nimport itertools\nimport math\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\nsieve_exists = False\nsieve_size = int(math.sqrt(9999999))\nsieve = {}\nprimes = [2]\n\ndef create_sieve():\n    for i in itertools.count(start=3):\n        if i > sieve_size:\n            break\n        if i % 2 == 0:\n            pass\n        else:\n            if i not in sieve:\n                primes.append(i)\n                j = i\n                while j < sieve_size:\n                    sieve[j] = True\n                    j += i\n\ndef is_prime(n):\n    global sieve_exists\n    if not sieve_exists:\n        create_sieve()\n        sieve_exists = True\n    for i in primes:\n        if n % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    pandigital_primes = []\n    for i in itertools.permutations(digits, len(digits)):\n        n = int(\"\".join(i))\n        if is_prime(n):\n            pandigital_primes.append(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return max(pandigital_primes) if pandigital_primes else None", "funcname": "main_solution", "ios": [{"input": {"digits": "768521"}, "output": 875621}, {"input": {"digits": "52917683"}, "output": 98765231}, {"input": {"digits": "81376"}, "output": 87631}, {"input": {"digits": "5913478"}, "output": 9874531}, {"input": {"digits": "937624"}, "output": 963427}, {"input": {"digits": "9683"}, "output": 8963}, {"input": {"digits": "56912"}, "output": 95621}, {"input": {"digits": "1"}, "output": 1}, {"input": {"digits": "36952418"}, "output": 98654123}, {"input": {"digits": "78235"}, "output": 87523}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Worros/2p2-Euler-Project", "path": "/problem-41/Sorrow/solution.py", "msgidx": 7836}}
{"problem_description": "Given a chessboard of size `n x n`, how can you place `n` queens on the board such that no two queens can attack each other? Provide all distinct solutions to the N-Queens puzzle for the given board size `n`.", "io_requirements": "Input:\n  `n` (int): The size of the board and the number of queens to place.\n\nOutput:\n  `return` (list of lists of strings): Each inner list represents a solution to the N-Queens problem. Each string in the inner list represents a row on the board, where 'Q' indicates a queen and '.' indicates an empty space.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Solves the N-Queens problem for a given board size n and returns a list of solutions.\n    Each solution is represented as a list of strings where 'Q' indicates a queen and '.' indicates an empty space.\n    \n    :param n: int, the size of the board and the number of queens to place\n    :return: list of lists of strings, each inner list represents a solution to the N-Queens problem\n    \"\"\"\n    def is_safe(board, row, col):\n        # Check this row on left side\n        for i in range(col):\n            if board[row][i] == 1:\n                return False\n        # Check upper diagonal on left side\n        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n            if board[i][j] == 1:\n                return False\n        # Check lower diagonal on left side\n        for i, j in zip(range(row, n, 1), range(col, -1, -1)):\n            if board[i][j] == 1:\n                return False\n        return True\n\n    def solve_nq_util(board, col):\n        # base case: If all queens are placed then return true\n        if col >= n:\n            return True\n        # Consider this column and try placing this queen in all rows one by one\n        for i in range(n):\n            if is_safe(board, i, col):\n                # Place this queen in board[i][col]\n                board[i][col] = 1\n                # recur to place rest of the queens\n                if solve_nq_util(board, col + 1):\n                    return True\n                # If placing queen in board[i][col] doesn't lead to a solution, then remove queen from board[i][col]\n                board[i][col] = 0\n        # if queen can not be placed in any row in this column col then return false\n        return False\n\n    def board_to_solution(board):\n        solution = []\n        for row in board:\n            solution.append(''.join('Q' if cell == 1 else '.' for cell in row))\n        return solution\n\n    board = [[0] * n for _ in range(n)]\n    if not solve_nq_util(board, 0):\n        return []\n    return [board_to_solution(board)]\n\n    # Convert the board to the desired output format\n    return [board_to_solution(board)]", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": [["..Q.", "Q...", "...Q", ".Q.."]]}, {"input": {"n": 6}, "output": [["...Q..", "Q.....", "....Q.", ".Q....", ".....Q", "..Q..."]]}, {"input": {"n": 7}, "output": [["Q......", "....Q..", ".Q.....", ".....Q.", "..Q....", "......Q", "...Q..."]]}, {"input": {"n": 5}, "output": [["Q....", "...Q.", ".Q...", "....Q", "..Q.."]]}, {"input": {"n": 10}, "output": [["Q.........", ".......Q..", ".Q........", "........Q.", ".....Q....", "..Q.......", ".........Q", "...Q......", "......Q...", "....Q....."]]}, {"input": {"n": 8}, "output": [["Q.......", "......Q.", "....Q...", ".......Q", ".Q......", "...Q....", ".....Q..", "..Q....."]]}, {"input": {"n": 9}, "output": [["Q........", "....Q....", ".Q.......", ".....Q...", "........Q", "..Q......", ".......Q.", "...Q.....", "......Q.."]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "btrif/Python_dev_repo", "path": "/Algorithms/Recursion/N Queens Problem.py", "msgidx": 7972}}
{"problem_description": "In a recursive card game, two players start with decks of cards numbered from 1 to 10. Each player draws the top card from their deck, and the player with the higher card wins the round, taking both cards and placing them at the bottom of their deck in a specific order. If a player draws a card that is greater than or equal to the number of cards remaining in their deck, they win the round immediately. The game continues until one player has all the cards. What is the score of the winning player's deck, calculated by summing the product of each card's value and its position from the bottom of the deck?", "io_requirements": "Input:\n  `p1` (list[int]): A list of integers representing the deck of player 1.\n  `p2` (list[int]): A list of integers representing the deck of player 2.\n\nOutput:\n  `return` (int): The score of the winning player's deck.", "refcode": "# import necessary packages\nfrom functools import lru_cache\nfrom collections import deque\n\n# main function\ndef main_solution(p1: list[int], p2: list[int]) -> int:\n    \"\"\"\n    Simulates a recursive card game between two players and returns the score of the winning player's deck.\n\n    Args:\n        p1 (list[int]): The deck of player 1.\n        p2 (list[int]): The deck of player 2.\n\n    Returns:\n        int: The score of the winning player's deck.\n    \"\"\"\n    def play_recursive(p1, p2):\n        \"\"\"Get the winning deck of the recursive combat game.\"\"\"\n        states_seen = set()  # List of all states seen. If repeated, p1 wins\n\n        while p1 and p2:\n            # Check for duplicate play state\n            state = str(p1) + str(p2)\n            if state in states_seen:\n                return 1, p1\n            states_seen.add(state)\n\n            a = p1.pop(0)\n            b = p2.pop(0)\n            if a > len(p1) or b > len(p2):\n                # A player does not have enough cards to recurse, high wins\n                winner = 1 if a > b else 2\n            else:\n                # Recursive play\n                winner, _ = play_recursive(p1[:a], p2[:b])\n\n            if winner == 1:\n                p1 += [a, b]\n            else:\n                p2 += [b, a]\n\n        return (1, p1) if p1 else (2, p2)\n\n    def score(deck: list[int]) -> int:\n        \"\"\"Get the score for a deck\"\"\"\n        return sum(i * card for i, card in enumerate(reversed(deck), 1))\n\n    # Play the recursive game\n    winner, hand = play_recursive(p1, p2)\n    \n    # Calculate and return the score of the winning player's deck\n    return score(hand)", "funcname": "main_solution", "ios": [{"input": {"p1": [], "p2": [2, 2, 9, 1, 7, 1, 8, 6, 5, 3]}, "output": 227}, {"input": {"p1": [9, 7, 8, 3, 3, 5, 2, 4, 9, 7, 8, 6, 4, 1, 10, 6, 5, 2], "p2": []}, "output": 987}, {"input": {"p1": [], "p2": [10, 4, 8, 2, 6, 1, 10, 5, 7, 3]}, "output": 327}, {"input": {"p1": [6, 3, 8, 5, 9, 5, 4, 3, 1, 1, 10, 6, 10, 7, 8, 2, 9, 4, 7, 2], "p2": []}, "output": 1148}, {"input": {"p1": [], "p2": [6, 1, 7, 5, 7, 1, 10, 9, 10, 2, 8, 8, 9, 3, 3, 2]}, "output": 785}, {"input": {"p1": [], "p2": [8, 7, 4, 2, 10, 7, 9, 5, 10, 3, 3, 1]}, "output": 495}, {"input": {"p1": [], "p2": [10, 7, 3, 2, 9, 1, 7, 6, 10, 8, 9, 3, 8, 5, 5, 1]}, "output": 839}, {"input": {"p1": [], "p2": [8, 6, 4, 6, 9, 4, 8, 3, 3, 1, 5, 2, 10, 9, 7, 5]}, "output": 768}, {"input": {"p1": [], "p2": [6, 6, 8, 8, 3, 2, 7, 7, 1, 2, 10, 3, 10, 1, 9, 5, 9, 4]}, "output": 954}, {"input": {"p1": [], "p2": [6, 2, 7, 7, 1, 2, 10, 6, 5, 3]}, "output": 270}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "n-Holmes/AdventOfCode2020", "path": "/Day22-CrabCombat.py", "msgidx": 7760}}
{"problem_description": "Given a grid of size `x` by `y`, how many unique paths are there from the top-left corner to the bottom-right corner if you can only move right or down? Alternatively, if the grid is symmetric (i.e., `x` equals `y`), how many unique paths are there to the diagonal point? Additionally, how many unique binary trees can be formed with `n` nodes? Lastly, given a set of coin denominations, how many ways can you make change for `n` units?", "io_requirements": "Input:\n  `problem_type` (str): A string indicating the type of problem to solve. Possible values are \"maze\", \"half_maze\", \"node\", and \"coin\".\n  `x` (int): An integer representing the x-coordinate for maze-related problems.\n  `y` (int): An integer representing the y-coordinate for maze-related problems.\n  `n` (int): An integer representing the number of nodes for the node problem or the target amount for the coin problem.\n  `coin_values` (list of int): A list of integers representing the denominations of coins for the coin problem.\n\nOutput:\n  `return` (int): An integer representing the solution to the specified problem.", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef maze(x, y):\n    if x == 0 and y == 0:\n        return 1\n    elif x > 0 and y > 0:\n        return maze(x-1, y) + maze(x, y-1)\n    elif x > 0 and y == 0:\n        return maze(x-1, y)\n    elif y > 0 and x == 0:\n        return maze(x, y-1)\n\ndef half_maze(x, y):\n    if x == 0 and y == 0:\n        return 1\n    elif x == y:\n        return maze(x, y-1)\n    elif x > 0 and y > 0:\n        return maze(x-1, y) + maze(x, y-1)\n    elif x > 0 and y == 0:\n        return maze(x-1, y)\n\ndef node(n):\n    if n == 0:\n        return 1\n    else:\n        return sum([node(i) * node(n-i-1) for i in range(0, n)])\n\ndef coin(n, arr):\n    if n == 0:\n        return 1\n    elif len(arr) == 0:\n        return 0\n    elif n < 0:\n        return 0\n    else:\n        return coin(n - arr[0], arr) + coin(n, arr[1:])\n\n# main function\ndef main_solution(problem_type, x, y, n, coin_values):\n    if problem_type == \"maze\":\n        return maze(x, y)\n    elif problem_type == \"half_maze\":\n        return half_maze(x, y)\n    elif problem_type == \"node\":\n        return node(n)\n    elif problem_type == \"coin\":\n        return coin(n, coin_values)\n    else:\n        raise ValueError(\"Invalid problem type\")", "funcname": "main_solution", "ios": [{"input": {"problem_type": "maze", "x": 9, "y": 10, "n": 7, "coin_values": [100, 1, 50, 5, 10, 500]}, "output": 92378}, {"input": {"problem_type": "coin", "x": 0, "y": 9, "n": 1, "coin_values": [500, 1, 50, 100]}, "output": 1}, {"input": {"problem_type": "coin", "x": 6, "y": 7, "n": 9, "coin_values": [5, 10, 500, 1, 50, 100]}, "output": 2}, {"input": {"problem_type": "half_maze", "x": 2, "y": 7, "n": 8, "coin_values": [1, 100, 5]}, "output": 36}, {"input": {"problem_type": "node", "x": 7, "y": 1, "n": 1, "coin_values": [100, 5]}, "output": 1}, {"input": {"problem_type": "half_maze", "x": 3, "y": 7, "n": 9, "coin_values": [10, 5, 1, 500, 50, 100]}, "output": 120}, {"input": {"problem_type": "maze", "x": 3, "y": 4, "n": 9, "coin_values": [5, 100, 1, 50, 500, 10]}, "output": 35}, {"input": {"problem_type": "maze", "x": 5, "y": 8, "n": 7, "coin_values": [5, 1, 10, 50, 100, 500]}, "output": 1287}, {"input": {"problem_type": "node", "x": 1, "y": 4, "n": 3, "coin_values": [100, 10]}, "output": 5}, {"input": {"problem_type": "node", "x": 4, "y": 9, "n": 0, "coin_values": [100, 10, 5, 50, 1, 500]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jabberwocky0139/recursion-drill", "path": "/rec06.py", "msgidx": 8042}}
{"problem_description": "In a high-temperature and pressurized chamber, a laboratory is studying the reaction of different elements with Hydrogen. Due to an unexpected power loss, the elements in the chamber started precipitating. Given the number of Carbon, Hydrogen, and Oxygen atoms in the chamber, how many molecules of Water (H2O), Carbon Dioxide (CO2), and Methane (CH4) will be produced following the order of reaction affinity?", "io_requirements": "Input:\n  `carbon_atoms` (int): The number of Carbon atoms in the chamber.\n  `hydrogen_atoms` (int): The number of Hydrogen atoms in the chamber.\n  `oxygen_atoms` (int): The number of Oxygen atoms in the chamber.\n\nOutput:\n  `return` (dict): A dictionary containing the number of molecules produced:\n    - `water_molecules` (int): The number of water molecules (H2O) produced.\n    - `carbon_dioxide_molecules` (int): The number of carbon dioxide molecules (CO2) produced.\n    - `methane_molecules` (int): The number of methane molecules (CH4) produced.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(carbon_atoms, hydrogen_atoms, oxygen_atoms):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    def burner(c, h, o):\n        water = 0\n        co2 = 0\n        methane = 0\n        carbon = c\n        hydrogen = h\n        oxygen = o\n        while hydrogen >= 2 and oxygen >= 1:\n            hydrogen += -2\n            oxygen += -1\n            water += 1\n        while carbon >= 1 and oxygen >= 2:\n            oxygen += -2\n            carbon += -1\n            co2 += 1\n        while carbon >= 1 and hydrogen >= 4:\n            hydrogen += -4\n            carbon += -1\n            methane += 1\n\n        return water, co2, methane\n    \n    # Convert JSON serializable inputs to the original input variables\n    c = carbon_atoms\n    h = hydrogen_atoms\n    o = oxygen_atoms\n    \n    # Call the burner function\n    water, co2, methane = burner(c, h, o)\n    \n    # Convert the output to JSON serializable format\n    result = {\n        \"water_molecules\": water,\n        \"carbon_dioxide_molecules\": co2,\n        \"methane_molecules\": methane\n    }\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"carbon_atoms": 820, "hydrogen_atoms": 14, "oxygen_atoms": 155}, "output": {"water_molecules": 7, "carbon_dioxide_molecules": 74, "methane_molecules": 0}}, {"input": {"carbon_atoms": 133, "hydrogen_atoms": 907, "oxygen_atoms": 925}, "output": {"water_molecules": 453, "carbon_dioxide_molecules": 133, "methane_molecules": 0}}, {"input": {"carbon_atoms": 569, "hydrogen_atoms": 181, "oxygen_atoms": 218}, "output": {"water_molecules": 90, "carbon_dioxide_molecules": 64, "methane_molecules": 0}}, {"input": {"carbon_atoms": 595, "hydrogen_atoms": 206, "oxygen_atoms": 961}, "output": {"water_molecules": 103, "carbon_dioxide_molecules": 429, "methane_molecules": 0}}, {"input": {"carbon_atoms": 798, "hydrogen_atoms": 192, "oxygen_atoms": 333}, "output": {"water_molecules": 96, "carbon_dioxide_molecules": 118, "methane_molecules": 0}}, {"input": {"carbon_atoms": 258, "hydrogen_atoms": 230, "oxygen_atoms": 64}, "output": {"water_molecules": 64, "carbon_dioxide_molecules": 0, "methane_molecules": 25}}, {"input": {"carbon_atoms": 815, "hydrogen_atoms": 814, "oxygen_atoms": 481}, "output": {"water_molecules": 407, "carbon_dioxide_molecules": 37, "methane_molecules": 0}}, {"input": {"carbon_atoms": 652, "hydrogen_atoms": 783, "oxygen_atoms": 123}, "output": {"water_molecules": 123, "carbon_dioxide_molecules": 0, "methane_molecules": 134}}, {"input": {"carbon_atoms": 461, "hydrogen_atoms": 852, "oxygen_atoms": 734}, "output": {"water_molecules": 426, "carbon_dioxide_molecules": 154, "methane_molecules": 0}}, {"input": {"carbon_atoms": 538, "hydrogen_atoms": 410, "oxygen_atoms": 964}, "output": {"water_molecules": 205, "carbon_dioxide_molecules": 379, "methane_molecules": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "caveman0612/stock-tracker-in-python", "path": "/fusion chamber shutdown.py", "msgidx": 8236}}
{"problem_description": "You are helping a group of elves assemble a sleigh based on a set of instructions. Each instruction specifies a step that must be completed before another step can begin. The steps are designated by single letters. Given the instructions, in what order should the steps be completed if more than one step is ready, and the step which is first alphabetically should be chosen?", "io_requirements": "Input:\n  `instructions` (str): A JSON string representing a list of strings. Each string contains two steps separated by a space, where the first step must be completed before the second step.\n\nOutput:\n  `return` (str): A string representing the order in which the steps should be completed, based on the given instructions.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Solution1:\n    def __init__(self, instructions):\n        self.vertices = {}\n        self.queue = []\n        self.result = \"\"\n        self.instructions = instructions\n\n        self.parse_input()\n        self.calc_indegree()\n        self.init_queue()\n\n    def insertAlphabetically(self, data):\n        step = data[0]\n        if not self.queue:\n            self.queue.append(data)\n        else:\n            index = 0\n            for item in self.queue:\n                if step > item[0]:\n                    index += 1\n                else:\n                    break\n            self.queue.insert(index, data)\n\n    def parse_input(self):\n        for line in self.instructions:\n            first_step, second_step = line.split()[1], line.split()[-3]\n            if first_step not in self.vertices:\n                self.vertices[first_step] = [0, []]\n            if second_step not in self.vertices:\n                self.vertices[second_step] = [0, []]\n            self.vertices[first_step][1].append(second_step)\n\n    def calc_indegree(self):\n        for key, value in self.vertices.items():\n            edges = self.vertices[key][1]\n            for edge in edges:\n                if edge in self.vertices:\n                    self.vertices[edge][0] += 1\n\n    def init_queue(self):\n        for key, value in self.vertices.items():\n            if value[0] == 0:\n                self.insertAlphabetically((key, value[0]))\n\n    def solve(self):\n        keep_going = True\n        while keep_going:\n            if not self.queue:\n                keep_going = False\n            else:\n                dequeuedItem = self.queue.pop(0)\n                self.result += dequeuedItem[0]\n                adjacent_edges = self.vertices[dequeuedItem[0]][1]\n                for edge in adjacent_edges:\n                    self.vertices[edge][0] -= 1\n                    if self.vertices[edge][0] == 0:\n                        self.insertAlphabetically((edge, 0))\n        return self.result\n\n# main function\ndef main_solution(instructions):\n    # Convert JSON serializable input to the original input format\n    instructions = json.loads(instructions)\n    \n    # Create an instance of the Solution1 class and solve the problem\n    solution = Solution1(instructions).solve()\n    \n    # Convert the result to a JSON serializable output\n    return solution", "funcname": "main_solution", "ios": [{"input": {"instructions": "[]"}, "output": ""}, {"input": {"instructions": "[\"Step B must be finished before step Z can begin.\"]"}, "output": "BZ"}, {"input": {"instructions": "[\"Step W must be finished before step M can begin.\"]"}, "output": "WM"}, {"input": {"instructions": "[\"Step X must be finished before step J can begin.\"]"}, "output": "XJ"}, {"input": {"instructions": "[\"Step L must be finished before step H can begin.\"]"}, "output": "LH"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "haakensonb/advent_of_code_2018", "path": "/day_7/day_7_part_1.py", "msgidx": 7703}}
{"problem_description": "Given a binary tree, how would you represent it in a 2D string array where the root node is placed in the middle of the first row, and the subtrees are printed in the left-bottom and right-bottom parts of the array? The array should follow the rules where each unused space is represented by an empty string, and the subtrees are printed recursively following the same rules.", "io_requirements": "Input:\n  `tree_nodes` (List[Any]): A list representing the binary tree in level order traversal. Each element in the list is either an integer representing the node value or `None` indicating a null node. The size of the list should be reasonable, typically less than 1KB.\n\nOutput:\n  `return` (List[List[str]]): A 2D list of strings representing the binary tree printed according to the specified rules. Each inner list represents a row in the printed tree, and each string in the inner list represents a node value or an empty string if the node is missing.", "refcode": "# import necessary packages\nimport collections\nfrom typing import List, Dict, Any\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(nodes: List[Any]) -> TreeNode:\n    if not nodes:\n        return None\n    root = TreeNode(nodes[0])\n    queue = [root]\n    i = 1\n    while queue and i < len(nodes):\n        node = queue.pop(0)\n        if nodes[i] is not None:\n            node.left = TreeNode(nodes[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(nodes) and nodes[i] is not None:\n            node.right = TreeNode(nodes[i])\n            queue.append(node.right)\n        i += 1\n    return root\n\ndef printTree(root: TreeNode) -> List[List[str]]:\n    stack = [(root, 1, 1)]\n    d = collections.defaultdict(dict)\n    max_level = 1\n    \n    while stack:\n        node, ind, level = stack.pop()\n        max_level = max(level, max_level)\n        d[level][ind] = node.val\n        \n        if node.left:\n            stack.append((node.left, 2 * (ind - 1) + 1, level + 1))\n        if node.right:\n            stack.append((node.right, 2 * (ind - 1) + 2, level + 1))\n            \n    res = [[\"\"] * (2 ** (max_level) - 1) for _ in range(max_level)]\n    \n    def traverse(level, ind, i, j):\n        if level not in d or ind not in d[level]: return\n        res[level - 1][(i + j) // 2] = str(d[level][ind])\n        traverse(level + 1, 2 * (ind - 1) + 1, i, (i + j) // 2 - 1)\n        traverse(level + 1, 2 * (ind - 1) + 2, (i + j) // 2 + 1, j)\n        \n    traverse(1, 1, 0, len(res[0]) - 1)\n    return res\n\n# main function\ndef main_solution(tree_nodes: List[Any]) -> List[List[str]]:\n    # Convert JSON serializable input to the original input variable\n    root = build_tree(tree_nodes)\n    \n    # Call the original function\n    result = printTree(root)\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_nodes": [32]}, "output": [["32"]]}, {"input": {"tree_nodes": [65]}, "output": [["65"]]}, {"input": {"tree_nodes": [97, 67, null]}, "output": [["", "97", ""], ["67", "", ""]]}, {"input": {"tree_nodes": [32, 15, 80, 15, 67, 8, 50, null, null, null, null]}, "output": [["", "", "", "32", "", "", ""], ["", "15", "", "", "", "80", ""], ["15", "", "67", "", "8", "", "50"]]}, {"input": {"tree_nodes": [99, 48, 94]}, "output": [["", "99", ""], ["48", "", "94"]]}, {"input": {"tree_nodes": [32, 20, 98, 27, 51, 17, null]}, "output": [["", "", "", "32", "", "", ""], ["", "20", "", "", "", "98", ""], ["27", "", "51", "", "17", "", ""]]}, {"input": {"tree_nodes": [34]}, "output": [["34"]]}, {"input": {"tree_nodes": [16, 92, 61, null, null]}, "output": [["", "16", ""], ["92", "", "61"]]}, {"input": {"tree_nodes": [81, 39, 96]}, "output": [["", "81", ""], ["39", "", "96"]]}, {"input": {"tree_nodes": [48, 74, 83, 22, 36]}, "output": [["", "", "", "48", "", "", ""], ["", "74", "", "", "", "83", ""], ["22", "", "36", "", "", "", ""]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "arthurDz/algorithm-studies", "path": "/linkedin/print_binary_tree.py", "msgidx": 8029}}
{"problem_description": "Given a string, determine if it meets the criteria for being classified as 'nice' or 'naughty' based on two different sets of rules. What are the classifications for the string under both sets of rules?", "io_requirements": "Input:\n  `input_str` (str): A string representing the input string to be checked for niceness criteria.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `part1` (str): The result of the first part of the check, either 'nice' or 'naughty'.\n    - `part2` (str): The result of the second part of the check, either 'nice' or 'naughty'.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef check_three_vowels(input_str):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    counter = 0\n    for char in input_str:\n        if char in vowels:\n            counter += 1\n    return counter >= 3\n\ndef check_double_letter(input_str):\n    precessor = ''\n    for char in input_str:\n        if char == precessor:\n            return True\n        precessor = char\n    return False\n\ndef check_not_forbidden_strings(input_str):\n    pattern = re.compile(\"ab|cd|pq|xy\")\n    return not bool(re.search(pattern, input_str))\n\ndef check_string(input_str):\n    if check_three_vowels(input_str) and check_double_letter(input_str) and check_not_forbidden_strings(input_str):\n        return 'nice'\n    else:\n        return 'naughty'\n\ndef indices(lst, element):\n    result = []\n    offset = -1\n    while True:\n        try:\n            offset = lst.index(element, offset+1)\n        except ValueError:\n            return result\n        result.append(offset)\n\ndef check_for_pairs(input_str):\n    valid_pair_counter = 0\n    liste = [input_str[i:i+2] for i in range(len(input_str)-1)]\n    for i in range(len(liste)):\n        match_indices = indices(liste, liste[i])\n        if len(match_indices) > 1 and (match_indices[-1] - match_indices[0] > 1):\n            valid_pair_counter += 1\n    return valid_pair_counter >= 1\n\ndef check_for_palindrom(input_str):\n    for i in range(len(input_str) - 2):\n        if input_str[i] == input_str[i+2]:\n            return True\n    return False\n\ndef check_string_2(input_str):\n    return check_for_pairs(input_str) and check_for_palindrom(input_str)\n\n# main function\ndef main_solution(input_str):\n    # Convert input to JSON serializable format if necessary\n    # No conversion needed as input_str is already a string\n    \n    # Call the core logic function\n    result_part1 = check_string(input_str)\n    result_part2 = check_string_2(input_str)\n    \n    # Convert output to JSON serializable format if necessary\n    # No conversion needed as results are already strings\n    \n    # Return the final output\n    return {\"part1\": result_part1, \"part2\": result_part2}", "funcname": "main_solution", "ios": [{"input": {"input_str": "bjsaamyrsgv"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "deredjsckayjo"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "bnwkw"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "clikqwtepxlhc"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "aadmhoownzxvy"}, "output": {"part1": "nice", "part2": false}}, {"input": {"input_str": "njwzzw"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "rbccdneglxj"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "xselhemlrwqyqvi"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "qvxxmfrndbsbrm"}, "output": {"part1": "naughty", "part2": false}}, {"input": {"input_str": "duoavwiihoo"}, "output": {"part1": "nice", "part2": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dev-mbusch/adventofcode2015", "path": "/day05_nice_string.py", "msgidx": 8349}}
{"problem_description": "In a game of Tic-Tac-Toe, given the current state of the board and the player whose turn it is, what is the outcome of the game if both players play optimally from this point onwards? Specifically, what is the value of the current game state for the current player?", "io_requirements": "Input:\n  `positions` (List[int]): A list of integers representing the current state of the Tic-Tac-Toe board. Each integer can be 0 (empty), 1 (player 1), or -1 (player -1). The list should have exactly 9 elements corresponding to the 9 positions on the board.\n  `curplayer` (int): An integer representing the current player. It can be either 1 or -1.\n\nOutput:\n  `return` (int): An integer representing the value of the current game state. The value can be 1 (if the current player can force a win), -1 (if the current player will lose), or 0 (if the game will end in a draw).", "refcode": "# import necessary packages\nfrom typing import List, Optional, Dict\nfrom abc import ABC, abstractmethod\n\n# all class and function definitions in the code file, if any\nclass GamePosition(ABC):\n    @abstractmethod\n    def value(self) -> Optional[int]:\n        pass\n\n    @abstractmethod\n    def player(self) -> int:\n        pass\n\n    @abstractmethod\n    def available_moves(self) -> List['GamePosition']:\n        pass\n\n\nclass TicTacToe(GamePosition):\n    def __init__(self, positions: List[int], curplayer: int) -> None:\n        self.positions = tuple(positions)\n        self.curplayer = curplayer\n\n    def __repr__(self) -> str:\n        return f\"({self.positions}, {self.curplayer})\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __eq__(self, another: object) -> bool:\n        return repr(self) == repr(another)\n\n    def value(self) -> Optional[int]:\n        for (a, b, c) in [(0, 1, 2), (3, 4, 5), (6, 7, 8),\n                          (0, 3, 6), (1, 4, 7), (2, 5, 8),\n                          (0, 4, 8), (2, 4, 6)]:\n            if self.positions[a] == self.positions[b] == self.positions[c] != 0:\n                return self.positions[a]\n        if all(x != 0 for x in self.positions):\n            return 0\n        return None\n\n    def available_moves(self) -> List['TicTacToe']:  # type: ignore\n        res = []\n        for i in range(9):\n            t = list(self.positions)\n            if t[i] == 0:\n                t[i] = self.curplayer\n                res.append(TicTacToe(t, 0-self.curplayer))\n        return res\n\n    def player(self) -> int:\n        return self.curplayer\n\n\nclass MinMaxSearch:\n    def __init__(self):\n        self.memo: Dict[GamePosition, int] = {}\n\n    def find_value(self, state: GamePosition):\n        if state not in self.memo:\n            val = state.value()\n            if val is None:\n                val = max(self.find_value(s) * state.player() for s in state.available_moves())\n                self.memo[state] = val * state.player()\n            else:\n                self.memo[state] = val\n        return self.memo[state]\n\n# main function\ndef main_solution(positions: List[int], curplayer: int) -> int:\n    # Convert JSON serializable inputs to the original input variables\n    game_state = TicTacToe(positions, curplayer)\n    mms = MinMaxSearch()\n    \n    # Find the value of the current game state\n    result = mms.find_value(game_state)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"positions": [0, 0, -1, 1, -1, 1, 1, -1, 0], "curplayer": -1}, "output": -1}, {"input": {"positions": [0, -1, -1, -1, 1, 0, 0, 1, -1], "curplayer": -1}, "output": -1}, {"input": {"positions": [-1, 1, 0, -1, -1, 0, 1, 0, 1], "curplayer": 1}, "output": 1}, {"input": {"positions": [0, 1, 1, 0, 1, 1, 1, -1, 0], "curplayer": -1}, "output": 1}, {"input": {"positions": [1, 1, 1, 1, 0, 1, 1, -1, -1], "curplayer": -1}, "output": 1}, {"input": {"positions": [1, 0, 0, 1, 1, -1, -1, 1, -1], "curplayer": -1}, "output": -1}, {"input": {"positions": [-1, -1, -1, -1, 1, -1, -1, -1, 0], "curplayer": -1}, "output": -1}, {"input": {"positions": [-1, 0, 1, 0, 0, 0, -1, -1, -1], "curplayer": 1}, "output": -1}, {"input": {"positions": [1, -1, 0, 1, 1, -1, -1, -1, 0], "curplayer": 1}, "output": 1}, {"input": {"positions": [0, 0, -1, -1, 1, 1, 0, 0, -1], "curplayer": -1}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chisness/aipoker", "path": "/ttt.py", "msgidx": 7902}}
{"problem_description": "In a game of chess, a knight moves in an L-shape pattern. Given a starting position and an ending position on a standard 8x8 chessboard, what is the shortest sequence of moves a knight must make to reach the target position from the starting position? The positions are denoted by a letter from 'a' to 'h' followed by a digit from '1' to '8'.", "io_requirements": "Input:\n  `start_vertex` (str): The starting position of the knight on the chessboard, represented as a string of length 2, where the first character is a letter from 'a' to 'h' and the second character is a digit from '1' to '8'.\n  `end_vertex` (str): The target position of the knight on the chessboard, represented in the same format as `start_vertex`.\n\nOutput:\n  `return` (list of str): A list of positions representing the shortest path from `start_vertex` to `end_vertex`, where each position is a string of length 2 in the same format as `start_vertex` and `end_vertex`.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\ndef add_edge(graph, v1, v2):\n    graph[v1].add(v2)\n    graph[v2].add(v1)\n\ndef build_graph():\n    letters = 'abcdefgh'  # \u0432\u0441\u0435 \u0431\u0443\u043a\u0432\u044b \u043d\u0430 \u0434\u043e\u0441\u043a\u0435\n    numbers = '12345678'  # \u0432\u0441\u0435 \u0446\u0438\u0444\u0440\u044b \u043d\u0430 \u0434\u043e\u0441\u043a\u0435\n    graph = {l + n: set() for l in letters for n in numbers}\n\n    # \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0445\u043e\u0434\u044b \u043a\u043e\u043d\u044f\n    for i in range(len(letters)):\n        for j in range(len(numbers)):\n            v1 = letters[i] + numbers[j]\n            if 0 <= i + 2 < len(letters) and 0 <= j + 1 < len(numbers):\n                v2 = letters[i + 2] + numbers[j + 1]\n                add_edge(graph, v1, v2)\n            if 0 <= i - 2 < len(letters) and 0 <= j + 1 < len(numbers):\n                v2 = letters[i - 2] + numbers[j + 1]\n                add_edge(graph, v1, v2)\n            if 0 <= i + 1 < len(letters) and 0 <= j + 2 < len(numbers):\n                v2 = letters[i + 1] + numbers[j + 2]\n                add_edge(graph, v1, v2)\n            if 0 <= i - 1 < len(letters) and 0 <= j + 2 < len(numbers):\n                v2 = letters[i - 1] + numbers[j + 2]\n                add_edge(graph, v1, v2)\n    return graph\n\n# main function\ndef main_solution(start_vertex, end_vertex):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    graph = build_graph()\n    distance = {v: None for v in graph}\n    parents = {v: None for v in graph}\n    distance[start_vertex] = 0\n    queue = deque([start_vertex])\n\n    while queue:\n        cur_v = queue.popleft()\n        for neigh_v in graph[cur_v]:\n            if distance[neigh_v] is None:\n                distance[neigh_v] = distance[cur_v] + 1\n                parents[neigh_v] = cur_v\n                queue.append(neigh_v)\n\n    path = [end_vertex]\n    parent = parents[end_vertex]\n    while parent is not None:\n        path.append(parent)\n        parent = parents[parent]\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return path[::-1]", "funcname": "main_solution", "ios": [{"input": {"start_vertex": "g4", "end_vertex": "g8"}, "output": ["g4", "h6", "g8"]}, {"input": {"start_vertex": "c2", "end_vertex": "b4"}, "output": ["c2", "b4"]}, {"input": {"start_vertex": "a5", "end_vertex": "e1"}, "output": ["a5", "c4", "e3", "g2", "e1"]}, {"input": {"start_vertex": "a5", "end_vertex": "h6"}, "output": ["a5", "c4", "e3", "g4", "h6"]}, {"input": {"start_vertex": "b2", "end_vertex": "c8"}, "output": ["b2", "c4", "b6", "c8"]}, {"input": {"start_vertex": "a8", "end_vertex": "h5"}, "output": ["a8", "b6", "d5", "f4", "h5"]}, {"input": {"start_vertex": "d3", "end_vertex": "b8"}, "output": ["d3", "e5", "c6", "b8"]}, {"input": {"start_vertex": "h5", "end_vertex": "d3"}, "output": ["h5", "f4", "d3"]}, {"input": {"start_vertex": "b3", "end_vertex": "e1"}, "output": ["b3", "c5", "d3", "e1"]}, {"input": {"start_vertex": "g3", "end_vertex": "e2"}, "output": ["g3", "e2"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shura08g/Python", "path": "/Practics/horse.py", "msgidx": 7618}}
{"problem_description": "Given a binary tree and a list of nodes, determine the mirror nodes for each of the given nodes. The mirror node of a node is defined as the node that is symmetrically opposite to it in the tree. If a mirror node does not exist, indicate so. What are the mirror nodes for the given list of nodes in the binary tree?", "io_requirements": "Input:\n- `N` (int): The number of nodes in the binary tree.\n- `Q` (int): The number of queries to find the mirror nodes.\n- `X` (int): The root node key of the binary tree.\n- `data` (list of strings): A list of strings where each string represents a node relationship in the format \"parent child side\" (e.g., \"2 3 R\" means node 2 has a right child 3).\n- `queries` (list of strings): A list of node keys for which the mirror nodes need to be found.\n\nOutput:\n- `return` (list of strings): A list of strings where each string is the result of the mirror query. If a mirror node exists, it returns the key of the mirror node; otherwise, it returns \"Not Exist\".", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node: \n    '''A binary tree node has data, reference to left child \n        and a reference to right child '''\n\n    def __init__(self, key, lchild=None, rchild=None): \n        self.key = key \n        self.lchild = None\n        self.rchild = None\n\ndef formNodes(data, root):\n    L = R = False\n    for i in range(len(data)):\n        perent, child, side = data[i].values()\n        if perent == root.key:\n            if side == 'L':\n                root.lchild = formNodes(data[:i] + data[i+1:], Node(child))\n                L = True\n            elif side == 'R':\n                root.rchild = formNodes(data[:i] + data[i+1:], Node(child))\n                R = True\n        if L and R:\n            break\n    return root\n        \n# recursive function to find mirror \ndef findMirrorRec(target, left, right): \n\n    # If any of the node is none then node itself \n    # and decendent have no mirror, so return \n    # none, no need to further explore! \n    if left == None or right == None: \n        return None\n\n    # if left node is target node, then return \n    # right's key (that is mirror) and vice versa \n    if left.key == target: \n        return right.key \n    if right.key == target: \n        return left.key \n\n    # first recur external nodes \n    mirror_val = findMirrorRec(target, left.lchild, right.rchild) \n    if mirror_val != None: \n        return mirror_val \n\n    # if no mirror found, recur internal nodes \n    return findMirrorRec(target, left.rchild, right.lchild) \n\n# interface for mirror search \ndef findMirror(root, target): \n    if root == None: \n        return None\n\n    if root.key == target: \n        return target \n\n    return findMirrorRec(target, root.lchild, root.rchild) \n\n# main function\ndef main_solution(N, Q, X, data, queries):\n    # Convert JSON serializable inputs to original input variables\n    data = [dict(zip(['perent', 'child', 'side'], d.split())) for d in data]\n    queries = [q for q in queries]\n\n    # Form the binary tree\n    root = formNodes(data, Node(str(X)))\n\n    # Find mirrors for each query\n    results = []\n    for query in queries:\n        mirror = findMirror(root, query)\n        results.append(mirror if mirror else 'Not Exist')\n\n    # Return the results as a JSON serializable output\n    return results", "funcname": "main_solution", "ios": [{"input": {"N": 5, "Q": 3, "X": 2, "data": ["4 5 L", "5 2 R", "2 1 L", "1 3 L"], "queries": [5, 3, 4]}, "output": ["Not Exist", "Not Exist", "Not Exist"]}, {"input": {"N": 5, "Q": 2, "X": 2, "data": ["4 2 L", "2 1 R", "1 3 L", "3 5 R"], "queries": [1, 5]}, "output": ["Not Exist", "Not Exist"]}, {"input": {"N": 5, "Q": 1, "X": 4, "data": ["5 2 L", "2 4 R", "4 3 R", "3 1 L"], "queries": [3]}, "output": ["Not Exist"]}, {"input": {"N": 5, "Q": 3, "X": 2, "data": ["4 3 R", "3 2 R", "2 1 R", "1 5 R"], "queries": [5, 4, 3]}, "output": ["Not Exist", "Not Exist", "Not Exist"]}, {"input": {"N": 5, "Q": 3, "X": 4, "data": ["4 1 R", "1 2 L", "2 5 R", "5 3 R"], "queries": [1, 3, 5]}, "output": ["Not Exist", "Not Exist", "Not Exist"]}, {"input": {"N": 5, "Q": 4, "X": 4, "data": ["3 2 R", "2 5 R", "5 1 R", "1 4 R"], "queries": [3, 5, 2, 4]}, "output": ["Not Exist", "Not Exist", "Not Exist", "Not Exist"]}, {"input": {"N": 5, "Q": 4, "X": 1, "data": ["5 2 L", "2 1 R", "1 4 L", "4 3 L"], "queries": [4, 2, 1, 5]}, "output": ["Not Exist", "Not Exist", "Not Exist", "Not Exist"]}, {"input": {"N": 6, "Q": 1, "X": 6, "data": ["5 4 R", "4 3 L", "3 2 R", "2 6 R", "6 1 L"], "queries": [6]}, "output": ["Not Exist"]}, {"input": {"N": 5, "Q": 1, "X": 5, "data": ["4 5 R", "5 1 R", "1 2 R", "2 3 R"], "queries": [5]}, "output": ["Not Exist"]}, {"input": {"N": 5, "Q": 3, "X": 2, "data": ["2 3 L", "3 5 L", "5 4 R", "4 1 R"], "queries": [3, 4, 1]}, "output": ["Not Exist", "Not Exist", "Not Exist"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Drahushchak/TestRepository", "path": "/test3.py", "msgidx": 8085}}
{"problem_description": "Given a series of movement commands for a chain of 10 segments, where each segment follows the previous one according to specific rules, how many unique positions does the tail of the chain visit after executing all the commands?", "io_requirements": "Input:\n  `movements` (list of strings): A list of movement commands where each string is in the format \"DIRECTION AMOUNT\". The `DIRECTION` can be one of 'U' (up), 'D' (down), 'L' (left), 'R' (right), 'UL' (up-left), 'UR' (up-right), 'DL' (down-left), 'DR' (down-right). The `AMOUNT` is an integer representing the number of steps in the given direction.\n\nOutput:\n  `return` (int): The number of unique positions visited by the tail of the chain.", "refcode": "# import necessary packages\nimport re\nimport collections\nimport itertools\nimport functools\nimport math\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef move_chain(direction, chain):\n    if len(chain) == 0:\n        return\n    if direction == '':\n        return\n    head_pos = chain[0]\n    tail_pos = chain[1] if len(chain) > 1 else [0,0]\n    tail_dir = ''\n    if direction[0] == 'U':\n        head_pos[1] += 1\n        if len(direction) == 2:\n            if direction[1] == 'L':\n                head_pos[0] -= 1\n            elif direction[1] == 'R':\n                head_pos[0] += 1\n        if head_pos[1] - tail_pos[1] > 1:\n            tail_dir = 'U'\n        if math.dist(head_pos, tail_pos) > 2:\n            if tail_pos[0] > head_pos[0]:\n                tail_dir = 'UL'\n            elif tail_pos[0] < head_pos[0]:\n                tail_dir = 'UR'\n        move_chain(tail_dir, chain[1:])\n    elif direction[0] == 'D':\n        head_pos[1] -= 1\n        if len(direction) == 2:\n            if direction[1] == 'L':\n                head_pos[0] -= 1\n            elif direction[1] == 'R':\n                head_pos[0] += 1\n        if tail_pos[1] - head_pos[1] > 1:\n            tail_dir = 'D'\n        if math.dist(head_pos, tail_pos) > 2:\n            if tail_pos[0] > head_pos[0]:\n                tail_dir = 'DL'\n            elif tail_pos[0] < head_pos[0]:\n                tail_dir = 'DR'\n        move_chain(tail_dir, chain[1:])\n    elif direction[0] == 'R':\n        head_pos[0] += 1\n        if head_pos[0] - tail_pos[0] > 1:\n            tail_dir = 'R'\n        if math.dist(head_pos, tail_pos) > 2:\n            if tail_pos[1] > head_pos[1]:\n                tail_dir = 'DR'\n            elif tail_pos[1] < head_pos[1]:\n                tail_dir = 'UR'\n        move_chain(tail_dir, chain[1:])\n    elif direction[0] == 'L':\n        head_pos[0] -= 1\n        if tail_pos[0] - head_pos[0] > 1:\n            tail_dir = 'L'\n        if math.dist(head_pos, tail_pos) > 2:\n            if tail_pos[1] > head_pos[1]:\n                tail_dir = 'DL'\n            elif tail_pos[1] < head_pos[1]:\n                tail_dir = 'UL'\n        move_chain(tail_dir, chain[1:])\n\n# main function\ndef main_solution(movements):\n    chain = [[0,0] for i in range(10)]\n    tail_visited = set()\n    tail_visited.add((0,0))\n    for movement in movements:\n        direction, amount = movement.split(' ')\n        amount = int(amount)\n        for _ in range(amount):\n            move_chain(direction, chain)\n            tail_visited.add(tuple(chain[9]))\n    return len(tail_visited)", "funcname": "main_solution", "ios": [{"input": {"movements": ["UL 4", "DR 3", "L 3", "DR 5", "L 2", "L 2", "DR 3", "UR 1"]}, "output": 1}, {"input": {"movements": ["U 1", "D 5", "R 3", "DL 4", "R 3", "UR 2", "L 1", "UL 3", "DR 1", "UL 3"]}, "output": 1}, {"input": {"movements": ["DL 3", "U 4", "UL 1", "UR 4", "U 4", "R 3", "DL 2"]}, "output": 3}, {"input": {"movements": ["L 1", "UL 3", "D 5", "DR 2", "R 3"]}, "output": 1}, {"input": {"movements": ["L 2", "L 3", "UR 5", "U 4", "DL 2", "UL 2", "DL 2", "R 1", "DR 4", "D 5"]}, "output": 3}, {"input": {"movements": ["DL 4", "L 4", "U 1", "DL 2", "R 2", "R 3", "UR 2", "D 4", "UR 5", "D 3"]}, "output": 1}, {"input": {"movements": ["D 4", "U 3", "DR 5", "UL 2", "R 1", "UR 5", "DR 3"]}, "output": 1}, {"input": {"movements": ["L 4", "U 2", "DL 2", "D 5", "UR 4", "U 2", "D 1", "L 4", "DL 2"]}, "output": 1}, {"input": {"movements": ["DR 2", "D 5", "D 2", "R 4", "DR 3", "L 1", "R 3", "UR 5", "UL 4"]}, "output": 7}, {"input": {"movements": ["DL 3", "DR 1", "R 3", "R 4", "L 5", "U 5", "D 4"]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cheahjs/adventofcode", "path": "/2022/9/code-2-abandoned.py", "msgidx": 8326}}
{"problem_description": "Given a string of characters, what are all the possible unique rearrangements (anagrams) of the string?", "io_requirements": "Input:\n  `mystr` (str): A string of characters for which all possible anagrams (permutations) need to be generated.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique anagram of the input string `mystr`.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(mystr):\n    # Convert the input string to a list of characters\n    mystr = list(mystr)\n    \n    # Generate all permutations of the list of characters\n    finalList = list(itertools.permutations(mystr))\n    \n    # Convert each permutation tuple to a list and join the characters to form strings\n    finalList = [''.join(item) for item in finalList]\n    \n    # Return the list of anagrams\n    return finalList", "funcname": "main_solution", "ios": [{"input": {"mystr": "yls"}, "output": ["yls", "ysl", "lys", "lsy", "syl", "sly"]}, {"input": {"mystr": "lqf"}, "output": ["lqf", "lfq", "qlf", "qfl", "flq", "fql"]}, {"input": {"mystr": "bcv"}, "output": ["bcv", "bvc", "cbv", "cvb", "vbc", "vcb"]}, {"input": {"mystr": "mci"}, "output": ["mci", "mic", "cmi", "cim", "imc", "icm"]}, {"input": {"mystr": "nvs"}, "output": ["nvs", "nsv", "vns", "vsn", "snv", "svn"]}, {"input": {"mystr": "gxc"}, "output": ["gxc", "gcx", "xgc", "xcg", "cgx", "cxg"]}, {"input": {"mystr": "sts"}, "output": ["sts", "sst", "tss", "tss", "sst", "sts"]}, {"input": {"mystr": "lhn"}, "output": ["lhn", "lnh", "hln", "hnl", "nlh", "nhl"]}, {"input": {"mystr": "kel"}, "output": ["kel", "kle", "ekl", "elk", "lke", "lek"]}, {"input": {"mystr": "dfm"}, "output": ["dfm", "dmf", "fdm", "fmd", "mdf", "mfd"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mayankagg9722/Placement-Preparation", "path": "/anagram.py", "msgidx": 7798}}
{"problem_description": "Given a set of digits from 0 to 9, what is the sum of all pandigital numbers that can be formed using these digits and satisfy the following sub-string divisibility property:\n- The number formed by the 2nd, 3rd, and 4th digits is divisible by 2.\n- The number formed by the 3rd, 4th, and 5th digits is divisible by 3.\n- The number formed by the 4th, 5th, and 6th digits is divisible by 5.\n- The number formed by the 5th, 6th, and 7th digits is divisible by 7.\n- The number formed by the 6th, 7th, and 8th digits is divisible by 11.\n- The number formed by the 7th, 8th, and 9th digits is divisible by 13.\n- The number formed by the 8th, 9th, and 10th digits is divisible by 17.\n\n(Note: The digits should be provided in a list format, where each digit is a unique integer from 0 to 9.)", "io_requirements": "Input:\n  `digits` (list of int): A list of integers representing the digits 0 through 9. The list should always contain exactly 10 elements, each being a unique digit from 0 to 9.\n\nOutput:\n  `return` (int): The sum of all pandigital numbers that satisfy the sub-string divisibility property.", "refcode": "# import necessary packages\nimport itertools\nfrom functools import reduce\n\n# main function\ndef main_solution(digits):\n    \"\"\"\n    Finds the sum of all 0 to 9 pandigital numbers that satisfy the sub-string divisibility property.\n\n    Args:\n        digits (list of int): A list of integers representing the digits 0 through 9.\n\n    Returns:\n        int: The sum of all pandigital numbers that satisfy the sub-string divisibility property.\n    \"\"\"\n    pd_nums = []\n    all_perms = list(itertools.permutations(digits))\n\n    for perm in all_perms:\n        if (perm[3] % 2) != 0:\n            continue\n        if (reduce(lambda x, y: x * 10 + y, perm[2:5]) % 3) != 0:\n            continue\n        if (perm[5] % 5) != 0:\n            continue\n        if (reduce(lambda x, y: x * 10 + y, perm[4:7]) % 7) != 0:\n            continue\n        if (reduce(lambda x, y: x * 10 + y, perm[5:8]) % 11) != 0:\n            continue\n        if (reduce(lambda x, y: x * 10 + y, perm[6:9]) % 13) != 0:\n            continue\n        if (reduce(lambda x, y: x * 10 + y, perm[7:10]) % 17) != 0:\n            continue\n\n        pd_nums.append(reduce(lambda x, y: x * 10 + y, perm))\n\n    return sum(pd_nums)", "funcname": "main_solution", "ios": [{"input": {"digits": [8, 0, 2, 9, 3, 7, 4, 6, 5, 1]}, "output": 16695334890}, {"input": {"digits": [7, 2, 8, 5, 1, 3, 4, 6, 0, 9]}, "output": 16695334890}, {"input": {"digits": [6, 5, 7, 3, 0, 9, 8, 2, 1, 4]}, "output": 16695334890}, {"input": {"digits": [2, 0, 3, 6, 4, 1, 7, 5, 9, 8]}, "output": 16695334890}, {"input": {"digits": [4, 8, 0, 7, 1, 5, 6, 2, 3, 9]}, "output": 16695334890}, {"input": {"digits": [5, 9, 3, 6, 1, 7, 4, 0, 2, 8]}, "output": 16695334890}, {"input": {"digits": [8, 1, 4, 0, 6, 9, 3, 7, 5, 2]}, "output": 16695334890}, {"input": {"digits": [0, 8, 9, 7, 5, 6, 2, 3, 4, 1]}, "output": 16695334890}, {"input": {"digits": [6, 7, 4, 1, 8, 9, 0, 2, 5, 3]}, "output": 16695334890}, {"input": {"digits": [9, 7, 3, 0, 1, 8, 4, 6, 2, 5]}, "output": 16695334890}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KyleRoarty/project_euler", "path": "/python/p043.py", "msgidx": 8059}}
{"problem_description": "Ada is a spy trying to find the safest places in a city to hide from enemy agents. The city is represented as an NxN grid, and the locations of the enemy agents are known. Given the locations of the agents, where should Ada hide to maximize her safety? What are the safest places in the city for Ada to hide?", "io_requirements": "Input:\n- `agents` (list of str): A list of alphanumeric coordinates where agents are located, e.g., ['A6', 'E3']. Each coordinate should be in the format of a letter followed by a number, where the letter represents the row and the number represents the column.\n- `city_size` (int): The size of the city grid, default is 10. This represents an NxN grid where N is the value of `city_size`.\n\nOutput:\n- `return` (str): A message indicating the safest places for Ada to hide or a special message if no safe places are found. The message can be one of the following:\n  - A list of alphanumeric coordinates (e.g., ['B2', 'C4']) indicating the safest places.\n  - \"The whole city is safe for Ada! :-)\" if the entire city is safe.\n  - \"There are no safe locations for Ada! :-(\" if no safe locations are found.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass SafetyFinder:\n    \"\"\"A class that contains everything we need to find the\n    safest places in the city for Ada to hide out\n    \"\"\"\n\n    def convert_coordinates(self, agents):\n        \"\"\"This method should take a list of alphanumeric coordinates (e.g. 'A6')\n        and return an array of the coordinates converted to arrays with zero-indexing.\n        For instance, 'A6' should become [0, 5]\n\n        Arguments:\n        agents -- a list-like object containing alphanumeric coordinates.\n\n        Returns a list of coordinates in zero-indexed vector form.\n        \"\"\"\n\n        def convert_coordinate(coordinate):\n            letter, digit = coordinate[0], coordinate[1:]\n            return [ord(letter) - 65, int(digit) - 1]\n\n        return [convert_coordinate(coordinate) for coordinate in agents]\n\n    def convert_coordinates_inverse(self, agents):\n        return [chr(x + 65) + str(y + 1) for x, y in agents]\n\n    def propagate(self, coords, field, n, i):\n        next_coords = set()\n        for x, y in coords:\n            field[x][y] = i\n            if x > 0:\n                next_coords.add((x - 1, y))\n            if x < n - 1:\n                next_coords.add((x + 1, y))\n            if y > 0:\n                next_coords.add((x, y - 1))\n            if y < n - 1:\n                next_coords.add((x, y + 1))\n        next_coords -= {(x, y) for x, y in next_coords if field[x][y]}\n        if next_coords:\n            self.propagate(next_coords, field, n, i + 1)\n\n    def find_safe_spaces(self, agents, n=10):\n\n        \"\"\"This method will take an array with agent locations and find\n        the safest places in the city for Ada to hang out.\n\n        Arguments:\n        agents -- a list-like object containing the map coordinates of agents.\n            Each entry should be formatted in indexed vector form,\n            e.g. [0, 5], [3, 7], etc.\n\n        Returns a list of safe spaces in indexed vector form.\n        \"\"\"\n\n        field = np.zeros((n, n))\n        agents = [(x, y) for x, y in agents if x < n and y < n]\n        if len(agents) == n * n:\n            return []\n        for x, y in agents:\n            field[x, y] = 1\n        self.propagate(agents, field, n, 2)\n        return np.argwhere(field == field.max()).tolist()\n\n    def advice_for_ada(self, agents, l=10):\n        \"\"\"This method will take an array with agent locations and offer advice\n        to Ada for where she should hide out in the city, with special advice for\n        edge cases.\n\n        Arguments:\n        agents -- a list-like object containing the map coordinates of the agents.\n            Each entry should be formatted in alphanumeric form, e.g. A10, E6, etc.\n\n        Returns either a list of alphanumeric map coordinates for Ada to hide in,\n        or a specialized message informing her of edge cases\n        \"\"\"\n        numeric_agents = self.convert_coordinates(agents)\n        save_spaces = self.find_safe_spaces(numeric_agents, l)\n        if save_spaces:\n            if len(save_spaces) == l ** 2:\n                return 'The whole city is safe for Ada! :-)'\n            return self.convert_coordinates_inverse(save_spaces)\n        return 'There are no safe locations for Ada! :-('\n\n# main function\ndef main_solution(agents, city_size=10):\n    \"\"\"\n    This function finds the safest places in the city for Ada to hide out based on the locations of agents.\n\n    Arguments:\n    agents (list of str): A list of alphanumeric coordinates where agents are located, e.g., ['A6', 'E3'].\n    city_size (int): The size of the city grid, default is 10.\n\n    Returns:\n    str: A message indicating the safest places for Ada to hide or a special message if no safe places are found.\n    \"\"\"\n    safety_finder = SafetyFinder()\n    advice = safety_finder.advice_for_ada(agents, city_size)\n    return advice", "funcname": "main_solution", "ios": [{"input": {"agents": ["C7", "C5", "G2", "E7", "F5", "D6", "D5", "G3"], "city_size": 7}, "output": ["A1"]}, {"input": {"agents": ["A2", "B2", "C5", "B2"], "city_size": 5}, "output": ["E1", "E3"]}, {"input": {"agents": ["C3"], "city_size": 6}, "output": ["F6"]}, {"input": {"agents": ["B3", "B1", "D4", "E3", "B2"], "city_size": 5}, "output": ["A5"]}, {"input": {"agents": ["B1", "D2"], "city_size": 5}, "output": ["A5"]}, {"input": {"agents": ["F7"], "city_size": 9}, "output": ["A1"]}, {"input": {"agents": ["E5", "C5", "C5", "A4", "C4", "F1"], "city_size": 6}, "output": ["B1"]}, {"input": {"agents": ["A4", "B5", "E3", "C6", "C2", "D6"], "city_size": 6}, "output": ["A1", "F1", "F5"]}, {"input": {"agents": ["A3", "A3", "A1", "C5"], "city_size": 5}, "output": ["E2"]}, {"input": {"agents": ["E7", "A7", "A2", "C6"], "city_size": 7}, "output": ["G1"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "falcowinkler/ada-lovelace-coding-challenge", "path": "/python/safe_spaces.py", "msgidx": 8253}}
{"problem_description": "In a circle of Elves, each Elf steals presents from the Elf directly across the circle. The Elves with no presents are removed, and the remaining Elves move in to keep the circle evenly spaced. Given the number of Elves, which Elf will end up with all the presents?", "io_requirements": "Input:\n  `t` (int): The number of Elves in the circle.\n\nOutput:\n  `return` (int): The position of the Elf that gets all the presents.", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# main function\ndef main_solution(t):\n    \"\"\"\n    Specialized Josephus function to determine which Elf gets all the presents.\n\n    Args:\n    t (int): The number of Elves in the circle.\n\n    Returns:\n    int: The position of the Elf that gets all the presents.\n    \"\"\"\n    return reduce(lambda j, n: (j + int(j >= n//2)) % n+1, range(2, t+1), 1)", "funcname": "main_solution", "ios": [{"input": {"t": 51}, "output": 24}, {"input": {"t": 5898}, "output": 5235}, {"input": {"t": 5539}, "output": 4517}, {"input": {"t": 6406}, "output": 6251}, {"input": {"t": 8770}, "output": 2209}, {"input": {"t": 7578}, "output": 1017}, {"input": {"t": 5032}, "output": 3503}, {"input": {"t": 7207}, "output": 646}, {"input": {"t": 8981}, "output": 2420}, {"input": {"t": 877}, "output": 148}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "amlinger/AdventOfCode", "path": "/2016/python/day19/part2.py", "msgidx": 8553}}
{"problem_description": "Given two jugs with capacities `x` liters and `y` liters, and an unlimited supply of water, is it possible to measure exactly `z` liters of water using these two jugs? You can perform the following operations: fill any jug completely, empty any jug, or pour water from one jug to the other until one of the jugs is either full or empty. Can you determine if it is possible to measure exactly `z` liters of water using these operations?", "io_requirements": "Input:\n  `x` (int): The capacity of the first jug in liters.\n  `y` (int): The capacity of the second jug in liters.\n  `z` (int): The desired amount of water in liters.\n\nOutput:\n  `return` (bool): `True` if it is possible to measure exactly `z` liters using the two jugs, otherwise `False`.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(x: int, y: int, z: int) -> bool:\n    # Ensure the inputs are JSON serializable\n    x = int(x)\n    y = int(y)\n    z = int(z)\n    \n    # Check if it's possible to measure exactly z liters using the two jugs\n    if x + y < z:\n        return False\n    if x == 0 or y == 0:\n        return z == 0 or x + y == z\n    return z % math.gcd(x, y) == 0", "funcname": "main_solution", "ios": [{"input": {"x": 54, "y": 1, "z": 135}, "output": false}, {"input": {"x": 98, "y": 44, "z": 101}, "output": false}, {"input": {"x": 8, "y": 58, "z": 200}, "output": false}, {"input": {"x": 83, "y": 33, "z": 38}, "output": true}, {"input": {"x": 94, "y": 17, "z": 73}, "output": true}, {"input": {"x": 63, "y": 78, "z": 24}, "output": true}, {"input": {"x": 58, "y": 87, "z": 162}, "output": false}, {"input": {"x": 99, "y": 9, "z": 126}, "output": false}, {"input": {"x": 28, "y": 67, "z": 171}, "output": false}, {"input": {"x": 20, "y": 92, "z": 30}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Dawyer/Code", "path": "/problems/LeetCode/LeetCode365. \u6c34\u58f6\u95ee\u9898.py", "msgidx": 7981}}
{"problem_description": "Given a spiral grid of size `spiral_size` by `spiral_size`, where the numbers are filled in a clockwise direction starting from 1, what is the sum of the numbers on the diagonals of the spiral?", "io_requirements": "Input:\n  `spiral_size` (int): The size of the spiral (an odd integer). For example, for a 5x5 spiral, `spiral_size` would be 5.\n\nOutput:\n  `return` (dict): A dictionary containing the sum of the numbers in the diagonals of the spiral. The key is `\"diagonal_sum\"` and the value is an integer representing the sum.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(spiral_size):\n    # Convert the input to an integer\n    spiral_size = int(spiral_size)\n    \n    # Initialize the list to store the sums of the diagonals\n    s = [1]\n    n = 0\n    r = [1]\n    \n    # Generate the spiral and calculate the sums of the diagonals\n    while n < spiral_size - 1:\n        n += 2\n        for i in range(4):\n            s += [n]\n            r += [sum(s)]\n    \n    # Calculate the sum of the diagonals\n    diagonal_sum = sum(r)\n    \n    # Return the result as a JSON serializable output\n    return {\"diagonal_sum\": diagonal_sum}", "funcname": "main_solution", "ios": [{"input": {"spiral_size": 923}, "output": {"diagonal_sum": 524647505}}, {"input": {"spiral_size": 549}, "output": {"diagonal_sum": 110464197}}, {"input": {"spiral_size": 249}, "output": {"diagonal_sum": 10323497}}, {"input": {"spiral_size": 887}, "output": {"diagonal_sum": 465637301}}, {"input": {"spiral_size": 65}, "output": {"diagonal_sum": 185281}}, {"input": {"spiral_size": 915}, "output": {"diagonal_sum": 511127081}}, {"input": {"spiral_size": 271}, "output": {"diagonal_sum": 13305421}}, {"input": {"spiral_size": 757}, "output": {"diagonal_sum": 289486261}}, {"input": {"spiral_size": 803}, "output": {"diagonal_sum": 345511225}}, {"input": {"spiral_size": 291}, "output": {"diagonal_sum": 16470841}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Braxalend/ProjectEuler", "path": "/SourceCode/Task28.py", "msgidx": 8614}}
{"problem_description": "Given four cards, each containing a number from 1 to 9, can you determine if it is possible to use the operations multiplication, division, addition, and subtraction (with parentheses allowed) to combine these numbers to achieve a final result of exactly 24?", "io_requirements": "Input:\n  `nums` (List[int]): A list of 4 integers, each ranging from 1 to 9.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the numbers in the list can be combined using the operations *, /, +, -, (, ) to result in the value 24.", "refcode": "# import necessary packages\nimport math\nfrom typing import List\n\n# main function\ndef main_solution(nums: List[int]) -> bool:\n    # Convert the input list of integers to a list of floats\n    nums = [float(num) for num in nums]\n    \n    def dfs(arr):\n        if len(arr) == 1:\n            return math.isclose(arr[0], 24.0)\n        \n        nex = [(i, t) for i in range(len(arr) - 1) for t in range(i + 1, len(arr))]\n        for x, y in nex:\n            rest = [i for i in range(len(arr)) if i != x and i != y]\n            for operator in [\"*\", \"/\", \"+\", \"-\"]:\n                if operator != '/' or arr[y] != 0:\n                    new_arr = [eval(\"%s%sfloat(%s)\" % (arr[x], operator, float(arr[y])))] + [arr[t] for t in rest]                \n                    if dfs(new_arr): return True\n                \n                if operator in [\"/\", \"-\"]:\n                    if operator != '/' or arr[x] != 0:\n                        new_arr = [eval(\"%s%sfloat(%s)\" % (arr[y], operator, arr[x]))] + [arr[t] for t in rest]                \n                        if dfs(new_arr): return True\n                    \n        return False\n    \n    return dfs(nums)", "funcname": "main_solution", "ios": [{"input": {"nums": [3, 7, 7, 1]}, "output": true}, {"input": {"nums": [3, 9, 8, 9]}, "output": true}, {"input": {"nums": [9, 7, 4, 8]}, "output": true}, {"input": {"nums": [9, 5, 5, 2]}, "output": true}, {"input": {"nums": [9, 6, 6, 1]}, "output": true}, {"input": {"nums": [9, 7, 3, 3]}, "output": true}, {"input": {"nums": [8, 9, 6, 8]}, "output": true}, {"input": {"nums": [4, 3, 1, 5]}, "output": true}, {"input": {"nums": [2, 8, 3, 3]}, "output": true}, {"input": {"nums": [9, 3, 7, 5]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "arthurDz/algorithm-studies", "path": "/microsoft/24_game.py", "msgidx": 8035}}
{"problem_description": "Given a positive integer `n`, what is the pattern of the 2D array formed by filling it in a spiral order starting from the top-left corner and moving right, down, left, and up in a cyclic manner?", "io_requirements": "Input:\n  `n` (int): The size of the 2D array (spiral). It should be a positive integer.\n\nOutput:\n  `return` (str): A JSON serialized string representing the 2D spiral array. Each element in the array is an integer.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef create_spiral(n):\n    spiral = [[0] * n for _ in range(n)]\n    row = col = direction = 0\n    row_dir = [0, 1, 0, -1]\n    col_dir = [1, 0, -1, 0]\n\n    for val in range(1, n * n + 1):\n        spiral[row][col] = val\n\n        row += row_dir[direction]\n        col += col_dir[direction]\n\n        if coor_invalid(spiral, row, col):\n            row -= row_dir[direction]\n            col -= col_dir[direction]\n\n            direction = (direction + 1) % 4\n\n            row += row_dir[direction]\n            col += col_dir[direction]\n\n    return spiral\n\n\ndef coor_invalid(spiral, row, col):\n    return (\n        (row < 0) or (row >= len(spiral)) or (col < 0) or (\n            col >= len(spiral)) or (spiral[row][col] != 0)\n    )\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required format\n    n = int(n)\n    \n    # Call the function to create the spiral\n    spiral = create_spiral(n)\n    \n    # Convert the output to JSON serializable format\n    spiral_json = json.dumps(spiral)\n    \n    return spiral_json", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": "[[1]]"}, {"input": {"n": 3}, "output": "[[1, 2, 3], [8, 9, 4], [7, 6, 5]]"}, {"input": {"n": 4}, "output": "[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]"}, {"input": {"n": 2}, "output": "[[1, 2], [4, 3]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ameeli/algorithms", "path": "/interview_prep/create_spiral_array.py", "msgidx": 8520}}
{"problem_description": "Sara is organizing an event and needs to find a special pitch number for the event. The pitch number `x` is a number between 1 and `max_amount` such that the sum of its divisors (excluding `x` itself) is greater than `x`, and no subset of these divisors adds up to exactly `x`. What is the first such pitch number within the specified range?", "io_requirements": "Input:\n  `max_amount` (int): The upper limit of the range within which to search for the number. It should be a positive integer.\n\nOutput:\n  `return` (int or None): The first number within the range [1, max_amount] that satisfies the conditions described. If no such number is found, it returns `None`.", "refcode": "# import necessary packages\nfrom itertools import combinations\n\n# all class and function definitions in the code file, if any\ndef divisor(root):\n    \"\"\" let's get all divisors for a number  \"\"\"\n    divisors = []\n    for i in range(1, root):\n        if root % i == 0:\n            divisors.append(i)\n    return divisors\n\ndef sumCheck(divisors, total):\n    \"\"\"  Let's verify that the sum can't be bigger than the total     \"\"\"\n    return sum(divisors) > total\n\ndef totalSumCheck(divisors, total):\n    \"\"\" Let's iterate through combinations and make sure\n    nothing sums to exactly equal the total   \"\"\"\n    for i in range(2, len(divisors)):\n        for j in combinations(divisors, i):\n            if sum(j) == total:\n                return False\n    return True\n\n# main function\ndef main_solution(max_amount):\n    \"\"\"\n    Finds the first number within a given range where the sum of its divisors (excluding the number itself)\n    is greater than the number, and no subset of its divisors sums up to exactly the number.\n    \"\"\"\n    for total in range(1, max_amount + 1):\n        divisors = divisor(total)\n        if sumCheck(divisors, total) and totalSumCheck(divisors, total):\n            return total\n    return None", "funcname": "main_solution", "ios": [{"input": {"max_amount": 635}, "output": 70}, {"input": {"max_amount": 305}, "output": 70}, {"input": {"max_amount": 535}, "output": 70}, {"input": {"max_amount": 813}, "output": 70}, {"input": {"max_amount": 657}, "output": 70}, {"input": {"max_amount": 358}, "output": 70}, {"input": {"max_amount": 963}, "output": 70}, {"input": {"max_amount": 79}, "output": 70}, {"input": {"max_amount": 577}, "output": 70}, {"input": {"max_amount": 748}, "output": 70}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "saragam25/Pitchup_solution", "path": "/pitchup_test.py", "msgidx": 7679}}
{"problem_description": "Given the Gregorian calendar rules, how many Sundays fell on the first of the month during a specific period from `start_year` to `end_year`?", "io_requirements": "Input:\n  `start_year` (int): The starting year of the range (inclusive).\n  `end_year` (int): The ending year of the range (inclusive).\n\nOutput:\n  `return` (int): The number of Sundays that fall on the first of the month between `start_year` and `end_year` (inclusive).", "refcode": "# import necessary packages\nimport datetime\n\n# main function\ndef main_solution(start_year, end_year):\n    # Convert input arguments to datetime format\n    start_date = datetime.date(start_year, 1, 1)\n    end_date = datetime.date(end_year, 12, 31)\n    \n    # Initialize count of Sundays on the first of the month\n    count = 0\n    \n    # Loop through each date from start_date to end_date\n    current_date = start_date\n    while current_date <= end_date:\n        # Check if the current date is the first of the month and a Sunday\n        if current_date.day == 1 and current_date.weekday() == 6:\n            count += 1\n        # Move to the next month\n        if current_date.month == 12:\n            current_date = datetime.date(current_date.year + 1, 1, 1)\n        else:\n            current_date = datetime.date(current_date.year, current_date.month + 1, 1)\n    \n    # Return the count of Sundays on the first of the month\n    return count", "funcname": "main_solution", "ios": [{"input": {"start_year": 1939, "end_year": 1976}, "output": 65}, {"input": {"start_year": 1941, "end_year": 1950}, "output": 16}, {"input": {"start_year": 1917, "end_year": 1963}, "output": 82}, {"input": {"start_year": 1928, "end_year": 1943}, "output": 29}, {"input": {"start_year": 1944, "end_year": 1995}, "output": 89}, {"input": {"start_year": 1958, "end_year": 1976}, "output": 32}, {"input": {"start_year": 1930, "end_year": 1966}, "output": 63}, {"input": {"start_year": 1956, "end_year": 1974}, "output": 34}, {"input": {"start_year": 1979, "end_year": 1979}, "output": 2}, {"input": {"start_year": 1924, "end_year": 1979}, "output": 96}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "stephen-weber/Project_Euler", "path": "/Python/Problem0019_Counting_Sundays.py", "msgidx": 7829}}
{"problem_description": "Given a set of dice with varying numbers of faces, what is the probability that the sum of the dice rolls will be greater than or equal to a specified value? The dice are represented by a list where each element indicates the number of faces on a die, and the value is the target sum.", "io_requirements": "Input:\n  `dice` (list of int): A list of integers representing the number of faces on each die. For example, `[6, 6, 6]` represents three six-sided dice.\n  `value` (int): The target value for which the probability of rolling greater than or equal to this value is to be calculated.\n\nOutput:\n  `return` (float): The probability of rolling a value greater than or equal to the specified `value` with the given dice, rounded to 4 decimal places.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef ways(value: int, diceCount: int, dice: list) -> int:\n    if value < 1 or diceCount < 1:\n        return 0\n    elif diceCount == 1:\n        return int(value <= dice[0])\n    else:\n        return sum(\n            ways(value - roll, diceCount - 1, dice[1:]) * ways(roll, 1, dice[0:1])\n            for roll in range(1, dice[0] + 1)\n        )\n\ndef probDiceGEQ(value: int, dice: list, precision: int = 4) -> float:\n    denom = np.prod(dice)\n    c = len(dice)\n    maxV = sum(dice)\n    return round(\n        sum([\n            ways(v, c, dice) / denom for v in range(value, maxV + 1)\n        ]), precision\n    )\n\n# main function\ndef main_solution(dice: list, value: int) -> float:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return probDiceGEQ(value, dice)", "funcname": "main_solution", "ios": [{"input": {"dice": [7, 7, 6, 11], "value": 28}, "output": 0.0108}, {"input": {"dice": [4, 6, 10, 5], "value": 21}, "output": 0.0575}, {"input": {"dice": [9, 5, 11, 8, 4], "value": 35}, "output": 0.0013}, {"input": {"dice": [4, 4, 7, 11], "value": 14}, "output": 0.6323}, {"input": {"dice": [6, 6, 6, 6, 4], "value": 16}, "output": 0.6063}, {"input": {"dice": [5, 5, 4, 10, 7], "value": 20}, "output": 0.367}, {"input": {"dice": [9, 12, 5, 6, 8], "value": 38}, "output": 0.0008}, {"input": {"dice": [8, 9, 11, 7], "value": 32}, "output": 0.0063}, {"input": {"dice": [8, 11, 11, 7, 10], "value": 26}, "output": 0.5314}, {"input": {"dice": [12, 11, 12, 8, 12], "value": 41}, "output": 0.0726}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cSquaerd/ccDiceSumming", "path": "/ccDiceSumming.py", "msgidx": 7883}}
{"problem_description": "Given a string that contains elements separated by '|' within square brackets, representing possible choices for combinations, what are all the possible combinations of the string, sorted in alphabetical order?", "io_requirements": "Input:\n  `input_string` (str): A string containing elements separated by '|' within square brackets, representing possible choices for combinations.\n\nOutput:\n  `return` (list of str): A list of all possible combinations of the input string, sorted in alphabetical order.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef unravel(string):\n    # Helper function to generate combinations\n    def generate_combinations(s):\n        if '[' not in s:\n            return [s]\n        start = s.index('[')\n        end = s.index(']')\n        options = s[start+1:end].split('|')\n        prefix = s[:start]\n        suffix = s[end+1:]\n        result = []\n        for option in options:\n            result.extend(generate_combinations(prefix + option + suffix))\n        return result\n\n    # Generate all combinations\n    combinations = generate_combinations(string)\n    # Sort the combinations alphabetically\n    combinations.sort()\n    return combinations\n\n# main function\ndef main_solution(input_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = unravel(input_string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "CPFl[ZtX]G"}, "output": ["CPFlZtXG"]}, {"input": {"input_string": "RojDF[XA|IE|lvZ|Q|ax]D"}, "output": ["RojDFIED", "RojDFQD", "RojDFXAD", "RojDFaxD", "RojDFlvZD"]}, {"input": {"input_string": "OWma[AgF|oA|xf|Aa]Q"}, "output": ["OWmaAaQ", "OWmaAgFQ", "OWmaoAQ", "OWmaxfQ"]}, {"input": {"input_string": "V[R|QQ]po"}, "output": ["VQQpo", "VRpo"]}, {"input": {"input_string": "fcT[M|I]GZx"}, "output": ["fcTIGZx", "fcTMGZx"]}, {"input": {"input_string": "I[G|VQ]q"}, "output": ["IGq", "IVQq"]}, {"input": {"input_string": "cMPW[aQ|pn]cMy"}, "output": ["cMPWaQcMy", "cMPWpncMy"]}, {"input": {"input_string": "Bo[aof|K|Pt]Ymke"}, "output": ["BoKYmke", "BoPtYmke", "BoaofYmke"]}, {"input": {"input_string": "GaUI[G|cDd|U]GcYA"}, "output": ["GaUIGGcYA", "GaUIUGcYA", "GaUIcDdGcYA"]}, {"input": {"input_string": "EWV[Gp|pDo|yK|KTj]Fcyo"}, "output": ["EWVGpFcyo", "EWVKTjFcyo", "EWVpDoFcyo", "EWVyKFcyo"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "garciaha/DE_daily_challenges", "path": "/2020-08-03/unravel.py", "msgidx": 7949}}
{"problem_description": "Given a set of floating-point numbers, how can we determine the sequence of values obtained by traversing a binary search tree constructed from these numbers in an outorder manner?", "io_requirements": "Input:\n  `values` (list of floats): A list of floating-point numbers representing the values to be inserted into the binary search tree.\n\nOutput:\n  `return` (list of floats): A list of floating-point numbers representing the values of the nodes in the binary search tree after an outorder traversal.", "refcode": "# import necessary packages\nimport math\nimport collections\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n    def create(self, val):\n        if self.root == None:\n            self.root = Node(val)\n        else:\n            current = self.root\n            while True:\n                if val < current.data:\n                    if current.left:\n                        current = current.left\n                    else:\n                        current.left = Node(val)\n                        break\n                elif val > current.data:\n                    if current.right:\n                        current = current.right\n                    else:\n                        current.right = Node(val)\n                        break\n                else:\n                    break\n\ndef height(root):\n    return heightrec(root, 0)\ndef heightrec(root, h):\n    if root is None or (root.left is None and root.right is None):\n        return h\n    hl = 1\n    hr = 1\n    if root.left:\n        hl += heightrec(root.left, h)\n    if root.right:\n        hr += heightrec(root.right, h)\n    if hl > hr:\n        return h + hl\n    return h + hr\n\ndef dfs_outorder_traverse(n, visitorfn):\n    thisfn = dfs_outorder_traverse\n    if n is None:\n        return\n    if n.right is not None:\n        thisfn(n.right, visitorfn)\n    visitorfn(n)\n    if n.left is not None:\n        thisfn(n.left, visitorfn)\n\n# main function\ndef main_solution(values):\n    # Create the binary search tree\n    tree = BinarySearchTree()\n    for val in values:\n        tree.create(val)\n    \n    # Traverse the tree in outorder and collect the node values\n    result = []\n    dfs_outorder_traverse(tree.root, lambda n: result.append(n.data))\n    \n    # Convert the result to a JSON serializable format\n    return result", "funcname": "main_solution", "ios": [{"input": {"values": [6.74, 7.31, 5.74, 9.32, 2.78, 6.24, 8.66, 8.57, 0.72, 1.09]}, "output": [9.32, 8.66, 8.57, 7.31, 6.74, 6.24, 5.74, 2.78, 1.09, 0.72]}, {"input": {"values": [2.68, 0.73, 3.29, 6.05, 8.03, 1.67, 2.44, 2.53, 9.33, 9.26]}, "output": [9.33, 9.26, 8.03, 6.05, 3.29, 2.68, 2.53, 2.44, 1.67, 0.73]}, {"input": {"values": [2.07, 8.13, 7.9, 8.36, 2.53, 8.83, 3.7, 7.79, 2.3, 2.67]}, "output": [8.83, 8.36, 8.13, 7.9, 7.79, 3.7, 2.67, 2.53, 2.3, 2.07]}, {"input": {"values": [0.49, 2.91, 7.02, 7.54, 1.57, 0.43, 3.26, 7.96, 5.73, 7.56]}, "output": [7.96, 7.56, 7.54, 7.02, 5.73, 3.26, 2.91, 1.57, 0.49, 0.43]}, {"input": {"values": [2.04, 7.43, 9.12, 1.91, 6.92, 7.24, 1.56, 6.1, 3.81, 5.24]}, "output": [9.12, 7.43, 7.24, 6.92, 6.1, 5.24, 3.81, 2.04, 1.91, 1.56]}, {"input": {"values": [6.92, 4.68, 0.99, 6.79, 8.22, 4.53, 7.09, 5.11, 2.86, 4.42]}, "output": [8.22, 7.09, 6.92, 6.79, 5.11, 4.68, 4.53, 4.42, 2.86, 0.99]}, {"input": {"values": [1.76, 3.55, 8.19, 9.77, 3.95, 0.35, 8.68, 4.16, 0.03, 7.39]}, "output": [9.77, 8.68, 8.19, 7.39, 4.16, 3.95, 3.55, 1.76, 0.35, 0.03]}, {"input": {"values": [9.71, 9.08, 5.78, 8.39, 9.85, 5.79, 4.22, 9.77, 4.98, 6.31]}, "output": [9.85, 9.77, 9.71, 9.08, 8.39, 6.31, 5.79, 5.78, 4.98, 4.22]}, {"input": {"values": [8.67, 9.34, 2.91, 3.54, 3.02, 9.09, 5.11, 1.14, 8.92, 6.71]}, "output": [9.34, 9.09, 8.92, 8.67, 6.71, 5.11, 3.54, 3.02, 2.91, 1.14]}, {"input": {"values": [2.91, 1.22, 5.23, 9.05, 9.32, 6.95, 2.09, 5.27, 3.9, 6.04]}, "output": [9.32, 9.05, 6.95, 6.04, 5.27, 5.23, 3.9, 2.91, 2.09, 1.22]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "justinmk/smurf", "path": "/py-misc/binary_tree_height.py", "msgidx": 8082}}
{"problem_description": "In a game, `n` people stand in a circle, and every `m`-th person is eliminated until only one person remains. Given the number of people `n` and the count `m`, which position in the circle will be the last remaining person?", "io_requirements": "Input:\n  `n` (int): The number of people standing in a circle.\n  `m` (int): The count to determine which person to remove.\n\nOutput:\n  `return` (int): The position of the last remaining person in the circle. If `n` or `m` is less than 1, it returns -1.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def LastRemaining_Solution(self, n, m):\n        res = 0\n        if n < 1 or m < 1:\n            return -1\n        numbers = list(range(n))\n        cur = 0\n        while len(numbers) > 1:\n            for i in range(0, m - 1):\n                cur += 1\n                if cur == len(numbers):\n                    cur = 0\n            numbers.remove(numbers[cur])\n            if cur == len(numbers):\n                cur = 0\n        res = numbers[0]\n        return res\n\nclass Solution2:\n    def LastRemaining_Solution(self, n, m):\n        res = 0\n        if n < 1 or m < 1:\n            return -1\n        last = 0\n        for i in range(2, n + 1):\n            last = (last + m) % i\n        return last\n\n# main function\ndef main_solution(n, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution2()\n    result = solution.LastRemaining_Solution(n, m)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 66, "m": 9}, "output": 19}, {"input": {"n": 12, "m": 4}, "output": 0}, {"input": {"n": 80, "m": 2}, "output": 32}, {"input": {"n": 10, "m": 8}, "output": 0}, {"input": {"n": 87, "m": 9}, "output": 55}, {"input": {"n": 62, "m": 2}, "output": 60}, {"input": {"n": 76, "m": 8}, "output": 69}, {"input": {"n": 73, "m": 6}, "output": 68}, {"input": {"n": 10, "m": 5}, "output": 2}, {"input": {"n": 10, "m": 4}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chengaojie0011/offer-comein", "path": "/py-project/Solution62.py", "msgidx": 7917}}
{"problem_description": "Given two ranges of integers, what is the sum of all unique pandigital products formed by multiplying any integer from the first range with any integer from the second range? A pandigital product is defined as a product whose digits, when combined with the digits of its factors, form a sequence containing all digits from 1 to 9 exactly once.", "io_requirements": "Input:\n  `x_start` (int): The starting value for the first range of numbers.\n  `x_end` (int): The ending value (exclusive) for the first range of numbers.\n  `y_start` (int): The starting value for the second range of numbers.\n  `y_end` (int): The ending value (exclusive) for the second range of numbers.\n\nOutput:\n  `return` (int): The sum of all unique pandigital products within the specified ranges.", "refcode": "# import necessary packages\nfrom datetime import datetime\nimport math\n\n# main function\ndef main_solution(x_start, x_end, y_start, y_end):\n    # Helper function to check if a multiplication is pandigital\n    def is_pandigital_mul(x, y):\n        mul = x * y\n        x_digits = [int(i) for i in str(x)]\n        y_digits = [int(i) for i in str(y)]\n        mul_digits = [int(i) for i in str(mul)]\n        all_digits = x_digits + y_digits + mul_digits\n        if len(all_digits) != 9 or 0 in all_digits:\n            return 0\n        for i in range(1, 10):\n            if i not in all_digits:\n                return 0\n        return mul\n\n    products = []\n    for i in range(x_start, x_end):\n        for j in range(y_start, y_end):\n            mul = is_pandigital_mul(i, j)\n            if mul != 0:\n                products.append(mul)\n    total = sum(set(products))\n    return total", "funcname": "main_solution", "ios": [{"input": {"x_start": 25, "x_end": 67, "y_start": 150, "y_end": 267}, "output": 24628}, {"input": {"x_start": 50, "x_end": 143, "y_start": 992, "y_end": 1897}, "output": 0}, {"input": {"x_start": 79, "x_end": 156, "y_start": 137, "y_end": 478}, "output": 0}, {"input": {"x_start": 100, "x_end": 157, "y_start": 247, "y_end": 828}, "output": 0}, {"input": {"x_start": 40, "x_end": 93, "y_start": 925, "y_end": 1216}, "output": 0}, {"input": {"x_start": 38, "x_end": 62, "y_start": 206, "y_end": 491}, "output": 0}, {"input": {"x_start": 42, "x_end": 86, "y_start": 776, "y_end": 1265}, "output": 0}, {"input": {"x_start": 35, "x_end": 56, "y_start": 258, "y_end": 481}, "output": 0}, {"input": {"x_start": 80, "x_end": 178, "y_start": 346, "y_end": 1004}, "output": 0}, {"input": {"x_start": 4, "x_end": 45, "y_start": 416, "y_end": 1205}, "output": 5796}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "aerkanc/euler", "path": "/problem032.py", "msgidx": 8273}}
{"problem_description": "Given a set of rules that describe which colored bags can contain other colored bags, and how many of each color can be contained, how many bags in total can be contained within a specified outer bag color?", "io_requirements": "Input:\n  `allowed_json` (str): A JSON string representing a dictionary where each key is a color of a bag and the value is a list of dictionaries. Each dictionary contains two keys: `color` (str) representing the inner bag color and `count` (int) representing the number of such bags.\n  `outer_color` (str): A string representing the color of the outer bag for which we want to calculate the total number of bags it can contain.\n\nOutput:\n  `return` (int): An integer representing the total number of bags that can be contained within the specified outer bag color.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef get_content_count(allowed, outer_color):\n    result = 0\n    if allowed[outer_color] == []:\n        return 0\n    for inner in allowed[outer_color]:\n        # Add number of bags at current level/color\n        result += inner['count']\n        # Add number of nested bags\n        result += inner['count'] * get_content_count(allowed, inner['color'])\n    return result\n\n# main function\ndef main_solution(allowed_json, outer_color):\n    # Convert JSON string to dictionary\n    allowed = json.loads(allowed_json)\n    \n    # Calculate the total number of bags inside the specified outer color\n    result = get_content_count(allowed, outer_color)\n    \n    # Return the result as an integer\n    return result", "funcname": "main_solution", "ios": [{"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [], \"color_2\": []}", "outer_color": "color_0"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [{\"color\": \"color_0\", \"count\": 3}], \"color_2\": []}", "outer_color": "color_1"}, "output": 3}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [], \"color_2\": [], \"color_3\": []}", "outer_color": "color_3"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [{\"color\": \"color_1\", \"count\": 3}], \"color_2\": []}", "outer_color": "color_0"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [], \"color_2\": [], \"color_3\": []}", "outer_color": "color_1"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [], \"color_2\": []}", "outer_color": "color_1"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [], \"color_2\": []}", "outer_color": "color_2"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [{\"color\": \"color_0\", \"count\": 2}], \"color_1\": [], \"color_2\": []}", "outer_color": "color_2"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [{\"color\": \"color_0\", \"count\": 2}], \"color_2\": []}", "outer_color": "color_2"}, "output": 0}, {"input": {"allowed_json": "{\"color_0\": [], \"color_1\": [], \"color_2\": [], \"color_3\": [{\"color\": \"color_1\", \"count\": 5}]}", "outer_color": "color_2"}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ericbollinger/AdventOfCode2020", "path": "/day07/second.py", "msgidx": 8662}}
{"problem_description": "Given a knight starting in the corner of a standard 8x8 chessboard, how many moves on average does it take for the knight to return to its starting corner if it moves randomly to any valid position on the board?", "io_requirements": "Input:\n  `iters` (int): The number of iterations to run the experiment. This determines the sample size for calculating the average number of moves.\n\nOutput:\n  `return` (float): The average number of moves required for the knight to return to its starting corner on a chessboard.", "refcode": "# import necessary packages\nimport numpy as np\nfrom scipy import linalg as la\n\n# all class and function definitions in the code file, if any\ndef matrix_maker():\n    \"\"\"Make a matrix representation of the system of equations, setting each equation \n    equal to -1. We use the convention that the knight's original corner is (1,1), \n    with other spaces ranging up to (8,8). The board is diagonally symmetric from the \n    knight's first space, so we only include rows for the upper half of the board (36 \n    spaces total). Row 0 corresponds to (1,1), and we fill subsequent rows by \n    traversing the board row-wise.\"\"\"\n    #Initialize the matrix\n    M = -np.eye(36)\n    #(1,1)\n    M[0,9] = 1\n    #(1,2)\n    M[1,[2,15,10]] = 1/3\n    #(1,3)\n    M[2,[1,9,11,16]] = 1/4\n    #(1,4) to (1,6)\n    indices = np.array([8, 12, 15, 17])\n    for i, index in enumerate([3,4,5]):\n        M[index,indices+i] = 1/4\n    #(1,7)\n    M[6,[11,18,20]] = 1/3\n    #(1,8)\n    M[7,[12,19]] = 1/2\n    #(2,2)\n    M[8,[3,16]] = 1/2\n    #(2,3)\n    M[9,[2,4,10,17,21]] = 1/6\n    #(2,4)\n    M[10,[1,5,9,16,18,22]] = 1/6\n    #(2,5) and (2,6)\n    indices = np.array([2, 6, 15, 19, 21, 23])\n    for i, index in enumerate([11, 12]):\n        M[index,indices+i] = 1/6\n    #(2,7)\n    M[13,[4,17,23,25]] = 1/4\n    #(2,8)\n    M[14,[5,24]] = 1/2\n    #(3,3)\n    M[15,[11,22]] = 1/2\n    #(3,4)\n    M[16,[2,4,8,10,12,17,23,26]] = 1/8\n    #(3,5)\n    M[17,[3,5,9,13,16,22,24,27]] = 1/8\n    #(3,6)\n    M[18,[4,6,10,14,21,25,26,28]] = 1/8\n    #(3,7)\n    M[19,[5,7,11,22,27,29]] = 1/6\n    #(3,8)\n    M[20,[6,12,23,28]] = 1/4\n    #(4,4)\n    M[21,[9,11,18,27]] = 1/4\n    #(4,5)\n    M[22,[10,12,15,17,19,23,28,30]] = 1/8\n    #(4,6)\n    M[23,[11,13,16,20,22,27,29,31]] = 1/8\n    #(4,7)\n    M[24,[12,14,17,26,30,32]] = 1/6\n    #(4,8)\n    M[25,[13,18,27,31]] = 1/4\n    #(5,5)\n    M[26,[16,18,24,31]] = 1/4\n    #(5,6)\n    M[27,[17,19,21,23,25,28,32,33]] = 1/8\n    #(5,7)\n    M[28,[18,20,22,27,31,34]] = 1/6\n    #(5,8)\n    M[29,[19,23,30,33]] = 1/4\n    #(6,6)\n    M[30,[22,24,29,34]] = 1/4\n    #(6,7)\n    M[31,[23,25,26,28,32,35]] = 1/6\n    #(6,8)\n    M[32,[24,27,31,34]] = 1/4\n    #(7,7)\n    M[33,[27,29]] = 1/2\n    #(7,8)\n    M[34,[28,30,32]] = 1/3\n    #(8,8)\n    M[35,31] = 1\n    #Return the matrix\n    return M\n\n# main function\ndef main_solution(iters: int) -> float:\n    \"\"\"\n    Calculate the expected number of moves for a knight to return to its starting corner on a chessboard.\n    \n    Args:\n    iters (int): Number of iterations to run the experiment.\n    \n    Returns:\n    float: The average number of moves required for the knight to return to its starting corner.\n    \"\"\"\n    # Initialize trackers\n    current_move = 0\n    all_moves = []\n    \n    # Repeat a statistically significant number of times\n    for _ in range(iters):\n        # Initialize knight position\n        knight = [1, 1]\n        # Make the first move\n        i = np.random.choice([1, 2])\n        j = 3 - i\n        knight = [1 + i, 1 + j]\n        current_move = 1\n        \n        # Repeat until the knight returns to [1,1]\n        while knight != [1, 1]:\n            # Choose a valid move\n            moved = False\n            while not moved:\n                i = np.random.choice([-2, -1, 1, 2])\n                j = np.random.choice([3 - np.abs(i), -3 + np.abs(i)])\n                if 1 <= knight[0] + i <= 8 and 1 <= knight[1] + j <= 8:\n                    moved = True\n                    knight[0] += i\n                    knight[1] += j\n                    current_move += 1\n        \n        # Save the results\n        all_moves.append(current_move)\n    \n    # Return the average number of moves\n    return np.average(all_moves)", "funcname": "main_solution", "ios": [{"input": {"iters": 941}, "output": 167.13921360255048}, {"input": {"iters": 695}, "output": 157.32661870503597}, {"input": {"iters": 763}, "output": 178.26474442988206}, {"input": {"iters": 802}, "output": 170.8079800498753}, {"input": {"iters": 193}, "output": 182.23834196891193}, {"input": {"iters": 388}, "output": 179.96391752577318}, {"input": {"iters": 734}, "output": 161.7683923705722}, {"input": {"iters": 203}, "output": 173.27093596059115}, {"input": {"iters": 756}, "output": 168.38095238095238}, {"input": {"iters": 516}, "output": 165.75581395348837}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "akotter2/Adam-Kotter-Code", "path": "/School_Projects/chess_knight.py", "msgidx": 8103}}
{"problem_description": "Given a binary tree, determine whether it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its center. What is the result of checking if the given binary tree is symmetrical?", "io_requirements": "Input:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented by an integer value, and `null` represents a missing node. The tree is serialized in a level-order traversal format.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        if not pRoot:\n            return True\n        return self.isMirror(pRoot.left, pRoot.right)\n\n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        return (left.val == right.val) and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    tree_structure = json.loads(tree_structure)\n    root = build_tree(tree_structure)\n    solution = Solution()\n    result = solution.isSymmetrical(root)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": "[7, 27, 35, null, null, 70, null, null, 49, 1, null, null, 12, null, null]"}, "output": false}, {"input": {"tree_structure": "[99, null, null]"}, "output": true}, {"input": {"tree_structure": "[13, 75, 5, null, null, 58, null, null, 9, 61, null, null, 46, null, null]"}, "output": false}, {"input": {"tree_structure": "[73, 15, 16, null, null, 65, null, null, 88, 64, null, null, 28, null, null]"}, "output": false}, {"input": {"tree_structure": "[61, null, null]"}, "output": true}, {"input": {"tree_structure": "[2, 46, 63, null, null, 98, null, null, 91, 83, null, null, 23, null, null]"}, "output": false}, {"input": {"tree_structure": "[79, 39, 58, null, null, 73, null, null, 49, 39, null, null, 58, null, null]"}, "output": false}, {"input": {"tree_structure": "[78, 57, 17, null, null, 29, null, null, 19, 90, null, null, 35, null, null]"}, "output": false}, {"input": {"tree_structure": "[11, 68, 87, null, null, 49, null, null, 56, 37, null, null, 35, null, null]"}, "output": false}, {"input": {"tree_structure": "[26, null, null]"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ShawnWuzh/algorithms", "path": "/\u6811-\u5bf9\u79f0\u7684\u4e8c\u53c9\u6811.py", "msgidx": 8023}}
{"problem_description": "A ship navigates using a series of instructions that move a waypoint relative to the ship and then move the ship towards the waypoint. Given a list of navigation instructions, what is the Manhattan distance between the ship's final position and the origin after following all the instructions?", "io_requirements": "Input:\n  `instructions` (list of strings): A list of navigation instructions where each string represents a single instruction. Each instruction consists of an action (one of \"N\", \"S\", \"E\", \"W\", \"L\", \"R\", \"F\") followed by a value (an integer).\n\nOutput:\n  `return` (int): The Manhattan distance between the final position of the ship and the origin (0, 0).", "refcode": "import math\n\ndef rotate_waypoint(waypoint, degrees, direction):\n    for _ in range(degrees):\n        if direction == \"L\":\n            new_waypoint = [0, 0, 0, 0]\n            new_waypoint[0] = waypoint[1]\n            new_waypoint[1] = waypoint[2]\n            new_waypoint[2] = waypoint[3]\n            new_waypoint[3] = waypoint[0]\n            waypoint = new_waypoint\n        else:\n            new_waypoint = [0, 0, 0, 0]\n            new_waypoint[1] = waypoint[0]\n            new_waypoint[2] = waypoint[1]\n            new_waypoint[3] = waypoint[2]\n            new_waypoint[0] = waypoint[3]\n            waypoint = new_waypoint\n    return waypoint\n\ndef move_waypoint(waypoint, instruction, amount):\n    if instruction in \"NESW\":\n        index = \"NESW\".index(instruction)\n        waypoint[index] += amount\n    return waypoint\n\ndef move_ship(position, waypoint, instruction, amount):\n    if instruction == \"F\":\n        position[0] += amount * (waypoint[0] - waypoint[2])\n        position[1] += amount * (waypoint[1] - waypoint[3])\n    else:\n        position[0] -= amount * (waypoint[0] - waypoint[2])\n        position[1] -= amount * (waypoint[1] - waypoint[3])\n    return position\n\ndef main_solution(instructions):\n    waypoint = [1, 10, 0, 0]\n    position = [0, 0]\n    \n    for i in instructions:\n        instruction = i[0]\n        amount = int(i[1:])\n        \n        if instruction in \"LR\":\n            degrees = int(amount / 90)\n            waypoint = rotate_waypoint(waypoint, degrees, instruction)\n        elif instruction in \"NESW\":\n            waypoint = move_waypoint(waypoint, instruction, amount)\n        elif instruction in \"FR\":\n            position = move_ship(position, waypoint, instruction, amount)\n    \n    distance = abs(position[0]) + abs(position[1])\n    return distance", "funcname": "main_solution", "ios": [{"input": {"instructions": ["S68", "E69", "W14", "R50", "F41", "S9", "E6", "F4", "S84", "F40"]}, "output": 15240}, {"input": {"instructions": ["F82", "R100", "N46", "R12", "R94", "N43", "W86", "R32", "N95", "W6"]}, "output": 902}, {"input": {"instructions": ["N53", "R25", "N92", "R14", "R98", "E24", "N6", "R84", "E33", "W51"]}, "output": 0}, {"input": {"instructions": ["E19", "N72", "S81", "E22", "R59", "E23", "W67", "F72", "E24", "R7"]}, "output": 1080}, {"input": {"instructions": ["F22", "S25", "W71", "R25", "S16", "S85", "N13", "S25", "E32", "S32"]}, "output": 242}, {"input": {"instructions": ["N13", "L38", "E63", "R97", "F89", "S68", "N16", "R60", "F73", "E78"]}, "output": 17890}, {"input": {"instructions": ["N68", "R69", "N28", "W17", "F65", "R75", "W19", "E54", "E13", "R16"]}, "output": 6760}, {"input": {"instructions": ["E3", "E78", "E64", "N89", "N84", "W79", "N7", "R98", "N20", "F88"]}, "output": 20856}, {"input": {"instructions": ["R71", "W13", "S59", "W73", "R24", "R46", "F34", "F7", "W96", "N20"]}, "output": 5494}, {"input": {"instructions": ["F94", "F89", "W69", "R64", "W26", "S36", "F55", "R7", "F4", "F62"]}, "output": 12507}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AleksOfficial/Codecademy", "path": "/Advent_of_Code/Advent_of_Code_2020/Day12/day12_pt2.py", "msgidx": 8561}}
{"problem_description": "In an airplane seating system, each seat is identified by a unique code consisting of 10 characters. The first 7 characters indicate the row (using 'F' for front and 'B' for back), and the last 3 characters indicate the column (using 'L' for left and 'R' for right). Given a list of such seat codes, what is the highest seat ID and the missing seat ID in the sequence?", "io_requirements": "Input:\n  `seatCodes` (list of strings): A list of seat codes where each seat code is a string of 10 characters. The first 7 characters are either 'F' or 'B' and the last 3 characters are either 'L' or 'R'.\n\nOutput:\n  `return` (dictionary): A dictionary with two keys:\n    - `highestSeatID` (int): The highest seat ID found in the list of seat codes.\n    - `missingSeatID` (int): The missing seat ID in the list of seat codes, which is the seat ID that is not present in the list but should be between the lowest and highest seat IDs.", "refcode": "# import necessary packages\nfrom statistics import median_low\n\n# all class and function definitions in the code file, if any\ndef bsp(code, min, max):\n    chars = range(min, max+1)\n    for i in range(len(code)):\n        if len(chars) == 2:\n            return chars[1] if code[i] == 'B' else chars[0]\n        if code[i] == 'B':  # take upper half\n            min += len(chars) // 2\n        else:\n            max = median_low(chars)\n        chars = range(min, max + 1)\n\ndef getSeatID(seatCode):\n    rowCode, colCode = seatCode[:7], seatCode[-3:]\n    row = bsp(rowCode, 0, 127)\n    col = bsp(colCode, 0, 7)\n    return row * 8 + col\n\n# main function\ndef main_solution(seatCodes):\n    # Convert the list of seat codes into a list of seat IDs\n    seatIDs = [getSeatID(seatCode) for seatCode in seatCodes]\n    \n    # Find the highest seat ID\n    highestSeatID = max(seatIDs)\n    \n    # Find the missing seat ID\n    sortedSeatIDs = sorted(seatIDs)\n    missingSeatID = None\n    for i in range(len(sortedSeatIDs) - 1):\n        if sortedSeatIDs[i] + 2 == sortedSeatIDs[i + 1]:\n            missingSeatID = sortedSeatIDs[i] + 1\n            break\n    \n    # Return the results as a dictionary\n    return {\n        \"highestSeatID\": highestSeatID,\n        \"missingSeatID\": missingSeatID\n    }", "funcname": "main_solution", "ios": [{"input": {"seatCodes": ["BFFBFFBRLL", "FBBFFFFRLR", "FFBBFFFLRL", "FFFFBFFRRR", "FBFFBFBLRL", "FFFBBBFLLR", "BBFBFFBLLR"]}, "output": {"highestSeatID": 840, "missingSeatID": null}}, {"input": {"seatCodes": ["FBFBFFFLLR", "FFBFBFFLLR", "FFFBBBFLRR", "FFBFBBBRLL", "FBFBFBFLLR", "BFBBBFFLLL", "FBBFFBBLLR"]}, "output": {"highestSeatID": 736, "missingSeatID": null}}, {"input": {"seatCodes": ["FFFFBFBRRR", "FFBFFBFRLR", "FBBFBFFRLR", "FBBBFFFRRR", "FBBBFFFLLR"]}, "output": {"highestSeatID": 448, "missingSeatID": null}}, {"input": {"seatCodes": ["BFFFFBBRRL", "BBFBFBFRLL", "BFBFBFFLRL", "BBBFBBFRLL", "BBFFFFBLRR", "BBFBFBBRLR", "BFFFBFBRLL", "FBFBFBBLLL"]}, "output": {"highestSeatID": 944, "missingSeatID": null}}, {"input": {"seatCodes": ["FFFBBFBRLL", "FBBBFFFRRL", "BFBBBFFLRR", "BBBBBBFLRR", "BFFFBFBRRL"]}, "output": {"highestSeatID": 1008, "missingSeatID": null}}, {"input": {"seatCodes": ["BFFFBFFRLL", "BFFFFBBLRL", "FFBBBFFLLL", "BFFFBBBLLL", "BFFBFFFLRR", "FFFBFFFLRR", "BFBBFFFLRR", "BBBBFBFRLL", "BBFFFFBRLR"]}, "output": {"highestSeatID": 976, "missingSeatID": null}}, {"input": {"seatCodes": ["FBFFFBBRLL", "FFFFBBBRRL", "FBBBBFBRLL", "BBBFBFBLRR", "FFFFBFBLLR"]}, "output": {"highestSeatID": 936, "missingSeatID": null}}, {"input": {"seatCodes": ["FBBFFFFLLL", "BFFBBFFRLR", "FFBFFFBRRR", "BFFBBFBRRR", "FFFFBBBRLL", "BFFFFBFRLL", "BBBFBFFLLL", "BFFBBFFRRL"]}, "output": {"highestSeatID": 928, "missingSeatID": null}}, {"input": {"seatCodes": ["FBFFFBFRRR", "BBFFBFBLRL", "FBBBBBFLLR", "BFBFBFFLLL", "BFBFBBFLLR", "BFBFFFFRRR"]}, "output": {"highestSeatID": 808, "missingSeatID": null}}, {"input": {"seatCodes": ["FFFFBBFRRL", "BFBBBBFRLL", "FFBFBFFRLR", "FBBFFFBLRR", "BFFFBBFRLL"]}, "output": {"highestSeatID": 752, "missingSeatID": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GMarsh0218/AdventOfCode2020", "path": "/Day5/Day5.py", "msgidx": 8297}}
{"problem_description": "Given two nested structures, determine if they have the same structural layout. The structures can be composed of lists and tuples, and the comparison should ignore the actual values but focus on the nesting pattern. For example, a list containing another list should match a tuple containing another tuple, but a list containing a tuple should not match a tuple containing a list. What is the result of comparing the given structures?", "io_requirements": "Input:\n  `original` (list or tuple): The first object to compare for structural similarity.\n  `other` (list or tuple): The second object to compare for structural similarity.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the two objects have the same nested structure.", "refcode": "# import necessary packages\nfrom itertools import starmap\n\n# all class and function definitions in the code file, if any\ndef same_structure_as(original, other):\n    if is_container(original) and is_container(other):\n        return (\n            type(original) == type(other) \n            and len(original) == len(other) \n            and all(starmap(\n                same_structure_as, \n                [(a,b) for (a,b) in zip(original,other)]\n            ))\n        )\n    elif is_container(original) or is_container(other):\n        return False\n    else:\n        return True\n\ndef is_container(x):\n    try:\n        it = iter(x)\n    except:\n        return False\n    return not isinstance(x, str)\n\n# main function\ndef main_solution(original, other):\n    # Convert input to JSON serializable types if necessary\n    original = convert_to_json_serializable(original)\n    other = convert_to_json_serializable(other)\n    \n    # Call the main logic function\n    result = same_structure_as(original, other)\n    \n    # Convert output to JSON serializable type if necessary\n    result = convert_to_json_serializable(result)\n    \n    return result\n\ndef convert_to_json_serializable(obj):\n    if isinstance(obj, (list, tuple)):\n        return [convert_to_json_serializable(item) for item in obj]\n    return obj", "funcname": "main_solution", "ios": [{"input": {"original": [[[]]], "other": [[[]]]}, "output": true}, {"input": {"original": [[[], []]], "other": [[[]], [[], []]]}, "output": false}, {"input": {"original": [[[], []], [[], []]], "other": [[[]], [[]]]}, "output": false}, {"input": {"original": [[]], "other": [[], [], []]}, "output": false}, {"input": {"original": [[[]]], "other": [[[]]]}, "output": true}, {"input": {"original": [[]], "other": [[]]}, "output": true}, {"input": {"original": [[[], []]], "other": [[[]]]}, "output": false}, {"input": {"original": [[]], "other": [[]]}, "output": true}, {"input": {"original": [[[]]], "other": [[[]]]}, "output": true}, {"input": {"original": [[], []], "other": [[]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "gprender/challenges", "path": "/python/same_structure.py", "msgidx": 8576}}
{"problem_description": "Given a 2D grid map where `0` represents water and `1` represents land, how many distinct islands are there in the grid? An island is formed by connecting adjacent land cells horizontally or vertically.", "io_requirements": "Input:\n  `graph` (list of lists of integers): A 2D matrix representing the graph where `0` indicates a water cell and `1` indicates a land cell. The size of the matrix should be reasonable (less than 1KB).\n\nOutput:\n  `return` (dictionary): A dictionary containing:\n    - `count` (integer): The number of distinct islands in the graph.\n    - `output` (list of lists of integers): A 2D matrix where each cell is marked with the island number it belongs to, starting from 1. Cells that are not part of any island are marked as `0`.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Graph:\n\n    def __init__(self, row, col, g):\n        self.ROW = row\n        self.COL = col\n        self.graph = g\n\n    def isVisited(self, i, j, visited):\n        safe = False\n        if (i >= 0 and i < self.ROW and j >= 0 and j < self.COL and not visited[i][j] and self.graph[i][j] == 0):\n            safe = True\n        return safe\n\n    def DFS(self, i, j, visited, output, count):\n        rowNbr = [-1, -1, -1,  0, 0,  1, 1, 1]\n        colNbr = [-1,  0,  1, -1, 1, -1, 0, 1]\n        visited[i][j] = True\n        output[i][j] = count+1\n        for k in range(8):\n            if self.isVisited(i + rowNbr[k], j + colNbr[k], visited):\n                self.DFS(i + rowNbr[k], j + colNbr[k], visited, output, count)\n\n    def countIslands(self):\n        visited = [[False for j in range(self.COL)]for i in range(self.ROW)]\n        output = [[0 for j in range(self.COL)]for i in range(self.ROW)]\n        count = 0\n        for i in range(self.ROW):\n            for j in range(self.COL):\n                if visited[i][j] == False and self.graph[i][j] == 0:\n                    self.DFS(i, j, visited, output, count)\n                    count += 1\n        return count, output\n\n# main function\ndef main_solution(graph):\n    # Convert the input list to a 2D list\n    graph = np.array(graph).tolist()\n    \n    # Get the dimensions of the graph\n    row = len(graph)\n    col = len(graph[0])\n    \n    # Create an instance of the Graph class\n    g = Graph(row, col, graph)\n    \n    # Count the number of islands and get the output matrix\n    count, output = g.countIslands()\n    \n    # Convert the output matrix to a JSON serializable format\n    output = np.array(output).tolist()\n    \n    # Return the count of islands and the output matrix\n    return {\"count\": count, \"output\": output}", "funcname": "main_solution", "ios": [{"input": {"graph": [[1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1]]}, "output": {"count": 2, "output": [[0, 1, 1, 0, 0, 2], [1, 1, 1, 1, 0, 2], [1, 1, 0, 1, 0, 0]]}}, {"input": {"graph": [[1, 1, 0], [0, 0, 0], [1, 0, 0], [1, 0, 0], [1, 1, 1]]}, "output": {"count": 1, "output": [[0, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 1], [0, 0, 0]]}}, {"input": {"graph": [[0, 1, 1, 1], [1, 0, 1, 0], [0, 1, 1, 1]]}, "output": {"count": 2, "output": [[1, 0, 0, 0], [0, 1, 0, 2], [1, 0, 0, 0]]}}, {"input": {"graph": [[0, 1, 0, 1], [0, 0, 0, 1], [0, 1, 1, 0], [1, 1, 1, 0], [1, 1, 0, 1]]}, "output": {"count": 1, "output": [[1, 0, 1, 0], [1, 1, 1, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 1, 0]]}}, {"input": {"graph": [[1, 0, 1], [1, 1, 1], [0, 1, 1], [0, 1, 1], [0, 0, 0]]}, "output": {"count": 2, "output": [[0, 1, 0], [0, 0, 0], [2, 0, 0], [2, 0, 0], [2, 2, 2]]}}, {"input": {"graph": [[1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0], [1, 1, 0, 0, 1, 1]]}, "output": {"count": 1, "output": [[0, 1, 1, 1, 1, 0], [1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0]]}}, {"input": {"graph": [[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [1, 1, 0, 1]]}, "output": {"count": 1, "output": [[1, 1, 1, 1], [1, 1, 0, 0], [1, 0, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [0, 0, 1, 0]]}}, {"input": {"graph": [[1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1]]}, "output": {"count": 1, "output": [[0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0]]}}, {"input": {"graph": [[1, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1]]}, "output": {"count": 1, "output": [[0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1], [0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0]]}}, {"input": {"graph": [[0, 1, 0], [1, 1, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1]]}, "output": {"count": 3, "output": [[1, 0, 2], [0, 0, 0], [0, 3, 3], [0, 0, 3], [0, 0, 0]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "fleiray/Count_of_Lake", "path": "/count_of_lake.py", "msgidx": 8583}}
{"problem_description": "Given a binary tree, what are the boundary values of the tree in an anti-clockwise direction starting from the root? The boundary includes the left boundary, leaves, and right boundary in order without duplicate nodes. The left boundary is defined as the path from the root to the left-most node, and the right boundary is defined as the path from the root to the right-most node. If the root doesn't have a left subtree or right subtree, then the root itself is considered the left or right boundary. The left-most node is defined as a leaf node reachable by always traveling to the left subtree if it exists, otherwise to the right subtree. The right-most node is defined similarly with left and right exchanged.", "io_requirements": "Input:\n  `tree_dict` (dict): A dictionary representing the binary tree. Each key is a node, and the value is another dictionary with keys \"val\" (int), \"left\" (dict or None), and \"right\" (dict or None).\n\nOutput:\n  `return` (list of int): A list of integers representing the boundary values of the binary tree in anti-clockwise order.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef traverseLeft(node, ans):\n    if node is not None:\n        if node.left is not None:\n            ans.append(node.val)\n            traverseLeft(node.left, ans)\n        elif node.right is not None:\n            ans.append(node.val)\n            traverseLeft(node.right, ans)\n\ndef traverseRight(node, ans):\n    if node is not None:\n        if node.right is not None:\n            traverseRight(node.right, ans)\n            ans.append(node.val)\n        elif node.left is not None:\n            traverseRight(node.left, ans)\n            ans.append(node.val)\n  \ndef traverseLeaf(node, ans):\n    if node is not None:\n        traverseLeaf(node.left, ans)\n        if node.left is None and node.right is None:\n            ans.append(node.val)\n        traverseLeaf(node.right, ans)\n\ndef tree_to_dict(node):\n    if node is None:\n        return None\n    return {\n        \"val\": node.val,\n        \"left\": tree_to_dict(node.left),\n        \"right\": tree_to_dict(node.right)\n    }\n\ndef dict_to_tree(d):\n    if d is None:\n        return None\n    node = TreeNode(d[\"val\"])\n    node.left = dict_to_tree(d[\"left\"])\n    node.right = dict_to_tree(d[\"right\"])\n    return node\n\n# main function\ndef main_solution(tree_dict):\n    # Convert JSON serializable input to TreeNode\n    root = dict_to_tree(tree_dict)\n    \n    # Traverse the tree to get the boundary values\n    ans = []\n    traverseLeft(root, ans)\n    traverseLeaf(root, ans)\n    traverseRight(root.right, ans)\n    \n    # Return the result as a list of integers\n    return ans", "funcname": "main_solution", "ios": [{"input": {"tree_dict": {"val": 44, "left": {"val": 38, "left": null, "right": null}, "right": null}}, "output": [44, 38]}, {"input": {"tree_dict": {"val": 16, "left": {"val": 47, "left": null, "right": null}, "right": null}}, "output": [16, 47]}, {"input": {"tree_dict": {"val": 10, "left": null, "right": null}}, "output": [10]}, {"input": {"tree_dict": {"val": 55, "left": null, "right": null}}, "output": [55]}, {"input": {"tree_dict": {"val": 91, "left": null, "right": {"val": 100, "left": null, "right": null}}}, "output": [91, 100]}, {"input": {"tree_dict": {"val": 79, "left": {"val": 69, "left": null, "right": null}, "right": null}}, "output": [79, 69]}, {"input": {"tree_dict": {"val": 25, "left": null, "right": {"val": 56, "left": null, "right": null}}}, "output": [25, 56]}, {"input": {"tree_dict": {"val": 31, "left": null, "right": {"val": 31, "left": null, "right": null}}}, "output": [31, 31]}, {"input": {"tree_dict": {"val": 54, "left": {"val": 36, "left": null, "right": null}, "right": null}}, "output": [54, 36]}, {"input": {"tree_dict": {"val": 14, "left": null, "right": {"val": 93, "left": null, "right": null}}}, "output": [14, 93]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "abhisheksingh75/Practice_CS_Problems", "path": "/Trees/Boundary Traversal Of Binary Tree.py", "msgidx": 8771}}
{"problem_description": "Given a sequence of moves applied to a 3D puzzle cube, what is the final configuration of the front face after performing these moves? The moves are specified in a string format, where each move consists of a face (F, B, U, D, L, R) and an optional rotation indicator (', 2).", "io_requirements": "Input:\n  `steps` (str): A string representing the sequence of moves to be applied to the cube. Each move is separated by a space. Each move consists of a face (F, B, U, D, L, R) and an optional rotation indicator (', 2).\n\nOutput:\n  `return` (list of lists): A 3x3 list representing the state of the front face of the cube after applying the sequence of moves. Each element in the list is a string representing the color of the corresponding square on the front face.", "refcode": "# import necessary packages\nimport numpy as np\n\n# Initialize the cube\ncube = np.reshape([\"\"] * 125, (5, 5, 5))\n\n# Define the initial colors for each face\ncube[0, :, :] = np.reshape([\"r\"] * 25, (5, 5))  # F\ncube[4, :, :] = np.reshape([\"o\"] * 25, (5, 5))  # B\ncube[:, 0, :] = np.reshape([\"y\"] * 25, (5, 5))  # U\ncube[:, 4, :] = np.reshape([\"w\"] * 25, (5, 5))  # D\ncube[:, :, 4] = np.reshape([\"g\"] * 25, (5, 5))  # R\ncube[:, :, 0] = np.reshape([\"b\"] * 25, (5, 5))  # L\n\n# Function to rotate a face of the cube\ndef rotate(face, rot):\n    if face == \"F\":\n        cube[0, :, :] = np.rot90(cube[0, :, :], -1 * rot)\n        cube[1, :, :] = np.rot90(cube[1, :, :], -1 * rot)\n    if face == \"B\":\n        cube[4, :, :] = np.rot90(cube[4, :, :], 1 * rot)\n        cube[3, :, :] = np.rot90(cube[3, :, :], 1 * rot)\n    if face == \"U\":\n        cube[:, 0, :] = np.rot90(cube[:, 0, :], 1 * rot)\n        cube[:, 1, :] = np.rot90(cube[:, 1, :], 1 * rot)\n    if face == \"D\":\n        cube[:, 3, :] = np.rot90(cube[:, 3, :], -1 * rot)\n        cube[:, 4, :] = np.rot90(cube[:, 4, :], -1 * rot)\n    if face == \"L\":\n        cube[:, :, 0] = np.rot90(cube[:, :, 0], -1 * rot)\n        cube[:, :, 1] = np.rot90(cube[:, :, 1], -1 * rot)\n    if face == \"R\":\n        cube[:, :, 3] = np.rot90(cube[:, :, 3], 1 * rot)\n        cube[:, :, 4] = np.rot90(cube[:, :, 4], 1 * rot)\n\n# Main function\ndef main_solution(steps):\n    # Convert the steps string into a list of steps\n    steps_list = steps.split()\n    \n    # Apply each step to the cube\n    for step in steps_list:\n        face = step[0]\n        try:\n            rot = step[1]\n            if rot == \"'\":\n                rotate(face, -1)\n            if rot == \"2\":\n                rotate(face, 1)\n                rotate(face, 1)\n        except IndexError:\n            rotate(face, 1)\n    \n    # Return the state of the front face (excluding the edges)\n    return cube[0, :, :][1:4, 1:4].tolist()", "funcname": "main_solution", "ios": [{"input": {"steps": "D2 B' D' B' R' F' F'"}, "output": [["y", "b", "b"], ["y", "r", "r"], ["w", "r", "r"]]}, {"input": {"steps": "F2 R' D U R'"}, "output": [["b", "o", "o"], ["r", "r", "w"], ["b", "o", "g"]]}, {"input": {"steps": "L2 R D' L2 B R' B R2"}, "output": [["r", "o", "b"], ["r", "r", "g"], ["b", "b", "w"]]}, {"input": {"steps": "D' F L U D' U' B' R2 F'"}, "output": [["g", "y", "r"], ["r", "r", "b"], ["y", "w", "w"]]}, {"input": {"steps": "F' U D2 R' F2 F B' D' B"}, "output": [["w", "b", "o"], ["o", "r", "w"], ["b", "o", "g"]]}, {"input": {"steps": "F2 R2 L' D R' F' R' U'"}, "output": [["y", "r", "w"], ["o", "r", "o"], ["w", "g", "w"]]}, {"input": {"steps": "U2 F' R' B B F"}, "output": [["o", "b", "r"], ["o", "r", "o"], ["o", "r", "g"]]}, {"input": {"steps": "L' U B L D B'"}, "output": [["b", "o", "b"], ["w", "r", "o"], ["w", "r", "r"]]}, {"input": {"steps": "U D' R' D' B2 D' B2 D2"}, "output": [["r", "g", "w"], ["w", "r", "r"], ["w", "r", "r"]]}, {"input": {"steps": "R2 D B' U R' U'"}, "output": [["r", "g", "r"], ["w", "r", "g"], ["o", "o", "g"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "annshress/DailyProgrammer", "path": "/157.py", "msgidx": 8357}}
{"problem_description": "Given a square board filled with numbers, and a direction to move, what will be the resulting configuration of the board after performing the specified move? The move operation involves shifting all numbers in the specified direction, merging adjacent equal numbers, and filling the gaps with zeros.", "io_requirements": "Input:\n  `direction` (str): A string representing the direction of the move. It should be one of the following: \"UP\", \"LEFT\", \"DOWN\", \"RIGHT\".\n  `length` (int): An integer representing the length of the square board.\n  `board_status` (list of lists of int): A 2D list representing the current status of the board. Each element in the list is an integer, where 0 represents an empty cell.\n\nOutput:\n  `return` (str): A string representing the state of the board after the move. The board is represented as a string where rows are separated by '|' and cells within a row are separated by a space.", "refcode": "# import necessary packages\nfrom enum import Enum\n\n# all class and function definitions in the code file, if any\nclass Direction(Enum):\n    UP = 1\n    LEFT = 2\n    DOWN = 3\n    RIGHT = 4\n\nclass Board(object):\n    def __init__(self, length, board_status):\n        self.length = length\n        self.board_status = board_status\n\n    def move(self, direction):\n        # Shift such that we only have to handle LEFT-ward movement.\n        {\n            Direction.UP: lambda: self._rotate(3),\n            Direction.RIGHT: lambda: self._rotate(2),\n            Direction.DOWN: lambda: self._rotate(1),\n            Direction.LEFT: lambda: None\n        }[direction]()\n        # Handle only LEFT-ward movement.\n        for row in range(self.length):\n            last_unmerged_col = 0\n            for col in range(1, self.length):\n                value = self.board_status[row][col]\n                if value != 0:\n                    if self.board_status[row][last_unmerged_col] == 0:\n                        self.board_status[row][last_unmerged_col] = value\n                        self.board_status[row][col] = 0\n                    elif self.board_status[row][last_unmerged_col] == value:\n                        self.board_status[row][last_unmerged_col] *= 2\n                        self.board_status[row][col] = 0\n                        last_unmerged_col += 1\n                    elif last_unmerged_col+1 != col:\n                        # Values are not equal, both non-zero, and not adjacent\n                        self.board_status[row][last_unmerged_col+1] = self.board_status[row][col]\n                        self.board_status[row][col] = 0\n                        last_unmerged_col += 1\n                    else:\n                        # Values are not equal, both non-zero, and are adjacent\n                        pass\n                        last_unmerged_col += 1\n        # Shift back to original orientation.\n        {\n            Direction.UP: lambda: self._rotate(1),\n            Direction.RIGHT: lambda: self._rotate(2),\n            Direction.DOWN: lambda: self._rotate(3),\n            Direction.LEFT: lambda: None\n        }[direction]()\n        return self\n\n    def _rotate(self, count=1):\n        \"\"\"\n        Rotate the board 90 degrees clockwise.\n        \"\"\"\n        new_board_status = [[0 for _ in range(self.length)] for _ in range(self.length)]\n        for i in range(self.length):\n            for j in range(self.length):\n                new_board_status[j][self.length-i-1] = self.board_status[i][j]\n        self.board_status = new_board_status\n        if count > 1:\n            self._rotate(count-1)\n\n    def __str__(self):\n        return '|'.join(' '.join(str(y) for y in x) for x in self.board_status)\n\n# main function\ndef main_solution(direction, length, board_status):\n    # Convert JSON serializable inputs to original input variables\n    direction = Direction[direction]\n    board = Board(length, board_status)\n    board.move(direction)\n    # Convert the output to JSON serializable format\n    return str(board)", "funcname": "main_solution", "ios": [{"input": {"direction": "LEFT", "length": 3, "board_status": [[1, 2, 0], [2, 1, 0], [4, 0, 0]]}, "output": "1 2 0|2 1 0|4 0 0"}, {"input": {"direction": "UP", "length": 4, "board_status": [[1, 2, 0, 2], [2, 2, 2, 1], [0, 2, 0, 0], [1, 0, 1, 0]]}, "output": "1 4 2 2|2 2 1 1|1 0 0 0|0 0 0 0"}, {"input": {"direction": "RIGHT", "length": 3, "board_status": [[0, 0, 1], [1, 0, 1], [0, 1, 2]]}, "output": "0 0 1|0 0 2|0 1 2"}, {"input": {"direction": "RIGHT", "length": 3, "board_status": [[1, 1, 2], [2, 0, 1], [2, 1, 2]]}, "output": "0 2 2|0 2 1|2 1 2"}, {"input": {"direction": "UP", "length": 2, "board_status": [[1, 2], [0, 1]]}, "output": "1 2|0 1"}, {"input": {"direction": "DOWN", "length": 3, "board_status": [[2, 0, 2], [1, 0, 0], [0, 2, 2]]}, "output": "0 0 0|2 0 0|1 2 4"}, {"input": {"direction": "RIGHT", "length": 3, "board_status": [[0, 0, 0], [0, 2, 0], [2, 0, 1]]}, "output": "0 0 0|0 0 2|0 2 1"}, {"input": {"direction": "UP", "length": 2, "board_status": [[1, 1], [2, 2]]}, "output": "1 1|2 2"}, {"input": {"direction": "RIGHT", "length": 3, "board_status": [[0, 2, 1], [2, 2, 2], [1, 0, 0]]}, "output": "0 2 1|0 2 4|0 0 1"}, {"input": {"direction": "UP", "length": 2, "board_status": [[1, 0], [2, 2]]}, "output": "1 2|2 0"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cspatel162/codeeval", "path": "/1-moderate/twenty-forty-eight/main.py", "msgidx": 8714}}
{"problem_description": "Given the classic n-queens puzzle, where the objective is to place n queens on an n\u00d7n chessboard such that no two queens can attack each other, what are the distinct configurations for placing the queens on a chessboard of size n?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (list of lists of strings): A list of all distinct solutions to the n-queens puzzle. Each solution is represented as a list of strings, where each string represents a row of the chessboard. 'Q' indicates a queen and '.' indicates an empty space.", "refcode": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n):\n        if n <= 0:\n            return []\n        board = [['.'] * n for _ in range(n)]\n        return self.dfs(n, 0, board, [False]*n)\n\n    def dfs(self, num, row, board, usedCols):\n        if row >= num:\n            aboard = copy.copy(board)\n            return [[''.join(arow) for arow in aboard]]\n\n        ret = []\n        for col, used in enumerate(usedCols):\n            if not used and self.canPlace(board, num, row, col):\n                usedCols[col] = True\n                board[row][col] = 'Q'\n                oneBoard = self.dfs(num, row+1, board, usedCols)\n                ret.extend(oneBoard)\n                board[row][col] = '.'\n                usedCols[col] = False\n        return ret\n\n    def canPlace(self, board, num, row, col):\n        delta = [(-1, -1), (-1, 1)]\n        for d in delta:\n            r = row + d[0]\n            c = col + d[1]\n            while 0 <= r < num and 0 <= c < num:\n                if board[r][c] == 'Q':\n                    return False\n                r += d[0]\n                c += d[1]\n        return True\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": [["Q"]]}, {"input": {"n": 2}, "output": []}, {"input": {"n": 3}, "output": []}, {"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shhuan/algorithms", "path": "/leetcode/hard/N_Queens.py", "msgidx": 8071}}
{"problem_description": "Given a string composed of lowercase alphabetic characters, how can we determine all the unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all unique permutations need to be generated. The string should not contain any special characters or spaces, and its length should be reasonable (less than 10 characters).\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string. The list will contain all possible permutations of the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Generate all permutations of the input string\n    permutations = [''.join(p) for p in itertools.permutations(input_string)]\n    \n    # Convert the list of permutations to a JSON serializable format\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "seg"}, "output": ["seg", "sge", "esg", "egs", "gse", "ges"]}, {"input": {"input_string": "ntm"}, "output": ["ntm", "nmt", "tnm", "tmn", "mnt", "mtn"]}, {"input": {"input_string": "boe"}, "output": ["boe", "beo", "obe", "oeb", "ebo", "eob"]}, {"input": {"input_string": "bgs"}, "output": ["bgs", "bsg", "gbs", "gsb", "sbg", "sgb"]}, {"input": {"input_string": "opi"}, "output": ["opi", "oip", "poi", "pio", "iop", "ipo"]}, {"input": {"input_string": "vfv"}, "output": ["vfv", "vvf", "fvv", "fvv", "vvf", "vfv"]}, {"input": {"input_string": "pbf"}, "output": ["pbf", "pfb", "bpf", "bfp", "fpb", "fbp"]}, {"input": {"input_string": "ehq"}, "output": ["ehq", "eqh", "heq", "hqe", "qeh", "qhe"]}, {"input": {"input_string": "cse"}, "output": ["cse", "ces", "sce", "sec", "ecs", "esc"]}, {"input": {"input_string": "mwo"}, "output": ["mwo", "mow", "wmo", "wom", "omw", "owm"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pypas/study", "path": "/big-o/ex12.py", "msgidx": 8672}}
{"problem_description": "Given a binary tree structure, determine whether the tree is a binary search tree. A binary search tree is a binary tree where the value of each node is greater than all the values in its left subtree and less than all the values in its right subtree. What is the result of checking if the provided binary tree structure is a binary search tree?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys:\n    - `value` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as a dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as a dictionary or None if there is no right child.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is a binary search tree (True) or not (False).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef depth_search(root, cbn, csn):\n    toggle = True\n    if cbn is None:\n        cbn = root.value\n    if csn is None:\n        csn = root.value\n    if root.left and root.left.value < csn:\n        toggle = depth_search(root.left, cbn, root.left.value)\n    else: \n        toggle = False\n    if root.right and csn < root.right.value < cbn:\n        toggle = depth_search(root.right, root.right.value, csn)\n    else: \n        toggle = False\n    return toggle\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(node_dict):\n        if not node_dict:\n            return None\n        root = TreeNode(node_dict['value'])\n        root.left = build_tree(node_dict['left'])\n        root.right = build_tree(node_dict['right'])\n        return root\n    \n    root = build_tree(tree_structure)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    result = depth_search(root, None, None)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"value": 7, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 95, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 42, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 38, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 41, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 4, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 64, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 74, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 34, "left": null, "right": null}}, "output": false}, {"input": {"tree_structure": {"value": 81, "left": null, "right": null}}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Piera/WB-Data-Structures-Algo", "path": "/explorations/binary_search_tree_validation.py", "msgidx": 8378}}
{"problem_description": "Given a binary tree where each node contains either a positive or negative integer, what is the maximum sum of all nodes in any subtree of the tree, and what is the value of the root node of that subtree?", "io_requirements": "Input:\n  `tree_array` (list of integers): A list of integers representing the nodes of a binary tree in level order. The list should be complete, meaning all levels of the tree are fully filled, except possibly the last level, which should be filled from left to right.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `max_sum` (integer): The maximum sum of all nodes in any subtree of the given binary tree.\n    - `root_value` (integer): The value of the root node of the subtree that has the maximum sum.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass BiTNode:\n    def __init__(self, x, lchild=None, rchild=None):\n        self.x = x\n        self.lchild = lchild\n        self.rchild = rchild\n\nclass BiTree:\n    def __init__(self):\n        self.root = None\n        self.maxSum = -2**31\n\n    def is_empty(self):\n        return self.root is None\n\n    def array2tree(self, arr):\n        def _array2tree(arr, begin, end):\n            if begin > end:\n                return None\n            mid = (begin + end + 1) // 2\n            root = BiTNode(arr[mid])\n            root.lchild = _array2tree(arr, begin, mid - 1)\n            root.rchild = _array2tree(arr, mid + 1, end)\n            return root\n        self.root = _array2tree(arr, 0, len(arr) - 1)\n\n    def findMaxSunTree(self, maxSubTree):\n        def _findMaxSunTree(root, maxSubTree):\n            if root is None:\n                return 0\n            lsum = _findMaxSunTree(root.lchild, maxSubTree)\n            rsum = _findMaxSunTree(root.rchild, maxSubTree)\n            sum = lsum + rsum + root.x\n            if sum > self.maxSum:\n                self.maxSum = sum\n                maxSubTree.x = root.x\n            return sum\n        _findMaxSunTree(self.root, maxSubTree)\n        return self.maxSum\n\n# main function\ndef main_solution(tree_array):\n    # Convert the input list to a binary tree\n    tree = BiTree()\n    tree.array2tree(tree_array)\n    \n    # Find the maximum sum subtree\n    maxSubTree = BiTNode(0)\n    max_sum = tree.findMaxSunTree(maxSubTree)\n    \n    # Return the maximum sum and the root value of the maximum sum subtree\n    return {\"max_sum\": max_sum, \"root_value\": maxSubTree.x}", "funcname": "main_solution", "ios": [{"input": {"tree_array": [-18, 0, 55, -89, -62, 63, -25, -48, 0, 10, 14, -33, -33, -36, 24]}, "output": {"max_sum": 55, "root_value": 55}}, {"input": {"tree_array": [80, 52, 10]}, "output": {"max_sum": 142, "root_value": 52}}, {"input": {"tree_array": [29, -15, 15, 28, 22, -57, 84, 29, 81, 33, 8, -44, -4]}, "output": {"max_sum": 209, "root_value": 84}}, {"input": {"tree_array": [91, -25, 59, -53, -44, 79, 45, -63, -47, 23, -46, 85, 100]}, "output": {"max_sum": 204, "root_value": 45}}, {"input": {"tree_array": [-27, 25, -12, 8, 67, -94, -44, -57, 59, 70]}, "output": {"max_sum": 75, "root_value": 67}}, {"input": {"tree_array": [9, -17, 69, -95, 93, -92]}, "output": {"max_sum": 93, "root_value": 93}}, {"input": {"tree_array": [-84, 62]}, "output": {"max_sum": -22, "root_value": 62}}, {"input": {"tree_array": [47, -42, -7, -27, -18, 4, -9, 69, 59, 61, -76]}, "output": {"max_sum": 104, "root_value": 59}}, {"input": {"tree_array": [91, 55]}, "output": {"max_sum": 146, "root_value": 55}}, {"input": {"tree_array": [84, -56, 73, -32, -45, 57, -2, -97, -100, 84]}, "output": {"max_sum": 84, "root_value": 84}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "2226171237/Algorithmpractice", "path": "/chapter03_tree/t3.4.py", "msgidx": 8880}}
{"problem_description": "Given a sequence where each term is generated by describing the digits of the previous term, what is the nth term in the sequence? The sequence starts with \"1\", and each subsequent term is formed by describing the previous term in terms of consecutive digits. For example, the second term is \"11\" because the first term has \"one 1\", the third term is \"21\" because the second term has \"two 1s\", and so on. What is the nth term in this sequence?", "io_requirements": "Input:\n  `n` (int): The row number in the look-and-say sequence to generate. It should be a positive integer.\n\nOutput:\n  `return` (str): The nth row of the look-and-say sequence. It is a string representing the sequence of digits.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Generate the nth row of the look-and-say sequence.\n\n    Args:\n    n (int): The row number in the look-and-say sequence to generate.\n\n    Returns:\n    str: The nth row of the look-and-say sequence.\n    \"\"\"\n    def next_look_and_say(s):\n        return ''.join(str(len(list(group))) + digit for digit, group in itertools.groupby(s))\n    \n    current = \"1\"\n    for _ in range(n - 1):\n        current = next_look_and_say(current)\n    \n    return current", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": "21"}, {"input": {"n": 7}, "output": "13112221"}, {"input": {"n": 9}, "output": "31131211131221"}, {"input": {"n": 5}, "output": "111221"}, {"input": {"n": 6}, "output": "312211"}, {"input": {"n": 2}, "output": "11"}, {"input": {"n": 4}, "output": "1211"}, {"input": {"n": 8}, "output": "1113213211"}, {"input": {"n": 1}, "output": "1"}, {"input": {"n": 10}, "output": "13211311123113112211"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kalyanitech2021/codingpractice", "path": "/string/easy/prgm6.py", "msgidx": 8690}}
{"problem_description": "Given a specific size for a magic square and a target number, how can you construct a magic square using domino tiles from a double-six set, where each row, column, and both main diagonals sum up to the target number? The domino tiles must be placed vertically and should be unique.", "io_requirements": "Input:\n  `size` (int): The size of the magic square (either 4 or 6).\n  `number` (int): The sum of the numbers in each row, column, and diagonal.\n\nOutput:\n  `return` (list of lists of int): The magic square represented as a list of lists of integers. Each inner list represents a row in the magic square.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(size, number):\n    # Convert non-JSON serializable inputs if necessary\n    size = int(size)\n    number = int(number)\n    \n    # Function to generate a magic square\n    def magic_domino(size, number):\n        # Placeholder implementation for demonstration\n        return ((1,) * size,) * size\n    \n    # Get the magic square\n    magic_square = magic_domino(size, number)\n    \n    # Convert the result to JSON serializable output\n    json_serializable_result = [list(row) for row in magic_square]\n    \n    return json_serializable_result", "funcname": "main_solution", "ios": [{"input": {"size": 4, "number": 14}, "output": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]}, {"input": {"size": 6, "number": 13}, "output": [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]}, {"input": {"size": 6, "number": 26}, "output": [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]}, {"input": {"size": 4, "number": 19}, "output": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]}, {"input": {"size": 6, "number": 18}, "output": [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]}, {"input": {"size": 4, "number": 22}, "output": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]}, {"input": {"size": 4, "number": 21}, "output": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]}, {"input": {"size": 6, "number": 10}, "output": [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]}, {"input": {"size": 4, "number": 10}, "output": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]}, {"input": {"size": 6, "number": 19}, "output": [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nickklaskala/checkio", "path": "/Codeship/magic_domino.py", "msgidx": 8660}}
{"problem_description": "Given two numbers in an outward clockwise spiral matrix, what is the Manhattan distance between these two numbers? The spiral matrix starts at the center with the number 1 and continues outward in a clockwise direction. The numbers increase sequentially as you move outward.", "io_requirements": "Input:\n  `a` (int): The first number in the spiral.\n  `b` (int): The second number in the spiral.\n\nOutput:\n  `return` (int): The Manhattan distance between the two numbers in the spiral matrix.", "refcode": "# import necessary packages\nfrom itertools import cycle\nfrom math import ceil\n\n# main function\ndef main_solution(a, b):\n    \"\"\"\n    Calculate the Manhattan distance between two numbers in an outward clockwise spiral matrix.\n\n    Args:\n    a (int): The first number in the spiral.\n    b (int): The second number in the spiral.\n\n    Returns:\n    int: The Manhattan distance between the two numbers.\n    \"\"\"\n    def out_spiral(n):\n        \"\"\"\n        Create a n*n matrix with outward clockwise spiral of integers starting at the center with 1 up to n*n.\n        \"\"\"\n        if n % 2 == 0:\n            return 'ERROR: n must be odd'\n        matrix = [['x'] * n for row in range(n)]\n        x, y = n // 2, n // 2\n        matrix[x][y] = 1\n        direction = (-1, 0)  # north\n        headings = cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])  # east, south, west, north\n        \n        def move(n):\n            nonlocal x, y, matrix\n            x += direction[0]\n            y += direction[1]\n            matrix[x][y] = n\n             \n        def turn_clockwise():\n            nonlocal direction\n            direction = next(headings)\n        \n        i = 2\n        for j in range(n):\n            for k in range(2):\n                for l in range(j + 1):\n                    if i > n * n:\n                        break\n                    move(i)\n                    i += 1\n                turn_clockwise()\n        return matrix\n\n    # Calculate the size of the matrix needed\n    n = ceil(max(a, b) ** 0.5)\n    if n % 2 == 0:\n        n += 1\n    \n    # Generate the spiral matrix\n    matrix = out_spiral(n)\n    \n    # Find the coordinates of the numbers in the matrix\n    a_coordinates = None\n    b_coordinates = None\n    for i, row in enumerate(matrix):\n        try:\n            a_coordinates = (i, row.index(a))\n        except ValueError:\n            pass\n        try:\n            b_coordinates = (i, row.index(b))\n        except ValueError:\n            pass\n    \n    # Calculate the Manhattan distance\n    return abs(a_coordinates[0] - b_coordinates[0]) + abs(a_coordinates[1] - b_coordinates[1])", "funcname": "main_solution", "ios": [{"input": {"a": 6, "b": 68}, "output": 4}, {"input": {"a": 22, "b": 79}, "output": 5}, {"input": {"a": 99, "b": 82}, "output": 17}, {"input": {"a": 65, "b": 32}, "output": 7}, {"input": {"a": 37, "b": 37}, "output": 0}, {"input": {"a": 76, "b": 65}, "output": 11}, {"input": {"a": 24, "b": 53}, "output": 5}, {"input": {"a": 89, "b": 52}, "output": 5}, {"input": {"a": 48, "b": 50}, "output": 2}, {"input": {"a": 35, "b": 48}, "output": 9}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dcontant/checkio", "path": "/square_spiral.py", "msgidx": 8910}}
{"problem_description": "Given a Boggle board and a dictionary of valid words, what are the valid words that can be constructed from the letters on the board by connecting adjacent letters (horizontally, vertically, or diagonally) without reusing any letter coordinate more than once per word?", "io_requirements": "Input:\n  `board` (str): A string representing the Boggle board. Rows are separated by semicolons (`;`) and each row is a string of letters.\n  `dictionary` (str): A string representing the dictionary of valid words. Words are separated by commas (`,`).\n\nOutput:\n  `return` (str): A string representing the valid words found on the board. Words are separated by commas (`,`).", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef is_valid_word(board, dictionary, word):\n    \"\"\"Check if a word can be formed on the board.\"\"\"\n    def dfs(x, y, index):\n        if index == len(word):\n            return True\n        if not (0 <= x < len(board) and 0 <= y < len(board[0])) or board[x][y] != word[index]:\n            return False\n        temp = board[x][y]\n        board[x][y] = '#'\n        result = any(dfs(x + dx, y + dy, index + 1) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)])\n        board[x][y] = temp\n        return result\n\n    return any(dfs(i, j, 0) for i in range(len(board)) for j in range(len(board[0])) if board[i][j] == word[0])\n\ndef findWords(board, dictionary):\n    \"\"\"Find all valid words on the board.\"\"\"\n    return [word for word in dictionary if is_valid_word(board, dictionary, word)]\n\n# main function\ndef main_solution(board, dictionary):\n    # Convert the board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [list(row) for row in board.split(';')]\n    \n    # Convert the dictionary to a list if it's not already\n    if isinstance(dictionary, str):\n        dictionary = dictionary.split(',')\n    \n    # Find all valid words on the board\n    valid_words = findWords(board, dictionary)\n    \n    # Return the valid words as a comma-separated string\n    return ','.join(valid_words)", "funcname": "main_solution", "ios": [{"input": {"board": "lda;ycc;gvv", "dictionary": "zvcqkmj,dehfe,hucqzurs,mjlid,bxznre,zqvvqjz,mcv,ddvzcghg,yuvea,oxxb,yryx"}, "output": ""}, {"input": {"board": "jfpn;drxr;pvxo;sxtl", "dictionary": "lng,ojvvnz,git,vhty,hhtd,thdi,lhnl,rgkxtvf,xoujy,uvopyxnu"}, "output": ""}, {"input": {"board": "wvhw;omvh;sutn;lvyz", "dictionary": "nwryy,ohyw,hgxyxqse,cnshk,spg,azhto,dbf,rlte,ejfis,lakc"}, "output": ""}, {"input": {"board": "knkje;lhzhy;fyxkm;hyujr;hrzbf", "dictionary": "cgid,qteq,fytyyeqn,tgrxd,rzt,tzmp,oag,xbmra,oei,pjv,mbd,hsk,bhpsnia,gphvqdr,bvt,eieakdlh,kofeh"}, "output": ""}, {"input": {"board": "mgv;cza;say", "dictionary": "ejfc,yriawg,twvog,pofifrm,dpplg,nxewmlbk,uwchem,mitttf,sen,xxwsyfi,widmqdj,nqzt,pbqf,fcbpo"}, "output": ""}, {"input": {"board": "aumoz;rivju;uhpxn;tyjod;vggsm", "dictionary": "zjwka,oyljdwa,roukngha,snyhjm,cddqwma,utnjc,jwz,usz,mtvjhbic,xnyhgpdz"}, "output": ""}, {"input": {"board": "owrzq;zbvnr;ptbuw;oetjy;ltbzi", "dictionary": "pvisi,aikq,vsrempef,uhlidk,ldzjr,biqbvjj,nrxfoy,vlqluib,gejbqyr,ivcdgyy"}, "output": ""}, {"input": {"board": "ytz;rkq;lwt", "dictionary": "hliych,zgop,nvvzqri,kpl,lewvy,tkd,oahwjfrx,yis,hvzsmt,egj,ihawb"}, "output": ""}, {"input": {"board": "zcb;saj;zjk", "dictionary": "nvjjcpl,evo,tmrrcamn,trkjiqr,jedzwle,mfzqx,vgmpldx,cgpgk,skl,dqmb,msum,ibf,iigdl,rbrmex,nrssgck"}, "output": ""}, {"input": {"board": "ceth;yrsr;fzqe;czug", "dictionary": "bycbute,vtcjze,hagsmtl,lnc,jszqgycp,kke,vcafwl,ibtrjjc,jmkqiky,szsylxm,pazxcfsf,ybjgsu,gvssz"}, "output": ""}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "peterehik/scripts", "path": "/src/boggle.py", "msgidx": 8775}}
{"problem_description": "Given a 2x3 puzzle board with tiles labeled from 1 to 5 and an empty square represented by 0, what is the minimum number of moves required to solve the puzzle by swapping the empty square with a 4-directionally adjacent number, such that the board is transformed into the solved state [[1, 2, 3], [4, 5, 0]]? If it is impossible to solve the puzzle, what should be returned?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2x3 list of integers representing the state of the board. The integers range from 0 to 5, where 0 represents an empty square.\n\nOutput:\n  `return` (int): The minimum number of moves required to solve the puzzle. If it is impossible to solve the puzzle, returns -1.", "refcode": "# import necessary packages\nfrom collections import deque\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        target_state = ((1,2,3),(4,5,0))\n        state = lambda board: tuple(map(tuple,board))\n        queue = deque([(state(board),0)])\n        seen = {state(board)}\n        def next_states(board_state):\n            zero_r,zero_c = next((r,c) for r in range(2) for c in range(3) if board_state[r][c]==0)\n            next_board = list(map(list,board_state))\n            next_states = []\n            for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:\n                nr,nc = zero_r+dr,zero_c+dc\n                if 0<=nr<2 and 0<=nc<3:\n                    next_board[zero_r][zero_c],next_board[nr][nc] = next_board[nr][nc],next_board[zero_r][zero_c]\n                    next_states.append(state(next_board))\n                    next_board[zero_r][zero_c],next_board[nr][nc] = next_board[nr][nc],next_board[zero_r][zero_c]\n            return next_states\n        \n        while queue:\n            cur_state,moves = queue.popleft()\n            if cur_state == target_state:\n                return moves\n            for next_state in next_states(cur_state):\n                if next_state not in seen:\n                    queue.append((next_state,moves+1))\n                    seen.add(next_state)\n        return -1\n\n# main function\ndef main_solution(board: List[List[int]]) -> int:\n    # Convert the input board to a JSON serializable format\n    board_json = board\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the slidingPuzzle method to get the result\n    result = solution.slidingPuzzle(board_json)\n    \n    # Return the result, which is already JSON serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[2, 1, 4], [3, 0, 5]]}, "output": 17}, {"input": {"board": [[4, 3, 1], [2, 5, 0]]}, "output": -1}, {"input": {"board": [[5, 2, 4], [0, 1, 3]]}, "output": -1}, {"input": {"board": [[0, 4, 1], [3, 2, 5]]}, "output": 13}, {"input": {"board": [[0, 5, 4], [1, 2, 3]]}, "output": -1}, {"input": {"board": [[2, 3, 0], [1, 5, 4]]}, "output": -1}, {"input": {"board": [[0, 3, 1], [5, 4, 2]]}, "output": -1}, {"input": {"board": [[1, 4, 5], [3, 0, 2]]}, "output": -1}, {"input": {"board": [[3, 1, 2], [0, 5, 4]]}, "output": -1}, {"input": {"board": [[5, 2, 1], [3, 4, 0]]}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sunnyyeti/Leetcode-solutions", "path": "/773 Sliding Puzzle.py", "msgidx": 8069}}
{"problem_description": "In a kingdom, there are `N` soldiers standing in a circle, indexed from 0 to `N-1`. The cruel king decides to execute them in a peculiar manner. Starting from the 0th position, the king skips `K-1` soldiers and executes the `K`-th soldier. This process continues around the circle until only one soldier remains. What is the index of the last remaining soldier who is given freedom?", "io_requirements": "Input:\n  `N` (int): The total number of soldiers standing in a circle.\n  `K` (int): The step size for executing soldiers. In each step, `K-1` soldiers are skipped, and the `K`-th soldier is executed.\n\nOutput:\n  `return` (int): The index of the last remaining soldier who is given freedom. The index is 0-based.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephus(n, k):\n    if n == 1:\n        return 0\n    luckySolInd = josephus(n-1, k)  # will return the lucky index from n-1 soldiers\n    lucky = (luckySolInd + k) % n   # As in every iteration index will be changed because of a soldier is being executed. So to maintain the index order k is added and % by n\n    return lucky\n\n# main function\ndef main_solution(N, K):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = josephus(N, K)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"N": 62, "K": 5}, "output": 20}, {"input": {"N": 67, "K": 3}, "output": 61}, {"input": {"N": 50, "K": 4}, "output": 46}, {"input": {"N": 2, "K": 3}, "output": 1}, {"input": {"N": 63, "K": 1}, "output": 62}, {"input": {"N": 72, "K": 4}, "output": 13}, {"input": {"N": 74, "K": 4}, "output": 21}, {"input": {"N": 88, "K": 2}, "output": 48}, {"input": {"N": 91, "K": 1}, "output": 90}, {"input": {"N": 11, "K": 4}, "output": 8}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "SUSHIL-PU/DSA-PYTHON", "path": "/RECURSION/josephusProblem.py", "msgidx": 8958}}
{"problem_description": "In a university, your attendance determines whether you will be allowed to attend your graduation ceremony. You are not allowed to miss classes for two or more consecutive days. Your graduation ceremony is on the last day of the academic year, which is the Nth day. Given the number of days N, how many ways can you attend classes over N days, and what is the probability that you will miss your graduation ceremony?", "io_requirements": "Input:\n  `N` (int): An integer representing the number of days.\n\nOutput:\n  `return` (list): A list containing two elements:\n    - The first element (int) is the total number of ways to attend classes over N days.\n    - The second element (str) is the probability that you will miss your graduation ceremony in the format \"numerator/denominator\".", "refcode": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(N):\n    # Convert input to integer\n    N = int(N)\n    \n    # Initialize lists to store results\n    l = []\n    l2 = []\n    l3 = []\n    \n    # Generate all possible attendance combinations\n    for i in product([\"A\", \"P\"], repeat=N):\n        # Check for consecutive absent days\n        for j in range(1, N):\n            if i[j] == i[j-1] and i[j] == \"A\":\n                break\n        else:\n            l.append(i)\n    \n    # Calculate total number of valid ways to attend classes\n    Total_count = len(l)\n    \n    # Calculate number of ways to miss the graduation ceremony\n    for i in l:\n        if i[-1] == \"A\":\n            l2.append(i)\n    p_count = len(l2)\n    \n    # Calculate the probability of missing the graduation ceremony\n    a = \"{}/{}\".format(p_count, Total_count)\n    \n    # Prepare the final output\n    l3.append(Total_count)\n    l3.append(a)\n    \n    # Return the final output as a list\n    return l3", "funcname": "main_solution", "ios": [{"input": {"N": 2}, "output": [3, "1/3"]}, {"input": {"N": 8}, "output": [55, "21/55"]}, {"input": {"N": 1}, "output": [2, "1/2"]}, {"input": {"N": 10}, "output": [144, "55/144"]}, {"input": {"N": 4}, "output": [8, "3/8"]}, {"input": {"N": 6}, "output": [21, "8/21"]}, {"input": {"N": 9}, "output": [89, "34/89"]}, {"input": {"N": 5}, "output": [13, "5/13"]}, {"input": {"N": 3}, "output": [5, "2/5"]}, {"input": {"N": 7}, "output": [34, "13/34"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KaArTtHiK/Leetcode-Programs", "path": "/InterViewChallengeProblems/TheGraduationProblem.py", "msgidx": 8932}}
{"problem_description": "Given a chessboard of size `n` x `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other? Two queens are said to threaten each other if they are in the same row, column, or diagonal.", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed.\n\nOutput:\n  `return` (int): The number of distinct solutions to the N-Queens problem for the given board size `n`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def __init__(self):\n        self.ans = 0\n\n    def backtracking(self, col_set, add_set, substract_set, records, row, n):\n        if row == n:\n            self.ans += 1\n\n        for col in range(n):\n            if not (col in col_set or row - col in substract_set or row + col in add_set):\n                records.append((row, col))\n                col_set.add(col)\n                add_set.add(row + col)\n                substract_set.add(row - col)\n                self.backtracking(col_set, add_set, substract_set, records, row + 1, n)\n                records.pop()\n                col_set.remove(col)\n                add_set.remove(row + col)\n                substract_set.remove(row - col)\n\n    def totalNQueens(self, n: int) -> int:\n        self.ans = 0                      \n        self.backtracking(set(), set(), set(), [], 0, n)\n        return self.ans\n\n# main function\ndef main_solution(n: int) -> int:\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.totalNQueens(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": 0}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 10}, "output": 724}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 5}, "output": 10}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "TimMKChang/AlgorithmSampleCode", "path": "/Backtracking/N-QueensII.py", "msgidx": 9190}}
{"problem_description": "Given a list of words, how can we efficiently find all anagrams of a specific word from the list? Specifically, what are the anagrams of a given word within the provided list of words?", "io_requirements": "Input:\n  `words_json` (str): A JSON-formatted string containing a list of words. Each word is a string.\n  `word` (str): The word for which to find anagrams.\n\nOutput:\n  `return` (list): A list of strings, each string being an anagram of the input word. If no anagrams are found, the list will be empty.", "refcode": "# import necessary packages\nimport json\nfrom collections import Counter, defaultdict\n\n# all class and function definitions in the code file, if any\nclass Anagrams:\n    known_anagrams = defaultdict(list)\n\n    def __init__(self, words_json) -> None:\n        self.words = json.loads(words_json)\n\n    def get_anagrams(self, word) -> list:\n        if not word:\n            return []\n\n        if word in self.known_anagrams.keys():\n            return self.known_anagrams[word]\n\n        result = []\n        word_counter = Counter(word)\n\n        for word_from_file in self.words:\n            if Counter(word_from_file) == word_counter:\n                result += [word_from_file]\n\n        self.known_anagrams[word] = result\n        return result\n\n# main function\ndef main_solution(words_json, word):\n    anagrams = Anagrams(words_json)\n    result = anagrams.get_anagrams(word)\n    return result", "funcname": "main_solution", "ios": [{"input": {"words_json": "[\"startle\", \"tea\", \"palest\"]", "word": "palest"}, "output": ["palest"]}, {"input": {"words_json": "[\"pleats\", \"palest\", \"startle\", \"plates\", \"eat\", \"rattles\", \"petals\", \"ate\", \"staple\"]", "word": "petals"}, "output": ["pleats", "palest", "plates", "petals", "staple"]}, {"input": {"words_json": "[\"ate\", \"pleats\", \"tea\", \"plates\"]", "word": "plates"}, "output": ["pleats", "plates"]}, {"input": {"words_json": "[\"petals\"]", "word": "petals"}, "output": ["pleats", "palest", "plates", "petals", "staple"]}, {"input": {"words_json": "[\"eat\", \"eta\", \"rattles\", \"startle\", \"tea\", \"starlet\", \"plates\", \"palest\", \"ate\", \"staple\"]", "word": "rattles"}, "output": ["rattles", "startle", "starlet"]}, {"input": {"words_json": "[\"eta\", \"starlet\", \"eat\", \"staple\", \"palest\", \"pleats\"]", "word": "staple"}, "output": ["staple", "palest", "pleats"]}, {"input": {"words_json": "[\"eta\", \"plates\"]", "word": "eta"}, "output": ["eta"]}, {"input": {"words_json": "[\"eat\", \"staple\", \"petals\", \"plates\"]", "word": "plates"}, "output": ["pleats", "plates"]}, {"input": {"words_json": "[\"petals\", \"rattles\", \"staple\", \"ate\", \"plates\", \"tea\", \"eta\", \"pastel\", \"pleats\"]", "word": "eta"}, "output": ["eta"]}, {"input": {"words_json": "[\"eat\", \"rattles\", \"plates\"]", "word": "eat"}, "output": ["eat"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "manerao-pritam/python-DS", "path": "/Daily coding problems/anagrams.py", "msgidx": 8780}}
{"problem_description": "Given a binary sequence of a certain length, where each digit can be either 0 or 1, what are the valid sequences that do not contain two consecutive 1's? Specifically, for a sequence of `num_bits` bits, what are the valid binary sequences?", "io_requirements": "Input:\n  `num_bits` (int): The number of bits in the binary sequence. It should be a positive integer.\n\nOutput:\n  `return` (list of int): A list of integers representing valid binary sequences where no two consecutive bits are set to 1. Each integer in the list corresponds to a valid binary sequence when interpreted as a binary number.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Puzzle1Solver(object):\n    \"\"\"A program that prints all sequences of binary digits, such that each\n       digit in the sequence is a 0 or 1, and no sequence has two 1's adjacent\n       in the output.\n    \"\"\"\n    @classmethod\n    def main(cls, num_bits):\n        max_val = (1 << num_bits) - 1\n        valid_sequences = []\n        val = 0\n        \n        while (val <= max_val):\n            is_valid = True\n\n            # Detect if we have any runs with two consecutive bits set\n            for bit_offset in range(0, num_bits - 1):\n                if 0x3 == (val >> bit_offset) & 0x3:\n                    # two bits are set, skip the known intermediates\n                    # - we know that the first clash will always occur when the \n                    #   least-significant bit (or bits) are zero, so we can skip\n                    #   in powers-of-two\n                    val += 1 << bit_offset\n                    is_valid = False\n                    break\n\n            if is_valid:\n                valid_sequences.append(val)\n                val += 1\n        \n        return valid_sequences\n\n# main function\ndef main_solution(num_bits):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  valid_sequences = Puzzle1Solver.main(num_bits)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return valid_sequences", "funcname": "main_solution", "ios": [{"input": {"num_bits": 2}, "output": [0, 1, 2]}, {"input": {"num_bits": 4}, "output": [0, 1, 2, 4, 5, 8, 9, 10]}, {"input": {"num_bits": 1}, "output": [0, 1]}, {"input": {"num_bits": 3}, "output": [0, 1, 2, 4, 5]}, {"input": {"num_bits": 5}, "output": [0, 1, 2, 4, 5, 8, 9, 10, 16, 17, 18, 20, 21]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "spruce808/learning", "path": "/PythonApplication1/PythonApplication1/PythonPuzzle1.py", "msgidx": 8574}}
{"problem_description": "Given a Sudoku board represented as a string, where each row is separated by a semicolon and each cell is represented by a character (`1-9` for numbers, `.` for empty cells), determine whether the board is a valid Sudoku configuration. A valid Sudoku board must satisfy the following conditions:\n1. Each row must contain the digits `1-9` without repetition.\n2. Each column must contain the digits `1-9` without repetition.\n3. Each of the nine 3x3 sub-grids must contain the digits `1-9` without repetition.\n\nIs the provided Sudoku board valid?", "io_requirements": "Input:\n  `board` (str): A string representing the Sudoku board. Each row is separated by a semicolon (`;`), and each cell in the row is represented by a character (`1-9` for numbers, `.` for empty cells). Example: `\"53..7;6..195;...8..6;8...6...3;4..8.3..1;7...2...6;...6....2;...419..5;....8..79\"`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the Sudoku board is valid (`True`) or not (`False`).", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isValidSudoku(self, board):\n        for i in range(9):\n            counter_row = Counter()\n            counter_column = Counter()\n            for j in range(9):\n                if counter_row[board[i][j]] == 1 or counter_column[board[j][i]] == 1:\n                    return False\n                if board[i][j] != '.':\n                    counter_row[board[i][j]] += 1\n                if board[j][i] != '.':\n                    counter_column[board[j][i]] += 1\n        for x in [0, 3, 6]:\n            for y in [0, 3, 6]:\n                counter = Counter()\n                for i in range(x, x + 3):\n                    for j in range(y, y + 3):\n                        if counter[board[i][j]] == 1:\n                            return False\n                        if board[i][j] != '.':\n                            counter[board[i][j]] += 1\n        return True\n\n# main function\ndef main_solution(board):\n    # Convert the input board to a list of lists if it's not already\n    if isinstance(board, str):\n        board = [list(row) for row in board.split(';')]\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the isValidSudoku method\n    result = solution.isValidSudoku(board)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": "941793..5;344193.19;74193559.;5.4473352;6525.7431;825656229;657654.26;441987147;264523569"}, "output": false}, {"input": {"board": "11276.459;.36469954;32413.753;898572522;28169.123;65.257314;864955168;545.52198;62652.23."}, "output": false}, {"input": {"board": ".121.2759;834452.62;97319.664;426538871;.24147347;685.521.1;939728.54;139149288;278769571"}, "output": false}, {"input": {"board": "6925.3176;64397.844;37214.167;715219355;..89.7355;527789784;676779364;5192.2317;36.951314"}, "output": false}, {"input": {"board": "83698.544;347434549;525.16674;271362489;873227799;576295.35;89131648.;834.53565;112277725"}, "output": false}, {"input": {"board": "197732823;548891128;.61193795;933239181;281171593;.6.819114;735494777;86.6.94.2;325391532"}, "output": false}, {"input": {"board": "943685554;9459964.2;426391825;337224..2;738796164;9761715.3;2.9255.44;933846.62;4389..753"}, "output": false}, {"input": {"board": "56..1.33.;333518935;513587494;911548.96;.74881783;9991681.8;5..9.7639;55.868433;272883279"}, "output": false}, {"input": {"board": "895623414;14..4.612;2983.2431;9.9381242;77..16547;896988471;1762719.1;141.469.9;421827644"}, "output": false}, {"input": {"board": "6.8969626;159829735;518285677;179134..1;88.937639;999724851;288884561;812742631;899961987"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "thomashirtz/leetcode", "path": "/solutions/36-valid-sudoku.py", "msgidx": 8882}}
{"problem_description": "Given the size of a spiral matrix, which is an odd integer, what is the sum of the numbers on the diagonals of the spiral?", "io_requirements": "Input:\n  `size` (int): The size of the spiral matrix. It must be an odd integer greater than 0.\n\nOutput:\n  `return` (dict): A dictionary containing the sum of the numbers on the diagonals of the spiral matrix. The key is `\"sum_of_diagonals\"` and the value is an integer representing the sum.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(size):\n    # Convert the size to an integer\n    size = int(size)\n    \n    # Initialize the spiral matrix\n    spiral = [[0 for _ in range(size)] for _ in range(size)]\n    \n    # Function to create the spiral\n    def create_spiral(init, step, ssum):\n        num = init - step\n        onespot = (init - 1) // 2\n        if step == onespot:\n            spiral[onespot][onespot] = 1\n            return ssum + 1\n        else:\n            val = init - (step * 2)\n            maxarr = init - 1 - step\n            tright = val * val\n            spiral[step][maxarr] = tright\n            tleft = tright - val + 1\n            spiral[step][step] = tleft\n            bleft = tleft - val + 1\n            spiral[maxarr][step] = bleft\n            bright = bleft - val + 1\n            spiral[maxarr][maxarr] = bright\n            i = step\n            j = maxarr - 1\n            temp = tright\n            while j > step:\n                temp -= 1\n                spiral[i][j] = temp\n                j -= 1\n            i = step + 1\n            j = step\n            temp = tleft\n            while i < maxarr:\n                temp -= 1\n                spiral[i][j] = temp\n                i += 1\n            i = maxarr\n            j = step + 1\n            temp = bleft\n            while j < maxarr:\n                temp -= 1\n                spiral[i][j] = temp\n                j += 1\n            i = maxarr - 1\n            j = maxarr\n            temp = bright\n            while i > step:\n                temp -= 1\n                spiral[i][j] = temp\n                i -= 1\n            ssum = ssum + tleft + tright + bleft + bright\n            return create_spiral(init, step + 1, ssum)\n    \n    # Calculate the sum of the numbers on the diagonals\n    result = create_spiral(size, 0, 0)\n    \n    # Return the result as a dictionary\n    return {\"sum_of_diagonals\": result}", "funcname": "main_solution", "ios": [{"input": {"size": 863}, "output": {"sum_of_diagonals": 428863965}}, {"input": {"size": 419}, "output": {"sum_of_diagonals": 49128377}}, {"input": {"size": 63}, "output": {"sum_of_diagonals": 168765}}, {"input": {"size": 763}, "output": {"sum_of_diagonals": 296422065}}, {"input": {"size": 457}, "output": {"sum_of_diagonals": 63734361}}, {"input": {"size": 277}, "output": {"sum_of_diagonals": 14208021}}, {"input": {"size": 393}, "output": {"sum_of_diagonals": 40543385}}, {"input": {"size": 281}, "output": {"sum_of_diagonals": 14831881}}, {"input": {"size": 793}, "output": {"sum_of_diagonals": 332766985}}, {"input": {"size": 745}, "output": {"sum_of_diagonals": 275940921}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Shoopufff/Project-Euler", "path": "/Spiral.py", "msgidx": 8573}}
{"problem_description": "In the Game of Life, a cellular automaton devised by mathematician John Conway, cells on a grid evolve over discrete time steps according to specific rules. Given an initial configuration of live and dead cells on a grid, what will be the state of the grid after one iteration of the Game of Life rules?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the initial state of the game board. Each element in the list is either `0` (dead cell) or `1` (live cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the state of the game board after one iteration of the Game of Life rules. Each element in the list is either `0` (dead cell) or `1` (live cell).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef get_live_neighboors(board, row, col, rows, cols):\n    count = 0\n    for r in range(row-1, row+2):\n        if r < 0 or r >= rows:\n            continue\n        for c in range(col-1, col+2):\n            if c < 0 or c >= cols:\n                continue\n            if r == row and c == col:\n                continue\n            if board[r][c] == 1 or board[r][c] == 3:\n                count += 1\n    return count\n\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> List[List[int]]:\n        rows = len(board)\n        cols = len(board[0])\n        for r in range(rows):\n            for c in range(cols):\n                num_live_cells = get_live_neighboors(board, r, c, rows, cols)\n                if board[r][c] == 1:\n                    if num_live_cells < 2 or num_live_cells > 3:\n                        board[r][c] = 3\n                elif board[r][c] == 0:\n                    if num_live_cells == 3:\n                        board[r][c] = 2\n        \n        for r in range(rows):\n            for c in range(cols):\n                if 1 <= board[r][c] <= 2:\n                    board[r][c] = 1\n                else:\n                    board[r][c] = 0\n        return board\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.gameOfLife(board)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[0, 1, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 0, 0]]}, "output": [[0, 1, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 0, 0]]}, {"input": {"board": [[0, 0, 0], [1, 0, 1], [0, 1, 0]]}, "output": [[0, 0, 0], [1, 0, 1], [0, 1, 0]]}, {"input": {"board": [[0, 0, 1, 1, 0], [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]}, "output": [[0, 0, 1, 1, 0], [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]}, {"input": {"board": [[0, 0, 1], [1, 0, 1], [0, 1, 1]]}, "output": [[0, 0, 1], [1, 0, 1], [0, 1, 1]]}, {"input": {"board": [[1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 0, 0]]}, "output": [[1, 1, 0], [0, 0, 1], [1, 0, 0], [0, 0, 0]]}, {"input": {"board": [[1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0]]}, "output": [[1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0]]}, {"input": {"board": [[0, 0, 0, 1, 0], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0]]}, "output": [[0, 0, 0, 1, 0], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0]]}, {"input": {"board": [[1, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0, 0]]}, "output": [[1, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0, 0]]}, {"input": {"board": [[1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0]]}, "output": [[1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0]]}, {"input": {"board": [[0, 1, 0], [1, 0, 1], [0, 1, 0], [0, 1, 1]]}, "output": [[0, 1, 0], [1, 0, 1], [0, 1, 0], [0, 1, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "avolokitin/abc", "path": "/leetcode/game_of_life.py", "msgidx": 9122}}
{"problem_description": "Given a set of mathematical expressions, how can we determine the sum of the results when evaluated under two different precedence rules: one where no precedence is applied (addition and multiplication are treated equally), and another where addition takes precedence over multiplication?", "io_requirements": "Input:\n  `expressions` (list of str): A list of mathematical expressions to be evaluated. Each expression is a string containing numbers, operators (+, *), and parentheses.\n\nOutput:\n  `return` (dict): A dictionary containing the sums of results for two different precedence rules.\n  - `\"part1\"` (int): Sum of results using no precedence rule.\n  - `\"part2\"` (int): Sum of results using addition precedence over multiplication.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(expressions):\n    \"\"\"\n    Computes the sum of results of complex mathematical expressions with different precedence rules.\n\n    Args:\n        expressions (list of str): A list of mathematical expressions to be evaluated.\n\n    Returns:\n        dict: A dictionary containing the sums of results for two different precedence rules.\n              Keys:\n              - \"part1\": Sum of results using no precedence rule.\n              - \"part2\": Sum of results using addition precedence over multiplication.\n    \"\"\"\n    def compute_simple_expression_no_precedence(expression):\n        elements = expression.split(\" \")\n        if len(elements) == 1:\n            return int(elements[0])\n\n        while \"+\" in elements or \"*\" in elements:\n            operator = elements[1]\n            e1 = int(elements[0])\n            e2 = int(elements[2])\n            value = e1 + e2 if operator == \"+\" else e1 * e2\n            elements[0:3] = [str(value)]\n\n        return int(elements[0])\n\n    def compute_complex_expression(expression, simplified_evaluator):\n        simplified_expression = \"\"\n        opened_parenthesis = 0\n        sub_expression = \"\"\n        for ch in expression:\n            if ch == \"(\":\n                if opened_parenthesis > 0:\n                    sub_expression += ch\n                opened_parenthesis += 1\n            elif ch == \")\":\n                opened_parenthesis -= 1\n                if opened_parenthesis == 0:\n                    sub_result = compute_complex_expression(sub_expression, simplified_evaluator)\n                    simplified_expression += str(sub_result)\n                    sub_expression = \"\"\n                if opened_parenthesis > 0:\n                    sub_expression += ch\n            else:\n                if opened_parenthesis > 0:\n                    sub_expression += ch\n                else:\n                    simplified_expression += ch\n\n        return simplified_evaluator(simplified_expression)\n\n    def compute_simple_expression_plus_precedence(expression):\n        elements = expression.split(\" \")\n        if len(elements) == 1:\n            return int(elements[0])\n\n        while \"+\" in elements:\n            index = elements.index(\"+\")\n            elements[index - 1:index + 2] = [str(int(elements[index - 1]) + int(elements[index + 1]))]\n\n        return math.prod(int(e) for e in elements if e != \"*\")\n\n    part1_sum = sum(compute_complex_expression(ex, compute_simple_expression_no_precedence) for ex in expressions)\n    part2_sum = sum(compute_complex_expression(ex, compute_simple_expression_plus_precedence) for ex in expressions)\n\n    return {\"part1\": part1_sum, \"part2\": part2_sum}", "funcname": "main_solution", "ios": [{"input": {"expressions": ["10 * 9 + 1", "8 + 9 + 8 + 8", "1 + 8 * 2", "7 + 10 * 3 * 3", "7 + 8 + 4 + 6 + 4"]}, "output": {"part1": 324, "part2": 333}}, {"input": {"expressions": ["6 * 3 + 3 * 6", "7 * 6 + 8", "6 * 9 + 3 * 5 * 9"]}, "output": {"part1": 2741, "part2": 3554}}, {"input": {"expressions": ["9 + 10 * 9", "2 + 5 + 3 + 10 + 2", "8 + 9 + 10 * 10"]}, "output": {"part1": 463, "part2": 463}}, {"input": {"expressions": ["8 * 3 + 4 + 2", "7 + 4 * 5 * 6", "1 + 1 + 3 + 2 + 2"]}, "output": {"part1": 369, "part2": 411}}, {"input": {"expressions": ["8 + 5 * 9", "2 * 2 + 7", "8 * 5 + 1 * 1", "1 * 10 + 4 * 7 * 9"]}, "output": {"part1": 1051, "part2": 1065}}, {"input": {"expressions": ["5 + 9 * 8 * 2 * 2", "7 + 8 * 4 * 4 * 5", "10 * 10 * 8 + 6"]}, "output": {"part1": 2454, "part2": 3048}}, {"input": {"expressions": ["1 + 2 + 7 * 3 + 2", "4 * 10 * 4 * 4", "7 + 3 + 5 + 4 * 3", "8 + 6 + 9 * 6"]}, "output": {"part1": 867, "part2": 885}}, {"input": {"expressions": ["6 * 10 + 9 + 9 + 7", "2 * 10 + 6 + 9", "3 + 3 * 3 * 5", "4 * 9 * 7 * 9 * 8"]}, "output": {"part1": 18354, "part2": 18494}}, {"input": {"expressions": ["2 + 1 * 7", "9 + 9 + 7 * 10 * 4", "4 + 4 * 1 + 1"]}, "output": {"part1": 1030, "part2": 1037}}, {"input": {"expressions": ["3 * 6 + 7 + 5 + 10", "5 * 7 * 3", "2 * 3 + 4 * 4 * 10"]}, "output": {"part1": 545, "part2": 749}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "leonardocarvalho/advent-of-code-2020", "path": "/18/solve.py", "msgidx": 9049}}
{"problem_description": "A monkey eats peaches in a peculiar way. On the first day, it eats half of the peaches it has and then eats one more. This pattern continues for several days until the last day when only one peach is left. How many peaches did the monkey start with on the first day, given the number of days it took to eat all the peaches?", "io_requirements": "Input:\n  `initial_peach_count` (int): The number of peaches left on the last day.\n  `days` (int): The total number of days to calculate backwards from the last day.\n\nOutput:\n  `return` (int): The total number of peaches on the first day.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(initial_peach_count, days):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  num = initial_peach_count\n  n = days\n  while n > 1:\n      num = (num + 1) * 2\n      n -= 1\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return num", "funcname": "main_solution", "ios": [{"input": {"initial_peach_count": 1, "days": 9}, "output": 766}, {"input": {"initial_peach_count": 1, "days": 4}, "output": 22}, {"input": {"initial_peach_count": 1, "days": 7}, "output": 190}, {"input": {"initial_peach_count": 1, "days": 18}, "output": 393214}, {"input": {"initial_peach_count": 1, "days": 8}, "output": 382}, {"input": {"initial_peach_count": 1, "days": 12}, "output": 6142}, {"input": {"initial_peach_count": 1, "days": 6}, "output": 94}, {"input": {"initial_peach_count": 1, "days": 2}, "output": 4}, {"input": {"initial_peach_count": 1, "days": 10}, "output": 1534}, {"input": {"initial_peach_count": 1, "days": 5}, "output": 46}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "liuli-liekkas/python_practice", "path": "/test/test21.py", "msgidx": 9136}}
{"problem_description": "You are planning a road trip and need to create a music playlist. You have a total of `N` songs required for the playlist, but you only have `M` unique songs downloaded. To ensure a good listening experience, you want to avoid repeating any song within a buffer of `B` songs. How many different valid playlists can you create that meet these criteria?", "io_requirements": "Input:\n  `N` (int): Total number of songs required for the playlist.\n  `M` (int): Number of unique songs available.\n  `B` (int): Buffer size to prevent repeats.\n\nOutput:\n  `return` (int): Total number of valid playlists.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(N, M, B):\n    \"\"\"\n    Calculate the total number of valid playlists for a road trip.\n\n    :param N: int, total number of songs required for the playlist.\n    :param M: int, number of unique songs available.\n    :param B: int, buffer size to prevent repeats.\n    :return: int, total number of valid playlists.\n    \"\"\"\n    if M > N:\n        return 0  # Not enough unique songs to create the playlist\n\n    # Calculate the number of ways to arrange M unique songs in N slots\n    total_ways = M ** N\n\n    # Adjust for the buffer constraint\n    if B > 0:\n        # Calculate the number of invalid playlists where songs repeat within the buffer\n        invalid_ways = 0\n        for i in range(1, B + 1):\n            invalid_ways += (M ** (N - i)) * (M - 1) ** i\n\n        total_ways -= invalid_ways\n\n    return total_ways", "funcname": "main_solution", "ios": [{"input": {"N": 1, "M": 1, "B": 1}, "output": 1}, {"input": {"N": 9, "M": 7, "B": 3}, "output": -49294931}, {"input": {"N": 9, "M": 9, "B": 3}, "output": -535161087}, {"input": {"N": 6, "M": 5, "B": 3}, "output": -14875}, {"input": {"N": 10, "M": 5, "B": 10}, "output": -25102571}, {"input": {"N": 1, "M": 1, "B": 0}, "output": 1}, {"input": {"N": 10, "M": 1, "B": 1}, "output": 1}, {"input": {"N": 6, "M": 2, "B": 4}, "output": 4}, {"input": {"N": 3, "M": 2, "B": 2}, "output": 2}, {"input": {"N": 3, "M": 3, "B": 0}, "output": 27}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AnneJoJo/Algorithm", "path": "/Algorithm2019/Greedy/playlisy.py", "msgidx": 8611}}
{"problem_description": "In a traditional game of Josephus, a group of people stand in a circle and are eliminated in a specific order. Given the number of people in the circle (`n`) and the step count (`m`) to eliminate the next person, which position in the circle will be the last remaining person?", "io_requirements": "Input:\n  `n` (int): The number of people in the circle.\n  `m` (int): The step count to eliminate the next person.\n\nOutput:\n  `return` (int): The position of the last remaining person in the circle.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef findFinalNum(circle, m):\n    offset = 0\n    while circle:\n        circle.pop((offset + m - 1) % len(circle))\n        offset = (offset + m - 1) % len(circle)\n        if len(circle) == 1:\n            return circle[0]\n    return -1\n\ndef lastRemaining(n, m):\n    if n < 1 or m < 1:\n        return -1\n    last = 0\n    for i in range(2, n+1):\n        last = (last + m) % i\n    return last\n\n# main function\ndef main_solution(n, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert JSON serializable inputs to the original input variables\n    circle = list(range(1, n + 1))\n    \n    # Call the function that requires non-json serializable inputs\n    result = findFinalNum(circle, m)\n    \n    # Return the result, which is already json serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 35, "m": 2}, "output": 33}, {"input": {"n": 25, "m": 9}, "output": 14}, {"input": {"n": 39, "m": 2}, "output": 33}, {"input": {"n": 11, "m": 6}, "output": 11}, {"input": {"n": 68, "m": 8}, "output": 2}, {"input": {"n": 17, "m": 7}, "output": 12}, {"input": {"n": 42, "m": 4}, "output": 29}, {"input": {"n": 73, "m": 1}, "output": 73}, {"input": {"n": 56, "m": 8}, "output": 50}, {"input": {"n": 54, "m": 10}, "output": 51}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mmylll/FDSS_Algorithm", "path": "/jzoffer/62-finalNumofCircle.py", "msgidx": 9021}}
{"problem_description": "Given a game board represented by a string consisting of characters '+' and '-', where '+' indicates a position that can be flipped, and '-' indicates a position that cannot be flipped, determine if a player can guarantee a win by flipping any two consecutive '+' characters to '--' in their turn. The player who cannot make a move loses the game. What is the result of the game for a given initial state of the game board?", "io_requirements": "Input:\n  `s` (str): A string consisting of characters '+' and '-'. The string represents the initial state of the game board.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the player can guarantee a win with the given initial state of the game board.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def canWin(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return self.canWin_memory(s, {})\n\n    def canWin_memory(self, s, hash):\n        if s in hash:\n            return hash[s]\n\n        for i in range(len(s) - 1):\n            if s[i:i+2] != \"++\":\n                continue\n            else:\n                news = s[:i] + '--' + s[i+2:]\n                if not self.canWin_memory(news, hash):\n                    hash[s] = True\n                    return True\n\n        hash[s] = False\n        return False\n\n# main function\ndef main_solution(s):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.canWin(s)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"s": "-+++-+++-"}, "output": false}, {"input": {"s": "--+++--++-"}, "output": false}, {"input": {"s": "-+-+"}, "output": false}, {"input": {"s": "-+--++-"}, "output": true}, {"input": {"s": "--+-+"}, "output": false}, {"input": {"s": "++--+--++-"}, "output": false}, {"input": {"s": "--"}, "output": false}, {"input": {"s": "-+---+"}, "output": false}, {"input": {"s": "----++"}, "output": true}, {"input": {"s": "------"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "poweihuang17/practice_leetcode_and_interview", "path": "/Leetcode/Backtracking/294_Flip_Game_II.py", "msgidx": 9169}}
{"problem_description": "Given a binary tree with nodes containing integer values, what are the paths from the root node to each of the leaf nodes? The tree is constructed by inserting the node values in the order they appear in the input.", "io_requirements": "Input:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. The string should be an array of integers, where each integer represents a node value to be inserted into the tree in the order they appear.\n\nOutput:\n  `return` (str): A JSON string representing the paths from the root to the leaves of the binary tree. Each path is represented as an array of integers, where each integer is a node value in the path.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass node(object):\n    def __init__(self, val=None, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    \n    def insert(self, *args):\n        if not args:\n            return\n        if not self.val:\n            self.val = args[0]\n            args = args[1:]\n            if not args:\n                return\n        for arg in args:\n            if arg < self.val:\n                if self.left: \n                    self.left.insert(arg)\n                else:\n                    self.left = node(arg)\n            else:\n                if self.right:\n                    self.right.insert(arg)\n                else:\n                    self.right = node(arg)\n    \n    def get_paths(self, lst:list=[]):\n        if self.left and self.right:\n            return self.left.get_paths(lst+[self.val]) + self.right.get_paths(lst+[self.val])\n        elif self.left:\n            return self.left.get_paths(lst+[self.val])\n        elif self.right:\n            return self.right.get_paths(lst+[self.val])\n        else:\n            return [lst+[self.val]]\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    tree_structure = json.loads(tree_structure)\n    root = node()\n    root.insert(*tree_structure)\n    \n    # Get the paths from the root to the leaves\n    paths = root.get_paths()\n    \n    # Convert the output to JSON serializable format\n    paths_serializable = json.dumps(paths)\n    \n    return paths_serializable", "funcname": "main_solution", "ios": [{"input": {"tree_structure": "[51, 46, 90, 55, 34, 14, 95, 49, 18]"}, "output": "[[51, 46, 34, 14, 18], [51, 46, 49], [51, 90, 55], [51, 90, 95]]"}, {"input": {"tree_structure": "[73, 3, 94, 28, 18, 42, 16, 32]"}, "output": "[[73, 3, 28, 18, 16], [73, 3, 28, 42, 32], [73, 94]]"}, {"input": {"tree_structure": "[62, 28, 41, 33, 39, 53, 56, 71, 35, 81, 62]"}, "output": "[[62, 28, 41, 33, 39, 35], [62, 28, 41, 53, 56], [62, 71, 62], [62, 71, 81]]"}, {"input": {"tree_structure": "[91, 57, 57, 27, 14, 51, 89, 23, 28]"}, "output": "[[91, 57, 27, 14, 23], [91, 57, 27, 51, 28], [91, 57, 57, 89]]"}, {"input": {"tree_structure": "[4, 38, 9, 64, 27, 15, 74, 91, 57, 53, 78, 80, 89, 45]"}, "output": "[[4, 38, 9, 27, 15], [4, 38, 64, 57, 53, 45], [4, 38, 64, 74, 91, 78, 80, 89]]"}, {"input": {"tree_structure": "[70, 3, 58, 39, 36, 8, 95, 95]"}, "output": "[[70, 3, 58, 39, 36, 8], [70, 95, 95]]"}, {"input": {"tree_structure": "[13, 79, 67, 53, 65, 21, 38, 74, 35, 73, 74]"}, "output": "[[13, 79, 67, 53, 21, 38, 35], [13, 79, 67, 53, 65], [13, 79, 67, 74, 73], [13, 79, 67, 74, 74]]"}, {"input": {"tree_structure": "[31, 35, 93, 88, 77, 98, 17, 35, 6, 33, 6, 92]"}, "output": "[[31, 17, 6, 6], [31, 35, 33], [31, 35, 93, 88, 77, 35], [31, 35, 93, 88, 92], [31, 35, 93, 98]]"}, {"input": {"tree_structure": "[7, 58, 57, 19, 72, 59, 100, 88, 95, 23]"}, "output": "[[7, 58, 57, 19, 23], [7, 58, 72, 59], [7, 58, 72, 100, 88, 95]]"}, {"input": {"tree_structure": "[34, 70, 27, 65, 23, 70, 91, 77]"}, "output": "[[34, 27, 23], [34, 70, 65], [34, 70, 70, 91, 77]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "crane-ium/daily-coding-problems", "path": "/dcp78-150/dcp110.py", "msgidx": 8837}}
{"problem_description": "Given a binary tree, determine whether it is a height-balanced binary tree. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. What is the result of checking the balance of the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. The JSON object should have keys as node IDs (starting from '0' for the root) and values as objects containing the node's value (`val`), left child ID (`left`), and right child ID (`right`). If a child does not exist, the corresponding key should be `null`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is balanced (`True`) or not (`False`).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        return True if self.recur(root) != -1 else False\n\n    def recur(self, root):\n        if not root:\n            return 0\n        left = self.recur(root.left)\n        if left == -1:\n            return -1\n        right = self.recur(root.right)\n        if right == -1:\n            return -1\n        if abs(left - right) < 2:\n            return max(left, right) + 1\n        else:\n            return -1\n\n# main function\ndef main_solution(tree_structure: str) -> bool:\n    # Convert the JSON serializable input to the original input variables\n    tree_structure_dict = json.loads(tree_structure)\n    root = build_tree(tree_structure_dict)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isBalanced(root)\n    \n    # Return the JSON serializable output\n    return result\n\ndef build_tree(tree_structure: dict) -> TreeNode:\n    if not tree_structure:\n        return None\n    nodes = {id: TreeNode(val) for id, val in tree_structure.items()}\n    for id, node in nodes.items():\n        if tree_structure[id]['left']:\n            node.left = nodes[tree_structure[id]['left']]\n        if tree_structure[id]['right']:\n            node.right = nodes[tree_structure[id]['right']]\n    return nodes['0']", "funcname": "main_solution", "ios": [{"input": {"tree_structure": "{\"0\": {\"val\": 69, \"left\": null, \"right\": null}, \"1\": {\"val\": 86, \"left\": null, \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 13, \"left\": null, \"right\": null}, \"1\": {\"val\": 34, \"left\": \"0\", \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 55, \"left\": null, \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 84, \"left\": null, \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 88, \"left\": null, \"right\": null}, \"1\": {\"val\": 18, \"left\": null, \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 77, \"left\": null, \"right\": null}, \"1\": {\"val\": 64, \"left\": null, \"right\": \"1\"}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 62, \"left\": null, \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 19, \"left\": null, \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 99, \"left\": null, \"right\": null}}"}, "output": true}, {"input": {"tree_structure": "{\"0\": {\"val\": 45, \"left\": null, \"right\": null}}"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kongkongo/LeetCode", "path": "/isBalanced.py", "msgidx": 9341}}
{"problem_description": "In a hexagonal tile grid, some tiles are initially active based on a series of move sequences. Each move sequence determines the final position of a tile, and if a tile is visited an odd number of times, it becomes active. After initializing the active tiles, the grid undergoes a series of iterations where the state of each tile is updated based on its neighbors. How many tiles remain active after a given number of iterations?", "io_requirements": "Input:\n  `move_list` (str): A multi-line string where each line represents a sequence of moves (e.g., \"e\", \"w\", \"sw\", \"se\", \"nw\", \"ne\") that determine the final position of a tile. The moves are separated by spaces or newlines.\n  `iterations` (int): The number of iterations to perform on the active tiles. Each iteration updates the state of the tiles based on the rules of the game.\n\nOutput:\n  `return` (int): The number of active tiles after the specified number of iterations.", "refcode": "# import necessary packages\nimport collections\n\n# all class and function definitions in the code file, if any\ndef tile_neighbor(pos, move):\n    x, y = pos\n    if move == 'e':\n        return x + 1, y\n    if move == 'w':\n        return x - 1, y\n    if move == 'sw':\n        return x - 1, y - 1\n    if move == 'se':\n        return x, y - 1\n    if move == 'nw':\n        return x, y + 1\n    if move == 'ne':\n        return x + 1, y + 1\n\ndef get_initially_active_tiles(move_list):\n    active_tiles = set()\n    for moves in move_list.splitlines():\n        pos = (0, 0)\n        while moves:\n            if moves[0] in 'sn':\n                pos = tile_neighbor(pos, moves[:2])\n                moves = moves[2:]\n            else:\n                pos = tile_neighbor(pos, moves[0])\n                moves = moves[1:]\n        if pos in active_tiles:\n            active_tiles.remove(pos)\n        else:\n            active_tiles.add(pos)\n    return active_tiles\n\ndef all_neighbors(x, y):\n    return [(x + 1, y),\n            (x - 1, y),\n            (x - 1, y - 1),\n            (x, y - 1),\n            (x, y + 1),\n            (x + 1, y + 1)]\n\ndef iterate(active_tiles):\n    neighbor_counts = collections.defaultdict(int)\n    for pos in active_tiles:\n        for n in all_neighbors(*pos):\n            neighbor_counts[n] += 1\n    new_active = {pos\n                  for pos in active_tiles\n                  if neighbor_counts.pop(pos, 0) in (1, 2)}\n    new_active |= {pos\n                   for pos, count in neighbor_counts.items()\n                   if count == 2}\n    return new_active\n\n# main function\ndef main_solution(move_list, iterations):\n    # Convert the move_list string to a set of initially active tiles\n    active_tiles = get_initially_active_tiles(move_list)\n    \n    # Iterate the active tiles for the specified number of iterations\n    for _ in range(iterations):\n        active_tiles = iterate(active_tiles)\n    \n    # Return the number of active tiles after the iterations\n    return len(active_tiles)", "funcname": "main_solution", "ios": [{"input": {"move_list": "nw", "iterations": 16}, "output": 0}, {"input": {"move_list": "nenesw\newseneswsenew\nw\nse\nswsesw\nnwswsenw\ne", "iterations": 43}, "output": 228}, {"input": {"move_list": "seneeneswneswenw", "iterations": 54}, "output": 0}, {"input": {"move_list": "nwsewnwseswnwsew\nwswwne\nneswnw\nseswnwnwenwwnenene\nnesw\nneseneswswswswse\nnewew", "iterations": 72}, "output": 1108}, {"input": {"move_list": "eswenwwwe\nenenwswneenwsenw\nswswwsenewe\nneswnesw", "iterations": 44}, "output": 0}, {"input": {"move_list": "neseesw\nne\nswse\nnwswsewneswenw\nnwneswwneeseeene\nnwseneenesw", "iterations": 66}, "output": 991}, {"input": {"move_list": "nwwnenwnesewnw\nsewesw\nnenewsenwwneswsee\nswnenwswne\nswnewenwseewwne\neesenenenwnwswwe", "iterations": 82}, "output": 1042}, {"input": {"move_list": "se\nne\nsew\nnwenw", "iterations": 18}, "output": 125}, {"input": {"move_list": "neneseswsewnenwswne\nesenw\nwseenwnwne\nsenenwswswsweswne\nneneswnwseenwnwnwsw\nnwswse\nneeeswne\nsw\nsenw", "iterations": 45}, "output": 502}, {"input": {"move_list": "eneeneeswwsew\nnwewwswnesww\nswswwse\nsw\nnesesewnw\nswsenwnene", "iterations": 33}, "output": 201}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ShaswatPrabhat/aoc2020", "path": "/day24/code.py", "msgidx": 8892}}
{"problem_description": "Imagine you are tasked with modeling the seating arrangement in a waiting area for a ferry. The seating layout is represented on a grid where each position can either be a floor (.), an empty seat (L), or an occupied seat (#). The rules for how people choose or abandon their seats depend on the number of occupied seats adjacent to a given seat. There are two sets of rules: one considers only the eight immediately adjacent seats, while the other considers the first seat visible in each of the eight directions. Given a seating layout and the version of the rules to apply, how many seats end up occupied once the seating arrangement reaches equilibrium?", "io_requirements": "Input:\n  `layout` (list of strings): A list where each string represents a row of the seating layout. Each character in the string can be '.', 'L', or '#', representing floor, empty seat, and occupied seat respectively.\n  `v` (int): An integer indicating the version of the seating rules to apply. `v=0` uses the original rules, and `v=1` uses the updated visibility rules.\n\nOutput:\n  `return` (int): The number of occupied seats ('#') after the seating layout reaches equilibrium according to the specified rules.", "refcode": "# import necessary packages\nfrom collections import defaultdict\nfrom typing import NamedTuple\n\n# all class and function definitions in the code file, if any\nclass Pt(NamedTuple):\n    x: int\n    y: int\n\nclass Board:\n    DELTAS = [Pt(0, 1), Pt(1, 1), Pt(1, 0), Pt(1, -1), Pt(0, -1), Pt(-1, -1), Pt(-1, 0), Pt(-1, 1)]\n\n    def __init__(self, layout, v=0):\n        self.grid = {}\n        self.generations = 0\n        self.max_y = len(layout)\n        self.max_x = len(layout[0])\n        self.v = v\n\n        for y, row in enumerate(layout):\n            for x, pos in enumerate(row):\n                self.grid[Pt(x, y)] = pos\n\n    def next_state(self, x, y):\n        if self.grid[Pt(x, y)] == '.':\n            return '.'\n        occupied_neighbors = 0\n        for d in self.DELTAS:\n            pt_to_check = Pt(x + d.x, y + d.y)\n            if pt_to_check in self.grid and self.grid[pt_to_check] == '#':\n                occupied_neighbors += 1\n        if self.grid[Pt(x, y)] == 'L' and occupied_neighbors == 0:\n            return '#'\n        elif self.grid[Pt(x, y)] == '#' and occupied_neighbors >= 4:\n            return 'L'\n        return self.grid[Pt(x, y)]\n\n    def find_neighbor_in_direction(self, x, y, d):\n        for dist in range(1, max(self.max_x, self.max_y)):\n            pt = Pt(x + dist * d.x, y + dist * d.y)\n            if pt not in self.grid:\n                return '.'\n            if self.grid[pt] == '#':\n                return '#'\n            if self.grid[pt] == 'L':\n                return 'L'\n\n    def next_state_v2(self, x, y):\n        if self.grid[Pt(x, y)] == '.':\n            return '.'\n        occupied_neighbors = 0\n        for d in self.DELTAS:\n            pt_to_check = self.find_neighbor_in_direction(x, y, d)\n            if pt_to_check == '#':\n                occupied_neighbors += 1\n        if self.grid[Pt(x, y)] == 'L' and occupied_neighbors == 0:\n            return '#'\n        elif self.grid[Pt(x, y)] == '#' and occupied_neighbors >= 5:\n            return 'L'\n        return self.grid[Pt(x, y)]\n\n    def tick(self):\n        self.generations += 1\n        if self.v == 0:\n            new_grid = {k: self.next_state(k.x, k.y) for k in self.grid}\n        else:\n            new_grid = {k: self.next_state_v2(k.x, k.y) for k in self.grid}\n        if new_grid != self.grid:\n            self.grid = new_grid\n            return 1\n        return 0\n\n    def run(self):\n        while self.tick() == 1:\n            pass\n\n# main function\ndef main_solution(layout: list, v: int) -> int:\n    board = Board(layout, v)\n    board.run()\n    return sum([v == '#' for k, v in board.grid.items()])", "funcname": "main_solution", "ios": [{"input": {"layout": ["..#L#L.", ".#.LLL#", "#.L.#L.", ".L#LL##", "LL..LL.", "#LL#.##", "#.###LL", "#LL###L", "#L#L#L."], "v": 0}, "output": 20}, {"input": {"layout": [".L#.L#.#L", "#.L.#...L", "#L.#.L.L.", "##LL#L#..", "....#..L#"], "v": 0}, "output": 13}, {"input": {"layout": ["#.#L.", "##L.#", "##LL#", "..#L#", "..#.L", "#.#.#", ".L.L."], "v": 0}, "output": 11}, {"input": {"layout": ["##L#L", "#.#..", "L#.#.", "#.#L.", ".#.##", "L.#L.", "LL#L#", "L#L#L"], "v": 0}, "output": 14}, {"input": {"layout": ["#.#.L##L", "LL.LL#.L", "##.L##LL", "##.L#.#L", "L#L..##."], "v": 1}, "output": 15}, {"input": {"layout": [".L...LL..", "..#L...#.", "L#L.L....", "###L.#L..", ".L##.LLLL"], "v": 1}, "output": 10}, {"input": {"layout": [".LL###L#.L", ".#.L.LLLL.", "L.##..##.#", "LL#L.L.##L", "..L##LL.L#", "LLLL..LL##", ".LLL.L.L.L", "#.#L#L#L.L"], "v": 0}, "output": 27}, {"input": {"layout": [".###L", "L#.L#", ".#L#L", "##.#L", "L#.L#"], "v": 1}, "output": 12}, {"input": {"layout": ["####.##LL.", ".#L##.L###", "..LL#.##L#", "...#.#.##L", "L##L#.#.LL"], "v": 0}, "output": 15}, {"input": {"layout": [".L###L#", "#.L#LLL", "LL##.##", ".#.L#.L", "L.##L##", "#L#...L", ".L.L##."], "v": 0}, "output": 18}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jvano74/advent_of_code", "path": "/2020/day_11_test.py", "msgidx": 8653}}
{"problem_description": "Given a list of integers, you need to perform a specific operation on a binary search tree constructed from these integers. The operation can be to insert a new integer, delete an existing integer, or return the in-order traversal of the tree. What will be the result of the specified operation on the binary search tree?", "io_requirements": "Input:\n- `elements` (list of int): List of integers to be inserted into the binary search tree.\n- `operation` (str): Operation to perform on the tree. Can be \"insert\", \"delete\", or \"inorder\".\n- `key` (int): Key value for the operation. Required for \"insert\" and \"delete\" operations.\n\nOutput:\n- `return` (list of int or None): Result of the operation. For \"inorder\", it returns a list of integers representing the in-order traversal of the tree. For \"insert\" and \"delete\", it returns None.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Tree():\n    def __init__(self, root=None):\n        self.root = root\n\nclass Node():\n    \"\"\"\u8282\u70b9\u5143\u7d20\u5b9a\u4e49\"\"\"\n    def __init__(self, key, p=None, left=None, right=None):\n        self.key = key\n        self.p = p\n        self.left = left\n        self.right = right\n\ndef treeInsert(tree, node):\n    \"\"\"\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u63d2\u5165\u7b97\u6cd5\"\"\"\n    y = None\n    root = tree.root\n    while root:\n        y = root\n        if node.key < root.key:\n            root = root.left\n        else:\n            root = root.right\n    node.p = y\n    if y is None:  # empty tree\n        tree.root = node\n    elif node.key < y.key:\n        y.left = node\n    else:\n        y.right = node\n\ndef treeDelete(T, z):\n    \"\"\"\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u5220\u9664\u7b97\u6cd5\"\"\"\n    if z.left is None:\n        transplant(T, z, z.right)\n    elif z.right is None:\n        transplant(T, z, z.left)\n    else:\n        y = treeMinimum(z.right)\n        if y.p != z:\n            transplant(T, y, y.right)\n            y.right = z.right\n            y.right.p = y\n        transplant(T, z, y)\n        y.left = z.left\n        y.left.p = y\n\ndef transplant(T, u, v):\n    \"\"\"\u5b50\u6811\u66ff\u6362\uff1a\u5728\u6811T\u4e2d\u7528\u6839\u8282\u70b9\u8282\u70b9\u4e3av\u7684\u5b50\u6811\u66ff\u6362\u6839\u8282\u70b9\u4e3au\u7684\u5b50\u6811\"\"\"\n    if u.p is None:\n        T.root = v\n    elif u == u.p.left:\n        u.p.left = v\n    else:\n        u.p.right = v\n    if v:\n        v.p = u.p\n\ndef treeMinimum(node):\n    while node.left:\n        node = node.left\n    return node\n\ndef inOrderWalkNode(node, result):\n    \"\"\"\u4e2d\u5e8f\u904d\u5386\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u4ece\u5c0f\u5230\u5927\u8f93\u51fa\u5143\u7d20\"\"\"\n    if node:\n        inOrderWalkNode(node.left, result)\n        result.append(node.key)\n        inOrderWalkNode(node.right, result)\n\n# main function\ndef main_solution(elements, operation, key=None):\n    \"\"\"\n    Main function to perform operations on a binary search tree.\n    \n    Input:\n    - elements (list of int): List of integers to be inserted into the binary search tree.\n    - operation (str): Operation to perform on the tree. Can be \"insert\", \"delete\", or \"inorder\".\n    - key (int): Key value for the operation. Required for \"insert\" and \"delete\" operations.\n    \n    Output:\n    - return (list of int or None): Result of the operation. For \"inorder\", it returns a list of integers representing the in-order traversal of the tree. For \"insert\" and \"delete\", it returns None.\n    \"\"\"\n    tree = Tree()\n    \n    # Insert all elements into the tree\n    for element in elements:\n        treeInsert(tree, Node(element))\n    \n    if operation == \"insert\":\n        treeInsert(tree, Node(key))\n        return None\n    elif operation == \"delete\":\n        node_to_delete = treeSearch2(tree, key)\n        if node_to_delete:\n            treeDelete(tree, node_to_delete)\n        return None\n    elif operation == \"inorder\":\n        result = []\n        inOrderWalkNode(tree.root, result)\n        return result\n    else:\n        raise ValueError(\"Invalid operation\")\n\ndef treeSearch2(tree, x):\n    \"\"\"\"\u4e8c\u53c9\u6811\u641c\u7d22\uff0c\u8fed\u4ee3\u7248\u672c\"\"\"\n    root = tree.root\n    while root and x != root.key:\n        if x < root.key:\n            root = root.left\n        else:\n            root = root.right\n    return root", "funcname": "main_solution", "ios": [{"input": {"elements": [45, 3, 29, 70, 36, 19, 42, 31, 37, 22], "operation": "inorder", "key": null}, "output": [3, 19, 22, 29, 31, 36, 37, 42, 45, 70]}, {"input": {"elements": [46, 88, 83, 51, 31, 25, 14, 34, 7, 55], "operation": "inorder", "key": null}, "output": [7, 14, 25, 31, 34, 46, 51, 55, 83, 88]}, {"input": {"elements": [62, 95, 23, 15, 4, 20, 74, 46, 50, 41], "operation": "inorder", "key": null}, "output": [4, 15, 20, 23, 41, 46, 50, 62, 74, 95]}, {"input": {"elements": [3, 25, 89, 37, 67, 51, 92, 53, 16, 86], "operation": "inorder", "key": null}, "output": [3, 16, 25, 37, 51, 53, 67, 86, 89, 92]}, {"input": {"elements": [96, 57, 56, 72, 65, 39, 50, 46, 4, 9], "operation": "inorder", "key": null}, "output": [4, 9, 39, 46, 50, 56, 57, 65, 72, 96]}, {"input": {"elements": [12, 85, 4, 100, 32, 58, 2, 57, 75, 5], "operation": "inorder", "key": null}, "output": [2, 4, 5, 12, 32, 57, 58, 75, 85, 100]}, {"input": {"elements": [78, 72, 16, 87, 91, 81, 85, 1, 76, 12], "operation": "inorder", "key": null}, "output": [1, 12, 16, 72, 76, 78, 81, 85, 87, 91]}, {"input": {"elements": [68, 67, 47, 87, 88, 94, 77, 61, 70, 85], "operation": "inorder", "key": null}, "output": [47, 61, 67, 68, 70, 77, 85, 87, 88, 94]}, {"input": {"elements": [56, 91, 25, 31, 10, 14, 71, 4, 59, 41], "operation": "inorder", "key": null}, "output": [4, 10, 14, 25, 31, 41, 56, 59, 71, 91]}, {"input": {"elements": [57, 74, 40, 37, 52, 8, 82, 10, 5, 61], "operation": "inorder", "key": null}, "output": [5, 8, 10, 37, 40, 52, 57, 61, 74, 82]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yidao620c/core-algorithm", "path": "/algorithms/c04_tree/bisearch_tree.py", "msgidx": 8888}}
{"problem_description": "Given a map represented by a grid of '0's and '1's, where '0' represents water and '1' represents land, how many distinct islands are there on the map? An island is defined as a contiguous block of land cells (connected horizontally or vertically) surrounded by water cells.", "io_requirements": "Input:\n  `island_map` (List[List[str]]): A 2D list representing the map where each element is either '0' (water) or '1' (land). The size of the map should be reasonable, typically less than 10x10 for practical purposes.\n\nOutput:\n  `return` (int): The number of islands found in the map. An island is defined as a contiguous block of '1's (land) surrounded by '0's (water).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def pretty_print_map(self, grid: List[List[str]]) -> str:\n        pretty_map = \"\"\n        for y in range(len(grid)):\n            for x in range(len(grid[0])):\n                pretty_map = pretty_map + f\"\\t{grid[y][x]}\"\n            pretty_map += \"\\n\"\n\n        return pretty_map\n\n    def get_num_islands(self, grid: List[List[str]]) -> int:\n        num_islands = 0\n\n        # Get our flag checker!\n        visited_coords = [[0 for _y in range(len(grid[0]))] for _x in range(len(grid))]\n\n        # Start map traversal!\n        for y in range(len(grid)):\n            for x in range(len(grid[0])):\n                # If this is water or land we've already visited, we're not \n                # interested; move to next coord.\n                if int(grid[y][x]) == 0:\n                    continue\n                if visited_coords[y][x] == 1:\n                    continue\n\n                # This is a piece of unvisited land! Start an island search.\n                searching_island = True\n                water_N = False\n                water_E = False\n                water_S = False\n                water_W = False\n                search_x = x\n                search_y = y\n                search_direction = \"N\"\n                while searching_island:\n                    visited_coords[search_y][search_x] = 1\n\n                    # Check for borders/water first, then visited land. When found,\n                    # either quit searching or change direction. If neither are \n                    # found, continue searching in the same direction.\n                    if search_direction == \"N\":\n                        search_y = search_y - 1\n                        on_starting_coord = search_x == x and search_y == y\n                        if search_y == -1 or int(grid[search_y][search_x]) == 0:\n                            search_y = search_y + 1\n                            water_N = True\n                            search_direction = \"E\"\n                        elif not on_starting_coord and visited_coords[search_y][search_x] == 1:\n                            searching_island = False\n                        else:\n                            search_direction = \"N\"\n                    elif search_direction == \"E\":\n                        search_x = search_x + 1\n                        on_starting_coord = search_x == x and search_y == y\n                        if search_x == len(grid[0]) or int(grid[search_y][search_x]) == 0:\n                            water_E = True\n                            search_direction = \"S\"\n                            search_x = search_x - 1\n                        elif not on_starting_coord and visited_coords[search_y][search_x] == 1:\n                            searching_island = False\n                        else:\n                            search_direction = \"E\"\n                    elif search_direction == \"S\":\n                        search_y = search_y + 1\n                        on_starting_coord = search_x == x and search_y == y\n                        if search_y == len(grid) or int(grid[search_y][search_x]) == 0:\n                            water_S = True\n                            search_direction = \"W\"\n                            search_y = search_y - 1\n                        elif not on_starting_coord and visited_coords[search_y][search_x] == 1:\n                            searching_island = False\n                        else:\n                            search_direction = \"S\"\n                    elif search_direction == \"W\":\n                        search_x = search_x - 1\n                        on_starting_coord = search_x == x and search_y == y\n                        if search_x == -1 or int(grid[search_y][search_x]) == 0:\n                            water_W = True\n                            search_direction = \"N\"\n                            search_x = search_x + 1\n                        elif not on_starting_coord and visited_coords[search_y][search_x] == 1:\n                            searching_island = False\n                        else:\n                            search_direction = \"W\"\n\n                    if water_N and water_E and water_S and water_W:\n                        num_islands += 1\n                        searching_island = False\n\n                # Finished searching island! Continuing traversal.\n\n        return num_islands\n\n# main function\ndef main_solution(island_map: List[List[str]]) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    return solution.get_num_islands(island_map)", "funcname": "main_solution", "ios": [{"input": {"island_map": [["1", "0", "1", "0"], ["0", "0", "1", "1"], ["1", "1", "0", "1"]]}, "output": 4}, {"input": {"island_map": [["1", "0", "1", "0"], ["1", "1", "0", "0"], ["1", "1", "0", "1"], ["0", "1", "0", "1"], ["0", "1", "1", "0"]]}, "output": 4}, {"input": {"island_map": [["0", "0", "0", "0", "1", "1"], ["1", "1", "0", "0", "1", "0"], ["1", "0", "0", "0", "0", "0"]]}, "output": 2}, {"input": {"island_map": [["0", "0", "1", "1"], ["1", "0", "1", "1"], ["1", "1", "0", "0"], ["1", "1", "0", "0"], ["0", "1", "0", "1"]]}, "output": 4}, {"input": {"island_map": [["1", "0", "1", "1"], ["1", "0", "0", "0"], ["0", "0", "1", "1"], ["0", "1", "0", "1"]]}, "output": 4}, {"input": {"island_map": [["0", "1", "0"], ["0", "0", "0"], ["0", "1", "1"], ["0", "0", "0"]]}, "output": 2}, {"input": {"island_map": [["0", "0", "0", "0", "1"], ["1", "0", "0", "0", "0"], ["0", "0", "1", "0", "1"], ["0", "0", "0", "0", "0"]]}, "output": 4}, {"input": {"island_map": [["1", "0", "0"], ["0", "0", "1"], ["0", "0", "1"]]}, "output": 2}, {"input": {"island_map": [["1", "0", "0", "1"], ["0", "1", "1", "0"], ["1", "1", "0", "0"], ["0", "1", "0", "1"], ["1", "1", "1", "0"]]}, "output": 5}, {"input": {"island_map": [["1", "0", "0", "1"], ["0", "0", "0", "0"], ["0", "0", "1", "1"], ["0", "1", "0", "0"], ["0", "1", "0", "1"], ["0", "0", "0", "1"]]}, "output": 5}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "g00dduck/leetcode-sols", "path": "/0000_island_search.py", "msgidx": 8905}}
{"problem_description": "Given a range of numbers from `start` to `end`, how many numbers within this range meet the criteria for being a valid password according to two different sets of rules? The first set of rules requires the number to have at least two adjacent digits that are the same and the digits to be in non-decreasing order. The second set of rules requires the number to have at least one pair of adjacent digits that are the same and the digits to be in non-decreasing order.", "io_requirements": "Input:\n  `start` (int): The starting number of the range to check for valid passwords.\n  `end` (int): The ending number of the range to check for valid passwords.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `count_part1` (int): The number of valid passwords according to the first part's criteria.\n    - `count_part2` (int): The number of valid passwords according to the second part's criteria.", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# main function\ndef main_solution(start, end):\n    # Convert non-JSON serializable inputs if necessary\n    start = int(start)\n    end = int(end)\n\n    def is_password(num):\n        t = str(num)\n        return (\n            any(x == y for x, y in zip(t, t[1:]))\n            and\n            all(int(x) <= int(y) for x, y in zip(t, t[1:]))\n        )\n\n    def is_password_two(num):\n        t = str(num)\n        digits = Counter(t)\n        return (\n            (2 in digits.values())\n            and\n            all(int(x) <= int(y) for x, y in zip(t, t[1:]))\n        )\n\n    count_part1 = sum(is_password(num) for num in range(start, end + 1))\n    count_part2 = sum(is_password_two(num) for num in range(start, end + 1))\n\n    # Return JSON serializable output\n    return {\"count_part1\": count_part1, \"count_part2\": count_part2}", "funcname": "main_solution", "ios": [{"input": {"start": 304987, "end": 680311}, "output": {"count_part1": 883, "count_part2": 587}}, {"input": {"start": 326150, "end": 802242}, "output": {"count_part1": 910, "count_part2": 600}}, {"input": {"start": 370069, "end": 510554}, "output": {"count_part1": 272, "count_part2": 174}}, {"input": {"start": 124567, "end": 891516}, "output": {"count_part1": 2211, "count_part2": 1490}}, {"input": {"start": 176707, "end": 521939}, "output": {"count_part1": 1499, "count_part2": 1032}}, {"input": {"start": 148342, "end": 285912}, "output": {"count_part1": 895, "count_part2": 615}}, {"input": {"start": 104200, "end": 637824}, "output": {"count_part1": 2835, "count_part2": 2000}}, {"input": {"start": 390604, "end": 689070}, "output": {"count_part1": 432, "count_part2": 277}}, {"input": {"start": 197557, "end": 845094}, "output": {"count_part1": 1682, "count_part2": 1146}}, {"input": {"start": 180398, "end": 495736}, "output": {"count_part1": 1483, "count_part2": 1025}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "qoqosz/Advent-of-Code-2019", "path": "/p04.py", "msgidx": 9226}}
{"problem_description": "In a historical game, `n` people stand in a circle, and every `k-th` person is eliminated until only one person remains. Given the number of people `n` and the skip count `k`, which position in the initial circle will be the last person standing?", "io_requirements": "Input:\n  `n` (int): The number of people standing in a circle.\n  `k` (int): The number of people skipped before removing the next person.\n\nOutput:\n  `return` (int): The position of the last remaining person (the winner) in the initial circle.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef josephusProblem(n, k):\n    places = list(range(1, n+1))\n    pointer = 0\n    while len(places) > 1:\n        pointer = (pointer + k-1) % len(places)\n        places.pop(pointer)\n    return places[0]\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    winner = josephusProblem(n, k)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return winner", "funcname": "main_solution", "ios": [{"input": {"n": 12, "k": 11}, "output": 6}, {"input": {"n": 83, "k": 43}, "output": 23}, {"input": {"n": 27, "k": 1}, "output": 27}, {"input": {"n": 29, "k": 27}, "output": 23}, {"input": {"n": 99, "k": 40}, "output": 60}, {"input": {"n": 65, "k": 32}, "output": 57}, {"input": {"n": 51, "k": 50}, "output": 45}, {"input": {"n": 83, "k": 55}, "output": 62}, {"input": {"n": 27, "k": 5}, "output": 18}, {"input": {"n": 28, "k": 28}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "heitorchang/learn-code", "path": "/battles/adhoc/josephus.py", "msgidx": 9611}}
{"problem_description": "Given a Roman numeral, determine if it is a valid Roman numeral in the range of 1 to 3999. What is the validity status of the provided Roman numeral?", "io_requirements": "Input:\n  `roman_numeral` (str): A string representing a Roman numeral in the range 1-3999. The string should be in uppercase and follow the standard Roman numeral rules.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string is a valid Roman numeral. Returns `True` if valid, `False` otherwise.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(roman_numeral):\n    # Define the patterns for each digit position\n    digit4 = r'IX|VI{0,3}|IV|I{1,3}'\n    digit3 = r'XC|LX{0,3}|XL|X{1,3}|' + digit4\n    digit2 = r'CM|DC{0,3}|CD|C{1,3}|' + digit3\n    digit1 = r'M{1,3}|' + digit2\n    pattern = (fr'({digit1})({digit2})({digit3})({digit4})|'\n               fr'({digit1})({digit2})({digit3})|({digit1})({digit2})|({digit1})')\n    \n    # Check if the input matches the pattern\n    if re.match(pattern, roman_numeral, flags=re.I):\n        return True\n    else:\n        return False", "funcname": "main_solution", "ios": [{"input": {"roman_numeral": "CCCVIII"}, "output": true}, {"input": {"roman_numeral": "MDLIV"}, "output": true}, {"input": {"roman_numeral": "CCLV"}, "output": true}, {"input": {"roman_numeral": "MCDVII"}, "output": true}, {"input": {"roman_numeral": "MCXCVI"}, "output": true}, {"input": {"roman_numeral": "MMMDCCLXXIII"}, "output": true}, {"input": {"roman_numeral": "MMCXLIV"}, "output": true}, {"input": {"roman_numeral": "MCCLXIII"}, "output": true}, {"input": {"roman_numeral": "MMMDCCXXXVII"}, "output": true}, {"input": {"roman_numeral": "MMCXXVI"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sockduct/Hackerrank", "path": "/Python/validrnum.py", "msgidx": 8818}}
{"problem_description": "Given a string representing the preorder traversal of a binary tree, where each node is either an integer or a sentinel value '#' representing a null node, determine whether the string is a valid serialization of a binary tree. What is the validity of the given preorder traversal string?", "io_requirements": "Input:\n  `preorder` (str): A comma-separated string representing the preorder traversal of a binary tree. Each value in the string must be either an integer or the character '#' representing a null node.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the given string is a correct preorder traversal serialization of a binary tree. Returns `True` if it is valid, otherwise `False`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isValidSerialization(self, preorder):\n        A = preorder.split(',')\n        cnt = 0\n        for i in range(len(A)-1):\n            if A[i] == '#':\n                if cnt == 0:    return False\n                cnt -= 1\n            else:\n                cnt += 1\n        \n        return cnt == 0 and A[-1] == '#'\n\n# main function\ndef main_solution(preorder):\n    # Convert the input string to a list of values\n    A = preorder.split(',')\n    \n    # Initialize the counter for unmatched '#' and numbers\n    cnt = 0\n    \n    # Iterate through the list of values\n    for i in range(len(A)-1):\n        if A[i] == '#':\n            if cnt == 0:    return False\n            cnt -= 1\n        else:\n            cnt += 1\n    \n    # Check the final condition\n    return cnt == 0 and A[-1] == '#'", "funcname": "main_solution", "ios": [{"input": {"preorder": "1,7,#,#,#"}, "output": true}, {"input": {"preorder": "#"}, "output": true}, {"input": {"preorder": "6,#,#"}, "output": true}, {"input": {"preorder": "#,#,8,9,7,4,#,4,#"}, "output": false}, {"input": {"preorder": "#,#,3,#,3,#,2,#"}, "output": false}, {"input": {"preorder": "#,8,4,#,#"}, "output": false}, {"input": {"preorder": "2,8,6,2,8,#"}, "output": false}, {"input": {"preorder": "8,#,#,7,7,#,4,#,#"}, "output": false}, {"input": {"preorder": "#,#,2,#"}, "output": false}, {"input": {"preorder": "#,#,#,5,8,#"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cybelewang/leetcode-python", "path": "/code331VerifyPreorderSerializationOfABinaryTree.py", "msgidx": 9025}}
{"problem_description": "Given a range of integers, what are the integers within this range that, when added to 100, result in a perfect square, and when added to 268 (100 + 168), also result in a perfect square?", "io_requirements": "Input:\n  `lower_bound` (int): The lower bound of the range to search for the integer.\n  `upper_bound` (int): The upper bound of the range to search for the integer.\n\nOutput:\n  `return` (list): A list of integers that satisfy the conditions. Each integer in the list is within the specified range and satisfies the condition that adding 100 to it results in a perfect square, and adding 168 to the result also results in a perfect square.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(lower_bound, upper_bound):\n    \"\"\"\n    Finds all integers within the specified range that satisfy the condition:\n    - Adding 100 to the integer results in a perfect square.\n    - Adding 168 to the result of the first condition also results in a perfect square.\n\n    Parameters:\n    lower_bound (int): The lower bound of the range to search for the integer.\n    upper_bound (int): The upper bound of the range to search for the integer.\n\n    Returns:\n    list: A list of integers that satisfy the conditions.\n    \"\"\"\n    results = []\n    for i in range(1, int(math.sqrt(upper_bound + 100)) + 1):\n        for j in range(i+1, int(math.sqrt(upper_bound + 268)) + 1):\n            x = i*i - 100\n            if x >= lower_bound and x <= upper_bound and (j*j - i*i == 168):\n                results.append(x)\n    return results", "funcname": "main_solution", "ios": [{"input": {"lower_bound": 687, "upper_bound": 1662}, "output": [1581]}, {"input": {"lower_bound": 430, "upper_bound": 898}, "output": []}, {"input": {"lower_bound": 557, "upper_bound": 1448}, "output": []}, {"input": {"lower_bound": 234, "upper_bound": 696}, "output": [261]}, {"input": {"lower_bound": 896, "upper_bound": 1691}, "output": [1581]}, {"input": {"lower_bound": 681, "upper_bound": 1182}, "output": []}, {"input": {"lower_bound": 473, "upper_bound": 1472}, "output": []}, {"input": {"lower_bound": 51, "upper_bound": 614}, "output": [261]}, {"input": {"lower_bound": 119, "upper_bound": 894}, "output": [261]}, {"input": {"lower_bound": 906, "upper_bound": 1848}, "output": [1581]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shu-qing/python-tutorials", "path": "/execises/003.py", "msgidx": 9277}}
{"problem_description": "Given a number of pairs of brackets, what are all the possible valid sequences of these brackets that can be generated?", "io_requirements": "Input:\n  `n` (int): The number of pairs of brackets to generate. Must be a positive integer.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a valid sequence of `n` pairs of brackets.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generator_brackets(n, sequence='', opened=0, closed=0):\n    if len(sequence) != 2 * n:\n        if opened < n:\n            generator_brackets(n, sequence + '(', opened + 1, closed)\n        if closed < opened:\n            generator_brackets(n, sequence + ')', opened, closed + 1)\n    else:\n        return sequence\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    results = []\n    def collect_results(sequence):\n        results.append(sequence)\n    \n    def generator_brackets_wrapper(n, sequence='', opened=0, closed=0):\n        if len(sequence) != 2 * n:\n            if opened < n:\n                generator_brackets_wrapper(n, sequence + '(', opened + 1, closed)\n            if closed < opened:\n                generator_brackets_wrapper(n, sequence + ')', opened, closed + 1)\n        else:\n            collect_results(sequence)\n    \n    generator_brackets_wrapper(n)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return results", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Slavik0041/BelHard_education", "path": "/bh_5_tasks-Sherlat_ready/hard/generate_brackets.py", "msgidx": 9542}}
{"problem_description": "Given a range of two-digit numbers, what is the product of all curious fractions within that range? A curious fraction is defined as a fraction where, by canceling one digit from the numerator and one digit from the denominator, the value of the fraction remains unchanged. The product should be represented as a fraction with its numerator and denominator.", "io_requirements": "Input:\n  `start_range` (int): The starting range for the numerator and denominator of the fractions to be checked.\n  `end_range` (int): The ending range for the numerator and denominator of the fractions to be checked.\n\nOutput:\n  `return` (dict): A dictionary containing the numerator and denominator of the product of all curious fractions found within the specified range. The keys are:\n    - `numerator` (int): The numerator of the product.\n    - `denominator` (int): The denominator of the product.", "refcode": "# import necessary packages\nfrom fractions import Fraction\nfrom functools import reduce\nfrom operator import mul\n\n# all class and function definitions in the code file, if any\ndef is_curious(num, den):\n    if(num==den):\n        return False\n    num_s, den_s = str(num), str(den)\n    if num_s[1] == den_s[1] == '0':\n        return False\n    try:\n        if num_s[0] == den_s[0] and Fraction(num, den) ==Fraction(int(num_s[1]),int(den_s[1])):\n            return True\n        if num_s[1] == den_s[0] and Fraction(num, den) ==Fraction(int(num_s[0]),int(den_s[1])):\n            return True\n        if num_s[0] == den_s[1] and Fraction(num, den) ==Fraction(int(num_s[1]),int(den_s[0])):\n            return True\n        if num_s[1] == den_s[1] and Fraction(num, den) ==Fraction(int(num_s[0]),int(den_s[0])):\n            return True\n    except:\n        pass\n    return False\n\ndef find_curious():\n    for num in range(11, 100):\n        for den in range(num, 100):\n            if is_curious(num, den):\n                yield Fraction(num, den)\n\n# main function\ndef main_solution(start_range, end_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    fractions = []\n    for num in range(start_range, end_range + 1):\n        for den in range(num, end_range + 1):\n            if is_curious(num, den):\n                fractions.append(Fraction(num, den))\n    \n    if not fractions:\n        return None\n    \n    product = reduce(mul, fractions)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"numerator\": product.numerator, \"denominator\": product.denominator}", "funcname": "main_solution", "ios": [{"input": {"start_range": 15, "end_range": 75}, "output": {"numerator": 1, "denominator": 10}}, {"input": {"start_range": 22, "end_range": 86}, "output": {"numerator": 2, "denominator": 5}}, {"input": {"start_range": 18, "end_range": 86}, "output": {"numerator": 2, "denominator": 5}}, {"input": {"start_range": 26, "end_range": 75}, "output": {"numerator": 2, "denominator": 5}}, {"input": {"start_range": 13, "end_range": 95}, "output": {"numerator": 1, "denominator": 50}}, {"input": {"start_range": 19, "end_range": 70}, "output": {"numerator": 2, "denominator": 5}}, {"input": {"start_range": 22, "end_range": 80}, "output": {"numerator": 2, "denominator": 5}}, {"input": {"start_range": 10, "end_range": 71}, "output": {"numerator": 1, "denominator": 10}}, {"input": {"start_range": 21, "end_range": 66}, "output": {"numerator": 2, "denominator": 5}}, {"input": {"start_range": 26, "end_range": 67}, "output": {"numerator": 2, "denominator": 5}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "smaranjitghose/PyProjectEuler", "path": "/solutions/33-digit-cancelling-fractions.py", "msgidx": 9244}}
{"problem_description": "Given a chessboard of size `n x n`, where `n` is an integer, and a special chess piece called KnightL that moves in an L shape, what is the minimum number of moves required for the KnightL to move from the top-left corner to the bottom-right corner for each possible pair of move sizes `(i, j)` where `1 <= i, j < n`? If it's not possible for the KnightL to reach the destination, the answer should be `-1`.", "io_requirements": "Input:\n  `n` (int): The size of the chessboard. It denotes an n x n chessboard.\n\nOutput:\n  `return` (list of lists of int): A 2D list where each element at position `[i][j]` represents the minimum number of moves required for a KnightL chess piece to move from the top-left corner to the bottom-right corner on an n x n chessboard, using moves defined by `(i+1, j+1)`. If it's not possible, the value is `-1`.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\ndef valid(x, y, n, vi):\n    if x >= n or x < 0 or y >= n or y < 0:\n        return False\n    if vi[x][y]:\n        return False\n    return True\n\ndef BFS(x, y, p, qq, n):\n    q = deque()\n    vi = [[False for _ in range(n)] for _ in range(n)]\n    dis = [[0 for _ in range(n)] for _ in range(n)]\n    vi[x][y] = True\n    q.append([x, y])\n    \n    dx = [p, p, -p, -p, qq, qq, -qq, -qq]\n    dy = [qq, -qq, qq, -qq, p, -p, p, -p]\n    \n    while q:\n        A = q.popleft()\n        X = A[0]\n        Y = A[1]\n        \n        for i in range(8):\n            newX = X + dx[i]\n            newY = Y + dy[i]\n            \n            if valid(newX, newY, n, vi):\n                q.append([newX, newY])\n                dis[newX][newY] = dis[X][Y] + 1\n                if newX == n-1 and newY == n-1:\n                    return dis[n-1][n-1]\n                vi[newX][newY] = True\n    \n    return -1\n\n# main function\ndef main_solution(n):\n    result = []\n    for i in range(1, n):\n        row = []\n        for j in range(1, n):\n            row.append(BFS(0, 0, i, j, n))\n        result.append(row)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": [[2, 4], [4, 1]]}, {"input": {"n": 4}, "output": [[3, 2, 3], [2, -1, -1], [3, -1, 1]]}, {"input": {"n": 5}, "output": [[4, 4, 2, 8], [4, 2, 4, 4], [2, 4, -1, -1], [8, 4, -1, 1]]}, {"input": {"n": 6}, "output": [[5, 4, 3, 2, 5], [4, -1, 2, -1, -1], [3, 2, -1, -1, -1], [2, -1, -1, -1, -1], [5, -1, -1, -1, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "skdonepudi/100DaysOfCode", "path": "/Day 91/KnightLOnChessBoard.py", "msgidx": 9091}}
{"problem_description": "Given a binary tree, how can we represent its structure in a 2D array where each level of the tree is represented as a list, and each node's value is placed at the correct position according to its level and position in the tree? Specifically, what is the 2D array representation of the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (list of integers or None): A list representing the binary tree in level order traversal. Each element in the list represents a node's value, with `None` indicating a null node.\n\nOutput:\n  `return` (string): A JSON string representing a list of lists of strings. Each inner list corresponds to a level in the binary tree, and each string in the inner list represents the value of a node at that level. Empty strings indicate positions where no node is present.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def printTree(self, root):\n        h = self.getHeight(root)\n        w = pow(2, h) - 1\n        self.res = [[\"\" for i in range(w)] for j in range(h)]\n        self.printHelper(root, 0, w - 1, 0, h)\n        return self.res\n    \n    def printHelper(self, node, i, j, currH, height):\n        if not node or currH == height:\n            return\n        nodePos = (i + j) // 2\n        self.res[currH][nodePos] = str(node.val)\n        self.printHelper(node.left, i, nodePos, currH + 1, height)\n        self.printHelper(node.right, nodePos + 1, j, currH + 1, height)\n        \n    def getHeight(self, root):\n        if not root:\n            return 0\n        return max(self.getHeight(root.left), self.getHeight(root.right)) + 1\n\n# main function\ndef main_solution(tree_structure):\n    # Convert JSON serializable input to TreeNode structure\n    def build_tree(data):\n        if not data:\n            return None\n        root = TreeNode(data[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(data):\n            node = queue.pop(0)\n            if data[i] is not None:\n                node.left = TreeNode(data[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(data) and data[i] is not None:\n                node.right = TreeNode(data[i])\n                queue.append(node.right)\n            i += 1\n        return root\n    \n    # Build the tree from the input structure\n    root = build_tree(tree_structure)\n    \n    # Use the Solution class to get the result\n    solution = Solution()\n    result = solution.printTree(root)\n    \n    # Convert the result to a JSON serializable format\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [81]}, "output": "[[\"81\"]]"}, {"input": {"tree_structure": [45, 44, null]}, "output": "[[\"\", \"45\", \"\"], [\"44\", \"\", \"\"]]"}, {"input": {"tree_structure": [50, 54, 28]}, "output": "[[\"\", \"50\", \"\"], [\"54\", \"\", \"28\"]]"}, {"input": {"tree_structure": [30]}, "output": "[[\"30\"]]"}, {"input": {"tree_structure": [63, 27, null, null, null, null, 43, 46, 35, 4, 23, null, 87, 42, null]}, "output": "[[\"\", \"63\", \"\"], [\"27\", \"\", \"\"]]"}, {"input": {"tree_structure": [60, null, null]}, "output": "[[\"60\"]]"}, {"input": {"tree_structure": [44, null, 22]}, "output": "[[\"\", \"44\", \"\"], [\"\", \"\", \"22\"]]"}, {"input": {"tree_structure": [62, 54, 21]}, "output": "[[\"\", \"62\", \"\"], [\"54\", \"\", \"21\"]]"}, {"input": {"tree_structure": [16, null, null, null, null, null, null]}, "output": "[[\"16\"]]"}, {"input": {"tree_structure": [22]}, "output": "[[\"22\"]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Huijuan2015/leetcode_Python_2019", "path": "/655. Print Binary Tree.py", "msgidx": 9286}}
{"problem_description": "Given the center coordinates of an H-tree, an initial length of the line segments, and the depth of the H-tree, how can we construct the H-tree using recursive line drawing?", "io_requirements": "Input:\n  `center_x` (float): The x-coordinate of the center of the H-tree.\n  `center_y` (float): The y-coordinate of the center of the H-tree.\n  `initial_length` (float): The initial length of the line segments.\n  `depth` (int): The depth of the H-tree to be constructed.\n\nOutput:\n  `return` (dict): A dictionary with a single key \"status\" indicating that the H-tree has been drawn.", "refcode": "# import necessary packages\nimport math\n\n# drawLine provided\ndef drawLine(x1, y1, x2, y2):\n    # draws line, assume implementation available\n    pass\n\n# main function\ndef main_solution(center_x, center_y, initial_length, depth):\n    # Convert input variables to JSON serializable types if necessary\n    center_x = float(center_x)\n    center_y = float(center_y)\n    initial_length = float(initial_length)\n    depth = int(depth)\n\n    def drawHTree(x, y, length, depth):\n        if depth <= 0:\n            return\n        new_length = length / math.sqrt(2)\n        drawHTree(x - new_length / 2, y - new_length / 2, new_length, depth - 1)  # LT\n        drawHTree(x - new_length / 2, y + new_length / 2, new_length, depth - 1)  # RB\n        drawHTree(x + new_length / 2, y - new_length / 2, new_length, depth - 1)  # RT\n        drawHTree(x + new_length / 2, y + new_length / 2, new_length, depth - 1)  # RB\n        drawLine(x - length / 2, y, x + length / 2, y)  # Horizontal line\n        drawLine(x, y - length / 2, x, y + length / 2)  # Vertical line\n\n    drawHTree(center_x, center_y, initial_length, depth)\n\n    # Return a JSON serializable output\n    return {\"status\": \"HTree drawn\"}", "funcname": "main_solution", "ios": [{"input": {"center_x": -6.692745230834447, "center_y": 98.77120723017183, "initial_length": 96.04936522280083, "depth": 2}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": -75.34939322986554, "center_y": 31.595664305039605, "initial_length": 57.89844743012827, "depth": 1}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": 81.91993618937218, "center_y": -69.59223179875458, "initial_length": 63.42093624544693, "depth": 3}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": -16.120226504699247, "center_y": -7.608537723548167, "initial_length": 93.22254624179786, "depth": 7}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": 12.941164054121998, "center_y": 58.95158299915494, "initial_length": 7.751895733663627, "depth": 4}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": 50.30991260511962, "center_y": -71.25146837181813, "initial_length": 44.428655175226965, "depth": 9}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": -26.252353380901923, "center_y": 40.7847173194844, "initial_length": 44.007447065344316, "depth": 7}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": 42.734519377847846, "center_y": -74.59155867950919, "initial_length": 45.333156368691824, "depth": 8}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": 75.17168587474987, "center_y": 28.803335309731978, "initial_length": 40.1835364922477, "depth": 5}, "output": {"status": "HTree drawn"}}, {"input": {"center_x": -68.53166349971012, "center_y": -96.62826322431218, "initial_length": 63.498564128956275, "depth": 10}, "output": {"status": "HTree drawn"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sandeepbaldawa/Programming-Concepts-Python", "path": "/trees/htree.py", "msgidx": 9372}}
{"problem_description": "Given a number tree where each number is defined as the sum of its two parents, what is the result of performing a specific operation on a particular row of the tree? The operations include calculating the sum of all entries in a row, the alternating sum of all entries in a row, the sum of the squares of the entries in a row, and the sum of the entries in a diagonal row that extends to the upper right from the first entry in the specified row.", "io_requirements": "Input:\n  `operation` (str): The type of operation to perform. Possible values are \"row_sum\", \"alternating_sum\", \"sum_of_squares\", and \"diagonal_sum\".\n  `row_index` (int): The index of the row in the number tree to perform the operation on. Must be a positive integer.\n\nOutput:\n  `return` (int or None): The result of the operation. Returns `None` if the operation is invalid or the row index is less than or equal to 0.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\ndef get_number(n, k):\n    if n == 0 or k == 0 or k == n:\n        return 1\n    elif k > n:\n        return None\n    else:\n        return get_number(n-1, k-1) + get_number(n-1, k)\n\ndef get_row_sum(i):\n    if i <= 0:\n        return None\n    total = 0\n    for n in range(i):\n        total += get_number(i-1, n)\n    return total\n\ndef get_alternating_sum(i):\n    if i <= 0:\n        return None\n    alternate_total = 0\n    for n in range(i):\n        if n % 2 == 0:\n            alternate_total += get_number(i-1, n)\n        else:\n            alternate_total -= get_number(i-1, n)\n    return alternate_total\n\ndef get_sum_of_squares(i):\n    if i <= 0:\n        return None\n    squares_total = 0\n    for n in range(i):\n        squares_total += (get_number(i-1, n))**2\n    return squares_total\n\ndef get_diagonal_sum(i):\n    if i <= 0:\n        return None\n    total_diagonal = 0\n    k = i // 2 + (i % 2)\n    for item in range(k):\n        total_diagonal += get_number(i-1, item)\n        i -= 1\n    return total_diagonal\n\n# main function\ndef main_solution(operation, row_index):\n    # Convert JSON serializable inputs to the original input variables\n    if operation == \"row_sum\":\n        result = get_row_sum(row_index)\n    elif operation == \"alternating_sum\":\n        result = get_alternating_sum(row_index)\n    elif operation == \"sum_of_squares\":\n        result = get_sum_of_squares(row_index)\n    elif operation == \"diagonal_sum\":\n        result = get_diagonal_sum(row_index)\n    else:\n        result = None\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"operation": "alternating_sum", "row_index": 4}, "output": 0}, {"input": {"operation": "alternating_sum", "row_index": 5}, "output": 0}, {"input": {"operation": "alternating_sum", "row_index": 8}, "output": 0}, {"input": {"operation": "sum_of_squares", "row_index": 6}, "output": 252}, {"input": {"operation": "sum_of_squares", "row_index": 8}, "output": 3432}, {"input": {"operation": "diagonal_sum", "row_index": 10}, "output": 55}, {"input": {"operation": "alternating_sum", "row_index": 2}, "output": 0}, {"input": {"operation": "row_sum", "row_index": 6}, "output": 32}, {"input": {"operation": "sum_of_squares", "row_index": 7}, "output": 924}, {"input": {"operation": "diagonal_sum", "row_index": 4}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Andersengebretsen/SMC-CS21", "path": "/engebretsen_number_tree.py", "msgidx": 9305}}
{"problem_description": "Given a graph represented by an adjacency matrix and a set number of colors, how can we determine all possible ways to color the vertices of the graph such that no two adjacent vertices share the same color?", "io_requirements": "Input:\n  `adjacency_matrix` (str): A JSON-serialized string representing a 2D list (matrix) where `adjacency_matrix[i][j]` is `1` if there is an edge between vertex `i` and vertex `j`, and `0` otherwise.\n  `num_colors` (int): An integer representing the number of colors available for coloring the vertices.\n\nOutput:\n  `return` (str): A JSON-serialized string representing a list of lists. Each inner list represents a valid coloring of the vertices using the given number of colors. Each element in the inner list is an integer representing the color assigned to the corresponding vertex.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef safe(A, v, color, c):\n    ans = True\n    for i in range(len(A)):\n        if A[v][i] == 1 and color[i] == c:\n            ans = False\n    return ans\n\ndef solve(A, m, color, v, alll):\n    if v == len(A[0]):\n        alll.append(list(color))\n    else:\n        for c in range(1, m + 1):\n            if safe(A, v, color, c):\n                color[v] = c\n                solve(A, m, color, v + 1, alll)\n    return alll\n\n# main function\ndef main_solution(adjacency_matrix, num_colors):\n    # Convert JSON serializable inputs to original input variables\n    A = json.loads(adjacency_matrix)\n    m = num_colors\n    V = len(A[0])\n    color = [None for _ in range(V)]\n    alll = []\n    \n    # Call the solve function with the converted inputs\n    ans = solve(A, m, color, 0, alll)\n    \n    # Convert the output to JSON serializable format\n    return json.dumps(ans)", "funcname": "main_solution", "ios": [{"input": {"adjacency_matrix": "[[0, 0, 1], [0, 0, 1], [1, 1, 0]]", "num_colors": 3}, "output": "[[1, 1, 2], [1, 1, 3], [1, 2, 3], [2, 1, 3], [2, 2, 1], [2, 2, 3]]"}, {"input": {"adjacency_matrix": "[[0, 0, 1], [0, 0, 0], [1, 0, 0]]", "num_colors": 2}, "output": "[[1, 1, 2], [1, 2, 2]]"}, {"input": {"adjacency_matrix": "[[0, 1, 1, 1, 1], [1, 0, 1, 0, 0], [1, 1, 0, 1, 1], [1, 0, 1, 0, 1], [1, 0, 1, 1, 0]]", "num_colors": 3}, "output": "[]"}, {"input": {"adjacency_matrix": "[[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]", "num_colors": 2}, "output": "[]"}, {"input": {"adjacency_matrix": "[[0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]", "num_colors": 2}, "output": "[[1, 2, 2, 2]]"}, {"input": {"adjacency_matrix": "[[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]]", "num_colors": 2}, "output": "[[1, 1, 2, 2]]"}, {"input": {"adjacency_matrix": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]", "num_colors": 2}, "output": "[[1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 1], [2, 2, 2]]"}, {"input": {"adjacency_matrix": "[[0, 1, 0, 0, 0], [1, 0, 1, 1, 1], [0, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 1, 0, 1, 0]]", "num_colors": 3}, "output": "[[1, 2, 1, 1, 3], [1, 2, 3, 1, 3], [3, 2, 1, 1, 3], [3, 2, 3, 1, 3]]"}, {"input": {"adjacency_matrix": "[[0, 1, 1], [1, 0, 1], [1, 1, 0]]", "num_colors": 3}, "output": "[[1, 2, 3]]"}, {"input": {"adjacency_matrix": "[[0, 0, 0, 0, 0], [0, 0, 1, 1, 1], [0, 1, 0, 1, 0], [0, 1, 1, 0, 1], [0, 1, 0, 1, 0]]", "num_colors": 3}, "output": "[[1, 1, 2, 3, 2], [2, 1, 2, 3, 2], [3, 1, 2, 3, 2]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Juanma1909/ADA", "path": "/graphcoloring.py", "msgidx": 9495}}
{"problem_description": "In a scenario where people need to cross a bridge with a flashlight, the flashlight can only be carried by one or two people at a time. Given the travel times of people on both sides of the bridge and the current position of the flashlight, what are the possible next states and the corresponding actions that can be taken to move people across the bridge?", "io_requirements": "Input:\n  `here` (list of int): A list of integers representing the travel times of people on the \"here\" side.\n  `there` (list of int): A list of integers representing the travel times of people on the \"there\" side.\n  `light` (int): An integer indicating the position of the light. 0 if the light is on the \"here\" side, 1 if it is on the \"there\" side.\n\nOutput:\n  `return` (dict): A dictionary where each key is a string representation of a state (a tuple of two frozensets and an integer) and each value is a tuple containing a list of travelers and a string indicating the direction of travel ('->' or '<-').", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\ndef bsuccessors3(state):\n    \"\"\"\n    Return a dict of {state:action} pairs.  \n    \n\tA state is a (here, there, light) tuple. Here and there are \n\tfrozensets of people (each person is represented by an integer\n\twhich corresponds to their travel time), and light is 0 if \n\tit is on the `here` side and 1 if it is on the `there` side.\n\n\tAn action is a tuple of (travelers, arrow), where the arrow is\n\t'->' or '<-'. \n\n    \"\"\"\n    here, there, light = state\n    if light == 0:\n        return dict(((here  - frozenset([a,b]),\n                      there | frozenset([a,b]), 1), (set([a,b]), '->'))\n                        for a in here for b in here)\n    else:\n        return dict(((here  | frozenset([a,b]),\n                      there - frozenset([a,b]), 0), (set([a,b]), '<-'))\n                        for a in there for b in there)\n\n# main function\ndef main_solution(here, there, light):\n    # Convert input variables to the required format\n    state = (frozenset(here), frozenset(there), light)\n    \n    # Call the bsuccessors3 function to get the result\n    result = bsuccessors3(state)\n    \n    # Convert the result to a JSON serializable format\n    serializable_result = {str(k): (list(v[0]), v[1]) for k, v in result.items()}\n    \n    return serializable_result", "funcname": "main_solution", "ios": [{"input": {"here": [9, 4], "there": [10, 2, 6, 3], "light": 0}, "output": {"(frozenset({4}), frozenset({2, 3, 6, 9, 10}), 1)": [[9], "->"], "(frozenset(), frozenset({2, 3, 4, 6, 9, 10}), 1)": [[9, 4], "->"], "(frozenset({9}), frozenset({2, 3, 4, 6, 10}), 1)": [[4], "->"]}}, {"input": {"here": [8, 2], "there": [], "light": 1}, "output": {}}, {"input": {"here": [10], "there": [3, 9], "light": 0}, "output": {"(frozenset(), frozenset({9, 10, 3}), 1)": [[10], "->"]}}, {"input": {"here": [2], "there": [3], "light": 0}, "output": {"(frozenset(), frozenset({2, 3}), 1)": [[2], "->"]}}, {"input": {"here": [5, 2], "there": [3], "light": 1}, "output": {"(frozenset({2, 3, 5}), frozenset(), 0)": [[3], "<-"]}}, {"input": {"here": [2, 5], "there": [], "light": 0}, "output": {"(frozenset({5}), frozenset({2}), 1)": [[2], "->"], "(frozenset(), frozenset({2, 5}), 1)": [[2, 5], "->"], "(frozenset({2}), frozenset({5}), 1)": [[5], "->"]}}, {"input": {"here": [4, 2, 3, 1], "there": [9], "light": 1}, "output": {"(frozenset({1, 2, 3, 4, 9}), frozenset(), 0)": [[9], "<-"]}}, {"input": {"here": [7], "there": [10], "light": 0}, "output": {"(frozenset(), frozenset({10, 7}), 1)": [[7], "->"]}}, {"input": {"here": [4, 10, 7], "there": [7, 3], "light": 1}, "output": {"(frozenset({10, 3, 4, 7}), frozenset({7}), 0)": [[3], "<-"], "(frozenset({3, 4, 7, 10}), frozenset(), 0)": [[3, 7], "<-"], "(frozenset({10, 4, 7}), frozenset({3}), 0)": [[7], "<-"]}}, {"input": {"here": [2], "there": [1, 10, 10, 10], "light": 1}, "output": {"(frozenset({1, 2}), frozenset({10}), 0)": [[1], "<-"], "(frozenset({1, 2, 10}), frozenset(), 0)": [[1, 10], "<-"], "(frozenset({2, 10}), frozenset({1}), 0)": [[10], "<-"]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "joyrexus/CS212", "path": "/homework/unit_4/bridge/successor.py", "msgidx": 9600}}
{"problem_description": "In a social network, users are represented as nodes in an undirected graph, where an edge between two nodes indicates a friendship. Given a graph representing the friendships and two specific users, what is the minimum number of friendships needed to connect the two users, or determine if they are not connected at all?", "io_requirements": "Input:\n  `graph_dict` (dict): A dictionary where keys are node labels (int) and values are lists of neighbor labels (list of int).\n  `s` (int): The label of the starting node.\n  `t` (int): The label of the target node.\n\nOutput:\n  `return` (int): The degrees of separation between the starting node and the target node, or -1 if they are not connected.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# Definition for Undirected graph node\nclass UndirectedGraphNode:\n    def __init__(self, x):\n        self.label = x\n        self.neighbors = []\n\n# main function\ndef main_solution(graph_dict, s, t):\n    \"\"\"\n    Calculate the degrees of separation between two nodes in an undirected graph.\n\n    :param graph_dict: A dictionary where keys are node labels and values are lists of neighbor labels.\n    :param s: The label of the starting node.\n    :param t: The label of the target node.\n    :return: The degrees of separation between the starting node and the target node, or -1 if they are not connected.\n    \"\"\"\n    # Convert graph_dict to a list of UndirectedGraphNode\n    nodes = {label: UndirectedGraphNode(label) for label in graph_dict}\n    for label, neighbors in graph_dict.items():\n        nodes[label].neighbors = [nodes[neighbor] for neighbor in neighbors]\n\n    # Initialize the solution class\n    solution = Solution()\n\n    # Get the result\n    result = solution.sixDegrees(list(nodes.values()), nodes[s], nodes[t])\n\n    # Return the result\n    return result\n\nclass Solution:\n    def sixDegrees(self, graph, s, t):\n        if not graph or not s or not t:\n            return -1\n\n        if s is t:\n            return 0\n\n        visited = set([s])\n        q = deque([s])\n        level = 0\n        while q:\n            level += 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                for neighbor in node.neighbors:\n                    if neighbor is t:\n                        return level\n                    if neighbor not in visited:\n                        q.append(neighbor)\n                        visited.add(neighbor)\n        return -1", "funcname": "main_solution", "ios": [{"input": {"graph_dict": {"1": [2], "2": []}, "s": 1, "t": 2}, "output": 1}, {"input": {"graph_dict": {"1": [4, 3], "2": [1], "3": [], "4": []}, "s": 2, "t": 1}, "output": 1}, {"input": {"graph_dict": {"1": [], "2": [], "3": [2]}, "s": 2, "t": 1}, "output": -1}, {"input": {"graph_dict": {"1": [], "2": [], "3": [1]}, "s": 2, "t": 1}, "output": -1}, {"input": {"graph_dict": {"1": [4, 3], "2": [4, 3], "3": [], "4": []}, "s": 2, "t": 4}, "output": 1}, {"input": {"graph_dict": {"1": [2], "2": [], "3": [2]}, "s": 1, "t": 3}, "output": -1}, {"input": {"graph_dict": {"1": [2], "2": []}, "s": 2, "t": 1}, "output": -1}, {"input": {"graph_dict": {"1": [4, 3], "2": [], "3": [2, 4], "4": []}, "s": 4, "t": 3}, "output": -1}, {"input": {"graph_dict": {"1": [], "2": []}, "s": 1, "t": 2}, "output": -1}, {"input": {"graph_dict": {"1": [2], "2": [1], "3": []}, "s": 2, "t": 3}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zsmountain/lintcode", "path": "/python/bfs/531_six_degrees.py", "msgidx": 9053}}
{"problem_description": "Given a directed acyclic graph (DAG) with a certain number of vertices and directed edges, what is the topological order of the vertices in the graph? The topological order must satisfy the condition that if there is a directed path from vertex A to vertex B, then vertex A appears before vertex B in the order.", "io_requirements": "Input:\n  `vertices` (int): The number of vertices in the graph.\n  `edges` (list of tuples): A list of tuples where each tuple represents a directed edge in the graph. Each tuple contains two integers `(u, v)` where `u` is the source vertex and `v` is the destination vertex.\n\nOutput:\n  `return` (list of int): A list of integers representing the topological order of the vertices in the graph. Each integer in the list corresponds to a vertex in the graph.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)  # \u90bb\u63a5\u8868\u5f62\u5f0f\u5b9e\u73b0\u56fe-- \u952e:\u5b57\u5178 , \u503c:\u5217\u8868(\u6bcf\u4e2a\u9876\u70b9\u6307\u5411\u7684\u9876\u70b9)\n        self.V = vertices               # \u9876\u70b9\u6570\n        self.indegree = [0] * (vertices+1)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def indegcount(self):               # \u8ba1\u7b97\u6240\u6709\u8282\u70b9\u7684\u5165\u5ea6\uff0c\u653e\u5230\u4e00\u4e2a\u5217\u8868\u4e2d\n        for u in self.graph:\n            for v in self.graph[u]:\n                self.indegree[v] += 1\n\n    def topologicalsort(self):\n        self.indegcount()\n        queue = [u for u in self.graph if self.indegree[u] == 0]  # \u67e5\u627e\u6240\u6709\u5165\u5ea6\u4e3a0\u7684\u8282\u70b9\uff0c\u5e76\u52a0\u5165\u5230\u961f\u5217\u4e2d\n        res = []\n        while queue:\n            u = queue.pop()                              # \u4e0d\u65ad\u5c06\u961f\u5217\u4e2d\u5165\u5ea6\u4e3a0\u7684\u8282\u70b9\u5f39\u51fa\n            res.append(u)                                # \u6bcf\u5f39\u51fa\u4e00\u4e2a\u5165\u5ea6\u4e3a0 \u7684\u8282\u70b9\uff0c\u5c31\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n            for v in self.graph[u]:\n                self.indegree[v] -= 1                    # \u5c06\u5165\u5ea6\u4e3a0\u7684\u8282\u70b9\u6307\u5411\u7684\u6240\u6709\u8282\u70b9\u7684\u5165\u5ea6\u51cf1\n                if self.indegree[v] == 0:                # \u51cf1\u540e\uff0c\u6307\u5411\u7684\u8282\u70b9\u5165\u5ea6\u82e5\u4e3a0\uff0c\u5219\u52a0\u5165\u961f\u5217\n                    queue.append(v)\n        return res\n\n# main function\ndef main_solution(vertices, edges):\n    # vertices: number of vertices in the graph\n    # edges: list of tuples representing directed edges (u, v)\n    \n    # Create a graph instance\n    g = Graph(vertices)\n    \n    # Add edges to the graph\n    for u, v in edges:\n        g.addEdge(u, v)\n    \n    # Perform topological sort\n    result = g.topologicalsort()\n    \n    # Return the result as a list of integers\n    return result", "funcname": "main_solution", "ios": [{"input": {"vertices": 7, "edges": [[6, 7], [1, 4], [3, 7], [2, 3], [2, 6]]}, "output": [2, 6, 3, 7, 1, 4]}, {"input": {"vertices": 9, "edges": [[6, 1], [4, 5], [4, 6], [5, 4], [2, 3]]}, "output": [2, 3]}, {"input": {"vertices": 8, "edges": [[8, 3], [1, 4], [1, 6], [4, 7], [4, 8]]}, "output": [1, 6, 4, 8, 3, 7]}, {"input": {"vertices": 7, "edges": [[3, 1], [2, 5], [1, 3], [2, 5], [4, 2], [7, 1]]}, "output": [7, 4, 2, 5]}, {"input": {"vertices": 6, "edges": [[6, 4], [4, 1], [4, 2], [5, 6], [5, 1]]}, "output": [5, 6, 4, 2, 1]}, {"input": {"vertices": 6, "edges": [[2, 4], [5, 3], [4, 2], [6, 2], [3, 6], [5, 2], [1, 6]]}, "output": [1, 5, 3, 6]}, {"input": {"vertices": 7, "edges": [[5, 4], [4, 6], [4, 1], [4, 7], [7, 6]]}, "output": [5, 4, 7, 6, 1]}, {"input": {"vertices": 10, "edges": [[1, 10], [10, 2], [10, 9], [5, 10], [10, 7], [4, 10]]}, "output": [4, 5, 1, 10, 7, 9, 2]}, {"input": {"vertices": 6, "edges": [[2, 3], [1, 2], [3, 2], [5, 4], [3, 5], [6, 1]]}, "output": [6, 1]}, {"input": {"vertices": 9, "edges": [[1, 3], [4, 1], [4, 7], [1, 5], [2, 5]]}, "output": [2, 4, 7, 1, 5, 3]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "7Bcoding/Python-data-structure-algorithm", "path": "/5-\u56fe\u8bba\u7b97\u6cd5/TopologicalOrder-\u62d3\u6251\u6392\u5e8f-1.py", "msgidx": 9510}}
{"problem_description": "Given a number, we are interested in finding out how many circular primes exist below that number. A circular prime is a prime number with the property that all rotations of its digits are also prime numbers. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers. How many circular primes are there below a given number?", "io_requirements": "Input:\n  `maximum` (int): The upper limit for checking circular primes. It should be a positive integer less than or equal to 1,000,000.\n\nOutput:\n  `return` (int): The count of circular primes below the given `maximum`.", "refcode": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    \n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef rotations(n):\n    yield n\n    n = str(n)\n    rotation = n[-1] + n[:-1]\n    while rotation != n:\n        yield int(rotation)\n        rotation = rotation[-1] + rotation[:-1]\n\ndef is_circular(n, primes):\n    rots = rotations(n)\n    res = True\n    for p in rots:\n        if p not in primes:\n            res = False\n            break\n    return res\n\n# main function\ndef main_solution(maximum):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  primes = set()\n  count = 0\n  for i in range(2, 1000001):\n      if is_prime(i):\n          primes.add(i)\n  for p in primes:\n      if p > maximum:\n          continue\n      if is_circular(p, primes):\n          count += 1\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return count", "funcname": "main_solution", "ios": [{"input": {"maximum": 833426}, "output": 49}, {"input": {"maximum": 353787}, "output": 47}, {"input": {"maximum": 582119}, "output": 49}, {"input": {"maximum": 123005}, "output": 43}, {"input": {"maximum": 522787}, "output": 49}, {"input": {"maximum": 736219}, "output": 49}, {"input": {"maximum": 604267}, "output": 49}, {"input": {"maximum": 60388}, "output": 38}, {"input": {"maximum": 988121}, "output": 53}, {"input": {"maximum": 395886}, "output": 49}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "areebbeigh/CompetitiveProgramming", "path": "/Project Euler/problem_35.py", "msgidx": 9026}}
{"problem_description": "Given a staircase with `steps` steps and a set of possible step sizes `step_set`, how many unique ways can you climb the staircase if you can only take steps of the sizes specified in `step_set`? The order of steps matters.", "io_requirements": "Input:\n  `steps` (int): The number of steps in the staircase.\n  `step_set` (str): A JSON serialized list of integers representing the possible step sizes.\n\nOutput:\n  `return` (int): The number of unique ways to climb the staircase with the given step sizes.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef ways_to_step(N, step_set):\n    counter = 0\n    for step in step_set:\n        if N - step < 0:\n            break\n        elif 0 <= N - step <= min(step_set):\n            counter += 1\n        else:\n            counter += ways_to_step(N - step, step_set)\n    return counter\n\n# main function\ndef main_solution(steps, step_set):\n    # Convert the JSON serializable input to the original input variables\n    step_set = json.loads(step_set)\n    \n    # Call the original function with the converted inputs\n    result = ways_to_step(steps, step_set)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"steps": 8, "step_set": "[4, 6, 8]"}, "output": 3}, {"input": {"steps": 13, "step_set": "[4]"}, "output": 1}, {"input": {"steps": 4, "step_set": "[1, 5, 6, 7, 9]"}, "output": 1}, {"input": {"steps": 17, "step_set": "[1, 6]"}, "output": 34}, {"input": {"steps": 15, "step_set": "[7]"}, "output": 1}, {"input": {"steps": 9, "step_set": "[1, 2, 3, 9]"}, "output": 150}, {"input": {"steps": 7, "step_set": "[2, 3, 4]"}, "output": 9}, {"input": {"steps": 2, "step_set": "[1, 7, 10]"}, "output": 1}, {"input": {"steps": 13, "step_set": "[2, 4]"}, "output": 13}, {"input": {"steps": 20, "step_set": "[3, 10]"}, "output": 6}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BaoCaiH/Daily_Coding_Problem", "path": "/Python/2019_01_27_Problem_12_Stepping_ways.py", "msgidx": 9028}}
{"problem_description": "In a manufacturing process, certain steps must be completed before others can begin. Given the dependencies between these steps, what is the correct order in which they should be executed to ensure all prerequisites are met?", "io_requirements": "Input:\n  `dependencies` (List[List[str]]): A list of lists where each inner list contains two strings representing the dependency between two steps. The first string in each inner list is the prerequisite step, and the second string is the step that requires the prerequisite.\n\nOutput:\n  `return` (str): A string representing the order in which the steps should be executed, concatenated without any separators.", "refcode": "# import necessary packages\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import List\n\n# all class and function definitions in the code file, if any\n@dataclass\nclass Step:\n    requires: List[\"Step\"]\n    required_by: List[\"Step\"]\n    name: str = None\n\ndef sort_ready(ready: List[Step]):\n    ready.sort(key=lambda x: x.name)\n\n# main function\ndef main_solution(dependencies: List[List[str]]):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    steps = defaultdict(lambda: Step(requires=[], required_by=[]))\n    \n    for name_a, name_b in dependencies:\n        a, b = steps[name_a], steps[name_b]\n        a.name = name_a\n        b.name = name_b\n        a.required_by.append(b)\n        b.requires.append(a)\n    \n    res = []\n    ready = []\n    \n    for x in steps.values():\n        if not x.requires:\n            ready.append(x)\n    \n    while steps:\n        sort_ready(ready)\n        r = ready[0]\n        ready.remove(r)\n        del steps[r.name]\n        res.append(r.name)\n        for x in r.required_by:\n            x.requires.remove(r)\n            if not x.requires:\n                ready.append(x)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return \"\".join(res)", "funcname": "main_solution", "ios": [{"input": {"dependencies": [["Z", "G"], ["C", "G"], ["C", "Z"], ["G", "N"], ["Z", "D"]]}, "output": "CZDGN"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Tishka17/adventofcode", "path": "/2018/day7.py", "msgidx": 9588}}
{"problem_description": "Given an interval [a, b], how many numbers are both square and palindromic within this interval? A number is considered fair and square if both the number itself and its square root are palindromes.", "io_requirements": "Input:\n  `a` (int): The lower bound of the interval [a, b].\n  `b` (int): The upper bound of the interval [a, b].\n\nOutput:\n  `return` (int): The count of fair and square numbers within the interval [a, b].", "refcode": "# import necessary packages\nfrom math import floor, ceil, sqrt\n\n# all class and function definitions in the code file, if any\ndef isPalindrome(number):\n    components = str(number)\n    length = len(components)\n    for x in range(length // 2):\n        if components[x] != components[-x - 1]:\n            return False\n    return True\n\ndef generatePally(digits):\n    if digits == 1:\n        return list(range(1, 10))\n\n    palindromes = []\n    lower = int(10 ** (digits // 2 - 1))\n    higher = 10 ** (digits // 2)\n    for x in range(lower, higher):\n        string = str(x)\n        if digits % 2 == 1:\n            for y in range(10):\n                palindromes.append(int(string + str(y) + string[::-1]))\n        else:\n            string += string[::-1]\n            palindromes.append(int(string))\n    return palindromes\n\n# main function\ndef main_solution(a, b):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    a = int(a)\n    b = int(b)\n    \n    # Pre-generate fair and square numbers within the range [1, 10**7]\n    fairSquares = []\n    fairSquaresROOTS = []\n    palindromes = []\n    for digits in range(1, 8):\n        palindromes += generatePally(digits)\n    for pally in palindromes:\n        square = pally ** 2\n        if isPalindrome(square):\n            fairSquares.append(square)\n            fairSquaresROOTS.append(pally)\n    \n    # Find the count of fair and square numbers within the interval [a, b]\n    lower = next(x for x in fairSquares if x >= a)\n    upper = next(y for y in reversed(fairSquares) if y <= b)\n    \n    if lower > upper:\n        result = 0\n    else:\n        result = fairSquares.index(upper) - fairSquares.index(lower) + 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"a": 2518346, "b": 6606877}, "output": 1}, {"input": {"a": 6057518, "b": 8926112}, "output": 0}, {"input": {"a": 1813694, "b": 4218100}, "output": 1}, {"input": {"a": 1821058, "b": 5248336}, "output": 1}, {"input": {"a": 8791191, "b": 9528041}, "output": 0}, {"input": {"a": 396425, "b": 683571}, "output": 0}, {"input": {"a": 8947695, "b": 9546204}, "output": 0}, {"input": {"a": 3007762, "b": 7060461}, "output": 1}, {"input": {"a": 533002, "b": 2786130}, "output": 2}, {"input": {"a": 9503488, "b": 9503880}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "alexandraback/datacollection", "path": "/solutions_2463486_1/Python/Loadedpizza/taskC-qual.py", "msgidx": 9911}}
{"problem_description": "Given a positive integer `n`, what are all the binary strings of length `n` where no two consecutive '1's are present?", "io_requirements": "Input:\n  `n` (int): The length of each binary string to be generated. Must be a positive integer.\n\nOutput:\n  `return` (str): A space-separated string of all nonconsecutive binary strings of length `n`. Each binary string in the output does not contain consecutive '1's.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generate_nonconsecutive(n):\n    lst = ['0', '1']\n    for x in range(n-1):\n        lst = [n + m for m in '01' for n in lst if '11' not in n + m]\n    return ' '.join(sorted(lst))\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = generate_nonconsecutive(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": "000 001 010 100 101"}, {"input": {"n": 4}, "output": "0000 0001 0010 0100 0101 1000 1001 1010"}, {"input": {"n": 1}, "output": "0 1"}, {"input": {"n": 2}, "output": "00 01 10"}, {"input": {"n": 5}, "output": "00000 00001 00010 00100 00101 01000 01001 01010 10000 10001 10010 10100 10101"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/9AMT6SC4Jz8tExihs_7.py", "msgidx": 9693}}
{"problem_description": "Given a set of points that define a polygon, how can we determine if a specific point lies within the boundaries of this polygon? Specifically, what is the result of checking if the point `(x, y)` is inside the polygon defined by the list of points `mask`?", "io_requirements": "Input:\n  `mask` (list of tuples): A list of points defining the polygon. Each point is a tuple (x, y, flag), where flag is 0 (move), 1 (goto), 2 (back to first point).\n  `point` (tuple): A tuple (x, y) representing the point to be checked.\n\nOutput:\n  `return` (bool): True if the point is inside the polygon, False otherwise.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass InOutChecker:\n    def __init__(self, mask):\n        \"\"\"\n        mask defines a set of polygons specified as a list of points. \n        A point is a tuple (x, y, flag), \n        where flag is 0 (move), 1 (goto), 2 (back to first point).\n        \"\"\"\n        self.mask = mask\n        self.ymin, self.ymax, self.edges = self._buildEdges(mask)\n\n    def _buildEdges(self, mask):\n        \"\"\"\n        Builds a list of segments from ymin to ymax.\n        For each y, a list of segments define what is inside.\n        If a point is within a segment, then it is inside.        \n        \"\"\"\n        x0, y0 = 0, 0\n        x1, y1, x2, y2 = 0, 0, 0, 0\n        ys = [int(t[1]) for t in mask]\n        ymin, ymax = min(ys), max(ys)\n        edges = {}\n        for x, y, flag in mask:\n            if flag == 0:\n                x0, y0 = x, y\n                x1, y1 = x, y\n                x2, y2 = x, y\n                continue\n            elif flag == 1:\n                x1, y1 = x2, y2\n                x2, y2 = x, y\n            elif flag == 2:\n                x1, y1 = x2, y2\n                x2, y2 = x0, y0\n\n            if y1 > y2:\n                xx1, yy1, xx2, yy2 = x2, y2, x1, y1\n            else:\n                xx1, yy1, xx2, yy2 = x1, y1, x2, y2\n\n            y1i, y2i = int(yy1), int(yy2)\n            if y1i == y2i:\n                continue\n            m = (xx2 - xx1) / (yy2 - yy1)\n            b = -m * yy1 + xx1\n            for yidx in range(y1i, y2i):\n                xpos = m * yidx + b\n                try:\n                    edges[yidx].append(xpos)\n                except:\n                    edges[yidx] = [xpos]\n\n        for y in range(ymin, ymax):\n            try:\n                edges[y].sort()\n            except Exception as e:\n                pass\n        return ymin, ymax, edges\n\n    def checkPoint(self, x, y):\n        \"\"\"\n        Checks if the given point (x,y) is inside the mask\n        First, finds the segments at the y position, where int(y) is used.\n        Then, the point is inside the mask if x in inside one of the segments. \n        \"\"\"\n        try:\n            yi = math.floor(y)\n            if yi <= self.ymin or self.ymax <= yi:\n                return False\n            row = self.edges[yi]\n\n            for idx in range(0, len(row), 2):\n                x0, x1 = row[idx : idx + 2]\n                if x0 < x < x1:\n                    return True\n        except Exception as e:\n            pass\n        return False\n\n# main function\ndef main_solution(mask, point):\n    \"\"\"\n    Determines if a given point is inside a polygon defined by a mask.\n\n    Parameters:\n    mask (list of tuples): A list of points defining the polygon. Each point is a tuple (x, y, flag), where flag is 0 (move), 1 (goto), 2 (back to first point).\n    point (tuple): A tuple (x, y) representing the point to be checked.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n    chk = InOutChecker(mask)\n    return chk.checkPoint(point[0], point[1])", "funcname": "main_solution", "ios": [{"input": {"mask": [[75.6316729019233, 31.52303403253961, 1], [71.43164533087014, 71.3919093700223, 2], [14.908764395958652, 22.590176306951115, 0]], "point": [84.90314203370296, 54.36731803425455]}, "output": false}, {"input": {"mask": [[75.67945063498269, 67.37421931673892, 0], [22.30976643145459, 60.28935359932387, 0], [85.01198003073927, 56.25092420299289, 1]], "point": [3.449877108418975, 90.1732452580721]}, "output": false}, {"input": {"mask": [[36.35495512564858, 12.453488192811225, 2], [80.0387928046241, 43.284831430849444, 1], [11.048829528911252, 24.86520339799415, 1], [82.55577497456585, 51.07543899504774, 1]], "point": [47.414498578148276, 59.05264733115574]}, "output": false}, {"input": {"mask": [[99.53542266169872, 9.605336213416892, 1], [41.729114702729106, 71.52809488310412, 0], [86.29466180334944, 87.53410234473596, 1]], "point": [4.341873290994213, 5.4041643066561456]}, "output": false}, {"input": {"mask": [[11.917230904703002, 59.23586220318363, 0], [72.94833013648051, 79.09751159754936, 1], [64.44415482591256, 12.462638946210058, 0]], "point": [67.1159594181153, 11.432422994882764]}, "output": false}, {"input": {"mask": [[40.90369064712759, 49.20441335271577, 0], [49.223627200428275, 92.92605413345314, 2], [62.275951756176916, 70.49914194200201, 2], [77.12685657237184, 43.4319587865727, 2]], "point": [89.19146265648729, 74.85508018834895]}, "output": false}, {"input": {"mask": [[49.718243122091835, 54.45814751414281, 1], [9.438520710435549, 50.229667173817425, 1], [69.42373774300253, 18.703881179258865, 1], [81.89902863327583, 67.43153463951566, 1]], "point": [8.087485213615297, 41.84085646106141]}, "output": false}, {"input": {"mask": [[89.43081725357571, 6.1462422637098335, 1], [51.195383756306526, 62.84003277390402, 0], [47.277222898084794, 60.632239096002294, 0], [60.97674388743258, 55.581178790198784, 1]], "point": [27.500742974496628, 39.918979406696764]}, "output": false}, {"input": {"mask": [[89.00927489738318, 5.972934765440307, 2], [21.536335275705376, 86.66103656200865, 1], [7.085148230869908, 64.223138975993, 2]], "point": [40.76550125504361, 79.88848090969049]}, "output": false}, {"input": {"mask": [[33.28882859397585, 37.06305175157449, 2], [1.9474606143968343, 73.6416893386443, 0], [17.49427675654308, 48.66239852931496, 2], [4.118681086571662, 22.892593057313604, 0]], "point": [96.67495679179639, 85.46755107218215]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KeckObservatory/SlitmaskDesignTool", "path": "/DesignTool/smdtLibs/inOutChecker.py", "msgidx": 9632}}
{"problem_description": "A monkey eats peaches every day, starting with a certain number of peaches on the first day. Each day, the monkey eats half of the remaining peaches plus one more. By the last day, only one peach is left. How many peaches were there on the first day if the monkey ate peaches for a given number of days?", "io_requirements": "Input:\n  `days` (int): The number of days to calculate backwards from the last day. For example, if the last day is day 10, then `days` should be 10.\n\nOutput:\n  `return` (int): The number of peaches on the first day.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(days):\n    # Initialize the number of peaches on the last day\n    m = 1\n    # Reverse iterate through the days to calculate the number of peaches on the first day\n    for i in range(days - 1, 0, -1):\n        m = 2 * (m + 1)\n    return m", "funcname": "main_solution", "ios": [{"input": {"days": 18}, "output": 393214}, {"input": {"days": 19}, "output": 786430}, {"input": {"days": 12}, "output": 6142}, {"input": {"days": 20}, "output": 1572862}, {"input": {"days": 13}, "output": 12286}, {"input": {"days": 2}, "output": 4}, {"input": {"days": 4}, "output": 22}, {"input": {"days": 11}, "output": 3070}, {"input": {"days": 3}, "output": 10}, {"input": {"days": 16}, "output": 98302}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "liucheng2912/py", "path": "/100\u4f8b/21.py", "msgidx": 9336}}
{"problem_description": "Given a set of coin denominations and a target amount in pence, how many different ways can the target amount be made using any number of the given coins?", "io_requirements": "Input:\n  `amount` (int): The target amount in pence (e.g., 200 for \u00a32).\n  `coins` (list of int): A list of integers representing the coin denominations available (e.g., [1, 2, 5, 10, 20, 50, 100, 200]).\n\nOutput:\n  `return` (int): The number of different ways the target amount can be made using the given coin denominations.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef makeChange(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in range(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\n# main function\ndef main_solution(amount, coins):\n    # Convert the coins list to a sorted list of integers\n    coins = sorted(coins)\n    # Call the makeChange function with the provided amount and coins\n    result = makeChange(amount, coins)\n    # Return the result as an integer\n    return result", "funcname": "main_solution", "ios": [{"input": {"amount": 90, "coins": [2, 5]}, "output": 10}, {"input": {"amount": 195, "coins": [1, 2, 5, 10, 20, 50, 100, 200]}, "output": 65934}, {"input": {"amount": 160, "coins": [2, 10, 20, 200]}, "output": 81}, {"input": {"amount": 193, "coins": [2, 5, 10, 20, 50, 100, 200]}, "output": 1239}, {"input": {"amount": 45, "coins": [1, 2, 5, 20, 50, 100, 200]}, "output": 166}, {"input": {"amount": 17, "coins": [10, 20, 50, 100, 200]}, "output": 0}, {"input": {"amount": 190, "coins": [2]}, "output": 1}, {"input": {"amount": 155, "coins": [1, 2, 10, 50, 100, 200]}, "output": 1148}, {"input": {"amount": 176, "coins": [5, 10]}, "output": 0}, {"input": {"amount": 18, "coins": [1, 20, 200]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BrunoTorresF/python-toy-problems", "path": "/coinSums.py", "msgidx": 9462}}
{"problem_description": "In a scenario where there are multiple buckets, one of which contains poison, and pigs can be used to identify the poisoned bucket by drinking from them, how many pigs are required to determine the poisoned bucket within a specified time frame? The pigs die within a certain number of minutes after drinking the poison, and you have a limited amount of time to conduct the tests.", "io_requirements": "Input:\n  `buckets` (int): The number of buckets, where one bucket contains poison.\n  `minutesToDie` (int): The time it takes for a pig to die after drinking poison.\n  `minutesToTest` (int): The total time available to test the buckets.\n\nOutput:\n  `return` (int): The minimum number of pigs required to determine which bucket contains poison within the given time frame.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(buckets, minutesToDie, minutesToTest):\n    \"\"\"\n    Calculate the minimum number of pigs needed to determine which bucket contains poison within a given time frame.\n\n    :param buckets: int, number of buckets.\n    :param minutesToDie: int, time it takes for a pig to die after drinking poison.\n    :param minutesToTest: int, total time available to test.\n    :return: int, minimum number of pigs required.\n    \"\"\"\n    number_of_try = math.floor(minutesToTest / minutesToDie)\n    number_of_pig = math.ceil(math.log(buckets, number_of_try + 1))\n    return int(number_of_pig)", "funcname": "main_solution", "ios": [{"input": {"buckets": 548, "minutesToDie": 16, "minutesToTest": 28}, "output": 10}, {"input": {"buckets": 629, "minutesToDie": 4, "minutesToTest": 78}, "output": 3}, {"input": {"buckets": 542, "minutesToDie": 14, "minutesToTest": 20}, "output": 10}, {"input": {"buckets": 754, "minutesToDie": 58, "minutesToTest": 108}, "output": 10}, {"input": {"buckets": 432, "minutesToDie": 31, "minutesToTest": 91}, "output": 6}, {"input": {"buckets": 930, "minutesToDie": 43, "minutesToTest": 65}, "output": 10}, {"input": {"buckets": 286, "minutesToDie": 22, "minutesToTest": 43}, "output": 9}, {"input": {"buckets": 328, "minutesToDie": 50, "minutesToTest": 65}, "output": 9}, {"input": {"buckets": 422, "minutesToDie": 7, "minutesToTest": 40}, "output": 4}, {"input": {"buckets": 610, "minutesToDie": 60, "minutesToTest": 94}, "output": 10}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "homerzhm/PlayLeetCode", "path": "/Questions/PoorPigs.py", "msgidx": 9607}}
{"problem_description": "Given a permutation of integers from 1 to N in standard index form, how can we represent this permutation in cycle form? Specifically, what is the cycle form representation of the permutation `p1` for a given number of objects `n`?", "io_requirements": "Input:\n  `n` (int): The number of objects being permuted.\n  `p1` (list of int): The permutation in standard index form, where each element is an integer between 1 and n.\n\nOutput:\n  `return` (list of int): The permutation in cycle form, where each element is an integer. Negative values indicate the start of a new cycle.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(n, p1):\n    # Convert the input list to a numpy array\n    p1 = np.array(p1, dtype=np.int32)\n    \n    # Initialize the output array\n    p2 = np.zeros(n, dtype=np.int32)\n    \n    i = 0\n    j = 1\n    \n    while j <= n:\n        if p1[j-1] < 0:\n            j += 1\n        else:\n            k = j\n            i += 1\n            p2[i-1] = -k\n            while p1[k-1] != j:\n                i += 1\n                p2[i-1] = p1[k-1]\n                p1[k-1] = -p1[k-1]\n                k = abs(p1[k-1])\n            p1[k-1] = -p1[k-1]\n    \n    # Convert the output array to a list\n    p2 = p2.tolist()\n    \n    return p2", "funcname": "main_solution", "ios": [{"input": {"n": 7, "p1": [7, 4, 3, 2, 6, 5, 1]}, "output": [-1, 7, -2, 4, -3, -5, 6]}, {"input": {"n": 8, "p1": [7, 1, 4, 5, 2, 6, 3, 8]}, "output": [-1, 7, 3, 4, 5, 2, -6, -8]}, {"input": {"n": 9, "p1": [8, 9, 4, 1, 3, 5, 6, 2, 7]}, "output": [-1, 8, 2, 9, 7, 6, 5, 3, 4]}, {"input": {"n": 7, "p1": [6, 2, 1, 3, 7, 4, 5]}, "output": [-1, 6, 4, 3, -2, -5, 7]}, {"input": {"n": 7, "p1": [1, 3, 5, 2, 6, 4, 7]}, "output": [-1, -2, 3, 5, 6, 4, -7]}, {"input": {"n": 7, "p1": [5, 1, 2, 4, 3, 6, 7]}, "output": [-1, 5, 3, 2, -4, -6, -7]}, {"input": {"n": 7, "p1": [4, 7, 5, 1, 6, 3, 2]}, "output": [-1, 4, -2, 7, -3, 5, 6]}, {"input": {"n": 5, "p1": [1, 2, 5, 4, 3]}, "output": [-1, -2, -3, 5, -4]}, {"input": {"n": 8, "p1": [1, 8, 5, 6, 3, 2, 7, 4]}, "output": [-1, -2, 8, 4, 6, -3, 5, -7]}, {"input": {"n": 6, "p1": [6, 2, 4, 5, 1, 3]}, "output": [-1, 6, 3, 4, 5, -2]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tnakaicode/jburkardt-python", "path": "/subset/perm1_index_to_cycle.py", "msgidx": 9712}}
{"problem_description": "Given a grid of size `grid_size` x `grid_size`, where you can only move to the right or down, how many unique paths are there from the top-left corner to the bottom-right corner?", "io_requirements": "Input:\n  `grid_size` (int): The size of the grid. For example, if `grid_size` is 20, the grid is 20x20.\n\nOutput:\n  `return` (int): The number of unique paths from the top-left corner to the bottom-right corner in the grid.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(grid_size):\n    \"\"\"\n    Calculate the number of unique paths from the top-left corner to the bottom-right corner in a grid of size `grid_size` x `grid_size`.\n    Only moves to the right and down are allowed.\n    \"\"\"\n    node_count = (grid_size + 1)**2\n    \n    def create_path_count_map(node_count):\n        nodes = {}\n        for x in range(1, node_count + 1):\n            if x <= (node_count**0.5):  # first row can only be reached by one path\n                nodes[x] = 1\n            elif x % (node_count**0.5) == 1:  # first column can only be reached by one path\n                nodes[x] = 1\n            else:\n                nodes[x] = nodes[x - 1] + nodes[x - (node_count**0.5)]\n        return nodes\n    \n    path_count_map = create_path_count_map(node_count)\n    return path_count_map[node_count]", "funcname": "main_solution", "ios": [{"input": {"grid_size": 5}, "output": 252}, {"input": {"grid_size": 2}, "output": 6}, {"input": {"grid_size": 8}, "output": 12870}, {"input": {"grid_size": 4}, "output": 70}, {"input": {"grid_size": 7}, "output": 3432}, {"input": {"grid_size": 6}, "output": 924}, {"input": {"grid_size": 3}, "output": 20}, {"input": {"grid_size": 10}, "output": 184756}, {"input": {"grid_size": 9}, "output": 48620}, {"input": {"grid_size": 1}, "output": 2}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nickprescott/coding_exercises", "path": "/project_euler/15_problem.py", "msgidx": 9844}}
{"problem_description": "In a game called \"look-and-say,\" players generate sequences by reading aloud the previous sequence and using that reading as the next sequence. For instance, \"211\" is read as \"one two, two ones,\" which becomes \"1221.\" Given an initial sequence and a number of iterations, what is the length of the resulting sequence after applying the look-and-say process for the specified number of times?", "io_requirements": "Input:\n  `starter` (str): The initial string to start the look-and-say sequence.\n  `iterations` (int): The number of iterations to apply the look-and-say process.\n\nOutput:\n  `return` (int): The length of the resulting string after the specified number of iterations.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef morph(string: str) -> str:\n    strings = []\n    newString = None\n    char = None\n    for i in range(len(string)):\n        if newString is None:\n            char = string[i]\n            newString = string[i]\n            continue\n        if char == string[i]:\n            newString += string[i]\n        else:\n            strings.append(newString)\n            newString = string[i]\n            char = string[i]\n\n    strings.append(newString)\n\n    newString = \"\"\n    for string in strings:\n        newString += str(len(string)) + string[0]\n\n    return newString\n\n# main function\ndef main_solution(starter: str, iterations: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    string = starter\n    for i in range(iterations):\n        string = morph(string)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(string)", "funcname": "main_solution", "ios": [{"input": {"starter": "2", "iterations": 31}, "output": 8786}, {"input": {"starter": "22111132", "iterations": 11}, "output": 128}, {"input": {"starter": "22", "iterations": 47}, "output": 2}, {"input": {"starter": "112312222", "iterations": 32}, "output": 42350}, {"input": {"starter": "1313323232", "iterations": 1}, "output": 18}, {"input": {"starter": "2222112", "iterations": 34}, "output": 26412}, {"input": {"starter": "221", "iterations": 8}, "output": 22}, {"input": {"starter": "13", "iterations": 41}, "output": 162556}, {"input": {"starter": "33132", "iterations": 15}, "output": 370}, {"input": {"starter": "3222", "iterations": 30}, "output": 11836}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nlindvay/AoC", "path": "/2015/day10/day10.py", "msgidx": 9321}}
{"problem_description": "Given a string, determine if there exists any permutation of the string that is a palindrome. What is the result of this determination for a randomly generated string?", "io_requirements": "Input:\n  `input_string` (str): A string for which we need to determine if it contains any palindromic permutations. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (str): Returns 'anidrom' if there is at least one palindromic permutation of the input string, otherwise returns 'not anidrom'.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef permutations(string, step, l):\n    if step == len(string) and \"\".join(string) not in l:\n        l.append(\"\".join(string))\n\n    for i in range(step, len(string)):\n        string_copy = [c for c in string]\n        string_copy[step], string_copy[i] = string_copy[i], string_copy[step]\n        permutations(string_copy, step + 1, l)\n\n# main function\ndef main_solution(input_string):\n    # input_string (str): The input string for which we need to determine if it contains any palindromic permutations.\n    l = []\n    permutations(list(input_string), 0, l)\n    \n    c = 0\n    for i in l:\n        if i == i[::-1]:\n            c += 1\n    \n    # return (str): Returns 'anidrom' if there is at least one palindromic permutation, otherwise returns 'not anidrom'.\n    return 'anidrom' if c > 0 else 'not anidrom'", "funcname": "main_solution", "ios": [{"input": {"input_string": "zlscl"}, "output": "not anidrom"}, {"input": {"input_string": "yjfhi"}, "output": "not anidrom"}, {"input": {"input_string": "gvxtf"}, "output": "not anidrom"}, {"input": {"input_string": "tee"}, "output": "anidrom"}, {"input": {"input_string": "jrjswl"}, "output": "not anidrom"}, {"input": {"input_string": "qbqgtu"}, "output": "not anidrom"}, {"input": {"input_string": "qif"}, "output": "not anidrom"}, {"input": {"input_string": "qaob"}, "output": "not anidrom"}, {"input": {"input_string": "qvgzxx"}, "output": "not anidrom"}, {"input": {"input_string": "qrmuo"}, "output": "not anidrom"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "manikshahkataria/codes", "path": "/anidrome.py", "msgidx": 9736}}
{"problem_description": "Given a string consisting of digits, uppercase letters, and lowercase letters, what are all the possible permutations of the string sorted in alphabetical order?", "io_requirements": "Input:\n  `input_string` (str): A string containing only digits, uppercase letters, and lowercase letters. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (str): A string containing all permutations of the input string, sorted in alphabetical order, with each permutation separated by a comma.", "refcode": "# import necessary packages\nimport string\n\n# all class and function definitions in the code file, if any\nRATING = dict(zip(list(string.digits + string.ascii_uppercase + string.ascii_lowercase),\n                  range(1, 26 + 26 + 10 + 1)))\n\ndef permutations(ar):\n    if len(ar) == 1:\n        return ar\n    accum = list()\n    for i, c in enumerate(ar):\n        accum.extend([c + perm for perm in permutations(ar[:i] + ar[i+1:])])\n    return accum\n\ndef sorter(n):\n    score = list()\n    for c in n:\n        score.append(RATING.get(c))\n    return score\n\n# main function\ndef main_solution(input_string):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = ','.join(sorted(permutations(input_string), key=sorter))\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "K4r"}, "output": "4Kr,4rK,K4r,Kr4,r4K,rK4"}, {"input": {"input_string": "D1o"}, "output": "1Do,1oD,D1o,Do1,o1D,oD1"}, {"input": {"input_string": "BKZ"}, "output": "BKZ,BZK,KBZ,KZB,ZBK,ZKB"}, {"input": {"input_string": "2sb"}, "output": "2bs,2sb,b2s,bs2,s2b,sb2"}, {"input": {"input_string": "HxZ"}, "output": "HZx,HxZ,ZHx,ZxH,xHZ,xZH"}, {"input": {"input_string": "yNq"}, "output": "Nqy,Nyq,qNy,qyN,yNq,yqN"}, {"input": {"input_string": "W9m"}, "output": "9Wm,9mW,W9m,Wm9,m9W,mW9"}, {"input": {"input_string": "ZO7"}, "output": "7OZ,7ZO,O7Z,OZ7,Z7O,ZO7"}, {"input": {"input_string": "Pym"}, "output": "Pmy,Pym,mPy,myP,yPm,ymP"}, {"input": {"input_string": "x4N"}, "output": "4Nx,4xN,N4x,Nx4,x4N,xN4"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "WilbertHo/codeeval", "path": "/hard/string_permutations/py/stringpermutations.py", "msgidx": 9789}}
{"problem_description": "Given a Tower of Hanoi puzzle with a certain number of disks, what is the sequence of moves required to solve the puzzle and move all disks from the starting peg to the destination peg, following the rules of the Tower of Hanoi?", "io_requirements": "Input:\n  `height` (int): The height of the tower in the Tower of Hanoi problem. It represents the number of disks to be moved.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a move in the format \"from_pole to to_pole\". Each move is a step in solving the Tower of Hanoi problem for the given height.", "refcode": "# import necessary packages\nimport time\n\n# all class and function definitions in the code file, if any\ndef move_tower(height, from_pole, to_pole, with_pole):\n    if height >= 1:\n        move_tower(height - 1, from_pole, with_pole, to_pole)\n        print(from_pole, 'to', to_pole)\n        move_tower(height - 1, with_pole, to_pole, from_pole)\n\n# main function\ndef main_solution(height):\n    # Convert the height to an integer if it's not already\n    height = int(height)\n    \n    # Initialize poles\n    from_pole = \"A\"\n    to_pole = \"C\"\n    with_pole = \"B\"\n    \n    # Capture the output of the move_tower function\n    import io\n    import sys\n    from contextlib import redirect_stdout\n    \n    output = io.StringIO()\n    with redirect_stdout(output):\n        move_tower(height, from_pole, to_pole, with_pole)\n    \n    # Get the captured output\n    moves = output.getvalue().strip().split(\"\\n\")\n    \n    # Return the moves as a list of strings\n    return moves", "funcname": "main_solution", "ios": [{"input": {"height": 2}, "output": ["A to B", "A to C", "B to C"]}, {"input": {"height": 1}, "output": ["A to C"]}, {"input": {"height": 3}, "output": ["A to C", "A to B", "C to B", "A to C", "B to A", "B to C", "A to C"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "OceanicSix/Python_program", "path": "/Study/Recursive/Hanoi_solution.py", "msgidx": 10150}}
{"problem_description": "Imagine you are standing at the top-left corner of a square grid. You can only move right or down. How many unique paths can you take to reach the bottom-right corner of the grid, given the grid size?", "io_requirements": "Input:\n  `grid_size` (int): The size of the grid (e.g., 20 for a 20x20 grid).\n\nOutput:\n  `return` (int): The number of unique routes from the top-left corner to the bottom-right corner of the grid.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nmap = {}\n\ndef routes(x, y):\n    \"\"\"Calculate unique routes across the diagonal of an an x by y grid\"\"\"\n    if 1 == x and 1 == y:\n        return 2\n    elif 0 == x or 0 == y:\n        return 1\n    elif (x,y) in map:\n        return map[(x,y)]\n    elif (y,x) in map:\n        return map[(y,x)]\n    else:\n        map[(x,y)] = routes(x-1, y) + routes(x, y-1)\n        return map[(x,y)]\n\n# main function\ndef main_solution(grid_size):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = routes(grid_size, grid_size)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"grid_size": 16}, "output": 601080390}, {"input": {"grid_size": 6}, "output": 924}, {"input": {"grid_size": 12}, "output": 2704156}, {"input": {"grid_size": 14}, "output": 40116600}, {"input": {"grid_size": 5}, "output": 252}, {"input": {"grid_size": 7}, "output": 3432}, {"input": {"grid_size": 20}, "output": 137846528820}, {"input": {"grid_size": 18}, "output": 9075135300}, {"input": {"grid_size": 17}, "output": 2333606220}, {"input": {"grid_size": 10}, "output": 184756}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "neilpa/euler", "path": "/Python/015.py", "msgidx": 9702}}
{"problem_description": "In a table tennis tournament, two teams, each consisting of three players, are set to compete. Team A has players named a, b, and c, while Team B has players named x, y, and z. The match-ups have been determined through a draw. However, certain constraints have been revealed: player a from Team A will not play against player x from Team B, and player c from Team A will not play against either player x or player z from Team B. Given these constraints, what are the possible match-ups for the three players from Team A against the players from Team B?", "io_requirements": "Input:\n  `team_a` (list of str): A list of three strings representing the players in team A. Example: `['a', 'b', 'c']`.\n  `team_b` (list of str): A list of three strings representing the players in team B. Example: `['x', 'y', 'z']`.\n\nOutput:\n  `return` (list of tuple): A list of tuples where each tuple represents a valid match-up between players from team A and team B. Each tuple contains three strings corresponding to the players from team B that team A's players will face. Example: `[('y', 'x', 'y'), ('y', 'z', 'y')]`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n\n# main function\ndef main_solution(team_a, team_b):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # team_a and team_b are lists of strings representing the players in each team\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through all possible combinations of players\n    for a in team_b:\n        for b in team_b:\n            for c in team_b:\n                if a != b and a != c and b != c:\n                    if a != 'x' and c != 'x' and c != 'z':\n                        result.append((a, b, c))\n    \n    # Return the result as a list of tuples\n    return result", "funcname": "main_solution", "ios": [{"input": {"team_a": ["c", "a", "b"], "team_b": ["y", "x", "z"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["b", "a", "c"], "team_b": ["x", "z", "y"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["a", "c", "b"], "team_b": ["x", "z", "y"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["a", "b", "c"], "team_b": ["z", "x", "y"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["b", "c", "a"], "team_b": ["x", "z", "y"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["c", "b", "a"], "team_b": ["x", "y", "z"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["b", "a", "c"], "team_b": ["x", "y", "z"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["b", "c", "a"], "team_b": ["z", "y", "x"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["b", "a", "c"], "team_b": ["y", "x", "z"]}, "output": [["z", "x", "y"]]}, {"input": {"team_a": ["c", "b", "a"], "team_b": ["y", "x", "z"]}, "output": [["z", "x", "y"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "maoxiaomai/Py100", "path": "/Py100/1-50/022.py", "msgidx": 9832}}
{"problem_description": "Given a string consisting of three words, how would the string be encoded and decoded using the Huffman algorithm?", "io_requirements": "Input:\n  `input_string` (str): A string containing three words to be encoded using the Huffman algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `encoded_string` (str): The encoded string using the Huffman algorithm.\n    - `decoded_string` (str): The decoded string after applying the Huffman algorithm.", "refcode": "# import necessary packages\nimport heapq\nfrom collections import Counter\nfrom collections import namedtuple\n\n# all class and function definitions in the code file, if any\nclass Node(namedtuple(\"Node\", [\"left\", \"right\"])):\n    \"\"\"\u041a\u043b\u0430\u0441\u0441 \u0443\u0437\u043b\u043e\u0432\"\"\"\n    def step(self, code_n, acc):\n        \"\"\"\n        \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b (\u0443\u0437\u043b\u043e\u0432)\n        \"\"\"\n        self.left.step(code_n, acc + \"0\")\n        self.right.step(code_n, acc + \"1\")\n\nclass Leaflet(namedtuple(\"Leaflet\", [\"symbol\"])):\n    \"\"\"\u041a\u043b\u0430\u0441\u0441 \u043b\u0438\u0441\u0442\u044c\u0435\u0432 \u0434\u0435\u0440\u0435\u0432\u0430, \u0432 \u043d\u0438\u0445 \u0445\u0440\u0430\u043d\u044f\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\"\"\"\n    def step(self, code_l, acc):\n        \"\"\"\n        \u041f\u0435\u0440\u0432\u043e\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0434\u043b\u044f \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0443\u0437\u043b\u043e\u0432 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u0432 \u043b\u0438\u0441\u0442\u0438\u043a\u0430\u0445\n        :param code_l:\n        :param acc: \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432\n        \"\"\"\n        code_l[self.symbol] = acc or \"0\"\n\ndef func_code(line):\n    \"\"\"\n    \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n    :param line: \u0432\u0432\u043e\u0434\u0438\u043c\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n    :return: \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0441 \u043a\u043e\u0434\u0430\u043c\u0438 + \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443\n    \"\"\"\n    head = []\n    for char, freq in Counter(line).items():\n        head.append((freq, len(head), Leaflet(char)))  # \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u043b\u0438\u0441\u0442\u0438\u043a\u043e\u0432\n    heapq.heapify(head)  # \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0434\u0432\u043e\u0438\u0447\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430 (\u043a\u0443\u0447\u0438)\n    counter = len(head)\n    while len(head) > 1:\n        freq1, _counter1, left = heapq.heappop(head)\n        freq2, _counter2, right = heapq.heappop(head)\n        heapq.heappush(head, (freq1 + freq2, counter, Node(left, right)))\n        counter += 1\n    dic_code = {}\n    if head:\n        [(freq, _count, root)] = head\n        root.step(dic_code, \"\")\n    return dic_code, \"\".join(dic_code[ch] for ch in line)\n\ndef func_decode(encode_in, code_in):\n    \"\"\"\n    \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0441\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u043e \u0441\u043b\u043e\u0432\u0430\u0440\u044e\n    :param encode_in: \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0440\u0430\u0437\u0430 \u0432 \u043a\u043e\u0434\u0435 \u0425\u0430\u0444\u0444\u043c\u0430\u043d\u0430\n    :param code_in: \u0441\u043b\u043e\u0432\u0430\u0440\u044c\n    :return: \u0440\u0430\u0441\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n    \"\"\"\n    decode_line = []\n    encode_char = ''\n    for ch_in in encode_in:\n        encode_char += ch_in\n        for key in code_in:\n            if code_in.get(key) == encode_char:\n                decode_line.append(key)\n                encode_char = ''\n                break\n    return \"\".join(decode_line)\n\n# main function\ndef main_solution(input_string):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    code, encoded_string = func_code(input_string)\n    decoded_string = func_decode(encoded_string, code)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"encoded_string\": encoded_string, \"decoded_string\": decoded_string}", "funcname": "main_solution", "ios": [{"input": {"input_string": "aZtg JpAfcc ChPf"}, "output": {"encoded_string": "0110011110001001000101010111100001010010000110111101111001", "decoded_string": "aZtg JpAfcc ChPf"}}, {"input": {"input_string": "xVSR LTv jDsZq"}, "output": {"encoded_string": "0110011110001001010101010111100010110111101111000001", "decoded_string": "xVSR LTv jDsZq"}}, {"input": {"input_string": "CgX sQzz eQyp"}, "output": {"encoded_string": "1100110111100111111100101101011000100001010", "decoded_string": "CgX sQzz eQyp"}}, {"input": {"input_string": "dUYjh yXc bOsZw"}, "output": {"encoded_string": "010001010110011110000011001101010110011100110111101111000", "decoded_string": "dUYjh yXc bOsZw"}}, {"input": {"input_string": "chM aMnvhV wEX"}, "output": {"encoded_string": "101001001110010110111100110101011101001111000001", "decoded_string": "chM aMnvhV wEX"}}, {"input": {"input_string": "BWSnS oFQa kNnP"}, "output": {"encoded_string": "10001001001010001011101010111100110101111101111010000", "decoded_string": "BWSnS oFQa kNnP"}}, {"input": {"input_string": "KhWIM qwH xWc"}, "output": {"encoded_string": "101010110111100110110011101111000100001011010", "decoded_string": "KhWIM qwH xWc"}}, {"input": {"input_string": "VKXVls VGjE RrZn"}, "output": {"encoded_string": "1110100010111101100111001111100010011010001101111001101000", "decoded_string": "VKXVls VGjE RrZn"}}, {"input": {"input_string": "oHkoT PgCN SCZmOD"}, "output": {"encoded_string": "1111010001011111011000001111000001100100010100011011110011011110", "decoded_string": "oHkoT PgCN SCZmOD"}}, {"input": {"input_string": "eQfng brIynE aMlDg"}, "output": {"encoded_string": "0010001101001110111100001010110011110001110100100010101011110011011111", "decoded_string": "eQfng brIynE aMlDg"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Sebkd/Algorythm", "path": "/eleven_task2.py", "msgidx": 9663}}
{"problem_description": "Given a range of five-digit numbers, identify all the numbers within that range that are considered Lily Numbers. A Lily Number is defined as a number where the sum of the products of its possible splits (each split being a pair of numbers derived from the original number) equals the original number itself. For example, 1461 can be split into (1 and 461), (14 and 61), and (146 and 1), and the sum of the products of these splits equals 1461. What are the Lily Numbers within the given range?", "io_requirements": "Input:\n  `start_range` (int): The starting number of the range to check for Lily Numbers.\n  `end_range` (int): The ending number of the range to check for Lily Numbers.\n\nOutput:\n  `return` (list of int): A list of all Lily Numbers found within the specified range.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def LilyNumber(self, num):\n        sum1 = 0\n        for i in range(1, 5):\n            sum_1 = num % (10 ** i)\n            sum_2 = (num // 10 ** i)\n            sum_3 = sum_1 * sum_2\n            sum1 += sum_3\n        return sum1 == num\n\n# main function\ndef main_solution(start_range, end_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    res = []\n    for num in range(start_range, end_range + 1):\n        d = Solution()\n        if d.LilyNumber(num):\n            res.append(num)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return res", "funcname": "main_solution", "ios": [{"input": {"start_range": 52074, "end_range": 70027}, "output": [65500]}, {"input": {"start_range": 58761, "end_range": 81673}, "output": [65500]}, {"input": {"start_range": 47362, "end_range": 96566}, "output": [65500]}, {"input": {"start_range": 64873, "end_range": 83454}, "output": [65500]}, {"input": {"start_range": 63582, "end_range": 73477}, "output": [65500]}, {"input": {"start_range": 82803, "end_range": 93560}, "output": []}, {"input": {"start_range": 65519, "end_range": 78450}, "output": []}, {"input": {"start_range": 67917, "end_range": 86069}, "output": []}, {"input": {"start_range": 37701, "end_range": 80442}, "output": [65500]}, {"input": {"start_range": 73949, "end_range": 97862}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "channajiang/Exercises_Book", "path": "/niuke/\u53d8\u79cd\u6c34\u4ed9\u82b1\u6570.py", "msgidx": 9578}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings where each string represents a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        tmp_str = []\n        left, right = 0, 0\n        if not n:\n            return res\n        self.helper(res, tmp_str, n, left, right)\n        return res\n\n    def helper(self, res, tmp_str, n, left, right):\n        if left < n:\n            tmp_str.append('(')\n            self.helper(res, tmp_str, n, left + 1, right)\n            tmp_str.pop()\n        if right < left:\n            tmp_str.append(')')\n            self.helper(res, tmp_str, n, left, right + 1)\n            tmp_str.pop()\n        if left == n and right == n:\n            res.append(''.join(tmp_str))\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dantangfan/leetcode", "path": "/GenerateParentheses.py", "msgidx": 9445}}
{"problem_description": "In a school, there are `m` rewards to be distributed among `n` students. Each student must receive at least `x` rewards. How many different ways can the rewards be distributed among the students?", "io_requirements": "Input:\n  `m` (int): Total number of rewards to be distributed.\n  `n` (int): Number of students.\n  `x` (int): Minimum number of rewards each student must receive.\n\nOutput:\n  `return` (int): Number of ways to distribute the rewards.", "refcode": "# import necessary packages\nimport time\n\n# main function\ndef main_solution(m, n, x):\n    \"\"\"\n    Calculate the number of ways to distribute 'm' rewards to 'n' students with a minimum of 'x' rewards per student.\n    \n    Parameters:\n    m (int): Total number of rewards to be distributed.\n    n (int): Number of students.\n    x (int): Minimum number of rewards each student must receive.\n    \n    Returns:\n    int: Number of ways to distribute the rewards.\n    \"\"\"\n    def reward(m, n, x):\n        if (m == 0 or n == 1 or m == 1):\n            return 1\n        else:\n            y = 0\n            a = m // n\n            for i in range(x, a + 1, 1):\n                y += reward(m - i, n - 1, i)\n            return y\n    \n    return reward(m, n, x)", "funcname": "main_solution", "ios": [{"input": {"m": 34, "n": 9, "x": 3}, "output": 15}, {"input": {"m": 33, "n": 1, "x": 28}, "output": 1}, {"input": {"m": 17, "n": 8, "x": 0}, "output": 230}, {"input": {"m": 45, "n": 5, "x": 9}, "output": 1}, {"input": {"m": 14, "n": 8, "x": 0}, "output": 116}, {"input": {"m": 45, "n": 8, "x": 0}, "output": 17674}, {"input": {"m": 48, "n": 6, "x": 1}, "output": 4494}, {"input": {"m": 23, "n": 9, "x": 0}, "output": 887}, {"input": {"m": 41, "n": 4, "x": 3}, "output": 270}, {"input": {"m": 45, "n": 2, "x": 20}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shiroNaux/Design-and-Analysis-Algorithm", "path": "/week_3/reward.py", "msgidx": 9703}}
{"problem_description": "In a game of chess, a player wants to move a specific chess piece from one position to another. Given the name of the chess piece, its current position, and the target position, can you determine if the move is valid according to the rules of chess?", "io_requirements": "Input:\n  `figure` (str): The name of the chess piece. Possible values are \"Pawn\", \"Knight\", \"Bishop\", \"Rook\", \"Queen\", and \"King\".\n  `start` (str): The starting position of the chess piece in standard chess notation (e.g., \"A8\").\n  `end` (str): The target position of the chess piece in standard chess notation (e.g., \"H8\").\n\nOutput:\n  `return` (bool): `True` if the chess piece can move from the `start` position to the `end` position according to the rules of chess, otherwise `False`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_pawn_move(start, end):\n    return start[0] == end[0] and ord(end[1]) - ord(start[1]) <= 2\n\ndef is_knight_move(start, end):\n    return sorted([abs(ord(end[0]) - ord(start[0])), abs(ord(end[1]) - ord(start[1]))]) == [1, 2]\n\ndef is_bishop_move(start, end):\n    return abs(ord(end[0]) - ord(start[0])) == abs(ord(end[1]) - ord(start[1]))\n\ndef is_rock_move(start, end):\n    return min(abs(ord(end[0]) - ord(start[0])), abs(ord(end[1]) - ord(start[1]))) == 0\n\ndef is_queen_move(start, end):\n    return is_bishop_move(start, end) or is_rock_move(start, end)\n\ndef is_king_move(start, end):\n    return max(abs(ord(end[0]) - ord(start[0])), abs(ord(end[1]) - ord(start[1]))) == 1\n\n# main function\ndef main_solution(figure, start, end):\n    figures = [\"Pawn\", \"Knight\", \"Bishop\", \"Rook\", \"Queen\", \"King\"]\n    if figure not in figures:\n        return False\n    \n    if figure == figures[0]:\n        return is_pawn_move(start, end)\n    elif figure == figures[1]:\n        return is_knight_move(start, end)\n    elif figure == figures[2]:\n        return is_bishop_move(start, end)\n    elif figure == figures[3]:\n        return is_rock_move(start, end)\n    elif figure == figures[4]:\n        return is_queen_move(start, end)\n    elif figure == figures[5]:\n        return is_king_move(start, end)", "funcname": "main_solution", "ios": [{"input": {"figure": "Bishop", "start": "F6", "end": "F8"}, "output": false}, {"input": {"figure": "Knight", "start": "F7", "end": "G3"}, "output": false}, {"input": {"figure": "Bishop", "start": "D5", "end": "D1"}, "output": false}, {"input": {"figure": "Knight", "start": "B2", "end": "F3"}, "output": false}, {"input": {"figure": "King", "start": "A4", "end": "F6"}, "output": false}, {"input": {"figure": "Pawn", "start": "D5", "end": "C6"}, "output": false}, {"input": {"figure": "Pawn", "start": "D2", "end": "D7"}, "output": false}, {"input": {"figure": "Rook", "start": "H4", "end": "F1"}, "output": false}, {"input": {"figure": "Bishop", "start": "F3", "end": "G7"}, "output": false}, {"input": {"figure": "King", "start": "B3", "end": "A8"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/i5KL9xzKt6WSBsds9_22.py", "msgidx": 9686}}
{"problem_description": "Given a range of integers, what is the sum of all numbers within that range that can form a 9-digit pandigital product with their divisors? A pandigital product is defined as a number that, when concatenated with its divisors, forms a 9-digit number containing each digit from 1 to 9 exactly once.", "io_requirements": "Input:\n  `n_start` (int): The starting integer for the range of numbers to check.\n  `n_end` (int): The ending integer for the range of numbers to check.\n\nOutput:\n  `return` (int): The sum of all numbers in the specified range that meet the criteria for being part of a pandigital product.", "refcode": "# import necessary packages\nimport datetime\nfrom sympy.ntheory import divisors\nfrom math import sqrt\n\n# main function\ndef main_solution(n_start, n_end):\n    # Convert JSON serializable inputs to the original input variables\n    n_start = int(n_start)\n    n_end = int(n_end)\n    \n    def is_pan(n):\n        s_n = str(n)\n        \n        if len(s_n) != 9:\n            return False\n        \n        digits = []\n        \n        for digit in s_n:\n            if digit == '0' or digit in digits:\n                return False\n            \n            digits.append(digit)\n        \n        return True\n    \n    s = 0\n    \n    for n in range(n_start, n_end + 1):\n        div = divisors(n)\n        \n        for d in div:\n            if d >= sqrt(n):\n                break\n            \n            a = ''\n            a += str(d) + str(n // d) + str(n)\n            \n            if is_pan(a):\n                s += n\n                break\n    \n    # Convert the output to JSON serializable format\n    return s", "funcname": "main_solution", "ios": [{"input": {"n_start": 2624, "n_end": 6171}, "output": 15538}, {"input": {"n_start": 4331, "n_end": 5220}, "output": 4396}, {"input": {"n_start": 2341, "n_end": 3506}, "output": 0}, {"input": {"n_start": 3060, "n_end": 7736}, "output": 37376}, {"input": {"n_start": 1870, "n_end": 9717}, "output": 45228}, {"input": {"n_start": 3772, "n_end": 9093}, "output": 45228}, {"input": {"n_start": 1172, "n_end": 8756}, "output": 45228}, {"input": {"n_start": 1628, "n_end": 1631}, "output": 0}, {"input": {"n_start": 2498, "n_end": 9088}, "output": 45228}, {"input": {"n_start": 1569, "n_end": 4554}, "output": 4396}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Lafungo/koenigsberg", "path": "/p32.py", "msgidx": 9677}}
{"problem_description": "Given two strings of lowercase alphabets and a value `k`, determine if the strings can be transformed into anagrams of each other by changing at most `k` characters. If possible, identify the characters that need to be changed in each string. What is the result and the necessary changes to achieve the transformation?", "io_requirements": "Input:\n  `str1` (str): The first string, containing only lowercase alphabets.\n  `str2` (str): The second string, containing only lowercase alphabets.\n  `k` (int): The maximum number of changes allowed to make the strings anagrams.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `result` (bool): True if the strings can be made anagrams with at most `k` changes, False otherwise.\n    - `extra` (list): A list of characters in `str2` that are not in `str1`, or None if `result` is False.\n    - `diff` (list): A list of characters in `str1` that are not in `str2`, or None if `result` is False.", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# main function\ndef main_solution(str1: str, str2: str, k: int) -> dict:\n    \"\"\"\n    Check if two strings are k-anagrams or not and return the result along with the necessary changes.\n    \n    Args:\n    str1 (str): The first string.\n    str2 (str): The second string.\n    k (int): The maximum number of changes allowed to make the strings anagrams.\n    \n    Returns:\n    dict: A dictionary containing the result, extra characters, and characters that need to be changed.\n    \"\"\"\n    if len(str1) != len(str2):\n        return {\"result\": False, \"extra\": None, \"diff\": None}\n\n    counter_map = Counter(str1)\n    extra = list()\n    changes = 0\n    for char in str2:\n        if counter_map[char] > 0:\n            counter_map[char] -= 1\n        else:\n            extra.append(char)\n            changes += 1\n\n        if changes > k:\n            return {\"result\": False, \"extra\": None, \"diff\": None}\n    diff = [c for c in counter_map if counter_map[c] > 0]\n    return {\"result\": True, \"extra\": extra, \"diff\": diff}", "funcname": "main_solution", "ios": [{"input": {"str1": "ilwtgnr", "str2": "rdjsfym", "k": 3}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "ofdgp", "str2": "eyimg", "k": 2}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "nsbtydoon", "str2": "jvzwwgqbc", "k": 1}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "zebtiayxh", "str2": "lmkutbjjd", "k": 3}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "axzqz", "str2": "ctpqn", "k": 2}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "nledvbx", "str2": "ckywfqz", "k": 1}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "zexbknihjm", "str2": "zjvlxatsxr", "k": 3}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "yrjaerdya", "str2": "rnewszbui", "k": 4}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "hudgggu", "str2": "isbwwtv", "k": 1}, "output": {"result": false, "extra": null, "diff": null}}, {"input": {"str1": "wwctkf", "str2": "vzlyxj", "k": 3}, "output": {"result": false, "extra": null, "diff": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "maneeshd/algo-ds", "path": "/algorithms/k_anagrams.py", "msgidx": 9946}}
{"problem_description": "Given a set of characters and a specified length, determine which strings of that length, composed of the given characters, are considered winning moves. A string is considered valid if it does not contain consecutive repeating characters. A string is a winning move if removing any one character from it results in a valid string that is not already a winning move. What are the winning moves for the given length and characters?", "io_requirements": "Input:\n  `length` (int): The length of the strings to be generated. It should be an integer between 3 and 7.\n  `characters` (str): A string containing the characters to be used for generating the strings. The string should contain only lowercase alphabetic characters.\n\nOutput:\n  `return` (list of str): A list of strings that are valid and winning moves, sorted by their length. Each string in the list is a valid string that does not contain consecutive repeating characters, and it is a winning move based on the given rules.", "refcode": "# import necessary packages\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\ndef isValid(string):\n    for i in range(1, len(string)):\n        if string[i] == string[i-1]: return False\n    return True\n\ndef get_moves(string):\n    res = []\n    for i in range(1, len(string) - 1):\n        if isValid(string[:i]+string[i+1:]): res.append(string[:i]+string[i+1:])\n    return res\n\n# main function\ndef main_solution(length, characters):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    isWinning = set()\n    \n    for s in product(characters, repeat=length):\n        string = \"\".join(s)\n        if not isValid(string): continue\n        for move in get_moves(string):\n            if not move in isWinning: isWinning.add(string)\n    \n    # Convert the set to a sorted list of strings\n    result = sorted(isWinning, key=lambda x: len(x))\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"length": 3, "characters": "aeb"}, "output": ["aeb", "bea", "bae", "abe", "eab", "eba"]}, {"input": {"length": 3, "characters": "cab"}, "output": ["bca", "cab", "abc", "cba", "acb", "bac"]}, {"input": {"length": 6, "characters": "cd"}, "output": []}, {"input": {"length": 5, "characters": "bc"}, "output": []}, {"input": {"length": 7, "characters": "bc"}, "output": []}, {"input": {"length": 5, "characters": "ba"}, "output": []}, {"input": {"length": 3, "characters": "ac"}, "output": []}, {"input": {"length": 6, "characters": "da"}, "output": []}, {"input": {"length": 4, "characters": "cd"}, "output": []}, {"input": {"length": 5, "characters": "cb"}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cormackikkert/competitive-programming", "path": "/AtCoder/Regular 064/DStupid.py", "msgidx": 9621}}
{"problem_description": "In the context of Conway's Game of Life, given an initial state of a board represented by a 2D grid of cells, where each cell is either dead (0) or alive (1), what will be the state of the board after one iteration of the game, following the rules of Conway's Game of Life?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the initial state of the board. Each element in the list is either `0` (dead cell) or `1` (live cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the final state of the board after applying the rules of Conway's Game of Life. Each element in the list is either `0` (dead cell) or `1` (live cell).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        m = len(board)\n        n = len(board[0])\n        \n        def isValidNeighbor(x, y):\n            return x < len(board) and x >= 0 and y < len(board[0]) and y >= 0\n\n        # All directions of neighbors\n        x_dir = [-1, -1, -1, 0, 0, 1, 1, 1]\n        y_dir = [-1,  0,  1, -1, 1, -1, 0, 1]\n        \n        for row in range(m):\n            for col in range(n):\n                live_neighbors = 0\n                for i in range(8):\n                    curr_x, curr_y = row + x_dir[i], col + y_dir[i]\n                    if isValidNeighbor(curr_x, curr_y) and abs(board[curr_x][curr_y]) == 1:\n                        live_neighbors += 1\n                \n                # Rules 1 and 3: -1 indicates a cell that was live but now is dead.\n                if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):\n                    board[row][col] = -1\n                    \n                # Rule 4: 2 indicates a cell that was dead but now is live.\n                if board[row][col] == 0 and live_neighbors == 3:\n                    board[row][col] = 2\n                 \n        # Get the final board\n        for row in range(m):\n            for col in range(n):\n                if board[row][col] >= 1:\n                    board[row][col] = 1\n                else:\n                    board[row][col] = 0\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # Convert input to the required format\n    solution = Solution()\n    solution.gameOfLife(board)\n    # Return the final board state\n    return board", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1]]}, "output": [[1, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0], [0, 1, 1]]}, {"input": {"board": [[0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 0, 0], [1, 0, 1]]}, "output": [[0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 0, 0], [1, 0, 1]]}, {"input": {"board": [[0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 0, 0], [0, 1, 0, 1, 1]]}, "output": [[0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 0, 0], [0, 1, 0, 1, 1]]}, {"input": {"board": [[0, 1, 0], [0, 1, 0], [0, 0, 0]]}, "output": [[0, 1, 0], [0, 1, 0], [0, 0, 0]]}, {"input": {"board": [[1, 1, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0]]}, "output": [[1, 1, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 1], [1, 0, 1, 0]]}, {"input": {"board": [[1, 0, 0, 1, 0], [1, 0, 0, 0, 1], [0, 1, 0, 1, 0]]}, "output": [[1, 0, 0, 1, 0], [1, 0, 0, 0, 1], [0, 1, 0, 1, 0]]}, {"input": {"board": [[0, 0, 1, 1, 1], [0, 0, 1, 1, 1], [1, 1, 1, 0, 0], [0, 0, 0, 0, 0]]}, "output": [[0, 0, 1, 1, 1], [0, 0, 1, 1, 1], [1, 1, 1, 0, 0], [0, 0, 0, 0, 0]]}, {"input": {"board": [[0, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 0]]}, "output": [[0, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 0]]}, {"input": {"board": [[1, 0, 1, 1], [1, 0, 0, 1], [1, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0]]}, "output": [[1, 0, 1, 1], [1, 0, 0, 1], [1, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0]]}, {"input": {"board": [[0, 0, 1, 1], [0, 0, 1, 1], [0, 0, 0, 0]]}, "output": [[0, 0, 1, 1], [0, 0, 1, 1], [0, 0, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "imjaya/Leetcode_solved", "path": "/289_Game_of_Life.py", "msgidx": 9776}}
{"problem_description": "Given a calibration string composed of chemical symbols and a set of replacement rules, how many unique new strings can be generated by substituting one symbol in the calibration string according to the provided rules?", "io_requirements": "Input:\n  `calib_str` (str): A string representing the calibration string, containing chemical symbols.\n  `replacements_str` (str): A string containing newline-separated replacement rules in the format \"symbol1 => symbol2\".\n\nOutput:\n  `return` (int): The number of unique new strings that can be generated by substituting one symbol in the calibration string according to the provided replacement rules.", "refcode": "# import necessary packages\nfrom collections import defaultdict\nimport re\nimport json\n\n# all class and function definitions in the code file, if any\ndef make_dict(replacements_str):\n    \"\"\"Returns dictionary mapping chars to possible replacements\"\"\"\n    replacements_dict = defaultdict(lambda:[])\n    for line in replacements_str.split(\"\\n\"):\n        words = line.split(\"=>\")\n        words = [word.strip() for word in words]\n        replacements_dict[words[0]].append(words[1])\n    return replacements_dict\n\ndef find_symbols(calib_str):\n    \"\"\"Returns list of symbols (strings) in a given string\n\n        Args:\n            calib_str: string used for calibration\n        Returns:\n            symbols: list of strings, each representing one symbol\n    \"\"\"\n    symbol_finder = re.compile('e|[A-Z][a-z]?').finditer\n    symbols = []\n    for match in symbol_finder(calib_str):\n        symbol = calib_str[match.start():match.end()]\n        symbols.append(symbol)\n    return symbols\n\ndef make_substitutions(symbols_list, replacements_dict):\n    \"\"\"Returns set of new strings, each made by substituting one symbol\n\n        Args:\n            symbols_list: list of symbols (string) representing original calibration string\n            replacements_dict: dict mapping strings to what they can be replaced with\n        Returns:\n            new_strings: set of all possible unique new strings\n    \"\"\"\n    new_strings = set()\n    for idx in range(len(symbols_list)):\n        symbol = symbols_list[idx]\n        if not replacements_dict.get(symbol):\n            continue\n        else:\n            possible_replacements = replacements_dict.get(symbol)\n            for replacement in possible_replacements:\n                new_string = \"\".join(symbols_list[:idx])\n                new_string += replacement\n                new_string += \"\".join(symbols_list[idx+1:])\n                new_strings.add(new_string)\n    return new_strings\n\n# main function\ndef main_solution(calib_str, replacements_str):\n    # Convert JSON serializable inputs to original input variables\n    replacements_dict = make_dict(replacements_str)\n    symbols_list = find_symbols(calib_str)\n    \n    # Core solution logic\n    new_strings = make_substitutions(symbols_list, replacements_dict)\n    \n    # Convert output to JSON serializable format\n    result = len(new_strings)\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"calib_str": "VqUOjAeGOm", "replacements_str": "H => Rd\nQ => Td\nU => QO\nM => ep\nZ => Pr"}, "output": 1}, {"input": {"calib_str": "eLRUyXSpiN", "replacements_str": "Q => vg\nA => Ho\nT => gu\nE => ta\nK => TA"}, "output": 0}, {"input": {"calib_str": "onxATDwQQN", "replacements_str": "R => Um\nN => xu\nH => eD\nK => YO\nN => qm"}, "output": 2}, {"input": {"calib_str": "AfqfsjBYBT", "replacements_str": "L => Jm\nP => Ub\nV => hS\nZ => XV\nX => GE"}, "output": 0}, {"input": {"calib_str": "aegipQkMHo", "replacements_str": "N => nJ\nZ => YH\nW => jD\nA => KV\nJ => Uj"}, "output": 0}, {"input": {"calib_str": "MMLFGTJFyf", "replacements_str": "G => SK\nK => QE\nY => ts\nB => gV\nX => SC"}, "output": 1}, {"input": {"calib_str": "PfGAmtvjCH", "replacements_str": "Y => Wy\nB => oS\nO => FD\nE => oZ\nK => FZ"}, "output": 0}, {"input": {"calib_str": "fDnXruJpKL", "replacements_str": "L => GH\nH => iU\nG => Bc\nF => UW\nG => pM"}, "output": 1}, {"input": {"calib_str": "ukFNSOqaxZ", "replacements_str": "H => QE\nS => YK\nH => Pe\nA => gr\nY => WC"}, "output": 1}, {"input": {"calib_str": "vruOToaEXl", "replacements_str": "Z => nv\nC => sE\nQ => Nu\nM => aB\nZ => JN"}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "micaswyers/Advent", "path": "/Advent2015/19/day19.py", "msgidx": 9306}}
{"problem_description": "In a game of N-Queens, where N queens are to be placed on an NxN chessboard such that no two queens threaten each other, given a partially filled board with some queens already placed, how many distinct ways can the remaining queens be placed to satisfy the rules of the game?", "io_requirements": "Input:\n  `num` (int): The number of queens to be placed on an NxN chessboard.\n  `initial_state` (list of int): A list representing the initial positions of the queens on the board. Each element in the list represents the column position of a queen in the corresponding row.\n\nOutput:\n  `return` (list of lists of int): A list of all possible solutions where each solution is represented as a list of integers. Each integer in the list represents the column position of a queen in the corresponding row.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef conflict(state, nextX):\n    nextY = len(state)\n    for i in range(nextY):\n        if abs(state[i]-nextX) in (0, nextY-i): # \u6c34\u5e73\u8ddd\u79bb\u4e3a0(\u540c\u4e00\u5217)\u6216\u7b49\u4e8e\u5782\u76f4\u8ddd\u79bb(\u4e00\u6761\u5bf9\u89d2\u7ebf\u4e0a)\n            return True\n    return False\n\ndef queens(num=8, state=()):\n    for pos in range(num):\n        if not conflict(state, pos):\n            if len(state) == num-1:\n                yield (pos,)\n            else:\n                for result in queens(num, state+(pos,)):\n                    yield (pos,)+result\n\n# main function\ndef main_solution(num, initial_state):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # Convert JSON serializable inputs to the original input variables\n  initial_state = tuple(initial_state)\n  \n  # Call the original function\n  result = list(queens(num, initial_state))\n  \n  # Convert the result to JSON serializable output\n  result = [list(solution) for solution in result]\n  \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"num": 8, "initial_state": [1, 0]}, "output": []}, {"input": {"num": 8, "initial_state": [3, 0, 7, 2, 5, 4, 6]}, "output": [[1]]}, {"input": {"num": 6, "initial_state": [2, 3, 4]}, "output": []}, {"input": {"num": 7, "initial_state": [0, 1, 4, 3]}, "output": []}, {"input": {"num": 7, "initial_state": [4, 1, 3, 6, 0, 2]}, "output": [[5]]}, {"input": {"num": 6, "initial_state": [4]}, "output": [[2, 0, 5, 3, 1]]}, {"input": {"num": 5, "initial_state": [1]}, "output": [[3, 0, 2, 4], [4, 2, 0, 3]]}, {"input": {"num": 7, "initial_state": [5, 6, 4]}, "output": []}, {"input": {"num": 4, "initial_state": []}, "output": [[1, 3, 0, 2], [2, 0, 3, 1]]}, {"input": {"num": 4, "initial_state": [1, 2, 0]}, "output": [[3]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EasonQian/python-demo", "path": "/src/queen-pro.py", "msgidx": 9714}}
{"problem_description": "Given the concept of amicable numbers, where two numbers are considered amicable if the sum of the proper divisors of each number is equal to the other number (and they are not equal to each other), what is the sum of all amicable numbers under a given limit `n`?", "io_requirements": "Input:\n  `n` (int): The upper limit under which to find all amicable numbers. Must be a positive integer.\n\nOutput:\n  `return` (int): The sum of all amicable numbers under the given limit `n`.", "refcode": "# import necessary packages\nimport time\n\n# all class and function definitions in the code file, if any\ndef divisores(n):\n    return [i for i in range(1, n // 2 + 1) if n % i == 0]\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    suma = 0\n    numeros = [False] * (n + 1)\n    for i in range(4, n):\n        s = sum(divisores(i))\n        if not numeros[i] and s < n:\n            numeros[s] = True\n            if (i == sum(divisores(s)) and i != s):\n                suma += i + s\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return suma", "funcname": "main_solution", "ios": [{"input": {"n": 4478}, "output": 8442}, {"input": {"n": 8864}, "output": 31626}, {"input": {"n": 3615}, "output": 8442}, {"input": {"n": 7523}, "output": 31626}, {"input": {"n": 2928}, "output": 8442}, {"input": {"n": 5265}, "output": 8442}, {"input": {"n": 9074}, "output": 31626}, {"input": {"n": 8907}, "output": 31626}, {"input": {"n": 8166}, "output": 31626}, {"input": {"n": 3210}, "output": 8442}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "floppp/programming_challenges", "path": "/project_euler/001-050/21.py", "msgidx": 9891}}
{"problem_description": "Given a binary tree, determine whether it is \"superbalanced\". A tree is considered \"superbalanced\" if the difference between the depths of any two leaf nodes is no greater than one. What is the result of checking if the given binary tree is \"superbalanced\"?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys `value` (int), `left` (dict or None), and `right` (dict or None).\n\nOutput:\n  `return` (bool): A boolean indicating whether the binary tree is \"superbalanced\". A tree is \"superbalanced\" if the difference between the depths of any two leaf nodes is no greater than one.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass BinaryTreeNode:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_balanced(tree):\n    results = []\n\n    def check(n, t1, t2):\n        if t1 and not t2:\n            results.append(n)\n            return check(n + 1, t1.left, t1.right) + n\n        elif t2 and not t1:\n            results.append(n)\n            return n + check(n + 1, t2.left, t2.right)\n        elif not t1 and not t2:\n            results.append(n)\n            return n\n        else:\n            return check(n + 1, t1.left, t1.right) + check(n + 1, t2.left, t2.right)\n\n    check(0, tree.left, tree.right)\n\n    return abs(max(results) - min(results)) <= 1\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(node_dict):\n        if node_dict is None:\n            return None\n        return BinaryTreeNode(\n            node_dict['value'],\n            build_tree(node_dict['left']),\n            build_tree(node_dict['right'])\n        )\n\n    tree = build_tree(tree_structure)\n    \n    # Call the original function with the converted input\n    result = is_balanced(tree)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"value": 45, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 69, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 23, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 79, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 66, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 93, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 21, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 97, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 2, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"value": 52, "left": null, "right": null}}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "UnicodeSnowman/programming-practice", "path": "/balanced_binary_tree/main.py", "msgidx": 9418}}
{"problem_description": "Given a set of 10 digits from 0 to 9, what are the combinations of four-digit numbers `ABCD` and `EFGH`, and a two-digit number `XY`, such that the product of the difference between `ABCD` and `EFGH` and `XY` equals 900?", "io_requirements": "Input:\n  `numbers` (list of integers): A list of 10 integers representing the digits from 0 to 9.\n\nOutput:\n  `return` (list of tuples): A list of tuples where each tuple contains three integers: `ABCD`, `EFGH`, and `XY`. Each tuple represents a solution where `(ABCD - EFGH) * XY = 900`.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list to a tuple to match the original code's requirement\n    numbers = tuple(numbers)\n    \n    # Initialize a list to store the results\n    results = []\n    \n    # Iterate over all permutations of the numbers\n    for item in itertools.permutations(numbers):\n        ABCD = item[0] * 1000 + item[1] * 100 + item[2] * 10 + item[3]\n        EFGH = item[4] * 1000 + item[5] * 100 + item[6] * 10 + item[7]\n        XY = item[8] * 10 + item[9]\n        \n        # Check the condition\n        if (ABCD - EFGH) * XY == 900:\n            results.append((ABCD, EFGH, XY))\n    \n    # Return the results as a list of tuples\n    return results", "funcname": "main_solution", "ios": [{"input": {"numbers": [2, 9, 0, 7, 3, 1, 5, 6, 8, 4]}, "output": [[7153, 6928, 4], [5012, 4987, 36], [6048, 5973, 12]]}, {"input": {"numbers": [3, 2, 5, 7, 4, 1, 0, 6, 9, 8]}, "output": [[5012, 4987, 36], [7153, 6928, 4], [6048, 5973, 12]]}, {"input": {"numbers": [7, 4, 5, 0, 2, 3, 8, 1, 9, 6]}, "output": [[7153, 6928, 4], [5012, 4987, 36], [6048, 5973, 12]]}, {"input": {"numbers": [2, 5, 3, 4, 7, 0, 9, 6, 8, 1]}, "output": [[5012, 4987, 36], [7153, 6928, 4], [6048, 5973, 12]]}, {"input": {"numbers": [1, 5, 8, 3, 7, 0, 6, 9, 2, 4]}, "output": [[5012, 4987, 36], [7153, 6928, 4], [6048, 5973, 12]]}, {"input": {"numbers": [0, 8, 3, 6, 9, 5, 2, 1, 7, 4]}, "output": [[6048, 5973, 12], [5012, 4987, 36], [7153, 6928, 4]]}, {"input": {"numbers": [4, 2, 0, 5, 8, 3, 9, 1, 7, 6]}, "output": [[5012, 4987, 36], [7153, 6928, 4], [6048, 5973, 12]]}, {"input": {"numbers": [0, 2, 8, 9, 1, 3, 7, 5, 6, 4]}, "output": [[7153, 6928, 4], [5012, 4987, 36], [6048, 5973, 12]]}, {"input": {"numbers": [7, 3, 0, 8, 4, 2, 9, 1, 6, 5]}, "output": [[7153, 6928, 4], [6048, 5973, 12], [5012, 4987, 36]]}, {"input": {"numbers": [8, 9, 4, 7, 2, 5, 0, 3, 6, 1]}, "output": [[7153, 6928, 4], [5012, 4987, 36], [6048, 5973, 12]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "koking0/Algorithm", "path": "/BlueBridgeCup/Subject/2013/National _C_C++_A/1/code.py", "msgidx": 9587}}
{"problem_description": "Given a set of numbers that need to be displayed on two six-sided cubes, where each cube can display digits from 0 to 9, and the digits 6 and 9 can be considered the same (i.e., a 6 can be flipped to show a 9 and vice versa), how many distinct pairs of cubes can be formed such that all the given numbers can be displayed on the cubes?", "io_requirements": "Input:\n  `numbers` (list of tuples): A list of tuples where each tuple contains two integers representing the numbers that should be on the cubes. The integers can be between 0 and 9, inclusive.\n\nOutput:\n  `return` (int): The number of distinct pairs of cubes that can display all the given numbers, accounting for double counting.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list of tuples to a list of lists for easier manipulation\n    numbers = [list(number) for number in numbers]\n    \n    # Generate all possible cubes\n    cubes = list(itertools.combinations(range(10), 6))\n    \n    count = 0\n    for i in cubes:\n        for j in cubes:\n            # Allowing for reversals of 6 and 9\n            i_extended = list(i) + [6 if x == 9 else 9 if x == 6 else x for x in i]\n            j_extended = list(j) + [6 if x == 9 else 9 if x == 6 else x for x in j]\n            \n            # Checking if each number can be found on the cubes\n            boolean = True\n            for number in numbers:\n                digit1, digit2 = number\n                if (digit1 in i_extended and digit2 in j_extended) or (digit2 in i_extended and digit1 in j_extended):\n                    continue\n                else:\n                    boolean = False\n                    break\n            if boolean:\n                count += 1\n    \n    # Accounting for double counting\n    return count // 2", "funcname": "main_solution", "ios": [{"input": {"numbers": [[9, 7], [6, 0], [7, 4], [2, 8]]}, "output": 4790}, {"input": {"numbers": [[4, 6], [4, 1], [0, 8], [4, 1]]}, "output": 6744}, {"input": {"numbers": [[9, 3], [7, 0], [0, 1], [1, 6], [3, 8]]}, "output": 4001}, {"input": {"numbers": [[3, 4], [3, 4], [9, 3], [9, 4], [6, 5], [2, 7]]}, "output": 4425}, {"input": {"numbers": [[1, 3], [9, 6], [6, 4], [6, 2], [1, 2]]}, "output": 4794}, {"input": {"numbers": [[6, 3], [3, 5], [4, 1], [6, 7], [3, 1], [7, 1]]}, "output": 3416}, {"input": {"numbers": [[5, 7], [1, 9], [5, 9], [0, 4], [5, 2]]}, "output": 2834}, {"input": {"numbers": [[6, 9], [0, 4], [4, 6]]}, "output": 9512}, {"input": {"numbers": [[4, 8], [9, 0], [4, 9], [7, 5], [8, 2], [0, 4], [7, 1]]}, "output": 1179}, {"input": {"numbers": [[2, 7], [1, 8], [8, 1], [3, 1], [4, 3]]}, "output": 3014}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "arnet95/Project-Euler", "path": "/Python/euler090.py", "msgidx": 9774}}
{"problem_description": "Given a set of `n` distinct elements, how can we generate all possible `m`-element combinations or permutations from this set? Specifically, what are the results for the chosen problem type ('permutation' or 'combination')?", "io_requirements": "Input:\n  `n` (int): \u8868\u793a\u6bcf\u6b65\u53ef\u9009\u62e9\u7684\u72b6\u6001\u7684\u6570\u91cf\u3002\n  `m` (int): \u8868\u793a\u6700\u7ec8\u65b9\u6848\u7684\u5143\u7d20\u4e2a\u6570\u3002\n  `problem_type` (str): \u95ee\u9898\u7c7b\u578b\uff0c\u53ef\u4ee5\u662f'permutation'\uff08\u5168\u6392\u5217\uff09\u6216'combination'\uff08\u7ec4\u5408\uff09\u3002\n\nOutput:\n  `return` (list of str): \u5305\u542b\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684\u6392\u5217\u6216\u7ec4\u5408\u7684\u5b57\u7b26\u4e32\u5217\u8868\u3002\u6bcf\u4e2a\u5b57\u7b26\u4e32\u8868\u793a\u4e00\u4e2a\u6392\u5217\u6216\u7ec4\u5408\u7684\u7ed3\u679c\u3002", "refcode": "# import necessary packages\nimport time\n\n# all class and function definitions in the code file, if any\ndef backtracking(n, m, check, handle):\n    \"\"\"\n    \u56de\u6eaf\u7b97\u6cd5\u975e\u9012\u5f52\u5b9e\u73b0\n    \"\"\"\n    k, a = 0, [-1 for _ in range(m)]\n\n    while k >= 0:\n        a[k] += 1\n\n        while a[k] < n and not check(a, k):\n            a[k] += 1\n\n        if a[k] == n or k == m:\n            k -= 1\n        else:\n            if k == m - 1:\n                handle(a)\n            else:\n                k += 1\n                a[k] = -1\n\ndef display(solution):\n    \"\"\"\n    \u6253\u5370\u7ed3\u679c\n    \"\"\"\n    arr = ['1', '2', '3', '4']\n    return ' '.join([arr[solution[i]] for i in range(len(solution))])\n\ndef check_permutation(a, k):\n    \"\"\"\n    \u51b2\u7a81\u68c0\u67e5\uff0c\u6ca1\u6709\u51b2\u7a81\u8fd4\u56deTrue\uff0c\u5426\u5219\u8fd4\u56deFalse\n    \"\"\"\n    for i in range(k):\n        if a[i] == a[k]:\n            return False\n    return True\n\ndef check_combination(solution, k):\n    \"\"\"\n    \u51b2\u7a81\u68c0\u67e5\uff0c\u6ca1\u6709\u51b2\u7a81\u8fd4\u56deTrue\uff0c\u5426\u5219\u8fd4\u56deFalse\n    \"\"\"\n    for i in range(k):\n        if solution[i] >= solution[k]:\n            return False\n    return True\n\n# main function\ndef main_solution(n, m, problem_type):\n    \"\"\"\n    n, m\u51b3\u5b9a\u6211\u4eec\u641c\u7d22\u7684\u89e3\u7a7a\u95f4\u5927\u5c0f\n    n\u8868\u793a\u6bcf\u6b65\u53ef\u9009\u62e9\u7684\u72b6\u6001\n    m\u8868\u793a\u6700\u7ec8\u65b9\u6848\u7684\u5143\u7d20\u4e2a\u6570\n    problem_type: \u95ee\u9898\u7c7b\u578b\uff0c\u53ef\u4ee5\u662f'permutation'\u6216'combination'\n    \"\"\"\n    if problem_type == 'permutation':\n        check = check_permutation\n    elif problem_type == 'combination':\n        check = check_combination\n    else:\n        raise ValueError(\"Invalid problem_type. Must be 'permutation' or 'combination'.\")\n\n    results = []\n\n    def handle(solution):\n        results.append(display(solution))\n\n    backtracking(n, m, check, handle)\n\n    return results", "funcname": "main_solution", "ios": [{"input": {"n": 2, "m": 2, "problem_type": "permutation"}, "output": ["1 2", "2 1"]}, {"input": {"n": 2, "m": 1, "problem_type": "combination"}, "output": ["1", "2"]}, {"input": {"n": 4, "m": 4, "problem_type": "combination"}, "output": ["1 2 3 4"]}, {"input": {"n": 4, "m": 2, "problem_type": "combination"}, "output": ["1 2", "1 3", "1 4", "2 3", "2 4", "3 4"]}, {"input": {"n": 3, "m": 1, "problem_type": "combination"}, "output": ["1", "2", "3"]}, {"input": {"n": 4, "m": 3, "problem_type": "combination"}, "output": ["1 2 3", "1 2 4", "1 3 4", "2 3 4"]}, {"input": {"n": 4, "m": 1, "problem_type": "combination"}, "output": ["1", "2", "3", "4"]}, {"input": {"n": 3, "m": 3, "problem_type": "permutation"}, "output": ["1 2 3", "1 3 2", "2 1 3", "2 3 1", "3 1 2", "3 2 1"]}, {"input": {"n": 2, "m": 1, "problem_type": "permutation"}, "output": ["1", "2"]}, {"input": {"n": 2, "m": 2, "problem_type": "combination"}, "output": ["1 2"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zuxinlin/leetcode", "path": "/Algorithm/3_back tracking/back_tracking.py", "msgidx": 10124}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses? For example, if you have 3 pairs of parentheses, what are the different ways to arrange them so that each arrangement is valid (i.e., every opening parenthesis has a corresponding closing parenthesis and they are properly nested)?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate. It should be a positive integer.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def __init__(self):\n        self._n = 0\n        self._total_result = []\n\n    def generateParenthesis(self, n):\n        self._n = n\n        if self._n == 0:\n            return []\n        one_result = \"(\"        # \u7b2c\u4e00\u4e2a\u80af\u5b9a\u662f\u5de6\u62ec\u53f7\n        self.generator(left=1, right=0, one_result=one_result)\n        return self._total_result\n\n    def generator(self, left, right, one_result):\n        if left < self._n:      # \u5982\u679c\u5de6\u62ec\u53f7\u7684\u6570\u91cf\u5c0f\u4e8en \uff08\u6839\u636e\u903b\u8f91\uff0c\u53f3\u62ec\u53f7\u80af\u5b9a\u4e5f\u5c0f\u4e8en\uff09\n            if left > right:    # \u5982\u679c\u5de6\u62ec\u53f7\u591a\u4e8e\u53f3\u62ec\u53f7\uff0c\u65e2\u53ef\u4ee5\u6dfb\u52a0\u5de6\u62ec\u53f7\uff0c\u4e5f\u53ef\u4ee5\u6dfb\u52a0\u53f3\u62ec\u53f7\n                self.generator(left+1, right, one_result+\"(\")   #\u521b\u5efa\u4e00\u4e2a\u52a0\u5de6\u62ec\u53f7\u7684\u5206\u652f\n                self.generator(left, right+1, one_result+\")\")   #\u521b\u5efa\u4e00\u4e2a\u52a0\u53f3\u62ec\u53f7\u7684\u5206\u652f\n            else:\n                self.generator(left+1, right, one_result+\"(\")   #\u5982\u679c\u5de6\u62ec\u53f7\u7b49\u4e8e\u53f3\u62ec\u53f7\uff0c\u53ea\u80fd\u52a0\u53f3\u62ec\u53f7\n        elif right < self._n:   # \u5982\u679c\u5de6\u62ec\u53f7\u5df2\u7ecf\u6709n\u4e2a\uff0c\u4f46\u662f\u53f3\u62ec\u53f7\u8fd8\u4e0d\u591fn\u4e2a\n            self.generator(left, right+1, one_result+\")\")       # \u5269\u4e0b\u7684\u5168\u90e8\u662f\u53f3\u62ec\u53f7\u5206\u652f\n        else:                   # \u5982\u679c\u5de6\u53f3\u62ec\u53f7\u90fd\u8fbe\u5230\u4e86n\u4e2a\n            self._total_result.append(one_result)   # \u5c06\u8be5\u5206\u652f\u6dfb\u52a0\u5230\u7ed3\u679c\u96c6\uff0c\u8fd4\u56de\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mengnan1994/Surrender-to-Reality", "path": "/py/0022_generate_parentheses.py", "msgidx": 10098}}
{"problem_description": "Given a grid of points with coordinates ranging from (0,0) to (max_range_of_x_and_y-1, max_range_of_x_and_y-1), how many right triangles can be formed with one vertex at the origin (0,0) and the other two vertices within the grid?", "io_requirements": "Input:\n  `max_range_of_x_and_y` (int): The maximum range for both x and y coordinates. This defines the grid size within which points are considered. The grid will be from (0,0) to (max_range_of_x_and_y-1, max_range_of_x_and_y-1).\n\nOutput:\n  `return` (int): The number of possible right triangles that can be formed with points (0,0), (x,y), and (x',y') where x, y, x', and y' are within the specified range.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef get_square_length(p_0, p_1):\n    return (p_0[0] - p_1[0]) ** 2 + (p_0[1] - p_1[1]) ** 2\n\ndef check_is_right_triangle(P, Q):\n    O = (0, 0)\n    OP = get_square_length(O, P)\n    OQ = get_square_length(O, Q)\n    PQ = get_square_length(P, Q)\n    squared_legs = [OP, OQ, PQ]\n    squared_legs.sort()\n    return squared_legs[2] == squared_legs[0] + squared_legs[1]\n\ndef get_possible_points(x_list, y_list):\n    possible_points = []\n    for x in x_list:\n        for y in y_list:\n            if not (x == 0 and y == 0):\n                possible_points.append((x, y))\n    return possible_points\n\n# main function\ndef main_solution(max_range_of_x_and_y):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  x_list = list(range(0, max_range_of_x_and_y))\n  y_list = list(range(0, max_range_of_x_and_y))\n  possible_points = get_possible_points(x_list, y_list)\n\n  num_of_right_triangles = 0\n  for ind_P, P in enumerate(possible_points):\n      for ind_Q in range(ind_P + 1, len(possible_points)):\n          Q = possible_points[ind_Q]\n          if check_is_right_triangle(P, Q) is True:\n              num_of_right_triangles += 1\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return num_of_right_triangles", "funcname": "main_solution", "ios": [{"input": {"max_range_of_x_and_y": 3}, "output": 14}, {"input": {"max_range_of_x_and_y": 8}, "output": 207}, {"input": {"max_range_of_x_and_y": 10}, "output": 353}, {"input": {"max_range_of_x_and_y": 9}, "output": 276}, {"input": {"max_range_of_x_and_y": 4}, "output": 33}, {"input": {"max_range_of_x_and_y": 7}, "output": 148}, {"input": {"max_range_of_x_and_y": 5}, "output": 62}, {"input": {"max_range_of_x_and_y": 6}, "output": 101}, {"input": {"max_range_of_x_and_y": 2}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jialing3/corner_cases", "path": "/Relue/Eu91.py", "msgidx": 9975}}
{"problem_description": "Given a sequence of hydrogen and oxygen atoms represented by the characters 'H' and 'O', respectively, how can you synchronize their release to form water molecules (H\u2082O) such that each molecule is formed immediately as soon as there are two hydrogen atoms and one oxygen atom available, and no atoms from different molecules are mixed?", "io_requirements": "Input:\n  `input_string` (str): A string consisting of 'H' and 'O' characters, where 'H' represents a hydrogen atom and 'O' represents an oxygen atom. The string length will be 3n, where n is an integer between 1 and 50, and there will be exactly 2n 'H' characters and n 'O' characters.\n\nOutput:\n  `return` (str): A string representing the formation of water molecules. Each water molecule is represented by the sequence \"HHO\". The output string will contain the concatenated results of valid water molecule formations from the input string.", "refcode": "# import necessary packages\nfrom threading import Lock\n\n# all class and function definitions in the code file, if any\nclass H2O:\n    def __init__(self):\n        self.lock = Lock()\n        self.num_h = 0\n        self.num_o = 0\n\n    def hydrogen(self):\n        # releaseHydrogen() outputs \"H\". Do not change or remove this line.\n        self.control(1, 0)\n\n    def oxygen(self):\n        # releaseOxygen() outputs \"O\". Do not change or remove this line.\n        self.control(0, 1)\n\n    def control(self, h, o):\n        with self.lock:\n            self.num_h += h\n            self.num_o += o\n            if self.num_h < 2 or self.num_o < 1:\n                return\n            self.num_h -= 2\n            self.num_o -= 1\n        return \"HHO\"\n\n# main function\ndef main_solution(input_string: str) -> str:\n    # input_string is a string of 'H' and 'O' characters representing hydrogen and oxygen atoms\n    h2o = H2O()\n    output = []\n    \n    for char in input_string:\n        if char == 'H':\n            output.append(h2o.hydrogen())\n        elif char == 'O':\n            output.append(h2o.oxygen())\n    \n    # Filter out None values and join the valid outputs\n    return ''.join(filter(None, output))", "funcname": "main_solution", "ios": [{"input": {"input_string": "OHHHHHHOHOOHOHHHOHHHOOHHHHHHHOHHOHOOOHHHHHHHHHHHOOHOHOOOHHHHOOHOHHOHHOHH"}, "output": ""}, {"input": {"input_string": "HHHOOOHOHHHOHHH"}, "output": ""}, {"input": {"input_string": "HHHHOOHOOHHOHOHHOHOOHHHHHHOHHOHOHOOOOHHHHOOHOHHHHHHOHHHOHHHHHHHOHHHHHHOHOHHOOH"}, "output": ""}, {"input": {"input_string": "HHOOOHHHHOHOHOOHHOHHHHHHHHHHHOHOHHHHOHOHOHHHHOHOHHHOOHHOHHOO"}, "output": ""}, {"input": {"input_string": "OHOHOHHHHOHHHHHHOOOHOHHHOHOHOOHHHHHHHOOHHOOOHOHHHHHOHOHHHOOHHHHHHOOOHHHHOOHHHHHHOHOHHHH"}, "output": ""}, {"input": {"input_string": "HOHOHOOHHHOHHOHHOHOOHHOHOHHHOHHHHHOHHHH"}, "output": ""}, {"input": {"input_string": "HHOHHHHOHOOHHHHOHOHHOHHOHHOHHHHHHOHHHOHHHOHHHHOHHHHHHOOHHHHHOOHHOOOOOHOOHHHOHHOOHHHHHHOOHOHHHHOO"}, "output": ""}, {"input": {"input_string": "HOHHHHHOOOOHOHHHHHHHHHOO"}, "output": ""}, {"input": {"input_string": "HOHHHHOHHOHOHHOHHHOOHHHHHHOHHOHHHOHOHOO"}, "output": ""}, {"input": {"input_string": "HOHHOOHHHHHHOOH"}, "output": ""}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Asunqingwen/LeetCode", "path": "/hard/Building H2O.py", "msgidx": 10039}}
{"problem_description": "Given a social network represented as a graph where each vertex represents a person and each edge represents a friendship between two people, what is the largest group of people who are all friends with each other (i.e., a clique)? The graph is provided as a list of edges connecting pairs of vertices.", "io_requirements": "Input:\n  `edges` (list of tuples): A list of tuples representing the edges of the graph. Each tuple contains two integers representing the vertices connected by the edge.\n\nOutput:\n  `return` (list of integers): A list of integers representing the vertices that form the maximum clique in the graph.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self, edges):\n        self.edges = edges\n        self.vertices = set(v for e in edges for v in e)\n\n    def is_adjacent(self, v1, v2):\n        return (v1, v2) in self.edges or (v2, v1) in self.edges\n\ndef is_clique(graph, vertices):\n    \"\"\"\n    Checks that vertices form clique of the graph.\n\n    :param graph: graph (object of Graph type)\n    :param vertices: list of vertices of the graph\n    :return: True if vertices are clique, otherwise False\n    \"\"\"\n    for v1 in vertices:\n        for v2 in vertices:\n            if v1 != v2 and not graph.is_adjacent(v1, v2):\n                return False\n    return True\n\ndef all_combinations(items):\n    \"\"\"\n    Returns all combinations of different number of items.\n    Includes all unique combinations of 1 item, 2 items, etc.\n\n    :param items: list of items\n    :return: list of lists, each list is a unique combination of given items\n    \"\"\"\n    combinations = []\n    for r in range(1, len(items) + 1):\n        combinations.extend(itertools.combinations(items, r))\n    return [list(c) for c in combinations]\n\ndef max_clique(graph):\n    \"\"\"\n    Returns max clique of the graph.\n\n    :param graph: graph (object of type Graph)\n    :return: max clique as list of vertices of the clique\n    \"\"\"\n    max_clique = []\n    for combination in all_combinations(graph.vertices):\n        if is_clique(graph, combination) and len(combination) > len(max_clique):\n            max_clique = combination\n    return max_clique\n\n# main function\ndef main_solution(edges):\n    # Convert JSON serializable input to original input variables\n    graph = Graph(edges)\n    \n    # Find the maximum clique in the graph\n    max_clique_vertices = max_clique(graph)\n    \n    # Convert the result to JSON serializable output\n    return max_clique_vertices", "funcname": "main_solution", "ios": [{"input": {"edges": [[2, 4], [1, 4], [5, 3], [2, 5], [4, 1]]}, "output": [1, 4]}, {"input": {"edges": [[1, 2], [2, 1], [5, 1], [4, 2], [4, 5]]}, "output": [1, 2]}, {"input": {"edges": [[2, 4], [6, 5], [5, 7], [4, 5], [2, 6], [2, 5], [5, 2]]}, "output": [2, 4, 5]}, {"input": {"edges": [[2, 4], [1, 2], [2, 1], [5, 1], [4, 2], [4, 5], [3, 5]]}, "output": [1, 2]}, {"input": {"edges": [[1, 5], [4, 6], [5, 1], [1, 4], [2, 3], [1, 3], [3, 5], [5, 2]]}, "output": [1, 3, 5]}, {"input": {"edges": [[2, 1], [4, 3], [5, 4], [6, 3], [3, 6], [2, 5], [1, 3], [3, 5]]}, "output": [3, 4, 5]}, {"input": {"edges": [[2, 4], [1, 5], [3, 1], [5, 4], [3, 2], [5, 2]]}, "output": [2, 4, 5]}, {"input": {"edges": [[6, 1], [4, 6], [5, 1], [6, 4], [2, 6], [3, 6], [1, 6]]}, "output": [1, 5]}, {"input": {"edges": [[2, 4], [1, 2], [3, 4], [4, 6], [2, 3], [5, 6], [1, 3], [5, 2]]}, "output": [1, 2, 3]}, {"input": {"edges": [[1, 5], [5, 4], [4, 2], [1, 4], [2, 3], [4, 5], [5, 3], [5, 2]]}, "output": [1, 4, 5]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "georgy-schukin/mpiaa-py", "path": "/mpiaa/np/max_clique.py", "msgidx": 10083}}
{"problem_description": "Markov is playing a Snakes and Ladders game on a board with 100 squares. He wonders, if he can always roll the die to whatever number he wants, what would be the least number of rolls to reach the destination square (100) from the starting square (1)? Given the positions of ladders and snakes on the board, how many rolls would it take for Markov to reach the destination?", "io_requirements": "Input:\n- `ladders` (list of lists of integers): A list of ladders where each ladder is represented by a list containing two integers, the start and end cell numbers of the ladder.\n- `snakes` (list of lists of integers): A list of snakes where each snake is represented by a list containing two integers, the start and end cell numbers of the snake.\n\nOutput:\n- `return` (integer): The minimum number of rolls required to reach the destination (cell 100) from the start (cell 1). If it's not possible to reach the destination, the function returns -1.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self):\n        self.neighbours = defaultdict(list)\n\n    def add_edge(self, u, v, dist):\n        if dist >= 0:\n            self.neighbours[u].append([v, dist])\n        else:\n            self.neighbours[u] = [[v, 0]]\n\n    def shortest_path(self):\n        queue = []\n        visited = {}\n        queue.append([0, 0])\n\n        while queue:\n            index, rolls = queue.pop(0)\n            if index in visited:\n                continue\n            visited[index] = rolls\n\n            if index == 99:\n                break\n\n            for neighbour in self.neighbours[index]:\n                if neighbour[0] not in visited:\n                    queue.append([neighbour[0], rolls + neighbour[1]])\n\n        if 99 in visited:\n            return visited[99]\n        else:\n            return -1\n\n# main function\ndef main_solution(ladders, snakes):\n    # Convert JSON serializable inputs to the original input variables\n    ladders = [[start, end] for start, end in ladders]\n    snakes = [[start, end] for start, end in snakes]\n\n    # Invoke the function that requires non-JSON serializable inputs\n    g = Graph()\n    for i in range(99):\n        for j in range(1, 7):\n            g.add_edge(i, i + j, 1)\n\n    for ladder in ladders:\n        g.add_edge(ladder[0] - 1, ladder[1] - 1, 0)\n\n    for snake in snakes:\n        g.add_edge(snake[0] - 1, snake[1] - 1, 0)\n\n    # Convert the output to JSON serializable\n    result = g.shortest_path()\n    return result", "funcname": "main_solution", "ios": [{"input": {"ladders": [[51, 68]], "snakes": [[29, 27], [72, 68]]}, "output": 15}, {"input": {"ladders": [[10, 88], [17, 37]], "snakes": [[84, 14], [7, 5]]}, "output": 4}, {"input": {"ladders": [[55, 92]], "snakes": [[18, 3], [48, 13], [82, 66]]}, "output": 11}, {"input": {"ladders": [[39, 42]], "snakes": [[65, 28], [12, 10], [22, 20]]}, "output": 17}, {"input": {"ladders": [[21, 77], [69, 75], [10, 17]], "snakes": [[55, 51]]}, "output": 8}, {"input": {"ladders": [[43, 55]], "snakes": [[33, 16]]}, "output": 15}, {"input": {"ladders": [[42, 74], [96, 99]], "snakes": [[68, 4]]}, "output": 12}, {"input": {"ladders": [[3, 44]], "snakes": [[78, 31]]}, "output": 11}, {"input": {"ladders": [[88, 93], [2, 88]], "snakes": [[17, 7]]}, "output": 3}, {"input": {"ladders": [[78, 90], [19, 98]], "snakes": [[22, 19], [78, 50]]}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lemming52/white_pawn", "path": "/hackerrank/snakesladders/solution.py", "msgidx": 10214}}
{"problem_description": "Given a string composed of lowercase letters, what are all the possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all unique permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = list(itertools.permutations(char_list))\n    \n    # Convert each permutation tuple back to a string\n    result = [''.join(permutation) for permutation in permutations]\n    \n    # Return the list of permutations as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "dpu"}, "output": ["dpu", "dup", "pdu", "pud", "udp", "upd"]}, {"input": {"input_string": "uye"}, "output": ["uye", "uey", "yue", "yeu", "euy", "eyu"]}, {"input": {"input_string": "bak"}, "output": ["bak", "bka", "abk", "akb", "kba", "kab"]}, {"input": {"input_string": "pkv"}, "output": ["pkv", "pvk", "kpv", "kvp", "vpk", "vkp"]}, {"input": {"input_string": "sof"}, "output": ["sof", "sfo", "osf", "ofs", "fso", "fos"]}, {"input": {"input_string": "ufd"}, "output": ["ufd", "udf", "fud", "fdu", "duf", "dfu"]}, {"input": {"input_string": "gov"}, "output": ["gov", "gvo", "ogv", "ovg", "vgo", "vog"]}, {"input": {"input_string": "aso"}, "output": ["aso", "aos", "sao", "soa", "oas", "osa"]}, {"input": {"input_string": "shg"}, "output": ["shg", "sgh", "hsg", "hgs", "gsh", "ghs"]}, {"input": {"input_string": "gmu"}, "output": ["gmu", "gum", "mgu", "mug", "ugm", "umg"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KaiyeZhou/LeetCode-repo", "path": "/problem/\u6253\u5370\u51fa\u7ed9\u5b9a\u5b57\u7b26\u4e32\u7684\u6240\u6709\u6392\u5217\u7ec4\u5408.py", "msgidx": 9688}}
{"problem_description": "You have a certain amount of money and you want to buy bottles of water. Each bottle of water costs 1 yuan. After drinking the water, you can exchange three empty bottles for one full bottle of water. Given the initial amount of money, how many bottles of water can you ultimately consume?", "io_requirements": "Input:\n  `initial_money` (int): The initial amount of money in yuan that can be used to buy water bottles.\n\nOutput:\n  `return` (int): The total number of bottles of water that can be consumed, including those obtained through recycling empty bottles.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef bottle(n):\n    if n < 3:\n        return n\n    else:\n        s = n // 3\n        return 3 * s + bottle(n - 2 * s)\n\n# main function\ndef main_solution(initial_money):\n    # Convert the input to an integer if it's not already\n    initial_money = int(initial_money)\n    \n    # Calculate the total number of bottles of water that can be consumed\n    total_bottles = bottle(initial_money)\n    \n    # Return the result as a JSON serializable output\n    return total_bottles", "funcname": "main_solution", "ios": [{"input": {"initial_money": 5}, "output": 7}, {"input": {"initial_money": 38}, "output": 56}, {"input": {"initial_money": 17}, "output": 25}, {"input": {"initial_money": 23}, "output": 34}, {"input": {"initial_money": 16}, "output": 23}, {"input": {"initial_money": 71}, "output": 106}, {"input": {"initial_money": 79}, "output": 118}, {"input": {"initial_money": 30}, "output": 44}, {"input": {"initial_money": 39}, "output": 58}, {"input": {"initial_money": 55}, "output": 82}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wangweicheng0606/Python-", "path": "/water.py", "msgidx": 10510}}
{"problem_description": "In a card game, a deck of cards is shuffled according to a specific set of rules. The deck is initially ordered from 0 to N-1, where N is the number of cards. The shuffle involves taking the top card off the deck and placing it on the table, then taking the next card off the top and placing it at the bottom of the deck in hand. This process is repeated until all cards are on the table. The deck is then reshuffled using the same rules until it returns to its original order. How many rounds are required to return the deck to its original order given a specific number of cards in the deck?", "io_requirements": "Input:\n  `size_of_deck` (int): The number of cards in the deck. Must be a positive integer.\n\nOutput:\n  `return` (int): The number of rounds required to return the deck to its original order.", "refcode": "# import necessary packages\nimport sys\nfrom time import time\n\n# all class and function definitions in the code file, if any\nclass Game():\n    def __init__(self, size_of_deck):\n        \"\"\"\n        At the creation of the game, we init a lookup table (shuffle_table)\n        to precalculate the distribution of card for a round\n        :param size_of_deck: Number of cards in the deck (MUST BE POSITIVE)\n        :return:\n        \"\"\"\n        self.deck = list(range(size_of_deck))\n        self.shuffle_table = list(range(size_of_deck))\n\n        table_deck = list()\n        deck = list(range(size_of_deck))\n\n        # Compute the lookup table\n        while deck:\n            # Step 1 : Take the top card off the deck and set it on the table\n            table_deck.append(deck.pop())\n\n            if deck:\n                # Step 2 : Take the next card off the top of desk and put it on the bottom of the deck in your hand.\n                deck.insert(0, deck.pop())\n\n        # Store the position of the card after one round as the lookup table\n        for x in range(size_of_deck):\n            self.shuffle_table[x] = table_deck[x]\n\n    def compute(self):\n        \"\"\"\n        :return: Return the number of round to come back to the initial deck\n        \"\"\"\n        # Two decks to use alternatively\n        decks = [list(self.deck), list(self.deck)]\n        round = 0\n\n        # Shuffle card until going back to original deck\n        while True:\n            # Select decks\n            deck = decks[(round + 1) % 2]\n            new_deck = decks[round % 2]\n\n            # Use the shuffle table to make the new deck\n            for x in deck:\n                new_deck[self.shuffle_table[x]] = deck[x]\n\n            round += 1\n\n            if self.is_over(new_deck):\n                break\n\n        # Return the number of round to come back to the original order\n        return round\n\n    @staticmethod\n    def is_over(deck):\n        \"\"\"\n        :return: Return true if the game deck is at initial status, False otherwise\n        \"\"\"\n        # First card value (We assumed that first card value is 0)\n        expected_value = 0\n\n        # Iterate on card value\n        for card in deck:\n            if card == expected_value:\n                # Increment expected value and continue\n                expected_value += 1\n            else:\n                # Deck is not as the initial status\n                return False\n        # Deck is at the initial status\n        return True\n\n# main function\ndef main_solution(size_of_deck):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    game = Game(size_of_deck)\n    rounds = game.compute()\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return rounds", "funcname": "main_solution", "ios": [{"input": {"size_of_deck": 24}, "output": 90}, {"input": {"size_of_deck": 75}, "output": 66}, {"input": {"size_of_deck": 88}, "output": 720}, {"input": {"size_of_deck": 34}, "output": 90}, {"input": {"size_of_deck": 70}, "output": 336}, {"input": {"size_of_deck": 53}, "output": 53}, {"input": {"size_of_deck": 42}, "output": 42}, {"input": {"size_of_deck": 66}, "output": 66}, {"input": {"size_of_deck": 32}, "output": 12}, {"input": {"size_of_deck": 89}, "output": 630}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "boltzj/coding-challenge", "path": "/question1/q1v3.py", "msgidx": 9882}}
{"problem_description": "Given a target position on a 2D plane, where the coordinates are represented by integers `x` and `y`, what is the sequence of moves required to reach the target position from the origin (0, 0) using the minimum number of jumps? Each jump can move you North, South, East, or West by a distance equal to the current jump number (starting from 1 and incrementing by 1 with each subsequent jump).", "io_requirements": "Input:\n  `x` (int): The x-coordinate of the target position.\n  `y` (int): The y-coordinate of the target position.\n\nOutput:\n  `return` (str): A string representing the sequence of moves (each character being 'N', 'S', 'E', or 'W') to reach the target position from the origin (0, 0).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef solve(x, y):\n    N = 0\n    currSum = 0\n    while currSum < abs(x) + abs(y) or (currSum + x + y) % 2 == 1:\n        N += 1\n        currSum += N\n    result = \"\"\n    while N > 0:\n        if abs(x) > abs(y):\n            if x > 0: \n                result += 'E'\n                x -= N\n            else:\n                result += 'W'\n                x += N\n        else:\n            if y > 0:\n                result += 'N'\n                y -= N\n            else:\n                result += 'S'\n                y += N\n        N -= 1\n    return result[::-1]\n\n# main function\ndef main_solution(x, y):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = solve(x, y)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"x": -35, "y": -4}, "output": "NNSSWWWWW"}, {"input": {"x": -73, "y": 88}, "output": "NESNWWNNWWNNWNWNWN"}, {"input": {"x": 89, "y": -78}, "output": "ENSESESESESESESESE"}, {"input": {"x": -92, "y": -35}, "output": "NNSNSNSWSWSWSWWWW"}, {"input": {"x": 46, "y": 38}, "output": "EWSNEWSNENENENE"}, {"input": {"x": 36, "y": 1}, "output": "WESNEEEEE"}, {"input": {"x": -10, "y": -78}, "output": "EWNSNSNSWSSSSSS"}, {"input": {"x": -77, "y": 19}, "output": "WSNEWEWNWNWWWWW"}, {"input": {"x": 28, "y": 64}, "output": "WSNEWSNENENENNN"}, {"input": {"x": -82, "y": -80}, "output": "NNSSNNSSWWSSWWSSWSW"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shaik1990/Codejam", "path": "/round1C 2013/pogostick/main.py", "msgidx": 10011}}
{"problem_description": "In the context of Conway's Game of Life, a cellular automaton, given a grid of size `N` by `N` with randomly initialized cells, what will be the state of the grid after `iterations` number of updates, following the rules of Conway's Game of Life?", "io_requirements": "Input:\n  `N` (int): The size of the grid (NxN).\n  `iterations` (int): The number of iterations to update the grid.\n\nOutput:\n  `return` (list of lists of int): The final state of the grid after the specified number of iterations. Each element in the list represents a cell in the grid, with values 1 (ON) or 0 (OFF).", "refcode": "# import necessary packages\nimport numpy as np\n\n# Constants\nON = 1\nOFF = 0\nvals = [1, 0]\n\n# Function to generate a random grid\ndef randomGrid(N): \n    \"\"\"returns a grid of NxN random values\"\"\"\n    return np.random.choice(vals, N*N, p=[0.2, 0.8]).reshape(N, N)\n\n# Function to update the grid based on Conway's Game of Life rules\ndef update(grid, N): \n    newGrid = grid.copy() \n    for i in range(N): \n        for j in range(N): \n            if i == 0:\n                if j == 0:\n                    total = int((grid[i, (j+1)] + \n                                 grid[(i+1), j] +\n                                 grid[(i+1), (j+1)])) \n                elif j == N-1:\n                    total = int((grid[i, (j-1)] +\n                                 grid[(i+1), j] +\n                                 grid[(i+1), (j-1)])) \n                else:\n                    total = int((grid[i, (j-1)] + grid[i, (j+1)] + \n                                 grid[(i+1), j] +\n                                 grid[(i+1), (j-1)] + grid[(i+1), (j+1)]))\n            elif i == N-1:\n                if j == 0:\n                    total = int((grid[i, (j+1)] + \n                                 grid[(i-1), j] +\n                                 grid[(i-1), (j+1)])) \n                elif j == N-1:\n                    total = int((grid[i, (j-1)] +\n                                 grid[(i-1), j] +\n                                 grid[(i-1), (j-1)])) \n                else:\n                    total = int((grid[i, (j-1)] + grid[i, (j+1)] + \n                                 grid[(i-1), j] +\n                                 grid[(i-1), (j-1)] + grid[(i-1), (j+1)])) \n            else:\n                if j == 0:\n                    total = int((grid[i, (j+1)] + \n                                 grid[(i-1), j] + grid[(i+1), j] + \n                                 grid[(i-1), (j+1)] + \n                                 grid[(i+1), (j+1)])) \n                elif j == N-1:\n                    total = int((grid[i, (j-1)] +\n                                 grid[(i-1), j] + grid[(i+1), j] + \n                                 grid[(i-1), (j-1)] +\n                                 grid[(i+1), (j-1)])) \n                else:\n                    total = int((grid[i, (j-1)] + grid[i, (j+1)] + \n                                 grid[(i-1), j] + grid[(i+1), j] + \n                                 grid[(i-1), (j-1)] + grid[(i-1), (j+1)] + \n                                 grid[(i+1), (j-1)] + grid[(i+1), (j+1)])) \n  \n            if grid[i, j]  == ON: \n                if (total < 2) or (total > 3): \n                    newGrid[i, j] = OFF \n            else: \n                if total == 3: \n                    newGrid[i, j] = ON \n    return newGrid\n\n# main function\ndef main_solution(N, iterations):\n    # Generate a random grid of size NxN\n    grid = randomGrid(N)\n    \n    # Update the grid for the specified number of iterations\n    for _ in range(iterations):\n        grid = update(grid, N)\n    \n    # Convert the final grid to a list of lists for JSON serialization\n    final_grid = grid.tolist()\n    \n    return final_grid", "funcname": "main_solution", "ios": [{"input": {"N": 6, "iterations": 1}, "output": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": {"N": 7, "iterations": 3}, "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]}, {"input": {"N": 6, "iterations": 4}, "output": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": {"N": 7, "iterations": 1}, "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": {"N": 7, "iterations": 4}, "output": [[0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": {"N": 6, "iterations": 5}, "output": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": {"N": 5, "iterations": 1}, "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": {"N": 5, "iterations": 2}, "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": {"N": 7, "iterations": 2}, "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0]]}, {"input": {"N": 5, "iterations": 3}, "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "spandian2019/119b_Conway", "path": "/tb_vector_gen.py", "msgidx": 9511}}
{"problem_description": "Given a sequence of digits from '0' to '9', find the sum of all pandigital numbers that can be formed using these digits, such that each number has a specific divisibility property. Specifically, for each pandigital number, the substring formed by the 2nd, 3rd, and 4th digits must be divisible by 2, the substring formed by the 3rd, 4th, and 5th digits must be divisible by 3, and so on up to the substring formed by the 8th, 9th, and 10th digits being divisible by 17. What is the sum of all such pandigital numbers?", "io_requirements": "Input:\n  `digits` (str): A string containing all digits from '0' to '9' in any order. The length of the string must be exactly 10 characters.\n\nOutput:\n  `return` (int): The sum of all 0 to 9 pandigital numbers that satisfy the divisibility property described in the problem.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(digits):\n    # Convert the input string to a list of characters\n    digits_list = list(digits)\n    \n    # Generate all permutations of the digits\n    numbers = permutations(digits_list)\n    \n    # Filter out permutations that start with '0'\n    number_list = [\"\".join(number) for number in numbers if number[0] != '0']\n    \n    sum_ = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    \n    # Check each number for the divisibility property\n    for number in number_list:\n        is_okay = True\n        for i in range(7):\n            if int(number[i+1:i+4]) % primes[i] != 0:\n                is_okay = False\n                break\n        if is_okay:\n            sum_ += int(number)\n    \n    # Return the sum of all valid pandigital numbers\n    return sum_", "funcname": "main_solution", "ios": [{"input": {"digits": "9036187542"}, "output": 16695334890}, {"input": {"digits": "0657921348"}, "output": 16695334890}, {"input": {"digits": "7256490138"}, "output": 16695334890}, {"input": {"digits": "8629435710"}, "output": 16695334890}, {"input": {"digits": "0879356214"}, "output": 16695334890}, {"input": {"digits": "9310852467"}, "output": 16695334890}, {"input": {"digits": "4618279530"}, "output": 16695334890}, {"input": {"digits": "9726438150"}, "output": 16695334890}, {"input": {"digits": "6053472981"}, "output": 16695334890}, {"input": {"digits": "9748162530"}, "output": 16695334890}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AlphaAlpacaa/Project-Euler-s-Solutions", "path": "/Project Euler's Solutions/Sub-string_divisibility.py", "msgidx": 10184}}
{"problem_description": "Given a range of numbers, what is the sum of all valid permutations of numbers within that range that meet the following criteria:\n- The number formed by the second, third, and fourth digits is divisible by 2.\n- The number formed by the third, fourth, and fifth digits is divisible by 3.\n- The number formed by the fourth, fifth, and sixth digits is divisible by 5.\n- The number formed by the fifth, sixth, and seventh digits is divisible by 7.\n- The number formed by the sixth, seventh, and eighth digits is divisible by 11.\n- The number formed by the seventh, eighth, and ninth digits is divisible by 13.\n- The number formed by the eighth, ninth, and tenth digits is divisible by 17.", "io_requirements": "Input:\n  `start_range` (int): The starting number of the range for generating permutations (inclusive).\n  `end_range` (int): The ending number of the range for generating permutations (exclusive).\n\nOutput:\n  `return` (int): The sum of all valid permutations of numbers within the given range that meet specific divisibility criteria.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef checkValid(numlist):\n    \"\"\"check the validity of a number as described: \"\"\"\n    if listToDigit(numlist[1:4]) % 2 != 0: return False\n    if listToDigit(numlist[2:5]) % 3 != 0: return False\n    if listToDigit(numlist[3:6]) % 5 != 0: return False\n    if listToDigit(numlist[4:7]) % 7 != 0: return False\n    if listToDigit(numlist[5:8]) % 11 != 0: return False\n    if listToDigit(numlist[6:9]) % 13 != 0: return False\n    if listToDigit(numlist[7:10]) % 17 != 0: return False\n    return True\n\ndef listToDigit(list):\n    return int(''.join(str(u) for u in list))\n\n# main function\ndef main_solution(start_range, end_range):\n    \"\"\"\n    This function calculates the sum of all valid permutations of numbers within the given range that meet specific divisibility criteria.\n    \"\"\"\n    # Convert JSON serializable inputs to the original input variables\n    start_range = int(start_range)\n    end_range = int(end_range)\n    \n    # Generate permutations within the specified range\n    lists = permutations(range(start_range, end_range))\n    \n    # Calculate the sum of all valid permutations\n    sum_valid_permutations = 0\n    for i in lists:\n        if checkValid(i):\n            sum_valid_permutations += listToDigit(i)\n    \n    # Convert the output to JSON serializable format\n    return sum_valid_permutations", "funcname": "main_solution", "ios": [{"input": {"start_range": 0, "end_range": 8}, "output": 0}, {"input": {"start_range": 5, "end_range": 15}, "output": 3932871567472498}, {"input": {"start_range": 4, "end_range": 14}, "output": 1170174721841530}, {"input": {"start_range": 5, "end_range": 14}, "output": 0}, {"input": {"start_range": 0, "end_range": 7}, "output": 0}, {"input": {"start_range": 0, "end_range": 10}, "output": 16695334890}, {"input": {"start_range": 2, "end_range": 10}, "output": 0}, {"input": {"start_range": 2, "end_range": 12}, "output": 3776223355202}, {"input": {"start_range": 3, "end_range": 8}, "output": 0}, {"input": {"start_range": 3, "end_range": 9}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dbkaiser/EulerKaiser", "path": "/python/pb43.py", "msgidx": 9915}}
{"problem_description": "In a scenario where missionaries and cannibals need to cross a river using a boat that can carry a limited number of people, how can we determine the sequence of moves that ensures all missionaries and cannibals reach the other side safely without ever allowing the cannibals to outnumber the missionaries on either side of the river? Specifically, what is the sequence of moves and the total number of crossings required given the initial number of missionaries (`m`), cannibals (`c`), and the boat capacity (`p`)?", "io_requirements": "Input:\n- `m` (int): The number of missionaries on the starting side.\n- `c` (int): The number of cannibals on the starting side.\n- `p` (int): The maximum number of people that can cross the river at once.\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `path` (str): A string representing the sequence of moves required to safely transport all missionaries and cannibals to the other side of the river.\n  - `crossings` (int): The total number of crossings required to achieve the goal.", "refcode": "import copy\n\nclass Side:\n    def __init__(self, m=0, c=0):\n        self.miss = m\n        self.cann = c\n\n    def __add__(self, new):\n        self.miss += new.miss\n        self.cann += new.cann\n        return self\n\n    def __sub__(self, new):\n        self.miss -= new.miss\n        self.cann -= new.cann\n        return self\n\n    def Safe(self):\n        return (self.miss >= 0 and self.cann >= 0 and (self.miss == 0 or (self.miss >= self.cann)))\n\n    def __str__(self):\n        return (\"[\" + str(self.miss) + \"M, \" + str(self.cann) + \"C]\")\n\nclass State:\n    def __init__(self, n=Side(), f=Side()):\n        self.depart = n\n        self.arrive = f\n        self.startSide = True\n        self.prevMove = None\n\n    def cross(self, travelers):\n        self.prevMove = travelers\n        if self.startSide:\n            self.depart -= travelers\n            self.arrive += travelers\n        else:\n            self.depart += travelers\n            self.arrive -= travelers\n        self.startSide = not self.startSide\n\n    def Safe(self):\n        return self.depart.Safe() and self.arrive.Safe()\n\n    def reachedTarget(self):\n        return not self.startSide and (self.depart.miss == 0 and self.depart.cann == 0)\n\n    def __str__(self):\n        whichSide = lambda isNear: (isNear and [\"S\"] or [\"F\"])[0]\n        safe = lambda Safe: (Safe and [\"\"] or [\"[i]\"])[0]\n        return \"%s : %s%s | | %s%s\" % (whichSide(self.startSide), self.depart, safe(self.depart.Safe()), self.arrive, safe(self.arrive.Safe()))\n\ndef main_solution(m, c, p):\n    q = [State(Side(m, c))]\n    searched = {}\n    while len(q) > 0:\n        current = q[0]\n        del q[0]\n        if current.reachedTarget():\n            break\n        searched[str(current)] = True\n        for miss in range(0, p+1):\n            for cann in range(max(0, 1 - miss), p+1 - miss):\n                new = copy.deepcopy(current)\n                new.parent = current\n                new.cross(Side(miss, cann))\n                if ((not new.Safe()) or (str(new) in searched)):\n                    pass\n                else:\n                    q.append(new)\n\n    path = \"\"\n    i = 0\n    while current is not None:\n        path = \" + %s\\n %s %s\" % (current.prevMove, current, path)\n        try:\n            current = current.parent\n            i += 1\n        except AttributeError:\n            current = None\n    path = path[8:]\n    return {\"path\": path, \"crossings\": i}", "funcname": "main_solution", "ios": [{"input": {"m": 2, "c": 4, "p": 1}, "output": {"path": " S : [2M, 4C][i] | | [0M, 0C] ", "crossings": 0}}, {"input": {"m": 2, "c": 5, "p": 2}, "output": {"path": " S : [2M, 5C][i] | | [0M, 0C]  + [2M, 0C]\n F : [0M, 5C] | | [2M, 0C] ", "crossings": 1}}, {"input": {"m": 4, "c": 4, "p": 1}, "output": {"path": " S : [4M, 4C] | | [0M, 0C]  + [0M, 1C]\n F : [4M, 3C] | | [0M, 1C] ", "crossings": 1}}, {"input": {"m": 1, "c": 2, "p": 1}, "output": {"path": " S : [1M, 2C][i] | | [0M, 0C]  + [1M, 0C]\n F : [0M, 2C] | | [1M, 0C] ", "crossings": 1}}, {"input": {"m": 3, "c": 5, "p": 1}, "output": {"path": " S : [3M, 5C][i] | | [0M, 0C] ", "crossings": 0}}, {"input": {"m": 3, "c": 1, "p": 1}, "output": {"path": " S : [3M, 1C] | | [0M, 0C]  + [1M, 0C]\n F : [2M, 1C] | | [1M, 0C] ", "crossings": 1}}, {"input": {"m": 5, "c": 5, "p": 1}, "output": {"path": " S : [5M, 5C] | | [0M, 0C]  + [0M, 1C]\n F : [5M, 4C] | | [0M, 1C] ", "crossings": 1}}, {"input": {"m": 3, "c": 3, "p": 1}, "output": {"path": " S : [3M, 3C] | | [0M, 0C]  + [0M, 1C]\n F : [3M, 2C] | | [0M, 1C] ", "crossings": 1}}, {"input": {"m": 5, "c": 2, "p": 1}, "output": {"path": " S : [5M, 2C] | | [0M, 0C]  + [1M, 0C]\n F : [4M, 2C] | | [1M, 0C] ", "crossings": 1}}, {"input": {"m": 3, "c": 4, "p": 1}, "output": {"path": " S : [3M, 4C][i] | | [0M, 0C]  + [0M, 1C]\n F : [3M, 3C] | | [0M, 1C] ", "crossings": 1}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "irfhanaz/AI_Lab", "path": "/assignment2-lions+buffalo.py", "msgidx": 10274}}
{"problem_description": "Sherlock Holmes has received a cryptic note from his nemesis, Moriarty, who claims to have infected a critical system with a virus. Moriarty provides a clue in the form of an integer, which Sherlock deduces is related to the length of a special number that can be used to neutralize the virus. This special number, known as a Decent Number, must follow specific rules: its digits can only be '3's and/or '5's, the number of '3's must be divisible by 5, and the number of '5's must be divisible by 3. Additionally, it must be the largest possible number of that length. Given the number of digits `n`, what is the largest Decent Number that can be formed, or should Sherlock conclude that it is impossible to form such a number?", "io_requirements": "Input:\n  `n` (int): The number of digits in the number to create.\n\nOutput:\n  `return` (str): The largest Decent Number having `n` digits, or \"-1\" if a decent number of that length cannot be formed. The Decent Number is represented as a string of '5's and '3's.", "refcode": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(n):\n    # Convert the input to an integer\n    n = int(n)\n    \n    if n < 3:\n        return \"-1\"\n    elif n % 3 == 0:\n        return \"5\" * n\n    else:\n        a = 5\n        b = n - 5\n        while b > 0:\n            if b % 3 == 0:\n                break\n            else:\n                a += 5\n                b -= 5\n        if b >= 0:\n            return \"5\" * b + \"3\" * a\n        else:\n            return \"-1\"", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": "555"}, {"input": {"n": 5}, "output": "33333"}, {"input": {"n": 13}, "output": "5553333333333"}, {"input": {"n": 17}, "output": "55555555555533333"}, {"input": {"n": 11}, "output": "55555533333"}, {"input": {"n": 1}, "output": "-1"}, {"input": {"n": 2}, "output": "-1"}, {"input": {"n": 19}, "output": "5555555553333333333"}, {"input": {"n": 8}, "output": "55533333"}, {"input": {"n": 10}, "output": "3333333333"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "amlan-dutta/Compititive-Programming", "path": "/cpp/Compititive series/2.Number_theory/sherlock.py", "msgidx": 10182}}
{"problem_description": "In a game involving marbles and multiple players, each player takes turns placing marbles in a circular arrangement. Certain rules apply when placing marbles, such as scoring points when a marble is placed in a specific position. Given the number of players and the total number of marbles, what is the highest score achieved by any player at the end of the game?", "io_requirements": "Input:\n  `num_players` (int): The number of players participating in the game.\n  `num_marbles` (int): The total number of marbles to be used in the game.\n\nOutput:\n  `return` (int): The maximum score achieved by any player after all marbles have been placed.", "refcode": "# import necessary packages\nfrom itertools import cycle\nfrom collections import deque\n\n# main function\ndef main_solution(num_players, num_marbles):\n  # Convert JSON serializable inputs to original input variables\n  available_marbles = [i for i in range(num_marbles, 0, -1)]\n  players = cycle([i for i in range(1, num_players + 1)])\n  players_scores = [0 for i in range(num_players)]\n  marbles_placed = deque([0])\n\n  for i in range(1, num_marbles + 1):\n      player = next(players)\n      if i % 23 == 0:\n          marbles_placed.rotate(7)\n          score = available_marbles.pop() + marbles_placed.pop()\n          players_scores[player - 1] += score\n          marbles_placed.rotate(-1)\n      else:\n          marbles_placed.rotate(-1)\n          marbles_placed.append(available_marbles.pop())\n\n  # Convert output to JSON serializable\n  return max(players_scores)", "funcname": "main_solution", "ios": [{"input": {"num_players": 604, "num_marbles": 2378}, "output": 3392}, {"input": {"num_players": 886, "num_marbles": 29818}, "output": 56138}, {"input": {"num_players": 128, "num_marbles": 99130}, "output": 2272894}, {"input": {"num_players": 47, "num_marbles": 35485}, "output": 794919}, {"input": {"num_players": 16, "num_marbles": 94581}, "output": 16061665}, {"input": {"num_players": 144, "num_marbles": 45449}, "output": 460219}, {"input": {"num_players": 915, "num_marbles": 6877}, "output": 9815}, {"input": {"num_players": 34, "num_marbles": 15686}, "output": 223022}, {"input": {"num_players": 329, "num_marbles": 66914}, "output": 453107}, {"input": {"num_players": 485, "num_marbles": 81606}, "output": 474448}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rayvoelker/adventofcode2018", "path": "/day9.py", "msgidx": 10070}}
{"problem_description": "Given a range of integers from `N` to `M`, what are the palindromic primes within this range?", "io_requirements": "Input:\n  `N` (int): The starting point of the range (inclusive).\n  `M` (int): The ending point of the range (inclusive).\n\nOutput:\n  `return` (list of int): A list of integers representing the palindromic primes found between `N` and `M` (inclusive).", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(num, fact=2):\n    if num == 2:\n        return True\n    if num > 1:\n        if fact < math.sqrt(num) + 1:\n            if num % fact == 0:\n                return False\n            else:\n                return is_prime(num, fact + 1)\n        else:\n            return True\n\ndef is_palindrome(pnum):\n    if len(pnum) <= 1:\n        return True\n    else:\n        if pnum[0] == pnum[-1]:\n            return is_palindrome(pnum[1:-1])\n        else:\n            return False\n\n# main function\ndef main_solution(N, M):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    palindromic_primes = []\n    for num in range(N, M + 1):\n        if is_prime(num) and is_palindrome(str(num)):\n            palindromic_primes.append(num)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return palindromic_primes", "funcname": "main_solution", "ios": [{"input": {"N": 3256, "M": 16035}, "output": [10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551]}, {"input": {"N": 4226, "M": 4865}, "output": []}, {"input": {"N": 7784, "M": 12682}, "output": [10301, 10501, 10601, 11311, 11411, 12421]}, {"input": {"N": 220, "M": 5966}, "output": [313, 353, 373, 383, 727, 757, 787, 797, 919, 929]}, {"input": {"N": 5490, "M": 12304}, "output": [10301, 10501, 10601, 11311, 11411]}, {"input": {"N": 9363, "M": 13705}, "output": [10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331]}, {"input": {"N": 8465, "M": 13223}, "output": [10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821]}, {"input": {"N": 2859, "M": 16653}, "output": [10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561]}, {"input": {"N": 7889, "M": 13455}, "output": [10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331]}, {"input": {"N": 8646, "M": 9449}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MrHamdulay/csc3-capstone", "path": "/examples/data/Assignment_8/prksel001/question4.py", "msgidx": 9985}}
{"problem_description": "In a game of Tic-Tac-Toe, given the current state of the board and the player whose turn it is, what is the optimal move that the player should make to maximize their chances of winning or minimizing their chances of losing?", "io_requirements": "Input:\n- `board_state` (list of lists of str): A 3x3 matrix representing the current state of the Tic-Tac-Toe board. Each cell can be 'X', 'O', or '.' (empty).\n- `turn` (int): Indicates whose turn it is. 1 for 'X' (maximizing player) and 0 for 'O' (minimizing player).\n\nOutput:\n- `result` (dict): A dictionary containing the best move and the resulting board state after the best move is made.\n  - `best_move` (tuple of int): The coordinates (row, column) of the best move.\n  - `new_board_state` (list of lists of str): The new state of the board after the best move is made.", "refcode": "import math\nfrom copy import deepcopy\n\nclass Board:\n    def __init__(self, board=[['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]):\n        self.board_state = board\n\n    def getValue(self):\n        board = self.board_state\n        winning = [\n            [board[0][0], board[0][1], board[0][2]],\n            [board[1][0], board[1][1], board[1][2]],\n            [board[2][0], board[2][1], board[2][2]],\n            [board[0][0], board[1][0], board[2][0]],\n            [board[0][1], board[1][1], board[2][1]],\n            [board[0][2], board[1][2], board[2][2]],\n            [board[0][0], board[1][1], board[2][2]],\n            [board[0][2], board[1][1], board[2][0]],\n        ]\n\n        if ['X', 'X', 'X'] in winning:\n            return 10\n        elif ['O', 'O', 'O'] in winning:\n            return -10\n        return 0\n\n    def isLeft(self):\n        board = self.board_state\n        for row in board:\n            for val in row:\n                if val == '.' or val == ' ':\n                    return True\n        return False\n\n    def nextMoves(self):\n        board = self.board_state\n        next_moves = []\n        for i, row in enumerate(board):\n            for j, val in enumerate(row):\n                if val == '.' or val == ' ':\n                    next_moves.append((i, j))\n        return next_moves\n\n    def isTerminal(self):\n        if self.getValue():\n            return True\n        if not self.isLeft():\n            return True\n        return False\n\nclass Game:\n    def __init__(self):\n        self.map = {1: 'X', 0: 'O'}\n\n    def max_value(self, board, alpha=-math.inf, beta=math.inf):\n        if board.isTerminal():\n            return board.getValue(), board\n\n        bestVal = -math.inf\n        bestBoard = None\n\n        for move in board.nextMoves():\n            newBoard_state = deepcopy(board.board_state)\n            newBoard_state[move[0]][move[1]] = 'X'\n            newBoard = Board(newBoard_state)\n            cost, res_board = self.min_value(newBoard, alpha, beta)\n\n            if bestVal < cost:\n                bestVal = cost\n                bestBoard = newBoard\n\n            alpha = max(alpha, bestVal)\n            if beta <= alpha:\n                break\n\n        return bestVal, bestBoard\n\n    def min_value(self, board, alpha=-math.inf, beta=math.inf):\n        if board.isTerminal():\n            return board.getValue(), board\n\n        bestVal = math.inf\n        bestBoard = None\n\n        for move in board.nextMoves():\n            newBoard_state = deepcopy(board.board_state)\n            newBoard_state[move[0]][move[1]] = 'O'\n            newBoard = Board(newBoard_state)\n            cost, res_board = self.max_value(newBoard, alpha, beta)\n\n            if bestVal > cost:\n                bestVal = cost\n                bestBoard = newBoard\n\n            beta = min(beta, bestVal)\n            if beta <= alpha:\n                break\n\n        return bestVal, bestBoard\n\n    def alpha_beta_search(self, turn, board):\n        if turn == 1:\n            result_board = self.max_value(deepcopy(board))\n        else:\n            result_board = self.min_value(deepcopy(board))\n        return result_board\n\ndef main_solution(board_state, turn):\n    \"\"\"\n    This function evaluates the current state of a Tic-Tac-Toe board and determines the best move for the given player using the Alpha-Beta pruning algorithm.\n\n    Input:\n    - board_state (list of lists of str): A 3x3 matrix representing the current state of the Tic-Tac-Toe board. Each cell can be 'X', 'O', or '.' (empty).\n    - turn (int): Indicates whose turn it is. 1 for 'X' (maximizing player) and 0 for 'O' (minimizing player).\n\n    Output:\n    - result (dict): A dictionary containing the best move and the resulting board state after the best move is made.\n        - 'best_move' (tuple of int): The coordinates (row, column) of the best move.\n        - 'new_board_state' (list of lists of str): The new state of the board after the best move is made.\n    \"\"\"\n    board = Board(board_state)\n    game = Game()\n    _, best_board = game.alpha_beta_search(turn, board)\n    best_move = None\n    for move in best_board.nextMoves():\n        if best_board.board_state[move[0]][move[1]] != board_state[move[0]][move[1]]:\n            best_move = move\n            break\n    return {\n        'best_move': best_move,\n        'new_board_state': best_board.board_state\n    }", "funcname": "main_solution", "ios": [{"input": {"board_state": [[".", ".", "O"], [".", ".", "."], ["X", "O", "."]], "turn": 0}, "output": {"best_move": null, "new_board_state": [["O", ".", "O"], [".", ".", "."], ["X", "O", "."]]}}, {"input": {"board_state": [[".", "X", "."], ["X", ".", "."], ["O", ".", "."]], "turn": 1}, "output": {"best_move": null, "new_board_state": [["X", "X", "."], ["X", ".", "."], ["O", ".", "."]]}}, {"input": {"board_state": [["X", "O", "."], [".", ".", "."], [".", "O", "."]], "turn": 0}, "output": {"best_move": null, "new_board_state": [["X", "O", "O"], [".", ".", "."], [".", "O", "."]]}}, {"input": {"board_state": [[".", ".", "O"], [".", "O", "O"], [".", ".", "X"]], "turn": 1}, "output": {"best_move": null, "new_board_state": [["X", ".", "O"], [".", "O", "O"], [".", ".", "X"]]}}, {"input": {"board_state": [[".", "X", "."], [".", "X", "."], [".", ".", "."]], "turn": 0}, "output": {"best_move": null, "new_board_state": [["O", "X", "."], [".", "X", "."], [".", ".", "."]]}}, {"input": {"board_state": [[".", "X", "."], [".", ".", "X"], [".", ".", "."]], "turn": 1}, "output": {"best_move": null, "new_board_state": [["X", "X", "."], [".", ".", "X"], [".", ".", "."]]}}, {"input": {"board_state": [["X", ".", "."], [".", ".", "X"], ["X", ".", "."]], "turn": 0}, "output": {"best_move": null, "new_board_state": [["X", "O", "."], [".", ".", "X"], ["X", ".", "."]]}}, {"input": {"board_state": [[".", ".", "."], [".", ".", "."], [".", ".", "."]], "turn": 0}, "output": {"best_move": null, "new_board_state": [["O", ".", "."], [".", ".", "."], [".", ".", "."]]}}, {"input": {"board_state": [[".", "X", "."], [".", ".", "."], [".", ".", "."]], "turn": 0}, "output": {"best_move": null, "new_board_state": [["O", "X", "."], [".", ".", "."], [".", ".", "."]]}}, {"input": {"board_state": [["O", ".", "."], [".", "O", "."], [".", ".", "O"]], "turn": 0}, "output": {"best_move": null, "new_board_state": [["O", ".", "."], [".", "O", "."], [".", ".", "O"]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Venkataraman-Nagarajan/Artificial-Intelligence", "path": "/EX7 - Tic-Tac-Toe (MinMax - Adversarial Search)/Tic-Tac-Toe.py", "msgidx": 9728}}
{"problem_description": "Given a hexagonal board with a specified radius, orientation, and size, what are the hex notations of all the hexagons on the board when converted to pixel coordinates and back to hex notation?", "io_requirements": "Input:\n  `radius` (int): The radius of the hexagonal board.\n  `orientation_name` (str): The name of the orientation ('pointy', 'flat', or 'flat_ascii').\n  `size_x` (float): The size of the hexagon in the x-direction.\n  `size_y` (float): The size of the hexagon in the y-direction.\n  `origin_x` (float): The x-coordinate of the origin.\n  `origin_y` (float): The y-coordinate of the origin.\n\nOutput:\n  `return` (list of str): A list of hex notations representing the hexagons in the board.", "refcode": "# import necessary packages\nimport math\nfrom collections import namedtuple\nfrom itertools import product\n\n# all class and function definitions in the code file, if any\nOrientation = namedtuple(\"Orientation\", [\"forward\", \"backward\", \"start_angle\"])\nLayout = namedtuple(\"Layout\", [\"orientation\", \"size\", \"origin\"])\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n\nORIENTATIONS = {\n    'pointy': Orientation(\n        forward=[math.sqrt(3.0), math.sqrt(3.0) / 2.0, 0.0, 3.0 / 2.0],\n        backward=[math.sqrt(3.0) / 3.0, -1.0 / 3.0, 0.0, 2.0 / 3.0],\n        start_angle=0.5\n    ),\n    'flat': Orientation(\n        forward=[3.0 / 2.0, 0.0, math.sqrt(3.0) / 2.0, math.sqrt(3.0)], \n        backward=[2.0 / 3.0, 0.0, -1.0 / 3.0, math.sqrt(3.0) / 3.0], \n        start_angle=0.0\n    ),\n    'flat_ascii': Orientation(\n        forward=[4, 0, 1, 2], \n        backward=[0, 0, 0, 0], # undefined \n        start_angle=0.0\n    )\n}\n\ndef get_radially_symmetric_hexagonal_board(radius): \n    return {Hex(*coords) for coords in product(range(-radius, radius+1), repeat=3) if sum(coords)==0}\n\nclass Hex():\n    def __repr__(self):\n        return self.notation\n    def __init__(self,x,y,z=None):\n        self.x = x\n        self.y = y\n        self.z = -x - y\n        if z is not None:\n            assert z == self.z\n    def __hash__(self):\n        return hash(self.axial)\n    def __eq__(self, compare_hex):\n        return self.x == compare_hex.x and self.y == compare_hex.y\n    def __add__(self, dv):\n        if isinstance(dv, Hex):\n            return Hex(self.x + dv.x, self.y + dv.y)\n        elif len(dv) == 2:\n            return Hex(self.x + dv[0],self.y + dv[1])\n    def __sub__(self, dv):\n        if isinstance(dv, Hex):\n            return Hex(self.x - dv.x, self.y - dv.y)\n        elif len(dv) == 2:\n            return Hex(self.x - dv[0],self.y - dv[1])\n    def hex(self):\n        return hex(self.x+5)[-1]+hex(self.y+5)[-1]\n    @classmethod\n    def from_hex(cls, hexstr):\n        return cls(int(hexstr[0],16)-5, int(hexstr[1],16)-5)\n    def to_pixel(self, layout):\n        x = (layout.orientation.forward[0] * self.x + layout.orientation.forward[1] * self.y) * layout.size.x\n        y = (layout.orientation.forward[2] * self.x + layout.orientation.forward[3] * self.y) * layout.size.y\n        return Point(x + layout.origin.x, y + layout.origin.y)\n    def round(self):\n        x, y, z = map(int, map(round, (self.x, self.y, self.z)))\n        x_diff, y_diff, z_diff = abs(x-self.x), abs(y-self.y), abs(z-self.z)\n        if x_diff>y_diff and x_diff>z_diff:\n            x = -y-z\n        elif y_diff > z_diff:\n            y = -x-z\n        else:\n            z = -x-y\n        return Hex(x,y,z)\n    @property\n    def axial(self):\n        return self.x, self.y\n    @property\n    def cube(self):\n        return self.x, self.y, self.z\n    @staticmethod\n    def from_pixel(point, layout):\n        x = (point.x-layout.origin.x)/layout.size.x\n        y = (point.y-layout.origin.y)/layout.size.y\n        x_ = layout.orientation.backward[0] * x + layout.orientation.backward[1] * y\n        y_ = layout.orientation.backward[2] * x + layout.orientation.backward[3] * y\n        return Hex(x_, y_).round()\n    def vertices(self, layout, offset=True):\n        angles = [(math.pi/3) * (layout.orientation.start_angle + i) for i in range(6)]\n        if offset:\n            x, y = self.to_pixel(layout)\n        else:\n            x = y = 0\n        vertices = [\n            Point(\n                round(x+layout.size.x*math.cos(angle)), \n                round(y+layout.size.y*math.sin(angle))\n            )\n            for angle in angles\n        ]\n        return vertices\n    def edges(self, layout):\n        vertices = self.vertices(layout)\n        vertices_ = vertices[1:] + [vertices[0]]\n        return zip(vertices, vertices_)\n    def rank(self, direction):\n        rank = -self.z if self.x*direction < 0 else self.y\n        rank = 6 - direction*rank\n        return rank\n    @property\n    def col(self):\n        x = self.x\n        if x>3: x+=1\n        return chr(102+x)\n    @property\n    def row(self):\n        return 12-self.rank(-1)\n    @property\n    def notation(self):\n        return f\"{self.col}{self.row}\"\n    @classmethod\n    def from_notation(cls, notation):\n        col, row = notation\n        x = ord(col)-102\n        if x > 3: x -= 1\n        rank = 6-int(row)\n        y = rank-x if x>0 else rank\n        hex = cls(x, y)\n        assert hex.notation == notation\n        return hex\n\n# main function\ndef main_solution(radius, orientation_name, size_x, size_y, origin_x, origin_y):\n    # Convert JSON serializable inputs to original input variables\n    layout = Layout(ORIENTATIONS[orientation_name], Point(size_x, size_y), Point(origin_x, origin_y))\n    \n    # Get the radially symmetric hexagonal board\n    board = get_radially_symmetric_hexagonal_board(radius)\n    \n    # Convert each hex to pixel coordinates\n    pixel_coordinates = [hex.to_pixel(layout) for hex in board]\n    \n    # Convert pixel coordinates back to hex notation\n    hex_notations = [Hex.from_pixel(point, layout).notation for point in pixel_coordinates]\n    \n    # Return the hex notations as a list of strings\n    return hex_notations", "funcname": "main_solution", "ios": [{"input": {"radius": 1, "orientation_name": "flat_ascii", "size_x": 5.03, "size_y": 9.0, "origin_x": 8.04, "origin_y": 6.48}, "output": ["f6", "f6", "f6", "f6", "f6", "f6", "f6"]}, {"input": {"radius": 1, "orientation_name": "flat", "size_x": 3.56, "size_y": 9.35, "origin_x": -5.05, "origin_y": -0.95}, "output": ["f5", "f6", "e5", "g6", "e6", "g5", "f7"]}, {"input": {"radius": 1, "orientation_name": "flat_ascii", "size_x": 5.36, "size_y": 6.55, "origin_x": -4.89, "origin_y": 9.94}, "output": ["f6", "f6", "f6", "f6", "f6", "f6", "f6"]}, {"input": {"radius": 1, "orientation_name": "flat_ascii", "size_x": 2.43, "size_y": 1.69, "origin_x": -8.98, "origin_y": -3.22}, "output": ["f6", "f6", "f6", "f6", "f6", "f6", "f6"]}, {"input": {"radius": 1, "orientation_name": "pointy", "size_x": 6.74, "size_y": 8.13, "origin_x": -4.38, "origin_y": -3.34}, "output": ["f5", "f6", "e5", "g6", "e6", "g5", "f7"]}, {"input": {"radius": 1, "orientation_name": "flat_ascii", "size_x": 1.24, "size_y": 7.8, "origin_x": 1.78, "origin_y": 7.13}, "output": ["f6", "f6", "f6", "f6", "f6", "f6", "f6"]}, {"input": {"radius": 1, "orientation_name": "flat_ascii", "size_x": 1.08, "size_y": 3.73, "origin_x": 1.5, "origin_y": -2.44}, "output": ["f6", "f6", "f6", "f6", "f6", "f6", "f6"]}, {"input": {"radius": 1, "orientation_name": "flat", "size_x": 1.02, "size_y": 3.99, "origin_x": -1.25, "origin_y": -7.56}, "output": ["f5", "f6", "e5", "g6", "e6", "g5", "f7"]}, {"input": {"radius": 1, "orientation_name": "flat_ascii", "size_x": 5.5, "size_y": 8.61, "origin_x": 6.47, "origin_y": -1.73}, "output": ["f6", "f6", "f6", "f6", "f6", "f6", "f6"]}, {"input": {"radius": 1, "orientation_name": "flat", "size_x": 7.71, "size_y": 7.9, "origin_x": -4.79, "origin_y": -0.16}, "output": ["f5", "f6", "e5", "g6", "e6", "g5", "f7"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jselvan/HexChess", "path": "/HexChess/hex.py", "msgidx": 9739}}
{"problem_description": "Given a list of integers, what is the maximum sum of any subset that does not contain consecutive elements from the original list?", "io_requirements": "Input:\n  `lista` (list of integers): A list of integers from which subsets will be generated and processed.\n\nOutput:\n  `return` (integer): The maximum sum of the subsets that do not contain consecutive elements from the original list.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(lista):\n    # Generate all subsets of the input list\n    subsets = []\n    for i in range(len(lista) + 1):\n        for subset in itertools.combinations(lista, i):\n            subsets.append(subset)\n\n    # Remove subsets that contain consecutive elements from the original list\n    removeElements = []\n    for k in range(len(subsets)):\n        count = 0\n        for i in range(len(lista)):\n            for j in range(len(subsets[k])):\n                if len(lista) <= i + j:\n                    break\n                if subsets[k][j] != lista[i + j]:\n                    count = 0\n                else:\n                    count += 1\n                if count == 2:\n                    removeElements.append(k)\n                    break\n            if count == 2:\n                break\n\n    removeElements = sorted(set(removeElements))\n    for i in range(len(removeElements)):\n        subsets.pop(removeElements[i] - i)\n\n    # Calculate the sum of each subset and find the maximum sum\n    maximos = [sum(elemento) for elemento in subsets]\n    return max(maximos)", "funcname": "main_solution", "ios": [{"input": {"lista": [25, 92, 55, 89, 57, 55, 69, 42, 18, 38]}, "output": 316}, {"input": {"lista": [95, 85, 96, 81, 19, 82, 5, 8, 58]}, "output": 331}, {"input": {"lista": [65, 49, 46, 45, 32, 27, 26]}, "output": 169}, {"input": {"lista": [34, 53, 35, 44, 70, 49, 5]}, "output": 146}, {"input": {"lista": [92, 91, 47, 91, 58, 63]}, "output": 245}, {"input": {"lista": [8, 100, 72, 70, 28]}, "output": 170}, {"input": {"lista": [89, 12, 38, 46, 18]}, "output": 145}, {"input": {"lista": [21, 49, 43, 2, 92, 21, 99, 28, 8, 92]}, "output": 347}, {"input": {"lista": [43, 25, 73, 36, 67, 37, 46]}, "output": 229}, {"input": {"lista": [35, 52, 3, 44, 63, 7, 82, 81, 35]}, "output": 232}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "fernote7/old_scripts", "path": "/Project1 NUPEI/puzzle.py", "msgidx": 10242}}
{"problem_description": "Given a string consisting of uppercase letters, what are all the possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    arr = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = [''.join(p) for p in itertools.permutations(arr)]\n    \n    # Return the list of permutations as a JSON serializable output\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "UMH"}, "output": ["UMH", "UHM", "MUH", "MHU", "HUM", "HMU"]}, {"input": {"input_string": "WUT"}, "output": ["WUT", "WTU", "UWT", "UTW", "TWU", "TUW"]}, {"input": {"input_string": "RDT"}, "output": ["RDT", "RTD", "DRT", "DTR", "TRD", "TDR"]}, {"input": {"input_string": "DQS"}, "output": ["DQS", "DSQ", "QDS", "QSD", "SDQ", "SQD"]}, {"input": {"input_string": "GGE"}, "output": ["GGE", "GEG", "GGE", "GEG", "EGG", "EGG"]}, {"input": {"input_string": "XSM"}, "output": ["XSM", "XMS", "SXM", "SMX", "MXS", "MSX"]}, {"input": {"input_string": "JLJ"}, "output": ["JLJ", "JJL", "LJJ", "LJJ", "JJL", "JLJ"]}, {"input": {"input_string": "RJQ"}, "output": ["RJQ", "RQJ", "JRQ", "JQR", "QRJ", "QJR"]}, {"input": {"input_string": "HPR"}, "output": ["HPR", "HRP", "PHR", "PRH", "RHP", "RPH"]}, {"input": {"input_string": "PUZ"}, "output": ["PUZ", "PZU", "UPZ", "UZP", "ZPU", "ZUP"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "piyushiitg/InterviewQuestions", "path": "/strings/permute.py", "msgidx": 10426}}
{"problem_description": "Given a set of rules describing which bags can contain other bags, how many distinct bag colors can eventually contain a specific target bag color?", "io_requirements": "Input:\n- `rules` (list of str): A list of strings where each string represents a rule about which bags can contain other bags. Each string follows the format \"color1 bags contain n color2 bags, m color3 bags, ...\".\n- `bag_color` (str): A string representing the target bag color to find the possible enclosing bags for. The string should be a valid color name without any special characters or numbers.\n\nOutput:\n- `return` (int): The number of distinct bag colors that can contain the target bag color.", "refcode": "# import necessary packages\nimport collections\nimport re\n\n# main function\ndef main_solution(rules, bag_color):\n    \"\"\"\n    Given a list of rules and a target bag color, this function returns the number of distinct bag colors that can eventually contain the target bag color.\n    \n    Parameters:\n    - rules (list of str): A list of strings where each string represents a rule about which bags can contain other bags.\n    - bag_color (str): The target bag color to find the possible enclosing bags for.\n    \n    Returns:\n    - int: The number of distinct bag colors that can contain the target bag color.\n    \"\"\"\n    def parse_rule(rule):\n        \"\"\" Helper function to parse a single rule and return the bag color and its contents. \"\"\"\n        colors = RE_FIND_COLORS.findall(rule)\n        return colors[0], colors[1:]\n\n    def parse_rules(rules):\n        \"\"\" Helper function to parse all rules and return a dictionary of productions. \"\"\"\n        return dict(map(parse_rule, rules))\n\n    def decant(dictionary):\n        \"\"\" Helper function to invert the dictionary so that the list members are now keys. \"\"\"\n        accumulator = collections.defaultdict(list)\n        for key, values in dictionary.items():\n            for value in values:\n                accumulator[value].append(key)\n        return dict(accumulator)\n\n    def recurse_sources(visited, paths, bag_color):\n        \"\"\" Helper function to recursively find all enclosing bags for a given bag color. \"\"\"\n        for enclosing_bag in paths.get(bag_color, []):\n            if enclosing_bag not in visited:\n                visited.add(enclosing_bag)\n                recurse_sources(visited, paths, enclosing_bag)\n\n    # Parse the rules and invert the dictionary\n    paths = decant(parse_rules(rules))\n    sources = set()\n    # Recursively find all enclosing bags for the target bag color\n    recurse_sources(sources, paths, bag_color)\n    # Return the number of distinct enclosing bag colors\n    return len(sources)\n\n# Regular expression to find bag colors in the rules\nRE_FIND_COLORS = re.compile('(?:^|\\d\\s)([\\w ]+?)\\sbags?')", "funcname": "main_solution", "ios": [{"input": {"rules": ["blue bags contain 5 green bag, 3 purple bags, 2 green bags.", "purple bags contain 4 purple bag.", "black bags contain 3 orange bag.", "white bags contain 3 white bag, 5 yellow bags, 2 yellow bags.", "green bags contain 1 purple bag, 4 blue bags."], "bag_color": "red"}, "output": 0}, {"input": {"rules": ["orange bags contain 3 white bag.", "orange bags contain no other bags.", "orange bags contain 4 blue bag, 2 yellow bags, 5 blue bags.", "purple bags contain 2 yellow bag, 3 purple bags, 2 purple bags.", "blue bags contain 5 purple bag, 4 yellow bags, 1 blue bags."], "bag_color": "purple"}, "output": 3}, {"input": {"rules": ["green bags contain 4 black bag, 2 orange bags.", "orange bags contain 1 black bag.", "yellow bags contain 3 yellow bag.", "red bags contain 4 white bag, 1 yellow bags.", "green bags contain 2 orange bag, 4 blue bags."], "bag_color": "blue"}, "output": 1}, {"input": {"rules": ["purple bags contain 5 blue bag, 4 white bags.", "green bags contain 3 black bag.", "black bags contain 5 purple bag, 5 green bags.", "purple bags contain 5 black bag.", "yellow bags contain no other bags."], "bag_color": "purple"}, "output": 3}, {"input": {"rules": ["white bags contain 5 yellow bag.", "green bags contain no other bags.", "purple bags contain no other bags.", "orange bags contain 4 blue bag.", "blue bags contain no other bags.", "black bags contain no other bags."], "bag_color": "red"}, "output": 0}, {"input": {"rules": ["black bags contain 5 purple bag, 1 yellow bags.", "yellow bags contain 1 white bag.", "red bags contain no other bags.", "yellow bags contain no other bags.", "black bags contain 2 white bag, 1 green bags.", "blue bags contain 3 red bag."], "bag_color": "black"}, "output": 0}, {"input": {"rules": ["orange bags contain 3 white bag, 1 red bags, 3 black bags.", "white bags contain 5 blue bag, 3 black bags.", "white bags contain no other bags.", "blue bags contain 3 green bag.", "yellow bags contain 4 black bag."], "bag_color": "purple"}, "output": 0}, {"input": {"rules": ["purple bags contain 1 purple bag, 3 yellow bags, 4 white bags.", "white bags contain 4 orange bag, 5 yellow bags, 4 orange bags.", "red bags contain 5 purple bag.", "yellow bags contain 2 purple bag.", "blue bags contain 2 white bag."], "bag_color": "blue"}, "output": 0}, {"input": {"rules": ["white bags contain 1 blue bag, 2 black bags, 3 red bags.", "yellow bags contain 1 orange bag.", "blue bags contain 4 white bag, 1 black bags, 4 white bags.", "blue bags contain no other bags.", "green bags contain 1 blue bag."], "bag_color": "purple"}, "output": 0}, {"input": {"rules": ["red bags contain 2 black bag.", "black bags contain no other bags.", "yellow bags contain 4 purple bag.", "purple bags contain 4 red bag.", "orange bags contain 4 green bag."], "bag_color": "blue"}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sweavo/code-advent-2020", "path": "/day7_1.py", "msgidx": 10278}}
{"problem_description": "Given a number N, which represents the size of an array, how can we generate a \"beautiful\" array of size N where for each i < j, there is no k satisfying i < k < j such that A[k] * 2 = A[i] + A[j]?", "io_requirements": "Input:\n  `N` (int): An integer representing the size of the array to be generated. It should be between 1 and 1000.\n\nOutput:\n  `return` (List[int]): A list of integers representing the \"beautiful\" array of size N. The list is a permutation of integers from 1 to N such that for each i < j, there is no k satisfying i < k < j where A[k] * 2 = A[i] + A[j].", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def beautifulArray(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: List[int]\n        \"\"\"\n        if N == 1:\n            return [1]\n        else:\n            l = self.beautifulArray(N//2)\n            r = self.beautifulArray(N-N//2)\n            return [x*2 for x in l] + [x*2-1 for x in r]\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.beautifulArray(N)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"N": 15}, "output": [8, 12, 4, 14, 6, 10, 2, 15, 7, 11, 3, 13, 5, 9, 1]}, {"input": {"N": 4}, "output": [4, 2, 3, 1]}, {"input": {"N": 11}, "output": [8, 4, 6, 10, 2, 7, 11, 3, 5, 9, 1]}, {"input": {"N": 7}, "output": [4, 6, 2, 7, 3, 5, 1]}, {"input": {"N": 8}, "output": [8, 4, 6, 2, 7, 3, 5, 1]}, {"input": {"N": 17}, "output": [16, 8, 12, 4, 14, 6, 10, 2, 15, 7, 11, 3, 13, 5, 9, 17, 1]}, {"input": {"N": 16}, "output": [16, 8, 12, 4, 14, 6, 10, 2, 15, 7, 11, 3, 13, 5, 9, 1]}, {"input": {"N": 9}, "output": [8, 4, 6, 2, 7, 3, 5, 9, 1]}, {"input": {"N": 12}, "output": [8, 12, 4, 6, 10, 2, 7, 11, 3, 5, 9, 1]}, {"input": {"N": 19}, "output": [16, 8, 12, 4, 14, 6, 10, 18, 2, 15, 7, 11, 19, 3, 13, 5, 9, 17, 1]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Gackle/leetcode_practice", "path": "/932.py", "msgidx": 10502}}
{"problem_description": "Given a range of numbers, what is the sum of all numbers within this range that are palindromic in both base 10 and base 2? The range should be defined by an upper limit.", "io_requirements": "Input:\n  `limit` (int): The upper limit for the range of numbers to check for double base palindromes.\n\nOutput:\n  `return` (int): The sum of all numbers below the given limit that are palindromic in both base 10 and base 2.", "refcode": "# import necessary packages\nfrom time import time\n\n# all class and function definitions in the code file, if any\ndef convert_to_bin(num):\n    return \"{0:b}\".format(num)\n\ndef is_palindrome(num):\n    word = str(num)\n    return word == word[::-1]\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    double_base_palindromes = []\n\n    for i in range(limit):\n        if is_palindrome(i) and is_palindrome(convert_to_bin(i)):\n            double_base_palindromes.append(i)\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(double_base_palindromes)", "funcname": "main_solution", "ios": [{"input": {"limit": 968244}, "output": 872187}, {"input": {"limit": 455300}, "output": 286602}, {"input": {"limit": 480795}, "output": 286602}, {"input": {"limit": 975294}, "output": 872187}, {"input": {"limit": 25860}, "output": 33579}, {"input": {"limit": 849166}, "output": 872187}, {"input": {"limit": 797835}, "output": 872187}, {"input": {"limit": 500040}, "output": 286602}, {"input": {"limit": 635249}, "output": 872187}, {"input": {"limit": 494488}, "output": 286602}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "benjamin22-314/Project-Euler-in-Python", "path": "/p36.py", "msgidx": 10266}}
{"problem_description": "Given a range of digits, what is the largest prime number that can be formed by permuting the digits within that range?", "io_requirements": "Input:\n  `start_range` (int): The starting number of the range (inclusive) from which permutations are generated.\n  `end_range` (int): The ending number of the range (inclusive) from which permutations are generated.\n\nOutput:\n  `return` (int or None): The largest prime number found by permuting the digits within the specified range. If no prime number is found, it returns `None`.", "refcode": "# import necessary packages\nfrom itertools import permutations\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)), 2):\n        if n % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(start_range, end_range):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    largest_prime = None\n    for p in permutations(range(end_range, start_range - 1, -1)):\n        n = int(''.join(map(str, p)))\n        if is_prime(n):\n            largest_prime = n\n            break\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return largest_prime", "funcname": "main_solution", "ios": [{"input": {"start_range": 5, "end_range": 9}, "output": 96857}, {"input": {"start_range": 5, "end_range": 8}, "output": 6857}, {"input": {"start_range": 3, "end_range": 7}, "output": 76543}, {"input": {"start_range": 2, "end_range": 6}, "output": 65423}, {"input": {"start_range": 1, "end_range": 4}, "output": 4231}, {"input": {"start_range": 2, "end_range": 8}, "output": 8765423}, {"input": {"start_range": 4, "end_range": 7}, "output": 6547}, {"input": {"start_range": 2, "end_range": 3}, "output": 23}, {"input": {"start_range": 3, "end_range": 4}, "output": 43}, {"input": {"start_range": 2, "end_range": 5}, "output": 4523}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cfwalter/euler", "path": "/041.py", "msgidx": 10534}}
{"problem_description": "Given a set of `n` elements, where `n` is an even number, how many distinct ways can the elements be paired?", "io_requirements": "Input:\n  `n` (int): The number of elements to be paired. Must be an even number.\n\nOutput:\n  `return` (int): The number of possible pairings of the elements.", "refcode": "# import necessary packages\nfrom math import factorial\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    \n    # Function to generate pairings iteratively\n    def pairings_iterative(n):\n        remaining = set(range(n))\n        paired = []\n        len_prev_stack = 0\n        stack = [0]\n        while stack:\n            i = stack[-1]\n            pushing = len_prev_stack < len(stack)\n            len_prev_stack = len(stack)\n            if pushing:\n                if i == n:\n                    assert len(paired)*2 == n\n                    stack.pop()\n                    yield paired[:]\n                    continue\n                for j in range(0, n):\n                    if i!=j and j in remaining:\n                        remaining.remove(i)\n                        remaining.remove(j)\n                        paired.append((i,j))\n                        while i not in remaining and i < n:\n                            i += 1\n                        stack.append(i)\n                        break\n            else:\n                assert paired[-1][0] == i\n                j = paired.pop()[1]\n                assert j not in remaining\n                remaining.add(j)\n                for j in range(j+1, n):\n                    if j!=i and j in remaining:\n                        remaining.remove(j)\n                        paired.append((i,j))\n                        while i not in remaining and i < n:\n                            i += 1\n                        stack.append(i)\n                        break\n                else:\n                    remaining.add(i)\n                    stack.pop()\n    \n    # Generate all pairings\n    pairings_list = list(pairings_iterative(n))\n    \n    # Return the number of pairings\n    return len(pairings_list)", "funcname": "main_solution", "ios": [{"input": {"n": 6}, "output": 15}, {"input": {"n": 4}, "output": 3}, {"input": {"n": 10}, "output": 945}, {"input": {"n": 8}, "output": 105}, {"input": {"n": 2}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "andres-erbsen/rooming", "path": "/pairings.py", "msgidx": 10311}}
{"problem_description": "Imagine you have a whole cake with strawberries on top. You want to cut the cake into `n` pieces such that each piece has a unique number of strawberries from 1 to `n`. Additionally, the sum of the strawberries on any two adjacent pieces must be a perfect square. What is the smallest number of pieces `n` for which such a cutting arrangement is possible?", "io_requirements": "Input:\n  `n` (int): The number of pieces to cut the cake into. This number should be greater than 0.\n\nOutput:\n  `return` (dict): A dictionary with two keys:\n    - `valid_sequence` (bool): Indicates whether a valid sequence of strawberry counts was found that satisfies the conditions.\n    - `min_n` (int or None): The smallest number of pieces that can be cut such that each piece has a unique number of strawberries and the sum of strawberries on adjacent pieces is a perfect square. If no valid sequence is found, this value is `None`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef check(n, sequence, square_list):\n    if len(sequence) == n:\n        if sequence[0] + sequence[-1] in square_list:\n            return True\n    else:\n        tail = sequence[-1]\n        for num in range(1, n + 1):\n            if (num not in sequence) and (tail + num in square_list):\n                if check(n, sequence + [num], square_list):\n                    return True\n        return False\n\n# main function\ndef main_solution(n):\n    # Convert input to the required format\n    n = int(n)\n    \n    # Generate the list of squares up to n^2\n    squares = [i * i for i in range(1, int(math.sqrt(2 * n - 1)) + 1)]\n    \n    # Check if a valid sequence can be formed\n    for num in range(1, n + 1):\n        if check(n, [num], squares):\n            return {\"valid_sequence\": True, \"min_n\": n}\n    \n    return {\"valid_sequence\": False, \"min_n\": None}", "funcname": "main_solution", "ios": [{"input": {"n": 15}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 7}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 17}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 1}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 14}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 11}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 9}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 5}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 13}, "output": {"valid_sequence": false, "min_n": null}}, {"input": {"n": 12}, "output": {"valid_sequence": false, "min_n": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "takecap/70puzzles", "path": "/src/q18.py", "msgidx": 10576}}
{"problem_description": "Given a range of numbers up to a certain limit, we are interested in identifying prime numbers that possess specific interesting properties. Specifically, we want to find prime numbers that are \"lucky\", \"palindromic\", or \"semiprime\". What are the prime numbers up to a given limit that satisfy all the specified properties?", "io_requirements": "Input:\n  `n` (int): The upper limit for generating prime numbers. Must be a positive integer.\n  `filters` (list of str): A list of strings representing the names of filter functions to apply to the prime numbers. Valid filter names are: `is_lucky`, `is_palindrome`, `is_semiprime_v2`.\n\nOutput:\n  `return` (list of int): A list of prime numbers that satisfy all the specified filters.", "refcode": "# import necessary packages\nfrom functools import reduce\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef is_prime(number):\n    for i in range(2, int(sqrt(number)) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef get_prime_numbers(n):\n    prime_numbers = []\n    for number in range(2, n+1):\n        if is_prime(number):\n            prime_numbers.append(number)\n    return prime_numbers\n\ndef is_lucky(number):\n    number = str(number)\n    if len(number) < 2:\n        return False\n    left_half = number[:len(number) // 2]\n    right_half = number[-(len(number) // 2):]\n    left_sum = sum([int(digit) for digit in left_half])\n    right_sum = sum([int(digit) for digit in right_half])\n    return left_sum == right_sum\n\ndef is_palindrome(number):\n    return str(number) == str(number)[::-1]\n\ndef is_semiprime_v2(number):\n    factors_count = 0\n    for i in range(2, int(sqrt(number)) + 1):\n        while number % i == 0:\n            number /= i\n            factors_count += 1\n        if factors_count >= 2:\n            break\n    if number > 1:\n        factors_count += 1\n    return factors_count == 2\n\n# main function\ndef main_solution(n, filters):\n    # Convert filters from JSON serializable format to original format\n    filter_funcs = [globals()[filter_name] for filter_name in filters]\n    \n    # Get prime numbers up to n\n    prime_numbers = get_prime_numbers(n)\n    \n    # Apply filters to prime numbers\n    filtered_primes = [num for num in prime_numbers if all(filter_func(num) for filter_func in filter_funcs)]\n    \n    # Return the result as a list of integers\n    return filtered_primes", "funcname": "main_solution", "ios": [{"input": {"n": 581, "filters": ["is_lucky"]}, "output": [11, 101, 131, 151, 181, 191, 313, 353, 373, 383]}, {"input": {"n": 609, "filters": ["is_palindrome", "is_lucky"]}, "output": [11, 101, 131, 151, 181, 191, 313, 353, 373, 383]}, {"input": {"n": 374, "filters": ["is_palindrome", "is_semiprime_v2", "is_lucky"]}, "output": []}, {"input": {"n": 144, "filters": ["is_lucky", "is_semiprime_v2", "is_palindrome"]}, "output": []}, {"input": {"n": 286, "filters": ["is_palindrome"]}, "output": [2, 3, 5, 7, 11, 101, 131, 151, 181, 191]}, {"input": {"n": 811, "filters": ["is_palindrome", "is_semiprime_v2", "is_lucky"]}, "output": []}, {"input": {"n": 263, "filters": ["is_semiprime_v2", "is_lucky", "is_palindrome"]}, "output": []}, {"input": {"n": 827, "filters": ["is_palindrome", "is_lucky", "is_semiprime_v2"]}, "output": []}, {"input": {"n": 906, "filters": ["is_semiprime_v2", "is_lucky"]}, "output": []}, {"input": {"n": 740, "filters": ["is_lucky", "is_semiprime_v2"]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "glotyuids/skillbox_learning", "path": "/lesson_011/02_prime_numbers.py", "msgidx": 10620}}
{"problem_description": "In an election using the Instant Runoff Voting system, each voter ranks their preferred candidates in order of preference. Given the preferences of several voters, which candidate will emerge as the winner according to the rules of the Instant Runoff Voting algorithm?", "io_requirements": "Input:\n  `voters` (list of lists): Each sublist represents a voter's preferences, with candidates ordered by preference. Each candidate is represented by a single character string.\n\nOutput:\n  `return` (str): The symbol corresponding to the winning candidate. If there is no winner, returns `None`.", "refcode": "# import necessary packages\nfrom collections import defaultdict, Counter\n\n# main function\ndef main_solution(voters):\n    \"\"\"\n    Calculates the winner of an election using the Instant Runoff Voting algorithm.\n\n    Args:\n    voters (list of lists): Each sublist represents a voter's preferences, with candidates ordered by preference.\n\n    Returns:\n    str: The symbol corresponding to the winning candidate. If there is no winner, returns None.\n    \"\"\"\n    votes_cast_so_far = 0\n    final_tally = Counter()\n    removed_candidates = set()\n    \n    for this_round in range(len(voters[0])):\n        this_round_votes = [voter[this_round] for voter in voters if voter[this_round] not in removed_candidates]\n        if not this_round_votes:\n            return None\n        tally = Counter(this_round_votes)\n        final_tally.update(tally)\n        votes_cast_so_far += sum(final_tally.values())\n        leader = final_tally.most_common(1)\n        if leader and final_tally[leader[0][0]] >= votes_cast_so_far / 2.0:\n            return leader[0][0]\n        lowest_vote = min(tally.values())\n        knockout_candidates = [candidate for candidate in tally if tally[candidate] == lowest_vote]\n        removed_candidates |= set(knockout_candidates)\n    \n    return None", "funcname": "main_solution", "ios": [{"input": {"voters": [["c", "a", "b"], ["a", "c", "b"], ["a", "c", "b"], ["a", "c", "b"], ["a", "c", "b"]]}, "output": "a"}, {"input": {"voters": [["c", "a", "b"], ["c", "a", "b"], ["b", "a", "c"], ["c", "a", "b"], ["c", "a", "b"]]}, "output": "c"}, {"input": {"voters": [["b", "c", "a"], ["b", "a", "c"], ["c", "a", "b"], ["c", "b", "a"], ["c", "a", "b"]]}, "output": "c"}, {"input": {"voters": [["b", "a", "c"], ["c", "b", "a"], ["b", "c", "a"], ["b", "c", "a"], ["c", "a", "b"]]}, "output": "b"}, {"input": {"voters": [["b", "a", "c"], ["a", "c", "b"], ["b", "c", "a"], ["b", "c", "a"], ["a", "c", "b"]]}, "output": "b"}, {"input": {"voters": [["b", "a", "c"], ["c", "a", "b"], ["b", "c", "a"], ["c", "b", "a"], ["c", "b", "a"], ["a", "c", "b"]]}, "output": "c"}, {"input": {"voters": [["a", "c", "b"], ["a", "b", "c"], ["b", "a", "c"], ["a", "b", "c"], ["c", "a", "b"]]}, "output": "a"}, {"input": {"voters": [["b", "c", "a"], ["b", "c", "a"], ["a", "c", "b"], ["b", "c", "a"], ["a", "c", "b"], ["c", "b", "a"]]}, "output": "b"}, {"input": {"voters": [["a", "c", "b"], ["b", "c", "a"], ["b", "a", "c"], ["a", "b", "c"], ["b", "c", "a"]]}, "output": "b"}, {"input": {"voters": [["c", "a", "b"], ["b", "a", "c"], ["b", "c", "a"], ["a", "b", "c"], ["b", "c", "a"]]}, "output": "b"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "julzhk/codekata", "path": "/instant_runoff_voting.py", "msgidx": 9899}}
{"problem_description": "Given a message containing letters, spaces, and special characters, how can we encode it using a clockwise spiral pattern within a square grid? Specifically, what will be the encoded message when the characters are placed in the corner cells of a square and moved in a clockwise direction, filling the outer cells first and then continuing for the remaining inner squares?", "io_requirements": "Input:\n  `message` (str): The message to be encoded using the clockwise cipher. It can contain spaces and special characters.\n\nOutput:\n  `return` (str): The encoded message in a single string, where characters are arranged in a clockwise spiral pattern within a square grid.", "refcode": "# import necessary packages\nimport math\n\n# recursive function to find clockwise coordinates of any index given the square size\ndef clockwise_pos(i, size, depth=0):\n    if size == 1:\n        return [depth, depth]  # base case (reached only with odd sizes)\n    elif i >= size**2 - (size-2)**2:\n        # keep moving to a smaller square until i will fall within its outer edge\n        return clockwise_pos(i-(size**2 - (size-2)**2), size-2, depth+1)\n    else:\n        # determine coordinates based on group, translate based on distance from corner\n        if i % 4 == 0:\n            coord = [0, 0 + i//4]\n        elif (i-1) % 4 == 0:\n            coord = [0 + i//4, size-1]\n        elif (i-2) % 4 == 0:\n            coord = [size-1, size-1 - i//4]\n        elif (i-3) % 4 == 0:\n            coord = [size-1 - i//4, 0]\n        # add depth to account for previous layers\n        coord[0] += depth\n        coord[1] += depth\n        return coord\n\n# main function\ndef main_solution(message):\n    # determine minimum size that will contain message\n    size = math.ceil(len(message)**0.5)\n    \n    # generate square\n    square = []\n    for y in range(size):\n        square.append([])\n        for x in range(size):\n            square[y].append(\" \")\n    # fill square using clockwise coordinates\n    for i in range(len(message)):\n        coord = clockwise_pos(i, size)\n        square[coord[0]][coord[1]] = message[i]\n    \n    # combine square to form encrypted message\n    encrypted_message = \"\"\n    for line in square:\n        for char in line:\n            encrypted_message += char\n    return encrypted_message", "funcname": "main_solution", "ios": [{"input": {"message": "wf_2M|U"}, "output": "wMf  |2U_"}, {"input": {"message": ":jQ\\^uTFRDs/k2i"}, "output": ":^Rj/k2uF iD\\sTQ"}, {"input": {"message": "DYmJc@?QnyWluQ"}, "output": "DcnYluQ@Q  yJW?m"}, {"input": {"message": "<sX-sr[\"SYRU\"yEBS,M"}, "output": "<sS\"sBS ,rU   Y\"  My-ER[X"}, {"input": {"message": "LS&G^j|IIDu$`-`=}*>"}, "output": "L^I`S=} *j$   DI  >-G`u|&"}, {"input": {"message": "l4vX](7Q+a"}, "output": "l]+4   (Q  aX 7v"}, {"input": {"message": ")G<Ek"}, "output": ")kG   E <"}, {"input": {"message": "a5i`jXS\\"}, "output": "aj5\\ X`Si"}, {"input": {"message": "4rJ_N+6"}, "output": "4Nr  +_6J"}, {"input": {"message": "}qU)j!>_db!@{"}, "output": "}jdq@{ !_  b)!>U"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/WBsxNXnqeFr4es9oh_7.py", "msgidx": 10526}}
{"problem_description": "Given a list of integers, how can we identify and separate the numbers that have exactly `k` proper divisors from those that are prime numbers? Specifically, what are the lists of numbers with exactly `k` proper divisors and the prime numbers from the given list `ls`?", "io_requirements": "Input:\n  `ls` (list of integers): A list of integers for which we need to find numbers with exactly `k` proper divisors and prime numbers.\n  `k` (integer): An integer representing the number of proper divisors that numbers in `ls` should have to remain in the list.\n\nOutput:\n  `return` (dictionary): A dictionary containing two keys:\n    - `ls` (list of integers): The updated list of integers from the input list `ls` that have exactly `k` proper divisors.\n    - `lista_primi` (list of integers): A list of integers from the input list `ls` that are prime numbers.", "refcode": "# import necessary packages\nfrom math import sqrt\n\n# main function\ndef main_solution(ls, k):\n    # Convert input to appropriate types if necessary\n    ls = list(ls)  # Ensure ls is a list of integers\n    k = int(k)     # Ensure k is an integer\n    \n    # Call the modi function to get the results\n    lista_primi = modi(ls, k)\n    \n    # Convert the results to JSON serializable format\n    return {\"ls\": ls, \"lista_primi\": lista_primi}\n\n# Function definition from the provided code file\ndef modi(ls, k):\n    lista_primi = []\n    fattore = 0\n    for num in range(len(ls) - 1, -1, -1):\n        fattore = 0\n        for i in range(2, int(sqrt(int(ls[num]))) + 1):\n            if int(ls[num]) % int(i) == 0:\n                fattore += 1\n        fattore = (fattore * 2)\n        if fattore == 0:\n            lista_primi.append(ls[num])\n        if fattore != k:\n            del ls[num]\n    lista_primi.reverse()\n    return lista_primi", "funcname": "main_solution", "ios": [{"input": {"ls": [9, 455, 308, 243, 341, 36, 939, 359, 338], "k": 8}, "output": {"ls": [36], "lista_primi": [359]}}, {"input": {"ls": [238, 734, 303, 647, 722, 126], "k": 8}, "output": {"ls": [], "lista_primi": [647]}}, {"input": {"ls": [679, 47, 309, 893, 762, 718], "k": 10}, "output": {"ls": [], "lista_primi": [47]}}, {"input": {"ls": [635, 404, 968, 736, 256], "k": 2}, "output": {"ls": [635], "lista_primi": []}}, {"input": {"ls": [716, 528, 674, 100, 186, 775, 376], "k": 7}, "output": {"ls": [], "lista_primi": []}}, {"input": {"ls": [251, 39, 671, 483, 620, 278, 898, 529, 829], "k": 7}, "output": {"ls": [], "lista_primi": [251, 829]}}, {"input": {"ls": [653, 656, 92, 755, 736, 321, 728, 783, 334, 315], "k": 0}, "output": {"ls": [653], "lista_primi": [653]}}, {"input": {"ls": [521, 185, 409, 578, 878, 328], "k": 5}, "output": {"ls": [], "lista_primi": [521, 409]}}, {"input": {"ls": [761, 848, 114, 883, 106], "k": 3}, "output": {"ls": [], "lista_primi": [761, 883]}}, {"input": {"ls": [770, 670, 672, 726, 346, 956, 685], "k": 7}, "output": {"ls": [], "lista_primi": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Fondamenti18/fondamenti-di-programmazione", "path": "/students/1802597/homework01/program01.py", "msgidx": 10904}}
{"problem_description": "In a game of poker, a player is dealt a hand of five cards. Given the hand, determine if it is a Royal Flush, which is the highest possible hand in poker consisting of the cards Ace, King, Queen, Jack, and 10, all of the same suit. What is the classification of the given hand?", "io_requirements": "Input:\n  `hand` (list of strings): A list of five strings representing the cards in the hand. Each string is formatted as \"Value of Suit\", e.g., \"Ace of Diamonds\".\n\nOutput:\n  `return` (string): A string indicating whether the hand is a \"Royal Flush\" or \"Not Royal Flush\".", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef translate_hand(hand):\n    mapping = translate_name_to_value()\n    parsed_hand = map(parse_card, hand)\n    valued_hand = map(lambda card: return_card_to_int_tuple(card[0], card[1], mapping), parsed_hand)\n    return sorted(valued_hand, reverse=True)\n\ndef return_card_to_int_tuple(value, suit, mapping):\n    if value in mapping:\n        value = mapping[value]\n    else:\n        value = int(value)\n\n    return (value, suit)\n\ndef check_royal_flush(hand):\n    royal_flush = False\n    first_suit = hand[0][1]\n    same_suit = reduce((lambda acc, card: acc and (first_suit == card[1])), hand, True)\n    if same_suit:\n        values = [card[0] for card in hand]\n        if values == [14, 13, 12, 11, 10]:\n            royal_flush = True\n    else:\n        royal_flush = False\n\n    return royal_flush\n\ndef translate_name_to_value():\n    mapping = {\n        \"Ace\": 14,\n        \"King\": 13,\n        \"Queen\": 12,\n        \"Jack\": 11\n    }\n\n    return mapping\n\ndef parse_card(string_description_of_card):\n    split = string_description_of_card.split()\n    return (split[0], split[2])\n\n# main function\ndef main_solution(hand):\n    # Convert the hand to a sorted list of tuples with integer values\n    translated_hand = translate_hand(hand)\n    \n    # Check if the hand is a Royal Flush\n    is_royal_flush = check_royal_flush(translated_hand)\n    \n    # Return the result as a string\n    if is_royal_flush:\n        return \"Royal Flush\"\n    else:\n        return \"Not Royal Flush\"", "funcname": "main_solution", "ios": [{"input": {"hand": ["3 of Spades", "5 of Clubs", "5 of Diamonds", "5 of Spades", "8 of Clubs"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["Ace of Clubs", "8 of Diamonds", "4 of Spades", "3 of Clubs", "Ace of Hearts"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["2 of Hearts", "Ace of Spades", "King of Hearts", "4 of Hearts", "Jack of Spades"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["4 of Spades", "9 of Spades", "4 of Hearts", "8 of Clubs", "4 of Spades"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["10 of Hearts", "10 of Diamonds", "Jack of Clubs", "2 of Clubs", "5 of Diamonds"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["2 of Hearts", "Queen of Hearts", "2 of Clubs", "6 of Diamonds", "6 of Spades"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["2 of Spades", "5 of Spades", "4 of Diamonds", "6 of Hearts", "6 of Hearts"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["King of Spades", "2 of Diamonds", "9 of Diamonds", "King of Spades", "Queen of Spades"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["Queen of Hearts", "7 of Hearts", "2 of Spades", "4 of Hearts", "2 of Clubs"]}, "output": "Not Royal Flush"}, {"input": {"hand": ["Ace of Diamonds", "Ace of Clubs", "10 of Spades", "6 of Spades", "10 of Clubs"]}, "output": "Not Royal Flush"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dariajung/pokermon", "path": "/poker.py", "msgidx": 10431}}
{"problem_description": "Given a binary tree, determine if it is symmetrical. A binary tree is symmetrical if it looks the same when reflected across its center. What is the result of checking if the given binary tree is symmetrical?", "io_requirements": "Input:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented by its value (an integer) or `null` if the node is `None`. The tree is serialized in a breadth-first manner.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetrical. `True` if the tree is symmetrical, otherwise `False`.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def isSymmetrical(self, pRoot):\n        return self.isSymBT(pRoot, pRoot)\n\n    def isSymBT(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None or left.val != right.val:\n            return False\n        return self.isSymBT(left.left, right.right) and self.isSymBT(left.right, right.left)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(nodes):\n        if not nodes:\n            return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            if nodes[i] is not None:\n                node.left = TreeNode(nodes[i])\n                queue.append(node.left)\n            i += 1\n            if i < len(nodes) and nodes[i] is not None:\n                node.right = TreeNode(nodes[i])\n                queue.append(node.right)\n            i += 1\n        return root\n\n    tree_nodes = json.loads(tree_structure)\n    pRoot = build_tree(tree_nodes)\n    \n    # Invoke the function that requires non-JSON serializable inputs\n    solution = Solution()\n    result = solution.isSymmetrical(pRoot)\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": "[23, 34, 49, 52, 89, 23, 73]"}, "output": false}, {"input": {"tree_structure": "[95, 2, 63, 20, 46, 42, 71]"}, "output": false}, {"input": {"tree_structure": "[59, 71, 63, 80, 68, 40, 68]"}, "output": false}, {"input": {"tree_structure": "[45, 9, 0]"}, "output": false}, {"input": {"tree_structure": "[60]"}, "output": true}, {"input": {"tree_structure": "[41, 24, 38, 49, 40, 43, 65]"}, "output": false}, {"input": {"tree_structure": "[87, 27, 84]"}, "output": false}, {"input": {"tree_structure": "[16, 5, 98]"}, "output": false}, {"input": {"tree_structure": "[92, 91, 73, 0, 56, 40, 77, 32, 21, 26, 22, 72, 57, 85, 50]"}, "output": false}, {"input": {"tree_structure": "[65, 56, 32, 50, 7, 26, 83, 1, 78, 15, 62, 87, 25, 30, 46]"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "15929134544/wangwang", "path": "/day10/58 \u5bf9\u79f0\u7684\u4e8c\u53c9\u6811.py", "msgidx": 10586}}
{"problem_description": "Given a standard 8x8 chessboard, how many unique ways can you place 8 queens such that no two queens threaten each other, starting the placement from a specific cell on the board?", "io_requirements": "Input:\n  `start_x` (int): The starting x-coordinate on the chessboard where the first queen is placed. It should be between 0 and 7.\n  `start_y` (int): The starting y-coordinate on the chessboard where the first queen is placed. It should be between 0 and 7.\n\nOutput:\n  `return` (int): The number of unique solutions found for placing 8 queens on the chessboard such that no two queens threaten each other, starting from the given coordinates.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass ChessBoard:\n\n    def __init__(self):\n        self.board = np.zeros((8,8))\n        self.queens_count = 0\n        self.found_solutions = 0\n        \n    def is_beyond_the_border(self, x, y):\n        return (x < 0 or x > 7 or y < 0 or y > 7)\n            \n    def place_the_queen(self, x, y):\n        if(self.board[x][y] != 0):\n            return False\n        \n        self.board[x][y] = 1\n        \n        for vector_x in {-1, 0, 1}:\n            for vector_y in {-1, 0, 1}:\n                if(vector_x == 0 and vector_y == 0):\n                    continue\n                \n                tmp_x = x + vector_x\n                tmp_y = y + vector_y\n                \n                while(not self.is_beyond_the_border(tmp_x, tmp_y)):\n                    self.board[tmp_x][tmp_y] += 2\n                    tmp_x += vector_x\n                    tmp_y += vector_y\n                    \n        self.queens_count += 1\n        \n        return True\n    \n    def remove_the_queen(self, x, y):\n        if(self.board[x][y] != 1):\n            return False\n        \n        self.board[x][y] = 0\n        \n        for vector_x in {-1, 0, 1}:\n            for vector_y in {-1, 0, 1}:\n                if(vector_x == 0 and vector_y == 0):\n                    continue\n                \n                tmp_x = x + vector_x\n                tmp_y = y + vector_y\n                \n                while(not self.is_beyond_the_border(tmp_x, tmp_y)):\n                    self.board[tmp_x][tmp_y] -= 2\n                    tmp_x += vector_x\n                    tmp_y += vector_y\n        \n        self.queens_count -= 1\n        \n        return True\n                    \n    def search_for_solution(self, x, y):\n        if(self.queens_count == 8):\n            self.found_solutions += 1\n            return True\n        \n        while(not self.is_beyond_the_border(x, y)):\n            if(self.board[x][y] == 0):\n                self.place_the_queen(x, y)\n                    \n                if(y == 7):\n                    new_x = x + 1\n                    new_y = 0\n                else:\n                    new_x = x\n                    new_y = y + 1\n                    \n                if(not self.search_for_solution(new_x, new_y)):\n                    self.remove_the_queen(x, y)\n                \n            if(y == 7):\n                x += 1\n                y = 0\n            else:\n                y += 1\n                        \n        if(self.queens_count == 0):\n            return True\n        \n        return False\n\n# main function\ndef main_solution(start_x, start_y):\n    board = ChessBoard()\n    board.search_for_solution(start_x, start_y)\n    return board.found_solutions", "funcname": "main_solution", "ios": [{"input": {"start_x": 3, "start_y": 2}, "output": 0}, {"input": {"start_x": 4, "start_y": 4}, "output": 0}, {"input": {"start_x": 1, "start_y": 7}, "output": 0}, {"input": {"start_x": 3, "start_y": 6}, "output": 0}, {"input": {"start_x": 5, "start_y": 5}, "output": 0}, {"input": {"start_x": 7, "start_y": 7}, "output": 0}, {"input": {"start_x": 5, "start_y": 6}, "output": 0}, {"input": {"start_x": 7, "start_y": 3}, "output": 0}, {"input": {"start_x": 1, "start_y": 5}, "output": 0}, {"input": {"start_x": 3, "start_y": 5}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vfliagin/python_scripts", "path": "/queens.py", "msgidx": 9779}}
{"problem_description": "Given a string of digits, how many unique prime numbers can be formed using the digits in the string?", "io_requirements": "Input:\n  `numbers` (str): A string of digits from which prime numbers are to be generated. Each character in the string is a digit.\n\nOutput:\n  `return` (int): The number of unique prime numbers that can be formed using the digits in the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef check_sosu(number):\n    if number == 0 or number == 1:\n        return False\n    for n in range(2, number):\n        if number % n == 0:\n            return False\n    return True\n\ndef func(numbers, adding_str='', history=[]):\n    if numbers == []:\n        if not adding_str == '':\n            num = int(adding_str)\n            if (check_sosu(num)):\n                if not num in history:\n                    history.append(num)\n    else:\n        for now_number in numbers:\n            t_numbers = numbers.copy()\n            t_numbers.remove(now_number)\n\n            history = func(t_numbers, adding_str, history)\n            if (adding_str == '' and now_number == '0'):\n                pass\n            else:\n                history = func(t_numbers, adding_str + now_number, history)\n\n    return history\n\n# main function\ndef main_solution(numbers):\n    # Convert the input string to a list of characters\n    numbers_list = list(numbers)\n    # Get the list of prime numbers\n    prime_numbers = func(numbers_list)\n    # Return the count of unique prime numbers\n    return len(prime_numbers)", "funcname": "main_solution", "ios": [{"input": {"numbers": "7114"}, "output": 9}, {"input": {"numbers": "8"}, "output": 9}, {"input": {"numbers": "237855"}, "output": 92}, {"input": {"numbers": "10"}, "output": 92}, {"input": {"numbers": "953189"}, "output": 247}, {"input": {"numbers": "6"}, "output": 247}, {"input": {"numbers": "470007"}, "output": 248}, {"input": {"numbers": "241"}, "output": 250}, {"input": {"numbers": "4253"}, "output": 254}, {"input": {"numbers": "831506"}, "output": 378}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EojinK1m/Practice_Algorithm_Problems", "path": "/programmers/level2/\uc18c\uc218_\ucc3e\uae30.py", "msgidx": 10786}}
{"problem_description": "Given a chessboard of size `n` x `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other? Each solution should be represented by the positions of the queens on the board.", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (str): A JSON string representing a list of lists. Each inner list contains tuples representing the positions of queens on the chessboard that satisfy the problem constraints.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef isProper(board, row, col):\n    return isRowProper(board, row, col) and isAngleProper(board, row, col) and isAntiAngleProper(board, row, col)\n\ndef isRowProper(board, row, col):\n    for i in range(row):\n        if board[i][col] == 1:\n            return False\n    return True\n\ndef isAngleProper(board, row, col):\n    k = col if row > col else row\n    for i in range(k):\n        if board[row - i - 1][col - i - 1] == 1:\n            return False\n    return True\n\ndef isAntiAngleProper(board, row, col):\n    n = len(board)\n    for i in range(row):\n        if col + i + 1 < n:\n            if board[row - i - 1][col + i + 1] == 1:\n                return False\n    return True\n\nclass EightQueen(object):\n    def __init__(self, n):\n        self.n = n\n        self.board = [[0 for _ in range(n)] for _ in range(n)]\n        self.paths = []\n\n    def solve(self, row):\n        if row >= self.n:\n            self.saveResult()\n        else:\n            for i in range(self.n):\n                if isProper(self.board, row, i):\n                    self.board[row][i] = 1\n                    self.solve(row + 1)\n                    self.board[row][i] = 0\n\n    def saveResult(self):\n        path = []\n        for i in range(self.n):\n            for j in range(self.n):\n                if self.board[i][j] == 1:\n                    path.append((i, j))\n                    break\n        self.paths.append(path)\n\n# main function\ndef main_solution(n):\n    # Convert input to the required format\n    n = int(n)\n    \n    # Initialize the EightQueen object and solve the problem\n    o = EightQueen(n)\n    o.solve(0)\n    \n    # Convert the result to a JSON serializable format\n    result = json.dumps(o.paths)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": "[[[0, 1], [1, 3], [2, 0], [3, 2]], [[0, 2], [1, 0], [2, 3], [3, 1]]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "danghualong/MyAlogrithms", "path": "/alog/eightQueen.py", "msgidx": 10298}}
{"problem_description": "Given an undirected graph represented by an adjacency list, determine whether it can be divided into two sets of nodes such that every edge connects a node in one set to a node in the other set. What is the result of this division for the given graph?", "io_requirements": "Input:\n  `graph` (List[List[int]]): A list of lists where each inner list represents the adjacency list of a node in the graph. Each node is an integer between 0 and len(graph)-1.\n\nOutput:\n  `return` (bool): Returns `True` if the graph is bipartite, otherwise returns `False`.", "refcode": "# import necessary packages\nfrom typing import List\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isBipartite_BFS(self, graph: List[List[int]]) -> bool:\n        graph_len = len(graph)\n        UNCOLORED, RED, GREEN = 0, 1, 2  # \u7ed9\u56fe\u4e2d\u8282\u70b9\u8d4b\u4e88\u4e09\u79cd\u72b6\u6001\n        color = [UNCOLORED] * graph_len\n\n        for i in range(graph_len):\n            if color[i] == UNCOLORED:\n                q = deque([i])\n                color[i] = RED\n                while q:\n                    node = q.popleft()\n                    color_tmp = GREEN if color[node] == RED else RED\n                    for neighbor in graph[node]:\n                        if color[neighbor] == UNCOLORED:\n                            color[neighbor] = color_tmp\n                            q.append(neighbor)\n                        elif color[neighbor] != color_tmp:\n                            return False\n        return True\n\n    def isBipartite_DFS(self, graph: List[List[int]]) -> bool:\n        graph_len = len(graph)\n        UNCOLORED, RED, GREEN = 0, 1, 2\n        color = [UNCOLORED] * graph_len\n        valid = True\n\n        def dfs(node: int, c: int):\n            nonlocal valid\n            color[node] = c\n            color_tmp = GREEN if c == RED else RED\n            for neighbor in graph[node]:\n                if color[neighbor] == UNCOLORED:\n                    dfs(neighbor, color_tmp)\n                    if not valid:\n                        return\n                elif color[neighbor] != color_tmp:\n                    valid = False\n                    return\n\n        for i in range(graph_len):\n            if color[i] == UNCOLORED:\n                dfs(i, RED)\n                if not valid:\n                    break\n        return valid\n\n# main function\ndef main_solution(graph: List[List[int]]) -> bool:\n    # Convert input to the required format if necessary\n    solu = Solution()\n    # Use BFS method for the solution\n    return solu.isBipartite_BFS(graph)", "funcname": "main_solution", "ios": [{"input": {"graph": [[1, 4, 2], [0, 4, 3], [4, 1], [2, 4], []]}, "output": false}, {"input": {"graph": [[], [2], [], [0]]}, "output": false}, {"input": {"graph": [[]]}, "output": true}, {"input": {"graph": [[], []]}, "output": true}, {"input": {"graph": [[3, 2], [], [0, 1], [2, 0]]}, "output": false}, {"input": {"graph": [[], [0]]}, "output": false}, {"input": {"graph": [[3], [], [0, 1], [], [1]]}, "output": false}, {"input": {"graph": [[2, 1], [], [1], [2]]}, "output": false}, {"input": {"graph": [[1], [2], [3, 0], [2], [2, 3, 0]]}, "output": false}, {"input": {"graph": [[], [0], [1]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sakurasakura1996/Leetcode", "path": "/leetcode\u672a\u5f52\u7c7b\u9898\u76ee/problem785_\u5224\u65ad\u4e8c\u5206\u56fe.py", "msgidx": 10667}}
{"problem_description": "Given a set of standard UK coin denominations and a target value in pence, how many different ways can the target value be made using any number of the given coins?", "io_requirements": "Input:\n  `value` (int): The target value in pence (e.g., 200 for \u00a32).\n  `coins` (list of int): A list of coin denominations in pence (e.g., [100, 50, 20, 10, 5, 2, 1]).\n\nOutput:\n  `return` (int): The number of different ways the target value can be made using any number of the given coins.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef checkCombination(combination, coins, value):\n    suma = 0\n    for i in range(len(combination)):\n        suma += combination[i] * coins[i]\n    return suma == value\n\ndef difference(combination, coins, value):\n    suma = 0\n    for i in range(len(combination)):\n        suma += combination[i] * coins[i]\n    return suma - value\n\n# main function\ndef main_solution(value, coins):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    coins = list(coins)\n    max_numbers = [value // coin for coin in coins]\n    combinations = []\n    combination = list(max_numbers)\n    \n    while not all(v == 0 for v in combination):\n        if checkCombination(combination, coins, value):\n            combinations.append(combination[:])\n\n        changes = False\n        for i in range(len(coins) - 1, -1, -1):\n            diff = difference(combination, coins, value)\n            if diff > coins[i]:\n                diff2 = combination[i] - int(diff / coins[i])\n                if diff2 < 0:\n                    if combination[i] != 0:\n                        changes = True\n                        combination[i] = 0\n                else:\n                    combination[i] = diff2\n                    changes = True\n                    break\n            else:\n                break\n        if changes:\n            continue\n\n        for i in range(len(coins) - 1, -1, -1):\n            if combination[i] != 0:\n                combination[i] -= 1\n                break\n            else:\n                combination[i] = max_numbers[i]\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(combinations) + 1", "funcname": "main_solution", "ios": [{"input": {"value": 20, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 42}, {"input": {"value": 10, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 12}, {"input": {"value": 1, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 2}, {"input": {"value": 50, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 452}, {"input": {"value": 100, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 4564}, {"input": {"value": 2, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 3}, {"input": {"value": 200, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 73682}, {"input": {"value": 5, "coins": [100, 50, 20, 10, 5, 2, 1]}, "output": 5}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jorgecalvar/ProjectEuler", "path": "/problema31.py", "msgidx": 10758}}
{"problem_description": "Given four colored cubes, each with six faces of different colors (blue, red, green, and yellow), how many ways can you stack these cubes in a vertical column such that each side of the column shows all four colors? The cubes cannot be turned in the same direction simultaneously, and their positions cannot be changed.", "io_requirements": "Input:\n  `cubes` (list of strings): A list of hexadecimal strings representing the colors of the six faces of each cube. Each string should be exactly 6 characters long and represent a valid hexadecimal number.\n\nOutput:\n  `return` (int): The number of ways to stack the four cubes such that each side of the column is showing all four colors.", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef rotate(n):\n    \"\"\"   rotate four side of a cube    \"\"\"\n    r = [n]\n    tb, others = n & 0xff0000, n & 0xffff\n    for i in range(3):\n        others = ((others & 0xf000) >> 12) | ((others & 0xff) << 8) | ((others & 0xf00) >> 4)\n        r.append(tb | others)\n    return r\n\ndef turnover(n):\n    \"\"\"turn over the cube\"\"\"\n    return [n, ((n & 0xf0f000) >> 4) | ((n & 0x0f0f00) << 4) | (n & 0xff)]\n\ndef turn(n, Rotate=True):\n    \"\"\" turn the cube\"\"\"\n    r = [n,\n         ((n & 0x0f) << 20) | ((n & 0xf0) << 12) | ((n & 0xff0000) >> 16) | (n & 0xff00),\n         ((n & 0x0f00) << 12) | ((n & 0xf000) << 4) | ((n & 0xff0000) >> 8) | (n & 0xff)]\n    if Rotate:\n        r = sum(map(turnover, r), [])\n        r = sum(map(rotate, r), [])\n    return r\n\ndef samecolor(aboves, below):\n    \"\"\"check if the below cube has the same color with any of above cubes, on any side\"\"\"\n    for above in aboves:\n        if above & below & 0xffff:\n            return True\n    return False\n\ndef combine(aboves, below):\n    \"\"\"put a cube below, generate a new sequence\"\"\"\n    return [a + [b] for a in aboves for b in below if not samecolor(a, b)]\n\ndef solve(cube):\n    \"\"\"solve the puzzle \"\"\"\n    # generate the permutation of the directions of the four cubes\n    permutation = [turn(cube[0], False)] + list(map(turn, cube[1:]))\n    # put four cubes together, and validate them\n    return reduce(combine, permutation, [[]])\n\n# main function\ndef main_solution(cubes):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert the input to the required format\n    cubes = list(map(int, cubes))\n    \n    # solve the puzzle\n    result = solve(cubes)\n    \n    # return the number of ways to stack the cubes\n    return len(result)", "funcname": "main_solution", "ios": [{"input": {"cubes": ["441228", "481428", "818412", "118241"]}, "output": 0}, {"input": {"cubes": ["118241", "818412", "441228", "481428"]}, "output": 0}, {"input": {"cubes": ["481428", "118241", "441228", "818412"]}, "output": 0}, {"input": {"cubes": ["441228", "818412", "118241", "481428"]}, "output": 0}, {"input": {"cubes": ["441228", "118241", "818412", "481428"]}, "output": 0}, {"input": {"cubes": ["118241", "818412", "481428", "441228"]}, "output": 0}, {"input": {"cubes": ["818412", "441228", "481428", "118241"]}, "output": 0}, {"input": {"cubes": ["818412", "481428", "441228", "118241"]}, "output": 0}, {"input": {"cubes": ["481428", "818412", "118241", "441228"]}, "output": 0}, {"input": {"cubes": ["818412", "481428", "118241", "441228"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "davies/daviescode", "path": "/Python/puzzle/puzzle.py", "msgidx": 9957}}
{"problem_description": "Given a binary tree, determine whether it is possible to partition the tree into two subtrees with equal sums by removing exactly one edge. What is the result indicating whether such a partition is possible?", "io_requirements": "Input:\n  `tree_dict` (dict): A dictionary representing the binary tree. Each key is a node, and the value is another dictionary with keys 'val' (int), 'left' (dict or None), and 'right' (dict or None).\n\nOutput:\n  `return` (int): Returns 1 if the tree can be partitioned into two trees of equal sum, otherwise returns 0.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Function to convert JSON serializable input to TreeNode\ndef build_tree(tree_dict):\n    if not tree_dict:\n        return None\n    root = TreeNode(tree_dict['val'])\n    root.left = build_tree(tree_dict['left'])\n    root.right = build_tree(tree_dict['right'])\n    return root\n\n# Function to convert TreeNode to JSON serializable output\ndef tree_to_dict(node):\n    if not node:\n        return None\n    return {\n        'val': node.val,\n        'left': tree_to_dict(node.left),\n        'right': tree_to_dict(node.right)\n    }\n\n# Function to find the sum of the tree\ndef find_sum(root, nodeSum):\n    if root is None:\n        return 0\n    \n    left_sum = find_sum(root.left, nodeSum)\n    right_sum = find_sum(root.right, nodeSum)\n    \n    nodeSum.append(left_sum + right_sum + root.val)\n    \n    return nodeSum[-1]\n\n# Main function\ndef main_solution(tree_dict):\n    # Convert JSON serializable input to TreeNode\n    root = build_tree(tree_dict)\n    \n    # Find the sum of the tree\n    nodeSum = []\n    total_sum = find_sum(root, nodeSum)\n    nodeSum.pop()\n    \n    # Check if the tree can be partitioned into two trees of equal sum\n    if total_sum % 2 == 0 and (total_sum // 2) in nodeSum:\n        return 1\n    return 0", "funcname": "main_solution", "ios": [{"input": {"tree_dict": {"val": -872057489, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": -77476225, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": -732540955, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": -223093865, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": 951914563, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": -915767799, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": 574246140, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": 997358323, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": -881527435, "left": null, "right": null}}, "output": 0}, {"input": {"tree_dict": {"val": 133912000, "left": null, "right": null}}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "arnabs542/Data-Structures-And-Algorithms", "path": "/Trees/Equal Tree Partition.py", "msgidx": 10632}}
{"problem_description": "Given a set of unique digits, what is the nth lexicographic permutation of these digits?", "io_requirements": "Input:\n  `digits` (list of int): A list of unique integers representing the digits to be permuted.\n  `nth_permutation` (int): The position of the desired lexicographic permutation, starting from 1.\n\nOutput:\n  `return` (str): A string representing the nth lexicographic permutation of the digits.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(digits, nth_permutation):\n    # Convert the list of digits to a tuple to be used in itertools.permutations\n    digits_tuple = tuple(digits)\n    \n    # Generate the permutations and get the nth one\n    permutations = itertools.permutations(digits_tuple)\n    nth_permutation_tuple = next(itertools.islice(permutations, nth_permutation - 1, None))\n    \n    # Convert the tuple back to a list and then to a string\n    nth_permutation_str = ''.join(map(str, nth_permutation_tuple))\n    \n    return nth_permutation_str", "funcname": "main_solution", "ios": [{"input": {"digits": [6, 4, 3, 0, 1, 8, 7, 9, 2, 5], "nth_permutation": 3385687}, "output": "5327061489"}, {"input": {"digits": [6, 7, 4, 5, 0, 1, 8, 3, 9, 2], "nth_permutation": 751740}, "output": "4635781290"}, {"input": {"digits": [2, 3, 9, 6, 8, 1, 5, 7, 0, 4], "nth_permutation": 170417}, "output": "2190735468"}, {"input": {"digits": [5, 1, 3, 4, 0, 2, 8, 7, 6, 9], "nth_permutation": 3352414}, "output": "9314576280"}, {"input": {"digits": [8, 4, 0, 1, 5, 3, 2, 6, 7, 9], "nth_permutation": 714079}, "output": "4923650817"}, {"input": {"digits": [7, 6, 2, 3, 1, 4, 9, 5, 8, 0], "nth_permutation": 1606944}, "output": "1385079426"}, {"input": {"digits": [3, 8, 1, 0, 9, 6, 4, 2, 5, 7], "nth_permutation": 631421}, "output": "8241753609"}, {"input": {"digits": [4, 2, 6, 5, 0, 7, 8, 9, 1, 3], "nth_permutation": 1232470}, "output": "5087163294"}, {"input": {"digits": [3, 6, 0, 4, 7, 2, 5, 9, 1, 8], "nth_permutation": 1370077}, "output": "4985167302"}, {"input": {"digits": [9, 7, 8, 5, 2, 3, 1, 0, 4, 6], "nth_permutation": 509553}, "output": "7209453186"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "belkina2701/python-tutorial", "path": "/venv/My_EP_24_Lexicographic_permutations.py", "msgidx": 10695}}
{"problem_description": "\u5c0fB\u5728\u7814\u7a76\u7535\u5b50\u8868\u683c\u7684\u5355\u5143\u683c\u5750\u6807\u7f16\u53f7\u65f6\uff0c\u53d1\u73b0\u6709\u4e24\u79cd\u4e0d\u540c\u7684\u8868\u793a\u65b9\u6cd5\uff1a\u4e00\u79cd\u662fExcel\u683c\u5f0f\uff08\u5982BB22\uff09\uff0c\u53e6\u4e00\u79cd\u662fRxCy\u683c\u5f0f\uff08\u5982R22C54\uff09\u3002\u5979\u60f3\u77e5\u9053\u5982\u4f55\u5c06\u4e00\u79cd\u683c\u5f0f\u7684\u5750\u6807\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u683c\u5f0f\u3002\u8bf7\u95ee\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u5750\u6807\u53ca\u5176\u8868\u793a\u683c\u5f0f\uff0c\u5982\u4f55\u5c06\u5176\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u683c\u5f0f\uff1f", "io_requirements": "Input:\n  `coordinate_system` (str): A string indicating the coordinate system. It can be either \"excel\" or \"rxcy\".\n  `coordinate` (str): A string representing the coordinate in the specified system. For \"excel\", it should be in the format like \"BB22\". For \"rxcy\", it should be in the format like \"R22C54\".\n\nOutput:\n  `return` (str): A string representing the coordinate converted to the other system. For \"excel\" input, it will return a string in \"rxcy\" format, and vice versa.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# excel\u683c\u5f0f\u5230RxCy\u683c\u5f0f\ndef excel_to_rxcy(S):\n    num1 = 0\n    num2 = 0\n    for i in S:\n        if str(i).isalpha():\n            num1 = num1*26 + ord(i) - 64\n        else:\n            num2 = num2*10 + ord(i) - 48\n    return 'R'+str(num2)+'C'+str(num1)\n\n# RxRy\u683c\u5f0f\u5230Excel\u683c\u5f0f\ndef rxry_to_excel(S):\n    # \u6c42\u51faC\u7684\u5217\u8868\u4f4d\u7f6e\n    C_index = S.index('C')\n    sub1 = S[1:C_index]\n    sub2 = S[C_index + 1:]\n    \n    num1 = 0\n    num2 = 0\n\n    for i in sub1:\n        num1 = num1*10 + ord(i) - 48\n    for i in sub2:\n        num2 = num2*10 + ord(i) - 48\n\n    SR = ''\n    while num2 != 0:\n        tmp = num2%26\n        '''\n        \u6b64\u5904\u6709\u5751\uff0c\u548c10\u8fdb\u5236\u4e0d\u540c\uff0c\u6ca1\u67090\uff0c\u6240\u4ee5\u6574\u9664\u65f6\u9700\u8981\u7279\u6b8a\u8003\u8651\n        '''\n        if tmp == 0:\n            tmp = 26\n            SR = chr(tmp + 64) + SR\n            num2 = int(num2/26) - 1\n        else:\n            SR = chr(tmp + 64) + SR\n            num2 = int(num2/26)\n\n    return SR+str(num1)\n\n# main function\ndef main_solution(coordinate_system, coordinate):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if coordinate_system == 'excel':\n        result = excel_to_rxcy(coordinate)\n    elif coordinate_system == 'rxcy':\n        result = rxry_to_excel(coordinate)\n    else:\n        raise ValueError(\"Invalid coordinate system\")\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"coordinate_system": "excel", "coordinate": "RZWU5352"}, "output": "R5352C334563"}, {"input": {"coordinate_system": "rxcy", "coordinate": "R1475C6437"}, "output": "IMO1475"}, {"input": {"coordinate_system": "rxcy", "coordinate": "R7321C63572"}, "output": "CPAB7321"}, {"input": {"coordinate_system": "rxcy", "coordinate": "R4945C33875"}, "output": "AXBW4945"}, {"input": {"coordinate_system": "rxcy", "coordinate": "R2521C13046"}, "output": "SGT2521"}, {"input": {"coordinate_system": "rxcy", "coordinate": "R2840C75441"}, "output": "DGOO2840"}, {"input": {"coordinate_system": "excel", "coordinate": "SROGJ4941"}, "output": "R4941C9009244"}, {"input": {"coordinate_system": "rxcy", "coordinate": "R5720C40325"}, "output": "BGPY5720"}, {"input": {"coordinate_system": "excel", "coordinate": "RGCJ7885"}, "output": "R7885C321188"}, {"input": {"coordinate_system": "excel", "coordinate": "VZLZ1898"}, "output": "R1898C404586"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "worthurlove/ACM-PRACTICE-Python", "path": "/BAIDU-1.py", "msgidx": 10135}}
{"problem_description": "Given a string that contains a scrambled sequence of characters, can you determine the sequence of digits that can be formed from the names of numbers (e.g., \"ZERO\", \"ONE\", \"TWO\", etc.)? What is the sorted sequence of digits that can be derived from the given string?", "io_requirements": "Input:\n  `input_str` (str): A string containing a scrambled sequence of characters that can potentially form the names of numbers (e.g., \"ZERO\", \"ONE\", \"TWO\", etc.).\n\nOutput:\n  `return` (str): A string representing the sorted sequence of digits that can be formed from the input string. If no valid sequence can be formed, it returns an empty string.", "refcode": "# import necessary packages\nfrom collections import Counter\n\n# all class and function definitions in the code file, if any\ndef make_dict_for_string(string):\n    d = {}\n    for c in string:\n        if c not in d:\n            d[c] = 0\n        d[c] += 1\n    return d\n\ndef dict_to_string(string_dict):\n    final = \"\"\n    for k in string_dict:\n        final += (k * string_dict[k])\n    return final\n\ndef string_contains(sub_str, parent_str):\n    sub_dict = make_dict_for_string(sub_str)\n    parent_dict = make_dict_for_string(parent_str)\n    for k in sub_dict:\n        if k not in parent_dict:\n            return False\n        if sub_dict[k] > parent_dict[k]:\n            return False\n    return True\n\ndef remove_stra_from_strb(str_a, str_b):\n    if not string_contains(str_a, str_b):\n        raise Exception(\"Check it first, you drangus!\")\n    d_a = make_dict_for_string(str_a)\n    d_b = make_dict_for_string(str_b)\n    for k in d_a:\n        d_b[k] -= d_a[k]\n    new_strb = dict_to_string(d_b)\n    return new_strb\n\nNUMBER_STRINGS = ['ZERO', 'SIX', 'EIGHT', 'TWO', 'FOUR', 'SEVEN', 'FIVE', 'NINE', 'ONE', 'THREE']\nNUMBERS = [0, 6, 8, 2, 4, 7, 5, 9, 1, 3]\nSTR_TO_NUM = dict(zip(NUMBER_STRINGS, NUMBERS))\n\ndef figure_out_number_set(input_str):\n    if input_str == \"\":\n        return True, []\n    \n    for num in NUMBER_STRINGS:\n        if string_contains(num, input_str):\n            str_without = remove_stra_from_strb(num, input_str)\n            worked, nums_of_remaining = figure_out_number_set(str_without)\n            if worked:\n                return True, [STR_TO_NUM[num]] + nums_of_remaining\n\n    # didn't work\n    return False, False\n\ndef figure_out_number_string(input_str):\n    worked, num_list = figure_out_number_set(input_str)\n    num_list = sorted(num_list)\n    if not worked:\n        return \"\"\n    return \"\".join([str(i) for i in num_list])\n\n# main function\ndef main_solution(input_str):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return figure_out_number_string(input_str)", "funcname": "main_solution", "ios": [{"input": {"input_str": "SXEINNINOE"}, "output": "169"}, {"input": {"input_str": "SNEETEVGEEHHTETRIHOZEERR"}, "output": "03378"}, {"input": {"input_str": "OWWTOT"}, "output": "22"}, {"input": {"input_str": "ONWETO"}, "output": "12"}, {"input": {"input_str": "HGIETXSI"}, "output": "68"}, {"input": {"input_str": "SNRNEEETFEHINVEIEV"}, "output": "3579"}, {"input": {"input_str": "OVEIEIENINOTWFWTNN"}, "output": "22599"}, {"input": {"input_str": "EFVOUSIEEFVNRXIS"}, "output": "4567"}, {"input": {"input_str": "ORNSWEERONEINVEETOZZ"}, "output": "00279"}, {"input": {"input_str": "ORUORUFF"}, "output": "44"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DaHuO/Supergraph", "path": "/codes/CodeJamCrawler/16_2_1_neat/16_2_1_TheDeeMan_get_digits.py", "msgidx": 10461}}
{"problem_description": "Given a number of pairs of parentheses, how can we generate all possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings, where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        if n == 0:\n            return res\n        self.helper(n, n, '', res)\n        return res\n\n    def helper(self, left, right, item, res):\n        if right < left:\n            return\n        if left == 0 and right == 0:\n            res.append(item)\n        if left > 0:\n            self.helper(left - 1, right, item + '(', res)\n        if right > 0:\n            self.helper(left, right - 1, item + ')', res)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 0}, "output": []}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lawtech0902/py_imooc_algorithm", "path": "/string/22_generate_parentheses.py", "msgidx": 10757}}
{"problem_description": "Given four distinct integers `a`, `b`, `c`, and `d` within specific ranges, what is the length of the longest sequence of natural numbers that can be formed using these integers and their combinations, and what is the sequence of integers that produced this longest sequence?", "io_requirements": "Input:\n  `a` (int): The first integer in the range [1, 6].\n  `b` (int): The second integer in the range [2, 7] and greater than `a`.\n  `c` (int): The third integer in the range [3, 8] and greater than `b`.\n  `d` (int): The fourth integer in the range [4, 9] and greater than `c`.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `max_count` (int): The length of the longest sequence of natural numbers that can be formed using the given integers and their combinations.\n    - `sequence` (str): A string representing the sequence of integers `a, b, c, d` that produced the longest sequence.", "refcode": "# import necessary packages\nimport time\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\nnum_lst = set()\nmax_count = 0\n\ndef combination_generator(initial, in_list):\n    if not in_list:\n        if initial > 0 and initial == int(initial):\n            num_lst.add(int(initial))\n        return\n\n    for x in in_list:\n        for y in range(4):\n            if y == 0:\n                index = in_list.index(x)\n                in_list.remove(x)\n                combination_generator(initial + x, in_list)\n                in_list.insert(index, x)\n\n            elif y == 1:\n                index = in_list.index(x)\n                in_list.remove(x)\n                combination_generator(initial - x, in_list)\n                in_list.insert(index, x)\n\n            elif y == 2:\n                index = in_list.index(x)\n                in_list.remove(x)\n                combination_generator(initial * x, in_list)\n                in_list.insert(index, x)\n\n            elif y == 3:\n                index = in_list.index(x)\n                in_list.remove(x)\n                combination_generator(initial / float(x), in_list)\n                in_list.insert(index, x)\n\ndef check_continuous():\n    global max_count\n    i, p_count = 1, 0\n    for e in num_lst:\n        if e == i:\n            p_count += 1\n        else:\n            break\n        i += 1\n    if p_count > max_count:\n        max_count = p_count\n\ndef list_gen(a, b, c, d):\n    global max_count\n    last_count = 0\n    strx = \"\"\n\n    combination_generator(a, [b, c, d])\n    combination_generator(d, [a, b, c])\n    combination_generator(c, [a, b, d])\n    combination_generator(b, [a, c, d])\n\n    combination_generator(-a, [b, c, d])\n    combination_generator(-d, [a, b, c])\n    combination_generator(-c, [a, b, d])\n    combination_generator(-b, [a, c, d])\n\n    check_continuous()\n    if last_count < max_count:\n        last_count = max_count\n        strx = str(a) + str(b) + str(c) + str(d)\n\n    num_lst.clear()\n    return max_count, strx\n\n# main function\ndef main_solution(a, b, c, d):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = list_gen(a, b, c, d)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"max_count\": result[0], \"sequence\": result[1]}", "funcname": "main_solution", "ios": [{"input": {"a": 2, "b": 3, "c": 8, "d": 9}, "output": {"max_count": 33, "sequence": "2389"}}, {"input": {"a": 2, "b": 6, "c": 7, "d": 8}, "output": {"max_count": 33, "sequence": "2678"}}, {"input": {"a": 4, "b": 7, "c": 8, "d": 9}, "output": {"max_count": 33, "sequence": "4789"}}, {"input": {"a": 1, "b": 7, "c": 8, "d": 9}, "output": {"max_count": 33, "sequence": "1789"}}, {"input": {"a": 1, "b": 6, "c": 8, "d": 9}, "output": {"max_count": 33, "sequence": "1689"}}, {"input": {"a": 1, "b": 3, "c": 5, "d": 8}, "output": {"max_count": 33, "sequence": "1358"}}, {"input": {"a": 2, "b": 3, "c": 6, "d": 8}, "output": {"max_count": 33, "sequence": "2368"}}, {"input": {"a": 1, "b": 5, "c": 6, "d": 8}, "output": {"max_count": 33, "sequence": "1568"}}, {"input": {"a": 6, "b": 7, "c": 8, "d": 9}, "output": {"max_count": 33, "sequence": "6789"}}, {"input": {"a": 3, "b": 4, "c": 8, "d": 9}, "output": {"max_count": 33, "sequence": "3489"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RaiManish3/ProjectEulerCode", "path": "/problems81_100/pe93_arithmetic_expressions.py", "msgidx": 10960}}
{"problem_description": "Given an initial state of a grid where each cell is either live or dead, how does the grid evolve after a certain number of steps in Conway's Game of Life?", "io_requirements": "Input:\n  `initial_grid` (list of lists of int): Initial state of the grid where each cell is either 1 (live) or -1 (dead). The grid should be at least 4x4 to avoid overlap of neighbours at corners.\n  `num_steps` (int): Number of steps/generations to simulate.\n\nOutput:\n  `return` (list of lists of int): Final state of the grid after the specified number of steps. Each cell is either 1 (live) or -1 (dead).", "refcode": "# import necessary packages\nimport numpy as np\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef takeStep(grid):\n    \"\"\"\n    Takes one step of Conway's Game of Life on grid.\n\n    Parameters:\n    grid (NumPy ndarray): State of the grid before taking a step.\n\n    Returns:\n    NumPy ndarray: State of the grid after taking the step.\n    \"\"\"\n\n    newGrid = np.empty(grid.shape)\n\n    # Iterating over rows and columns of grid\n    for row, col in list(itertools.product(range(grid.shape[0]), range(grid.shape[1]))):\n        # If live cell (+1)\n        if(grid[row, col] == 1):\n            # If number of live neighbours is < 2 or > 3, dies\n            if(findLiveNeighbourCount(grid, row, col) < 2 or findLiveNeighbourCount(grid, row, col) > 3):\n                newGrid[row, col] = -1\n            # Else if number of live neighbours is 2 or 3, lives\n            elif(findLiveNeighbourCount(grid, row, col) in {2, 3}):\n                newGrid[row, col] = 1\n        # If dead cell\n        elif(grid[row, col] == -1):\n            # If number of live neighbours is 3, becomes alive\n            if(findLiveNeighbourCount(grid, row, col) == 3):\n                newGrid[row, col] = 1\n            # Else stays dead\n            else:\n                newGrid[row, col] = -1\n\n    return newGrid\n\ndef findLiveNeighbourCount(grid, row, col):\n    \"\"\"\n    Finds the number of live neighbours in the Moore neighbourhood of a cell.\n\n    Parameters:\n    grid (NumPy ndarray): Grid on which the game is being played.\n    row (int): Row of the cell of interest in the grid.\n    col (int): Column of the cell of interest in the grid.\n\n    Returns:\n    int: Number of live neighbours around the cell grid[row, col].\n    \"\"\"\n\n    if(grid.shape[0] <= 3 or grid.shape[1] <= 3):\n        print('grid must be of shape at least 4x4 to avoid overlap of neighbours at corners')\n        return None\n\n    numRows, numCols = grid.shape\n    # Indices of 8 nearest neighbours as a list of 2-tuples\n    neighbourIndices = list(itertools.product([(row-1)%numRows, row, (row+1)%numRows], [(col-1)%numCols, col, (col+1)%numCols]))\n    neighbourIndices.remove((row, col))\n\n    count = 0   # Counter for live (+1) neighbours\n    for i, j in neighbourIndices:\n        if(grid[i, j] == 1):\n            count += 1\n\n    return count\n\n# main function\ndef main_solution(initial_grid, num_steps):\n    \"\"\"\n    Simulates Conway's Game of Life for a given number of steps starting from an initial grid.\n\n    Parameters:\n    initial_grid (list of lists of int): Initial state of the grid where each cell is either 1 (live) or -1 (dead).\n    num_steps (int): Number of steps/generations to simulate.\n\n    Returns:\n    list of lists of int: Final state of the grid after the specified number of steps.\n    \"\"\"\n    grid = np.array(initial_grid)\n    for _ in range(num_steps):\n        grid = takeStep(grid)\n    return grid.tolist()", "funcname": "main_solution", "ios": [{"input": {"initial_grid": [[1, -1, -1, 1], [-1, 1, -1, -1], [-1, 1, 1, 1], [-1, 1, -1, 1]], "num_steps": 13}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[-1, -1, 1, -1], [1, -1, -1, 1], [-1, 1, -1, 1], [-1, 1, -1, 1]], "num_steps": 19}, "output": [[1.0, -1.0, 1.0, -1.0], [1.0, -1.0, 1.0, -1.0], [-1.0, -1.0, -1.0, 1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[-1, -1, -1, 1], [1, 1, 1, 1], [1, 1, 1, -1], [1, -1, 1, -1]], "num_steps": 19}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[1, 1, -1, -1], [-1, 1, 1, 1], [-1, -1, -1, -1], [1, -1, -1, -1]], "num_steps": 13}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[-1, 1, 1, -1], [-1, -1, 1, 1], [-1, 1, -1, 1], [-1, -1, 1, 1]], "num_steps": 19}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[1, 1, 1, -1], [-1, -1, 1, -1], [1, 1, 1, -1], [-1, 1, 1, 1]], "num_steps": 9}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[-1, 1, 1, -1], [-1, -1, -1, -1], [1, -1, 1, -1], [1, 1, 1, -1]], "num_steps": 12}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[1, -1, -1, -1], [-1, -1, 1, 1], [1, 1, 1, -1], [1, 1, 1, 1]], "num_steps": 18}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[-1, 1, -1, 1], [1, 1, 1, 1], [-1, 1, -1, -1], [1, 1, -1, 1]], "num_steps": 13}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, -1.0]]}, {"input": {"initial_grid": [[-1, -1, 1, -1], [-1, -1, -1, 1], [1, 1, -1, 1], [-1, 1, 1, 1]], "num_steps": 9}, "output": [[-1.0, -1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, 1.0], [1.0, 1.0, -1.0, -1.0], [-1.0, -1.0, -1.0, 1.0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nikhilkmr300/conway", "path": "/conway.py", "msgidx": 10697}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (List[str]): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution(object):\n    def path(self, res, curpath, left, right):\n        '''\n        left:\u76ee\u524d\u7684\u5de6\u62ec\u53f7\u6570\n        right:\u76ee\u524d\u7684\u53f3\u62ec\u53f7\u6570\n        '''\n        if left == right and left == 0:\n            res.append(curpath)\n            return\n        if left >= right:\n            # \u4f59\u4e0b\u7684\u5de6\u62ec\u53f7\u6570\u76ee\u5927\u4e8e\u7b49\u4e8e\u53f3\u62ec\u53f7 \u6570\u76ee\u7684\u65f6\u5019\u53ea\u80fd\u52a0\u5165\u5de6\u62ec\u53f7\n            curpath += '('\n            self.path(res, curpath, left - 1, right)\n        else:\n            if left:\n                self.path(res, curpath + '(', left - 1, right)\n            if right:\n                self.path(res, curpath + ')', left, right - 1)\n\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        curpath = ''\n        self.path(res, curpath, n, n)\n        return res\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hustlrr/leetcode", "path": "/accepted/Generate Parentheses.py", "msgidx": 10886}}
{"problem_description": "Given a positive integer `n` and another positive integer `m` which is less than or equal to `n`, how many distinct ways can `n` be expressed as the sum of positive integers, where each integer in the sum is less than or equal to `m`?", "io_requirements": "Input:\n  `n` (int): The integer to be partitioned.\n  `m` (int): The maximum integer to use in the partitions.\n\nOutput:\n  `return` (int): The number of ways to partition the integer `n` using integers up to `m`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def equation_count(self, n, m):\n        if n == 1 or m == 1:\n            return 1\n        elif n < m:\n            return self.equation_count(n, n)\n        elif n == m:\n            return self.equation_count(n, n-1) + 1\n        else:\n            return self.equation_count(n, m-1) + self.equation_count(n-m, m)\n\n# main function\ndef main_solution(n, m):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    S = Solution()\n    result = S.equation_count(n, m)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 31, "m": 22}, "output": 6775}, {"input": {"n": 49, "m": 12}, "output": 85067}, {"input": {"n": 28, "m": 11}, "output": 2812}, {"input": {"n": 4, "m": 1}, "output": 1}, {"input": {"n": 27, "m": 9}, "output": 1845}, {"input": {"n": 25, "m": 14}, "output": 1819}, {"input": {"n": 33, "m": 30}, "output": 10139}, {"input": {"n": 24, "m": 10}, "output": 1204}, {"input": {"n": 50, "m": 26}, "output": 198463}, {"input": {"n": 43, "m": 25}, "output": 62049}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Artistzq/learn_python", "path": "/alg/recursion/equation_count.py", "msgidx": 10584}}
{"problem_description": "Given a truth table with multiple input and output variables, how can we derive the Boolean expressions for each output variable based on the truth values provided in the table? Specifically, what are the Boolean expressions for the outputs `OZ`, `OY`, and `OX` in the given truth table?", "io_requirements": "Input:\n  `matrix` (list of lists): A truth table represented as a list of lists. The first list is the header containing input and output names. The subsequent lists contain the truth values for each combination of inputs.\n\nOutput:\n  `return` (str): A string representing the Boolean expressions for each output variable in the truth table. Each expression is separated by a space.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\nclass BooleanExpressionCreator:\n    \"\"\"Generating Boolean expression from truth table\"\"\"\n\n    @staticmethod\n    def input_output_counter(matrix):\n        \"\"\"ToDo\"\"\"\n        header_tuple = matrix[0]  # getting input and output name tuple for naming\n        count_outputs = 0\n        count_inputs = 0\n        for x in header_tuple:\n            if bool(re.match('I', x, re.IGNORECASE)):\n                # inputs are start with \"I\" and outputs \"O\"\n                # as example inputs IA, IB .... outputs OZ, OY ......,\n                # So in this regex check whether it starts with I or not\n                count_inputs += 1\n            else:\n                count_outputs += 1\n\n        return count_inputs, count_outputs, header_tuple\n\n    @staticmethod\n    def boolean_expression_generator(matrix):\n        \"\"\"ToDo\"\"\"\n        inputs_count, outputs_count, tuple_head = BooleanExpressionCreator.input_output_counter(matrix)\n        boolean_expression_set = \"\"\n        value_matrix = matrix[1:]\n        #  remove header tuple and create new matrix with values\n        for i in range(outputs_count):\n            #  generating boolean expression for each output separately\n            boolean_expression = \"\"\n            for x in range(len(value_matrix)):  # generating boolean expression for each tuple of truth table\n                current_tuple = value_matrix[x]\n                if 1 == current_tuple[inputs_count + i]:  # only genera boolean expression for outputs when \"1\"\n                    temp_boolean_expresion = BooleanExpressionCreator.bool_expression_of_each_tuple_each_output(\n                        inputs_count, current_tuple, tuple_head)\n                    if 0 == len(boolean_expression):        # concatenate each boolean expression\n                        boolean_expression = boolean_expression + temp_boolean_expresion\n                    else:\n                        boolean_expression = boolean_expression + \" + \" + temp_boolean_expresion\n                # if 0 < len(temp_boolean_expresion):\n            if 0 < len(boolean_expression):\n                boolean_expression_set = boolean_expression_set + tuple_head[inputs_count+i][1:] + ' = '\\\n                                     + boolean_expression + \"  \"\n            # concatenate boolean expression of every outputs'\n        return boolean_expression_set\n\n    @staticmethod\n    def bool_expression_of_each_tuple_each_output(input_count, tuple_current, tuple_head):\n        \"\"\"ToDo\"\"\"\n        boolean_expression = \"\"\n        # if 1 == tuple_current[input_count + output_place - 1]:\n        for j in range(input_count):\n            if 1 == tuple_current[j]:   # check whether input is \"1\" or not.\n                # If it is Getting Input from tuple head value\n                boolean_expression = boolean_expression + tuple_head[j][1:]\n            else:\n                boolean_expression = boolean_expression + tuple_head[j][1:] + \"\\'\"\n        return boolean_expression\n\n# main function\ndef main_solution(matrix):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    boolean_expression_set = BooleanExpressionCreator.boolean_expression_generator(matrix)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return boolean_expression_set", "funcname": "main_solution", "ios": [{"input": {"matrix": [["IA", "IB", "OA"], [0, 1, 1], [1, 0, 1], [1, 0, 0], [0, 1, 0]]}, "output": "A = A'B + AB'  "}, {"input": {"matrix": [["IA", "IB", "OA"], [1, 1, 1], [0, 0, 0], [1, 1, 1], [1, 0, 1]]}, "output": "A = AB + AB + AB'  "}, {"input": {"matrix": [["IA", "IB", "OA"], [0, 1, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0]]}, "output": "A = A'B'  "}, {"input": {"matrix": [["IA", "IB", "OA"], [1, 1, 1], [1, 1, 0], [0, 0, 1], [0, 1, 0]]}, "output": "A = AB + A'B'  "}, {"input": {"matrix": [["IA", "IB", "OA"], [1, 1, 0], [0, 0, 0], [0, 1, 1], [1, 0, 0]]}, "output": "A = A'B  "}, {"input": {"matrix": [["IA", "IB", "OA"], [1, 0, 1], [0, 1, 1], [0, 0, 0], [0, 0, 0]]}, "output": "A = AB' + A'B  "}, {"input": {"matrix": [["IA", "IB", "OA"], [1, 0, 0], [1, 1, 1], [0, 1, 0], [0, 0, 0]]}, "output": "A = AB  "}, {"input": {"matrix": [["IA", "IB", "OA"], [1, 0, 0], [0, 0, 0], [1, 1, 1], [0, 0, 1]]}, "output": "A = AB + A'B'  "}, {"input": {"matrix": [["IA", "IB", "OA"], [0, 1, 0], [1, 0, 1], [1, 1, 0], [1, 0, 1]]}, "output": "A = AB' + AB'  "}, {"input": {"matrix": [["IA", "IB", "OA"], [1, 1, 0], [1, 0, 0], [1, 1, 0], [0, 1, 1]]}, "output": "A = A'B  "}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Innovelogic/relations-derivator", "path": "/boolean_expression_creator.py", "msgidx": 10931}}
{"problem_description": "Given a list of numbers with the same length, what is the shortest chain of numbers that links the first number to the last number, where each number in the chain differs from the previous number by exactly one digit?", "io_requirements": "Input:\n  `numbers` (list of integers): A list of positive integers with the same length. The list should contain at least two numbers.\n\nOutput:\n  `return` (list of integers): The shortest chain of numbers from the first number to the last number in the input list. If no such chain exists, an empty list is returned.", "refcode": "# import necessary packages\nimport collections\nimport operator\n\n# main function\ndef main_solution(numbers):\n    # Convert numbers to strings for easier manipulation\n    numbers = list(map(str, numbers))\n    \n    # Initialize the queue and visited dictionary\n    q, v = collections.deque({numbers.pop()}), {}\n\n    # Breadth-first search to find the shortest path\n    while q:\n        t = q.popleft()\n\n        if t == numbers[0]:\n            result = []\n            while True:\n                result.append(int(t))\n                try:\n                    t = v[t]\n                except KeyError:\n                    return result[::-1]  # Reverse the result to get the correct order\n\n        for u in numbers:\n            if sum(map(operator.ne, t, u)) <= 1 and u not in v:\n                v[u] = t\n                q.append(u)\n\n    return []  # Return an empty list if no path is found", "funcname": "main_solution", "ios": [{"input": {"numbers": [196, 719, 482, 605, 622, 469, 468]}, "output": []}, {"input": {"numbers": [586, 165, 394, 269, 319, 749, 318, 597]}, "output": []}, {"input": {"numbers": [616, 664, 122, 684, 824, 330]}, "output": []}, {"input": {"numbers": [2542, 4075, 9475, 7218, 5420, 1456, 6928, 8369]}, "output": []}, {"input": {"numbers": [638, 796, 866, 417, 594]}, "output": []}, {"input": {"numbers": [7429, 7750, 1257, 7394, 4149, 1608, 3841, 8384, 6170]}, "output": []}, {"input": {"numbers": [1183, 5855, 7928, 3029, 8217, 7831, 6482, 5131]}, "output": []}, {"input": {"numbers": [8230, 4521, 2651, 3712, 6825, 5659, 1722, 1066, 8869]}, "output": []}, {"input": {"numbers": [9115, 8449, 3020, 8966, 5206, 8339, 9517, 6997, 3095]}, "output": []}, {"input": {"numbers": [899, 340, 157, 542, 344]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "roman-kachanovsky/checkio-python", "path": "/solutions/alice_in_wonderland/digits_doublets.py", "msgidx": 10730}}
{"problem_description": "In a game of Tic Tac Toe, given a specific board state, what is the optimal next move for the current player? The board state is represented by a 3x3 grid where each cell can be either 'X', 'O', or empty. The optimal move should be determined based on the current state of the board.", "io_requirements": "Input:\n  `board_state` (str): A JSON-serialized string representing a 3x3 matrix. Each element in the matrix can be 'X', 'O', or `null` (representing an empty cell).\n\nOutput:\n  `return` (list): A list containing two integers representing the optimal move's row and column indices. If no move is possible (e.g., the game is over), an empty list is returned.", "refcode": "# import necessary packages\nfrom copy import deepcopy\nimport json\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# all class and function definitions in the code file, if any\ndef initial_state():\n    \"\"\"\n    Returns starting state of the board.\n    \"\"\"\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\ndef player(board):\n    \"\"\"\n    Returns player who has the next turn on a board.\n    \"\"\"\n    flat_board = [element for row in board for element in row]\n    x = flat_board.count(X)\n    o = flat_board.count(O)\n    return X if (x + o) % 2 == 0 else O\n\ndef actions(board):\n    \"\"\"\n    Returns set of all possible actions (i, j) available on the board.\n    \"\"\"\n    actions_set = set()\n    for row in range(3):\n        for col in range(3):\n            if board[row][col] == EMPTY:\n                actions_set.add((row, col))\n    return actions_set\n\ndef result(board, action):\n    \"\"\"\n    Returns the board that results from making move (i, j) on the board.\n    \"\"\"\n    i, j = action\n    if board[i][j] != EMPTY:\n        raise NameError(\"Cell (\" + str(i) + \", \" + str(j) + \") is already occupied\")\n    new_board = deepcopy(board)\n    new_board[i][j] = player(board)\n    return new_board\n\ndef winner(board):\n    \"\"\"\n    Returns the winner of the game, if there is one.\n    \"\"\"\n    lines = []\n    for i in range(3):\n        lines.append([(i, 0), (i, 1), (i, 2)])\n        lines.append([(0, i), (1, i), (2, i)])\n    lines.append([(0, 0), (1, 1), (2, 2)])\n    lines.append([(2, 0), (1, 1), (0, 2)])\n\n    for line in lines:\n        three_cells = []\n        for row, col in line:\n            three_cells.append(board[row][col])\n        if three_cells[0] is not EMPTY and three_cells[0] == three_cells[1] == three_cells[2]:\n            return three_cells[0]\n    return None\n\ndef terminal(board):\n    \"\"\"\n    Returns True if game is over, False otherwise.\n    \"\"\"\n    if winner(board) is not None:\n        return True\n    for row in range(3):\n        for col in range(3):\n            if board[row][col] == EMPTY:\n                return False\n    return True\n\ndef utility(board):\n    \"\"\"\n    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.\n    \"\"\"\n    res = winner(board)\n    if res == X:\n        return 1\n    elif res == O:\n        return -1\n    else:\n        return 0\n\ndef minimax(board):\n    \"\"\"\n    Returns the optimal action for the current player on the board.\n    \"\"\"\n    if terminal(board):\n        return None\n    return max_value(board)[0] if player(board) == X else min_value(board)[0]\n\ndef max_value(board):\n    \"\"\"\n    Returns the action with the higher value associated and the said value\n    \"\"\"\n    optimalAction = None\n    value = -2\n\n    for action in actions(board):\n        new_board = result(board, action)\n        if terminal(new_board):\n            new_value = utility(new_board)\n        else:\n            _, new_value = min_value(new_board)\n        if new_value > value:\n            optimalAction = action\n            value = new_value\n    return (optimalAction, value)\n\ndef min_value(board):\n    \"\"\"\n    Returns the action with the lowest value associated and the said value\n    \"\"\"\n    optimalAction = None\n    value = 2\n\n    for action in actions(board):\n        new_board = result(board, action)\n        if terminal(new_board):\n            new_value = utility(new_board)\n        else:\n            _, new_value = max_value(new_board)\n        if new_value < value:\n            optimalAction = action\n            value = new_value\n    return (optimalAction, value)\n\n# main function\ndef main_solution(board_state):\n    \"\"\"\n    Determines the optimal next move for the current player on the given Tic Tac Toe board state.\n    \n    Input:\n    - board_state (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each element can be 'X', 'O', or None.\n    \n    Output:\n    - return (list): A list containing two integers representing the optimal move's row and column indices.\n    \"\"\"\n    board = json.loads(board_state)\n    optimal_move = minimax(board)\n    return list(optimal_move) if optimal_move else []", "funcname": "main_solution", "ios": [{"input": {"board_state": "[[\"X\", \"O\", \"X\"], [\"X\", \"O\", \"O\"], [\"X\", \"O\", \"X\"]]"}, "output": []}, {"input": {"board_state": "[[null, null, \"O\"], [null, null, null], [null, null, \"X\"]]"}, "output": [2, 1]}, {"input": {"board_state": "[[\"X\", null, null], [null, null, null], [null, null, null]]"}, "output": [1, 1]}, {"input": {"board_state": "[[null, null, null], [null, null, null], [\"O\", \"X\", \"X\"]]"}, "output": [0, 0]}, {"input": {"board_state": "[[null, \"O\", \"O\"], [\"O\", \"X\", \"X\"], [\"O\", \"X\", \"X\"]]"}, "output": [0, 0]}, {"input": {"board_state": "[[null, null, null], [null, null, null], [null, null, \"X\"]]"}, "output": [1, 1]}, {"input": {"board_state": "[[\"O\", \"X\", \"O\"], [\"O\", \"X\", \"O\"], [null, \"X\", \"X\"]]"}, "output": []}, {"input": {"board_state": "[[\"X\", null, \"X\"], [\"O\", \"O\", \"O\"], [null, null, \"X\"]]"}, "output": []}, {"input": {"board_state": "[[null, null, null], [\"X\", \"O\", null], [null, null, null]]"}, "output": [0, 1]}, {"input": {"board_state": "[[null, null, null], [\"O\", \"X\", null], [null, \"X\", \"O\"]]"}, "output": [0, 1]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bonato-simone/CS50AI", "path": "/0-search/tictactoe/tictactoe.py", "msgidx": 10575}}
{"problem_description": "Given a directed graph with a set of nodes and edges, and a starting node, what is the order of nodes visited during a Breadth-First Search (BFS) traversal starting from the given node?", "io_requirements": "Input:\n  `nodes` (list of int): A list of integers representing the nodes in the graph.\n  `edges` (list of tuple of int): A list of tuples representing the edges in the graph. Each tuple contains two integers representing the source and target nodes of the edge.\n  `start_node` (int): An integer representing the starting node for the BFS traversal.\n\nOutput:\n  `return` (str): A string representing the order of nodes visited during the BFS traversal, separated by spaces.", "refcode": "# import necessary packages\nimport networkx as nx\n\n# main function\ndef main_solution(nodes, edges, start_node):\n    # Create a directed graph\n    G = nx.DiGraph()\n    \n    # Add nodes to the graph\n    G.add_nodes_from(nodes)\n    \n    # Add edges to the graph\n    for edge in edges:\n        G.add_edge(edge[0], edge[1])\n    \n    # Perform BFS starting from the start_node\n    visited = set()\n    queue = [start_node]\n    traversal_order = []\n    \n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            traversal_order.append(node)\n            for neighbor in G.neighbors(node):\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    \n    # Convert the traversal order to a space-separated string\n    return ' '.join(map(str, traversal_order))", "funcname": "main_solution", "ios": [{"input": {"nodes": [0, 1, 2, 3, 4], "edges": [[4, 1], [4, 1], [3, 1], [3, 1]], "start_node": 4}, "output": "4 1"}, {"input": {"nodes": [0, 1, 2, 3], "edges": [[1, 2], [3, 1], [0, 3]], "start_node": 3}, "output": "3 1 2"}, {"input": {"nodes": [0, 1, 2, 3, 4], "edges": [[2, 4], [0, 3], [2, 0], [2, 1]], "start_node": 0}, "output": "0 3"}, {"input": {"nodes": [0, 1, 2, 3], "edges": [[3, 0], [0, 1], [1, 2], [3, 0]], "start_node": 2}, "output": "2"}, {"input": {"nodes": [0, 1, 2, 3], "edges": [[2, 3], [1, 2], [1, 3], [1, 2], [3, 1]], "start_node": 0}, "output": "0"}, {"input": {"nodes": [0, 1, 2, 3], "edges": [[0, 2], [1, 3], [3, 2]], "start_node": 2}, "output": "2"}, {"input": {"nodes": [0, 1, 2, 3], "edges": [[0, 2], [3, 0], [3, 1], [2, 0], [1, 2]], "start_node": 1}, "output": "1 2 0"}, {"input": {"nodes": [0, 1, 2, 3, 4], "edges": [[0, 1], [0, 4], [1, 0]], "start_node": 0}, "output": "0 1 4"}, {"input": {"nodes": [0, 1, 2, 3], "edges": [[0, 2], [0, 2], [0, 2], [3, 0]], "start_node": 2}, "output": "2"}, {"input": {"nodes": [0, 1, 2, 3], "edges": [[0, 3], [0, 3], [2, 3]], "start_node": 0}, "output": "0 3"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Jairgo/Proyecto-FInal-Estructuras", "path": "/BFS.py", "msgidx": 10705}}
{"problem_description": "In a hypothetical farm, each mature cow gives birth to one calf every year, and cows never die. Initially, there is only one calf. Each calf takes 3 years to mature and start giving birth. Given the number of years `n`, how many cows will there be after `n` years?", "io_requirements": "Input:\n  `n` (int): The number of years to calculate the number of cows.\n\nOutput:\n  `return` (int): The total number of cows after `n` years.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(n: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    if n < 4:\n        return n\n    else:\n        f1, f2, f3 = 1, 2, 3\n        for i in range(n-3):\n            f4 = f3 + f1\n            f1 = f2\n            f2 = f3\n            f3 = f4\n        return f4", "funcname": "main_solution", "ios": [{"input": {"n": 10}, "output": 41}, {"input": {"n": 18}, "output": 872}, {"input": {"n": 15}, "output": 277}, {"input": {"n": 8}, "output": 19}, {"input": {"n": 16}, "output": 406}, {"input": {"n": 6}, "output": 9}, {"input": {"n": 7}, "output": 13}, {"input": {"n": 4}, "output": 4}, {"input": {"n": 13}, "output": 129}, {"input": {"n": 3}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shzxd/Xleetcode", "path": "/\u6bcd\u725b\u751f\u4ea7.py", "msgidx": 11163}}
{"problem_description": "In an IoT mesh network, signals can only travel a maximum of 5 units. Given the coordinates of the switch, the light, and the mesh hubs (which capture and forward signals), determine if the switch can successfully toggle the light. What is the result of this operation?", "io_requirements": "Input:\n  `switch` (list of int): A list containing two integers representing the coordinates of the switch.\n  `hubs` (list of list of int): A list of lists, where each inner list contains two integers representing the coordinates of a mesh hub.\n  `light` (list of int): A list containing two integers representing the coordinates of the light.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the switch can successfully toggle the light. Returns `True` if the switch can toggle the light, otherwise `False`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef getDistance(p1, p2):\n    '''\n    Finds the distance between two points\n    Uses the distance formula\n    '''\n    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))\n\n# main function\ndef main_solution(switch, hubs, light):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    network = {'switch': switch, 'hub': hubs, 'light': light}\n    \n    def canToggle(network):\n        r = 5\n        p1 = network['switch']\n        p2 = network['light']\n\n        # Check if the switch can toggle the network \n        if getDistance(p1, p2) <= r:\n            # The switch is within range of the network so toggle away\n            return True\n        else:\n            # The switch is not in range of the network, so we check the hubs \n            if len(network['hub']) > 0: # Only perform when there are hubs\n                for i in range(len(network['hub'])):\n                    # Check if hub is within distance of switch \n                    # If so then make the hub the new switch\n                    p1 = network[\"switch\"]\n                    p2 = network[\"hub\"][i]\n                    if getDistance(p1, p2) <= r:\n                        # Substitute the switch for hub[i]\n                        new_network = {'switch': network[\"hub\"][i], 'hub': network['hub'], 'light': network['light']}\n                        new_network[\"hub\"].pop(i) # Remove the hub after rebuilding the network\n\n                        # Check if the new switch can toggle the light\n                        return canToggle(new_network)\n\n                    # The switch is not within range of the hub\n                    return False\n            else:\n                return False\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return canToggle(network)", "funcname": "main_solution", "ios": [{"input": {"switch": [0, 10], "hubs": [[9, 10], [4, 9]], "light": [0, 5]}, "output": true}, {"input": {"switch": [4, 3], "hubs": [[9, 9]], "light": [6, 8]}, "output": false}, {"input": {"switch": [10, 5], "hubs": [[3, 8]], "light": [10, 5]}, "output": true}, {"input": {"switch": [1, 4], "hubs": [], "light": [0, 9]}, "output": true}, {"input": {"switch": [0, 3], "hubs": [[6, 4]], "light": [8, 9]}, "output": false}, {"input": {"switch": [2, 1], "hubs": [[3, 8], [10, 8]], "light": [4, 5]}, "output": true}, {"input": {"switch": [2, 3], "hubs": [[6, 9]], "light": [6, 1]}, "output": true}, {"input": {"switch": [6, 0], "hubs": [[7, 10]], "light": [10, 7]}, "output": false}, {"input": {"switch": [7, 6], "hubs": [[0, 9]], "light": [2, 1]}, "output": false}, {"input": {"switch": [3, 9], "hubs": [], "light": [10, 10]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DevShasa/code-challenges", "path": "/Cassidy-Williams-newsletter-challenges/casidoo-4-1-2021.py", "msgidx": 10640}}
{"problem_description": "Given a Constraint Satisfaction Problem (CSP) with a set of variables and their corresponding assignments, how can we determine if the assignments are both valid and complete for the given variables?", "io_requirements": "Input:\n  `variables` (list of str): A list of variable names in the CSP problem.\n  `assignments` (dict): A dictionary where keys are variable names and values are their assigned values.\n\nOutput:\n  `return` (dict): A dictionary with keys 'is_valid' and 'is_complete', each containing a boolean value indicating if the assignments are valid and complete, respectively.", "refcode": "# import necessary packages\nfrom abc import ABC, abstractmethod\n\n# all class and function definitions in the code file, if any\nclass Csp(ABC):\n    \"\"\"ABC representing a generic CSP problem.\n\n    All the generic methods makes a csp able to be solved by the csp solver.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Object creator.\"\"\"\n        ABC.__init__(self)\n\n    @abstractmethod\n    def is_solved(self):\n        \"\"\"Check if the csp is solved.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_valid_assignment(self, var):\n        \"\"\"Check if the value assigned to var is valid.\"\"\"\n        pass\n\n    @abstractmethod\n    def select_unassigned_variable(self):\n        \"\"\"Select the next unassigned var to be assigned.\"\"\"\n        pass\n\n    @abstractmethod\n    def unassign_variable(self, var):\n        \"\"\"Return back the var to the set of unassigned vars.\"\"\"\n        pass\n\n    @abstractmethod\n    def order_domain_value(self):\n        \"\"\"Order the domain values to the problem.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_complete(self):\n        \"\"\"Check if the assignment is complete.\"\"\"\n        pass\n\n    @abstractmethod\n    def add_value(self, var, value):\n        \"\"\"Check if the assignment is complete.\"\"\"\n        pass\n\n    @abstractmethod\n    def remove_value(self, var):\n        \"\"\"Check if the assignment is complete.\"\"\"\n        pass\n\n# main function\ndef main_solution(variables, assignments):\n    \"\"\"\n    This function checks if a given set of assignments to variables in a CSP problem is valid and complete.\n\n    Parameters:\n    - variables (list of str): A list of variable names in the CSP problem.\n    - assignments (dict): A dictionary where keys are variable names and values are their assigned values.\n\n    Returns:\n    - result (dict): A dictionary with keys 'is_valid' and 'is_complete', each containing a boolean value indicating if the assignments are valid and complete, respectively.\n    \"\"\"\n    class DummyCsp(Csp):\n        def __init__(self, variables, assignments):\n            super().__init__()\n            self.variables = variables\n            self.assignments = assignments\n\n        def is_solved(self):\n            return self.is_complete() and all(self.is_valid_assignment(var) for var in self.assignments)\n\n        def is_valid_assignment(self, var):\n            # Dummy validation: Check if the assigned value is a string\n            return isinstance(self.assignments.get(var), str)\n\n        def select_unassigned_variable(self):\n            return next((var for var in self.variables if var not in self.assignments), None)\n\n        def unassign_variable(self, var):\n            if var in self.assignments:\n                del self.assignments[var]\n\n        def order_domain_value(self):\n            return []\n\n        def is_complete(self):\n            return set(self.assignments.keys()) == set(self.variables)\n\n        def add_value(self, var, value):\n            self.assignments[var] = value\n\n        def remove_value(self, var):\n            if var in self.assignments:\n                del self.assignments[var]\n\n    csp = DummyCsp(variables, assignments)\n    is_valid = all(csp.is_valid_assignment(var) for var in assignments)\n    is_complete = csp.is_complete()\n\n    return {\n        'is_valid': is_valid,\n        'is_complete': is_complete\n    }", "funcname": "main_solution", "ios": [{"input": {"variables": ["var0", "var1", "var2"], "assignments": {"var0": "noX", "var1": "jlN", "var2": "ydO"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1"], "assignments": {"var0": "ioR", "var1": "ePs"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1"], "assignments": {"var0": "jQx", "var1": "ITY"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1", "var2"], "assignments": {"var0": "uFG", "var1": "ior", "var2": "FBX"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1", "var2"], "assignments": {"var0": "EXZ", "var1": "Mrw", "var2": "szZ"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1"], "assignments": {"var0": "Wfq", "var1": "mHT"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1"], "assignments": {"var0": "pRg", "var1": "DzK"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1"], "assignments": {"var0": "JLN", "var1": "mRG"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1"], "assignments": {"var0": "kQz", "var1": "keJ"}}, "output": {"is_valid": true, "is_complete": true}}, {"input": {"variables": ["var0", "var1", "var2"], "assignments": {"var0": "uSl", "var1": "IyG", "var2": "BSa"}}, "output": {"is_valid": true, "is_complete": true}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "viniciusferreiradasilva/generic-csp-solver", "path": "/csp/Csp.py", "msgidx": 10591}}
{"problem_description": "In an airline that uses binary space partitioning to seat passengers, each boarding pass contains a string that specifies the seat location. Given a list of such boarding pass strings, what is the highest seat ID among them?", "io_requirements": "Input:\n  `boarding_passes` (list of strings): A list of boarding pass strings, where each string represents a seat specification using the format \"FBFBBFFRLR\". Each string is exactly 10 characters long, with the first 7 characters indicating the row and the last 3 characters indicating the column.\n\nOutput:\n  `return` (int): The highest seat ID found among the provided boarding passes. The seat ID is calculated by multiplying the row number by 8 and then adding the column number.", "refcode": "import math\n\ndef binary_partition(instructions, left_bound, right_bound, left_step, right_step):\n    for inst in instructions:\n        if inst == left_step:\n            right_bound = left_bound + math.floor((right_bound - left_bound) / 2)\n        elif inst == right_step:\n            left_bound = left_bound + math.ceil((right_bound - left_bound) / 2)\n        else:\n            raise ValueError(f'Unknown instruction {inst} in {instructions}')\n\n    return left_bound\n\ndef parse_row(row_part):\n    instr = list(row_part)\n    left_bound, right_bound = 0, 127\n    return binary_partition(instr, left_bound, right_bound, left_step='F', right_step='B')\n\ndef parse_col(col_part):\n    instr = list(col_part)\n    left_bound, right_bound = 0, 7\n    return binary_partition(instr, left_bound, right_bound, left_step='L', right_step='R')\n\ndef calculate_seat_id(row, col):\n    return row * 8 + col\n\ndef parse_seat_id(line):\n    row_num = parse_row(line[:7])\n    col_num = parse_col(line[7:])\n    return calculate_seat_id(row_num, col_num)\n\ndef main_solution(boarding_passes):\n    seat_ids = [parse_seat_id(bp) for bp in boarding_passes]\n    highest_seat_id = max(seat_ids)\n    return highest_seat_id", "funcname": "main_solution", "ios": [{"input": {"boarding_passes": ["FFFFFFBRLL", "BFFFBFBRRL", "BFFBBBBLRL", "FBFBBFFLLL", "BBBFBBFRLR", "FBBFBBFRLL"]}, "output": 949}, {"input": {"boarding_passes": ["FFFFBBFRRR", "BFFFBFFLRR", "BBFFBBFLRR", "FFFBFBFLLL", "FFBFFFBLRL", "FBFFBFBRRR"]}, "output": 819}, {"input": {"boarding_passes": ["FFBBFFFRRR", "FBBFBBFRLR", "BFBBBFFLLL", "FBFFFBBLRL", "FBBBBBFRLR"]}, "output": 736}, {"input": {"boarding_passes": ["FBBBBFBLLL", "BFFBBBBLRR", "FBFFBFFLRL", "FBBBFFFLRL", "BBFBFBBLRL", "FBFBBBFRRR", "BBFBFBFLRR"]}, "output": 858}, {"input": {"boarding_passes": ["FBBFFFFLLL", "FFBBFFBRRL", "BBBBBFFLLL", "BFBFFBFRLL", "FFFFFBFRRL"]}, "output": 992}, {"input": {"boarding_passes": ["BFFBFBBRLL", "BFBFBBBLLL", "BBFFBBFLRR", "FBBFFBFRLR", "FFBBBFBLRR", "BFFFFBBRRL", "FFBFFBBLLR", "BFFFFBBRLR", "BBFBFFBLLL"]}, "output": 840}, {"input": {"boarding_passes": ["BFFFBFBRLL", "BBBBBFFRRR", "FBBFFBFLLL", "BBBFFFBRRR", "FFFFFFFLRL", "FFFBFBFLLR"]}, "output": 999}, {"input": {"boarding_passes": ["BFFFBFFRLR", "FBFFFBFRRR", "BFFBFBFLLL", "BBFBBBBRLL", "FBFFBFFLRL"]}, "output": 892}, {"input": {"boarding_passes": ["FBBFFFBRRL", "FBBBFFBLRR", "BBFFFFFLLR", "BFBFFBBRRR", "FFFBFBFLLR"]}, "output": 769}, {"input": {"boarding_passes": ["FBFFBBBRRR", "BFBFBBFLLL", "FBFBFFBRLL", "FBBFFFBRLL", "BBFFBFBRRR", "FFBFBFBLRR", "FBBFBBBLRL", "FBFBFBFLLR"]}, "output": 815}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DiscreteObject/adventofcode2020", "path": "/day05.py", "msgidx": 11320}}
{"problem_description": "During a military operation, a group of soldiers finds themselves surrounded by enemy forces. To avoid capture, they decide to form a circle and eliminate every k-th soldier until only one remains. Given the number of soldiers `n` and the elimination step count `k`, what is the position of the last remaining soldier?", "io_requirements": "Input:\n  `n` (int): The number of soldiers standing in a circle.\n  `k` (int): The elimination step count. Every k-th soldier is eliminated.\n\nOutput:\n  `return` (int): The position of the last survivor in the circle.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(n, k):\n    # Convert the input to the required format for the josephus function\n    soldiers = deque(reversed(range(n)))\n    \n    while len(soldiers) > 1:\n        # rotate soldiers k-1 steps\n        soldiers.rotate(k-1)\n        # kth soldier is popped (killed)\n        soldiers.pop()\n    \n    # Convert the output to JSON serializable format\n    return soldiers.pop() + 1", "funcname": "main_solution", "ios": [{"input": {"n": 175, "k": 2}, "output": 95}, {"input": {"n": 499, "k": 6}, "output": 238}, {"input": {"n": 730, "k": 4}, "output": 163}, {"input": {"n": 687, "k": 5}, "output": 46}, {"input": {"n": 874, "k": 9}, "output": 159}, {"input": {"n": 590, "k": 8}, "output": 140}, {"input": {"n": 688, "k": 6}, "output": 158}, {"input": {"n": 561, "k": 2}, "output": 99}, {"input": {"n": 622, "k": 10}, "output": 354}, {"input": {"n": 343, "k": 2}, "output": 175}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ravindra-ut/data-structures-algorithms-coding-competition", "path": "/Number Theory/josepheus.py", "msgidx": 11174}}
{"problem_description": "Given a string consisting of lowercase letters, what are all the unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of all unique permutations of the input string. Each permutation is represented as a string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef All_permutation(s, l, r, result):\n    if l == r:\n        result.append(''.join(s))\n    else:\n        for i in range(l, r + 1):\n            s[i], s[l] = s[l], s[i]\n            All_permutation(s, l + 1, r, result)\n            s[i], s[l] = s[l], s[i]\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    s = list(input_string)\n    # Initialize an empty list to store all permutations\n    result = []\n    # Generate all permutations\n    All_permutation(s, 0, len(s) - 1, result)\n    # Return the result as a list of strings\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "eay"}, "output": ["eay", "eya", "aey", "aye", "yae", "yea"]}, {"input": {"input_string": "tmo"}, "output": ["tmo", "tom", "mto", "mot", "omt", "otm"]}, {"input": {"input_string": "knb"}, "output": ["knb", "kbn", "nkb", "nbk", "bnk", "bkn"]}, {"input": {"input_string": "lag"}, "output": ["lag", "lga", "alg", "agl", "gal", "gla"]}, {"input": {"input_string": "yqa"}, "output": ["yqa", "yaq", "qya", "qay", "aqy", "ayq"]}, {"input": {"input_string": "lbs"}, "output": ["lbs", "lsb", "bls", "bsl", "sbl", "slb"]}, {"input": {"input_string": "hvp"}, "output": ["hvp", "hpv", "vhp", "vph", "pvh", "phv"]}, {"input": {"input_string": "phk"}, "output": ["phk", "pkh", "hpk", "hkp", "khp", "kph"]}, {"input": {"input_string": "xol"}, "output": ["xol", "xlo", "oxl", "olx", "lox", "lxo"]}, {"input": {"input_string": "lzi"}, "output": ["lzi", "liz", "zli", "zil", "izl", "ilz"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vikas9905/python_algo", "path": "/Backtracking/all_permutation_of_string.py", "msgidx": 11403}}
{"problem_description": "\u5c0f\u660e\u53c2\u52a0\u4e86\u4e00\u4e2a\u8da3\u5473\u8fd0\u52a8\u4f1a\uff0c\u5176\u4e2d\u4e00\u4e2a\u9879\u76ee\u662f\u8df3\u683c\u5b50\u3002\u5730\u4e0a\u753b\u7740\u4e00\u4e9b\u683c\u5b50\uff0c\u6bcf\u4e2a\u683c\u5b50\u91cc\u5199\u4e00\u4e2a\u5b57\uff0c\u5982\u4e0b\u6240\u793a\uff1a\n\n\u4ece\u6211\u505a\u8d77\u632f\n\u6211\u505a\u8d77\u632f\u5174\n\u505a\u8d77\u632f\u5174\u4e2d\n\u8d77\u632f\u5174\u4e2d\u534e\n\n\u6bd4\u8d5b\u65f6\uff0c\u5c0f\u660e\u9700\u8981\u4ece\u5de6\u4e0a\u89d2\u7684\u201c\u4ece\u201d\u5b57\u683c\u5b50\u5f00\u59cb\uff0c\u53ef\u4ee5\u6a2a\u5411\u6216\u7eb5\u5411\u8df3\u5230\u76f8\u90bb\u7684\u683c\u5b50\u91cc\uff0c\u4f46\u4e0d\u80fd\u8df3\u5230\u5bf9\u89d2\u7684\u683c\u5b50\u6216\u5176\u5b83\u4f4d\u7f6e\u3002\u4ed6\u9700\u8981\u8df3\u5230\u201c\u534e\u201d\u5b57\u7ed3\u675f\uff0c\u5e76\u4e14\u8df3\u8fc7\u7684\u8def\u7ebf\u521a\u597d\u6784\u6210\u201c\u4ece\u6211\u505a\u8d77\u632f\u5174\u4e2d\u534e\u201d\u8fd9\u53e5\u8bdd\u3002\n\n\u8bf7\u95ee\u5c0f\u660e\u4e00\u5171\u6709\u591a\u5c11\u79cd\u53ef\u80fd\u7684\u8df3\u8dc3\u8def\u7ebf\u5462\uff1f", "io_requirements": "Input:\n  `start_x` (int): The starting x-coordinate on the grid.\n  `start_y` (int): The starting y-coordinate on the grid.\n\nOutput:\n  `return` (int): The number of possible paths from the starting position to the end position on the grid.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef f(x, y):\n    if x == 3 or y == 4:\n        return 1\n    return f(x + 1, y) + f(x, y + 1)\n\n# main function\ndef main_solution(start_x, start_y):\n    # Convert JSON serializable inputs to the original input variables\n    x = int(start_x)\n    y = int(start_y)\n    \n    # Call the original function with the converted inputs\n    result = f(x, y)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"start_x": 0, "start_y": 2}, "output": 10}, {"input": {"start_x": 1, "start_y": 1}, "output": 10}, {"input": {"start_x": 3, "start_y": 0}, "output": 1}, {"input": {"start_x": 2, "start_y": 3}, "output": 2}, {"input": {"start_x": 1, "start_y": 2}, "output": 6}, {"input": {"start_x": 0, "start_y": 3}, "output": 4}, {"input": {"start_x": 2, "start_y": 4}, "output": 1}, {"input": {"start_x": 0, "start_y": 4}, "output": 1}, {"input": {"start_x": 1, "start_y": 3}, "output": 3}, {"input": {"start_x": 3, "start_y": 2}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jingsongliujing/laoqiaobei", "path": "/\u632f\u5174\u4e2d\u534e\u627e\u8def\u5b50.py", "msgidx": 10927}}
{"problem_description": "Given a list of words, what is the longest common sequence of characters that appears at the end of each word?", "io_requirements": "Input:\n  `inpStrings` (list of strings): A list of strings for which the longest common postfix needs to be found.\n\nOutput:\n  `return` (string): The longest common postfix of the input strings.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef findCommon(inp1, inp2):\n    size1 = len(inp1)\n    size2 = len(inp2)\n\n    size = size1 if size1 < size2 else size2\n\n    common = \"\"\n    for i in range(size):\n        if inp1[size1 - 1 - i] == inp2[size2 - 1 - i]:\n            common = inp1[size1 - 1 - i] + common\n        else:\n            break\n\n    return common\n\ndef longest_common_postfix(inpStrings):\n    size = len(inpStrings)\n    \n    if size == 0:\n        return \"\"\n\n    size2 = int(size / 2)\n\n    if size <= 2:\n        if size == 1:\n            return inpStrings[0]\n        else:\n            return findCommon(inpStrings[0], inpStrings[1])\n    else:\n        common1 = longest_common_postfix(inpStrings[0:size2])\n        common2 = longest_common_postfix(inpStrings[size2:size])\n        return findCommon(common1, common2)\n\n# main function\ndef main_solution(inpStrings):\n    # Convert input to list of strings if it's not already\n    if isinstance(inpStrings, str):\n        inpStrings = inpStrings.split()\n    \n    # Call the core function to get the longest common postfix\n    result = longest_common_postfix(inpStrings)\n    \n    # Return the result as a string\n    return result", "funcname": "main_solution", "ios": [{"input": {"inpStrings": ["dvbazoueud", "atigvtz", "kdvltlyxqf", "pkaczrjse", "iwzmllak", "sjnylhk", "nqgyyejnf", "maiizuxxi"]}, "output": ""}, {"input": {"inpStrings": ["jjpgngszjy", "ycbpuiruhw", "jassca", "tlgabii"]}, "output": ""}, {"input": {"inpStrings": ["fmsoowmmi", "euwdfx", "vzdeb", "vxsqitd"]}, "output": ""}, {"input": {"inpStrings": ["jcijtcjkgd", "ekhnpl", "levyr", "jhzcii", "wycfkw"]}, "output": ""}, {"input": {"inpStrings": ["aehvath", "xgbfonjm", "avocdxw", "ixkbqd", "hlpyfsrgt", "pxvwdttjwd", "shonaqysqz"]}, "output": ""}, {"input": {"inpStrings": ["pbmbwik", "xqfbjtm", "haqzdkamo", "laikzh", "wizdngdm", "buztitckd", "vbpubxyxlx"]}, "output": ""}, {"input": {"inpStrings": ["yfvmejoclf", "xncpv", "nqxdyorhw", "usups", "neajv", "ggktmzyvh", "cdlbrqxw", "mwymwj", "vvmxdwkz"]}, "output": ""}, {"input": {"inpStrings": ["nbjnuq", "ichumhps", "edpzotp", "ocyznicg", "srgmfoc", "daqdwb", "lfjrwc"]}, "output": ""}, {"input": {"inpStrings": ["extfujim", "oudqgmhmtg", "ltfen", "mqkffb", "rqiqqzzxqj", "umniflpt", "gekiek"]}, "output": ""}, {"input": {"inpStrings": ["ctwaovbmyh", "vskkyfl"]}, "output": ""}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "furkanaktas/CSE-321", "path": "/hw4/lcp_141044029.py", "msgidx": 10703}}
{"problem_description": "In a game of Tic-Tac-Toe, given an initial board configuration and the player who starts first, what will be the final state of the board and the outcome of the game?", "io_requirements": "Input:\n  `initial_state` (list of int): A list of 9 integers representing the initial state of the Tic-Tac-Toe board. Each integer can be 0 (empty), 1 (COMP's move), or -1 (HUMAN's move).\n  `first_player` (int): An integer representing who plays first. 0 means HUMAN plays first, and 1 means COMP plays first.\n\nOutput:\n  `return` (dict): A dictionary containing the final state of the board and the result of the game.\n    - `final_state` (list of int): A list of 9 integers representing the final state of the Tic-Tac-Toe board.\n    - `result` (int): An integer representing the result of the game. 1 means COMP wins, -1 means HUMAN wins, and 0 means a draw.", "refcode": "# import necessary packages\nfrom math import inf as infinity\nimport copy\n\nCOMP = 1\nHUMAN = -1\n\ndef children_states(state, player):\n    turn = player\n    children = []\n    for i in range(9):\n        if state[i] == 0:\n            children +=  [tuple(state[j]  if j!=i else turn for j in range(9))]\n    return children\n\nThree_aligned = {(0,1,2),(3,4,5),(6,7,8),(0,3,6),(1,4,7),(2,5,8),(0,4,8),(2,4,6)}\n\ndef eval_win(state, player):\n    for (i,j,k) in Three_aligned:\n        if state[i] != 0 and state[i] == state[j] and state[j] == state[k]:\n            return state[i]\n    for i in range(9):\n        if state[i] == 0:\n            return children_states(state, player)\n    return 0\n\ndef horizontalMirror(state):\n    return (state[6],state[7],state[8],state[3],state[4],state[5],state[0],state[1],state[2])\n\ndef verticalMirror(state):\n    return (state[2],state[1],state[0],state[5],state[4],state[3],state[8],state[7],state[6])\n\ndef turn90(state):    \n    return (state[6],state[3],state[0],state[7],state[4],state[1],state[8],state[5],state[2])\n\ndef symmetryInTree(state):\n    if state in Tree:\n        return state\n    if horizontalMirror(state) in Tree:\n        return horizontalMirror(state)\n    if verticalMirror(state) in Tree:\n        return verticalMirror(state)\n    state = turn90(state)\n    if state in Tree:\n        return state\n    state = turn90(state)\n    if state in Tree:\n        return state\n    state = turn90(state)\n    if state in Tree:\n        return state\n    return False\n\ndef minimax(current_state, player):\n    global Scores\n    children = eval_win(current_state, player)\n    if type(children) == int:\n        score = children\n    else:\n        turn = player\n        score = -turn\n        for child_state in children:\n            result = symmetryInTree(child_state)\n            if type(result) == bool:\n                minimax(child_state, -player)\n                score = max(score,Scores[child_state]) if turn == COMP else min(score,Scores[child_state])\n            else :\n                score = max(score,Scores[result]) if turn == COMP else min(score,Scores[result])\n    Tree[current_state] = children\n    Scores[current_state] = score\n\n# main function\ndef main_solution(initial_state, first_player):\n    global Tree, Scores\n    Tree = {}\n    Scores = {}\n    \n    initial_state = tuple(initial_state)\n    first_player = int(first_player)\n    \n    if first_player == 0:\n        minimax(initial_state, HUMAN)\n    else:\n        minimax(initial_state, COMP)\n    \n    if first_player == 1:\n        children = eval_win(initial_state, COMP)\n        best = -infinity\n        best_index = None\n        for c in children:\n            result = symmetryInTree(c)\n            if Scores[result] > best:\n                best = Scores.get(result)\n                best_index = c\n        initial_state = best_index\n    \n    while type(eval_win(initial_state, COMP)) != int:\n        children = eval_win(initial_state, HUMAN)\n        best = infinity\n        best_index = None\n        for c in children:\n            result = symmetryInTree(c)\n            if Scores[result] < best:\n                best = Scores.get(result)\n                best_index = c\n        initial_state = best_index\n        \n        if type(eval_win(initial_state, HUMAN)) == int:\n            break\n        \n        children = eval_win(initial_state, COMP)\n        best = -infinity\n        best_index = None\n        for c in children:\n            result = symmetryInTree(c)\n            if Scores[result] > best:\n                best = Scores.get(result)\n                best_index = c\n        initial_state = best_index\n    \n    score = eval_win(initial_state, COMP)\n    return {\"final_state\": list(initial_state), \"result\": score}", "funcname": "main_solution", "ios": [{"input": {"initial_state": [0, 0, 0, 0, 1, 1, 0, 0, 0], "first_player": 0}, "output": {"final_state": [-1, 1, -1, 1, 1, 1, 0, 0, 0], "result": 1}}, {"input": {"initial_state": [-1, 0, -1, 0, 0, 0, 0, 1, -1], "first_player": 0}, "output": {"final_state": [-1, -1, -1, 0, 0, 0, 0, 1, -1], "result": -1}}, {"input": {"initial_state": [1, -1, -1, 0, -1, 0, 0, 0, 0], "first_player": 0}, "output": {"final_state": [1, -1, -1, -1, -1, 1, -1, 0, 0], "result": -1}}, {"input": {"initial_state": [0, 0, 0, 0, 0, 0, -1, -1, 0], "first_player": 1}, "output": {"final_state": [1, -1, 1, -1, 1, 0, -1, -1, -1], "result": -1}}, {"input": {"initial_state": [0, 0, 1, 1, 0, 0, 0, 0, 0], "first_player": 1}, "output": {"final_state": [1, -1, 1, 1, 1, -1, 1, 0, 0], "result": 1}}, {"input": {"initial_state": [-1, 0, 0, 1, 1, 0, -1, 0, 0], "first_player": 0}, "output": {"final_state": [-1, 1, -1, 1, 1, -1, -1, -1, 1], "result": 0}}, {"input": {"initial_state": [0, -1, -1, 0, 0, -1, 0, -1, 0], "first_player": 0}, "output": {"final_state": [-1, -1, -1, 0, 0, -1, 0, -1, 0], "result": -1}}, {"input": {"initial_state": [0, 0, -1, 0, 0, 0, 0, 0, -1], "first_player": 0}, "output": {"final_state": [-1, 1, -1, -1, 1, -1, 0, 0, -1], "result": -1}}, {"input": {"initial_state": [0, 0, 0, 0, 0, 0, 0, 0, 0], "first_player": 0}, "output": {"final_state": [-1, -1, 1, 1, 1, -1, -1, 1, -1], "result": 0}}, {"input": {"initial_state": [-1, 0, 0, 0, 0, 0, 0, 1, -1], "first_player": 1}, "output": {"final_state": [-1, -1, 1, 1, 1, -1, -1, 1, -1], "result": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rvende/TicTacToe", "path": "/main.py", "msgidx": 10597}}
{"problem_description": "Given a set of airline tickets with unordered source and destination airports, how can we arrange them into a correct itinerary order, starting from a valid source airport and ending at a valid destination airport?", "io_requirements": "Input:\n  `unorderedTickets` (str): A JSON string representing a dictionary where keys are source airports and values are destination airports.\n\nOutput:\n  `return` (str): A JSON string representing a list of tuples. Each tuple contains a source airport and its corresponding destination airport in the correct itinerary order. If no valid itinerary can be formed, it returns an empty list.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef arrangeItinerary(unorderedTickets):\n    if not unorderedTickets:\n        return None\n\n    sources = sorted(unorderedTickets.keys())\n    destinations = sorted(unorderedTickets.values())\n\n    startPoints = [src for src in sources if src not in destinations]\n\n    if len(startPoints) > 1:\n        return None  # Ambiguous start point\n\n    if len(startPoints) == 0:\n        return None  # No valid start point\n\n    temp = startPoints[0]\n    visited = [temp]\n    itinerary = []\n\n    while unorderedTickets.get(temp):\n        dst = unorderedTickets[temp]\n        if dst in visited:\n            break\n        visited.append(dst)\n        itinerary.append((temp, dst))\n        temp = dst\n\n    return itinerary\n\n# main function\ndef main_solution(unorderedTickets):\n    # Convert JSON serializable input to the original input format\n    unorderedTickets = json.loads(unorderedTickets)\n\n    # Call the arrangeItinerary function\n    itinerary = arrangeItinerary(unorderedTickets)\n\n    # Convert the output to JSON serializable format\n    if itinerary is None:\n        return json.dumps([])\n    return json.dumps(itinerary)", "funcname": "main_solution", "ios": [{"input": {"unorderedTickets": "{\"SFO\": \"DFW\", \"ORD\": \"LAX\", \"ZAW\": \"ATL\", \"LAX\": \"ZAW\", \"ATL\": \"IAD\", \"DFW\": \"LAX\", \"IAD\": \"ZAW\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"IAD\": \"ATL\", \"LAX\": \"ZAW\", \"DEN\": \"SFO\", \"DFW\": \"DEN\", \"SD\": \"ORD\", \"JFK\": \"ATL\", \"SFO\": \"LAX\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"SFO\": \"ATL\", \"ATL\": \"LAX\", \"JFK\": \"SFO\"}"}, "output": "[[\"JFK\", \"SFO\"], [\"SFO\", \"ATL\"], [\"ATL\", \"LAX\"]]"}, {"input": {"unorderedTickets": "{\"DEN\": \"SFO\", \"ZAW\": \"SFO\", \"JFK\": \"DFW\", \"SD\": \"ZAW\", \"IAD\": \"SFO\", \"LAX\": \"IAD\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"DEN\": \"IAD\", \"LAX\": \"SD\", \"DFW\": \"SD\", \"ATL\": \"ORD\", \"SFO\": \"DFW\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"ZAW\": \"ORD\", \"IAD\": \"DEN\", \"SD\": \"ZAW\", \"ORD\": \"SFO\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"DFW\": \"SD\", \"JFK\": \"DFW\", \"ATL\": \"IAD\", \"LAX\": \"SFO\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"SFO\": \"DFW\", \"DEN\": \"SFO\", \"IAD\": \"JFK\", \"SD\": \"ORD\", \"ZAW\": \"SD\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"ATL\": \"SD\", \"SFO\": \"DEN\", \"DFW\": \"ATL\", \"LAX\": \"SFO\", \"SD\": \"SFO\"}"}, "output": "[]"}, {"input": {"unorderedTickets": "{\"SD\": \"IAD\", \"ORD\": \"DFW\", \"JFK\": \"LAX\", \"IAD\": \"SFO\"}"}, "output": "[]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "keshy/CodeKata", "path": "/src/code/kata/companies/FlightConnectionPath.py", "msgidx": 10497}}
{"problem_description": "Given a number, what is the largest prime number that is also a palindrome and is less than the given number?", "io_requirements": "Input:\n  `upper_limit` (int): The upper limit under which to find the biggest prime palindrome.\n\nOutput:\n  `return` (int): The biggest prime palindrome found under the given `upper_limit`. If no such number exists, returns `None`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    m = int(math.sqrt(num))\n    for i in range(3, m+1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef is_palindrome(s):\n    return str(s) == str(s)[::-1]\n\n# main function\ndef main_solution(upper_limit):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  for i in range(upper_limit-1, 1, -1):\n      if is_prime(i) and is_palindrome(i):\n          return i\n  return None", "funcname": "main_solution", "ios": [{"input": {"upper_limit": 581}, "output": 383}, {"input": {"upper_limit": 929}, "output": 919}, {"input": {"upper_limit": 622}, "output": 383}, {"input": {"upper_limit": 418}, "output": 383}, {"input": {"upper_limit": 198}, "output": 191}, {"input": {"upper_limit": 232}, "output": 191}, {"input": {"upper_limit": 850}, "output": 797}, {"input": {"upper_limit": 962}, "output": 929}, {"input": {"upper_limit": 724}, "output": 383}, {"input": {"upper_limit": 921}, "output": 919}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "michaelrbock/codeeval", "path": "/easy/prime_palindrome.py", "msgidx": 10866}}
{"problem_description": "Given a sequence of logical statements, where each statement implies the next, determine whether the entire sequence of implications holds true. What is the result of the multiple implication for the given sequence of boolean values?", "io_requirements": "Input:\n  `lst` (list of bool): A list of boolean values representing the logical variables. The list can be empty, in which case the function should return `None`.\n\nOutput:\n  `return` (bool or None): The result of the multiple implication calculation. Returns `True` if the implication holds for the entire list, `False` otherwise. Returns `None` if the input list is empty.", "refcode": "# import necessary packages\nfrom functools import reduce\n\n# main function\ndef main_solution(lst):\n    # Convert the input list to a list of boolean values if it's not already\n    lst = [bool(item) for item in lst]\n    \n    # Calculate the multiple implication\n    result = reduce(lambda p, q: not p or q, lst) if lst else None\n    \n    # Return the result as a boolean or None if the list is empty\n    return result", "funcname": "main_solution", "ios": [{"input": {"lst": [true, false, false, true, false, true, false]}, "output": false}, {"input": {"lst": [true, true, false, true, true, true, false]}, "output": false}, {"input": {"lst": [true, false, true, false, false]}, "output": true}, {"input": {"lst": [true, false, false, true]}, "output": true}, {"input": {"lst": [false]}, "output": false}, {"input": {"lst": [false, false, false, false, true]}, "output": true}, {"input": {"lst": [true]}, "output": true}, {"input": {"lst": [false, true]}, "output": true}, {"input": {"lst": [true, true, true, false, false]}, "output": true}, {"input": {"lst": [true, true, false, true, true, true, true, false]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "krnets/codewars-practice", "path": "/7kyu/Multiple implications/index.py", "msgidx": 11474}}
{"problem_description": "Given a sequence of parentheses, how can we determine if the parentheses are balanced and properly nested? Specifically, for a given string containing only the characters '(', ')', '{', '}', '[', and ']', what is the result of checking whether the parentheses are balanced?", "io_requirements": "Input:\n  `s` (str): A string containing only the characters '(', ')', '{', '}', '[', and ']'. The string represents a sequence of parentheses to be checked for balance.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string `s` has balanced parentheses. Returns `True` if the parentheses are balanced, otherwise `False`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def isValid(self, s):\n        openParens = ['(', '{', '[']\n        closingParens = [')', '}', ']']\n        stack = []\n        for char in s:\n            if char in openParens:\n                stack.append(char)\n            elif char in closingParens:\n                if len(stack) <= 0:\n                    return False\n                if openParens.index(stack.pop()) != closingParens.index(char):\n                    return False\n        return len(stack) == 0\n\n# main function\ndef main_solution(s):\n    # Convert the input string to a JSON serializable type if necessary\n    # In this case, the input is already a string, so no conversion is needed\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the isValid method to check if the parentheses are balanced\n    result = solution.isValid(s)\n    \n    # Convert the result to a JSON serializable type if necessary\n    # In this case, the result is a boolean, so no conversion is needed\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"s": ""}, "output": true}, {"input": {"s": "{(}[{("}, "output": false}, {"input": {"s": "))[[[])"}, "output": false}, {"input": {"s": "("}, "output": false}, {"input": {"s": "{]]{(]]]["}, "output": false}, {"input": {"s": "][(["}, "output": false}, {"input": {"s": "][[(]}{[}"}, "output": false}, {"input": {"s": "}])}]{]"}, "output": false}, {"input": {"s": "{([((}[]}("}, "output": false}, {"input": {"s": "]([)(]"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Rahulk1p/python-Questions", "path": "/Prob4.py", "msgidx": 11120}}
{"problem_description": "In the Game of Life, a cellular automaton devised by the British mathematician John Conway, cells on a grid evolve over discrete time steps according to specific rules. Given an initial configuration of a grid where each cell is either dead (0) or alive (1), what will be the state of the grid after one iteration of the Game of Life rules?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the initial state of the game board. Each element in the list is either 0 (dead cell) or 1 (alive cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the state of the game board after one iteration of the Game of Life rules. Each element in the list is either 0 (dead cell) or 1 (alive cell).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        We will keep 0 and 1 as dead and alive, respectively.\n        And we will add 2 and 3 as dead -> alive, and alive -> dead,\n        respectively.\n        \"\"\"\n        nei = [[-1, -1], [0, -1], [1, -1],\n               [-1, 0], [1, 0],\n               [-1, 1], [0, 1], [1, 1]]\n\n        def next_interation(board: List[List[int]], i: int, j: int) -> int:\n            begin_with = board[i][j]\n            count = 0\n            for di, dj in nei:\n                if 0 <= i + di < len(board) and 0 <= j + dj < len(board[0]):\n                    count += board[i + di][j + dj] % 2\n\n            if begin_with == 0 and count == 3:\n                return 2\n            elif begin_with == 1 and (count not in [2, 3]):\n                return 3\n            return begin_with\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                board[i][j] = next_interation(board, i, j)\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 2:\n                    board[i][j] = 1\n                elif board[i][j] == 3:\n                    board[i][j] = 0\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    solution.gameOfLife(board)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return board", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0]]}, "output": [[1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0]]}, {"input": {"board": [[0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 1], [0, 0, 1, 1]]}, "output": [[0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 1], [0, 0, 1, 1]]}, {"input": {"board": [[0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 0]]}, "output": [[0, 0, 0], [0, 1, 0], [0, 0, 0], [1, 0, 0], [0, 0, 0]]}, {"input": {"board": [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1], [1, 0, 1, 0], [1, 0, 0, 1], [1, 0, 1, 0]]}, "output": [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1], [1, 0, 1, 0], [1, 0, 0, 1], [1, 0, 1, 0]]}, {"input": {"board": [[1, 1, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0], [0, 0, 1], [1, 0, 1]]}, "output": [[1, 1, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0], [0, 0, 1], [1, 0, 1]]}, {"input": {"board": [[1, 0, 0], [1, 0, 1], [1, 0, 1], [0, 0, 0]]}, "output": [[1, 0, 0], [1, 0, 1], [1, 0, 1], [0, 0, 0]]}, {"input": {"board": [[0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 0]]}, "output": [[0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 0]]}, {"input": {"board": [[0, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 0], [0, 1, 1, 0, 0]]}, "output": [[0, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 0], [0, 1, 1, 0, 0]]}, {"input": {"board": [[0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1]]}, "output": [[0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1]]}, {"input": {"board": [[0, 1, 1, 1], [0, 0, 1, 1], [0, 1, 1, 1], [0, 0, 0, 0]]}, "output": [[0, 1, 1, 1], [0, 0, 1, 1], [0, 1, 1, 1], [0, 0, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "inverseTrig/leet_code", "path": "/289_game_of_life.py", "msgidx": 10656}}
{"problem_description": "Given a partially filled 4x4 Sudoku puzzle, where each cell can contain a number between 1 and 4, and 0 represents an empty cell, what is the fully solved state of the puzzle?", "io_requirements": "Input:\n  `numbers` (list of lists of integers): A 4x4 grid representing a partially filled Sudoku puzzle. Each element in the grid is an integer between 0 and 4, where 0 represents an empty cell.\n\nOutput:\n  `return` (list of lists of integers): A 4x4 grid representing the solved Sudoku puzzle. Each element in the grid is an integer between 1 and 4.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list to a numpy array\n    Numbers = np.array(numbers)\n    \n    while(0 in Numbers):\n        for x in range(4): #\u6a2a\u4e00\u5217\n            for y in range(4): #\u7e26\u4e00\u5217\n                if(x == 0 or x == 1): #\u30d6\u30ed\u30c3\u30af\u306e\u914d\u5206\n                    if(y == 0 or y == 1):\n                        block = 1\n                    else:\n                        block = 2\n                else:\n                    if(y == 0 or y == 1):\n                        block = 3\n                    else:\n                        block = 4\n\n                imNum = [1, 2, 3, 4]\n\n                for a in range(1, 5):\n                    if(block == 1):\n                        if(a in Numbers[x] or a in Numbers[:, y] or\n                           a in Numbers[:2, :2]):\n                            imNum.remove(a)\n                    elif(block == 2):\n                        if(a in Numbers[x] or a in Numbers[:, y] or\n                           a in Numbers[:2, 2:4]):\n                            imNum.remove(a)\n                    elif(block == 3):\n                        if(a in Numbers[x] or a in Numbers[:, y] or\n                           a in Numbers[2:4, :2]):\n                            imNum.remove(a)\n                    else:\n                        if(a in Numbers[x] or a in Numbers[:, y] or\n                           a in Numbers[2:4, 2:4]):\n                            imNum.remove(a)\n\n                    if(len(imNum) == 1):\n                        if(Numbers[x][y] == 0):\n                            Numbers[x][y] = imNum[0]\n                    else:\n                        pass\n\n    # Convert the numpy array back to a list of lists for JSON serialization\n    return Numbers.tolist()", "funcname": "main_solution", "ios": [{"input": {"numbers": [[1, 3, 0, 1], [4, 1, 4, 1], [0, 4, 2, 2], [3, 1, 0, 1]]}, "output": [[1, 3, 4, 1], [4, 1, 4, 1], [4, 4, 2, 2], [3, 1, 4, 1]]}, {"input": {"numbers": [[3, 4, 0, 4], [3, 3, 2, 2], [3, 1, 4, 1], [4, 4, 3, 2]]}, "output": [[3, 4, 1, 4], [3, 3, 2, 2], [3, 1, 4, 1], [4, 4, 3, 2]]}, {"input": {"numbers": [[3, 0, 4, 2], [2, 0, 2, 4], [2, 1, 2, 0], [2, 4, 4, 2]]}, "output": [[3, 4, 4, 2], [2, 4, 2, 4], [2, 1, 2, 3], [2, 4, 4, 2]]}, {"input": {"numbers": [[0, 1, 4, 3], [4, 3, 1, 3], [1, 1, 4, 2], [3, 1, 0, 4]]}, "output": [[2, 1, 4, 3], [4, 3, 1, 3], [1, 1, 4, 2], [3, 1, 4, 4]]}, {"input": {"numbers": [[4, 4, 4, 2], [1, 4, 2, 4], [2, 1, 4, 3], [2, 0, 3, 4]]}, "output": [[4, 4, 4, 2], [1, 4, 2, 4], [2, 1, 4, 3], [2, 4, 3, 4]]}, {"input": {"numbers": [[2, 3, 4, 3], [1, 1, 0, 4], [4, 2, 0, 3], [1, 1, 1, 2]]}, "output": [[2, 3, 4, 3], [1, 1, 2, 4], [4, 2, 4, 3], [1, 1, 1, 2]]}, {"input": {"numbers": [[4, 0, 0, 0], [0, 3, 4, 1], [4, 4, 2, 2], [4, 2, 0, 0]]}, "output": [[4, 1, 3, 4], [2, 3, 4, 1], [4, 4, 2, 2], [4, 2, 1, 3]]}, {"input": {"numbers": [[0, 4, 0, 1], [4, 0, 2, 4], [4, 4, 1, 4], [0, 1, 0, 4]]}, "output": [[2, 4, 3, 1], [4, 3, 2, 4], [4, 4, 1, 4], [3, 1, 4, 4]]}, {"input": {"numbers": [[2, 4, 1, 2], [3, 4, 3, 1], [3, 2, 3, 1], [3, 3, 1, 0]]}, "output": [[2, 4, 1, 2], [3, 4, 3, 1], [3, 2, 3, 1], [3, 3, 1, 4]]}, {"input": {"numbers": [[1, 4, 3, 0], [1, 2, 3, 1], [0, 1, 3, 2], [0, 3, 4, 0]]}, "output": [[1, 4, 3, 4], [1, 2, 3, 1], [4, 1, 3, 2], [2, 3, 4, 4]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "takerunkoritta/nampre", "path": "/test.py", "msgidx": 11000}}
{"problem_description": "In a survey, a group of people are asked a series of questions, and each person answers 'yes' to a subset of these questions. Given the list of questions each group member answered 'yes' to, how many questions did every member of the group answer 'yes' to?", "io_requirements": "Input:\n  `group_answers` (list of strings): A list where each string represents the answers of a group member. Each string contains lowercase letters representing the questions each member answered 'yes' to.\n\nOutput:\n  `return` (int): The number of questions that every member in the group answered 'yes' to.", "refcode": "# import necessary packages\nimport string\n\n# main function\ndef main_solution(group_answers):\n    # Convert the input list of strings into a list of sets\n    group_sets = [set(answer) for answer in group_answers]\n    \n    # Find the intersection of all sets in the group\n    common_answers = set.intersection(*group_sets)\n    \n    # Return the number of common answers\n    return len(common_answers)", "funcname": "main_solution", "ios": [{"input": {"group_answers": ["ixybyovhrz", "g", "vnctkixpb", "gjgtvk", "fpb"]}, "output": 0}, {"input": {"group_answers": ["v", "etntpsbzc", "kxua", "uudzj", "igm"]}, "output": 0}, {"input": {"group_answers": ["ryqblq", "niw", "u"]}, "output": 0}, {"input": {"group_answers": ["rpe"]}, "output": 3}, {"input": {"group_answers": ["aqrtt"]}, "output": 4}, {"input": {"group_answers": ["qbtwstbvat", "ghxh", "mefixl", "nzdduryhi", "iwi"]}, "output": 0}, {"input": {"group_answers": ["oqrexfvpbx", "by"]}, "output": 1}, {"input": {"group_answers": ["eas", "upgpbmd", "nldu", "xjd"]}, "output": 0}, {"input": {"group_answers": ["heyrl"]}, "output": 5}, {"input": {"group_answers": ["nroecm", "aswum", "dqaxdw"]}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "briannaf/aoc2020", "path": "/day_6/day6_part2.py", "msgidx": 11583}}
{"problem_description": "Given a recursive algorithm that generates a dragon curve, what are the coordinates of the points that form the curve at a specified recursion level and angle? The recursion level determines the complexity of the curve, and the angle affects the shape of the curve.", "io_requirements": "Input:\n  `level` (int): The level of recursion for generating the dragon curve. Must be a non-negative integer.\n  `alpha` (float): The angle in radians used in the transformation of points. Must be a float value.\n\nOutput:\n  `return` (list of lists of floats): A list of points representing the dragon curve. Each point is a list containing two float values representing the x and y coordinates.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef generate_dragon(level, alpha=np.pi / 4):\n    if level == 0:\n        return [[0.0, 0.0], [10.0, 10.0]]\n    sub_points = generate_dragon(level - 1)  # \u83b7\u5f97level-1\u7684\u70b9\n    cos_alp = np.cos(alpha)\n    sin_alp = np.sin(alpha)\n    new_points = []                          # \u65b0\u7684\u6570\u636e\u70b9\n    for i in range(len(sub_points) - 1):\n        x1 = sub_points[i][0]\n        y1 = sub_points[i][1]\n        x2 = sub_points[i + 1][0]\n        y2 = sub_points[i + 1][1]    \n        if i % 2 == 0:\n            new_x = 0.707 * (cos_alp * (x2 - x1) + sin_alp * (y2 - y1)) + x1\n            new_y = 0.707 * (-sin_alp * (x2 - x1) + cos_alp * (y2 - y1)) + y1\n        else:\n            new_x = 0.707 * (cos_alp * (x2 - x1) - sin_alp * (y2 - y1)) + x1\n            new_y = 0.707 * (sin_alp * (x2 - x1) + cos_alp * (y2 - y1)) + y1\n        new_points.append([x1, y1])\n        new_points.append([new_x, new_y])\n    new_points.append([x2, y2])\n    return new_points\n\n# main function\ndef main_solution(level, alpha):\n    # Convert JSON serializable inputs to the original input variables\n    alpha = float(alpha)\n    level = int(level)\n    \n    # Generate the dragon curve points\n    points = generate_dragon(level, alpha)\n    \n    # Convert the output to JSON serializable format\n    points_serializable = [[float(x), float(y)] for x, y in points]\n    \n    return points_serializable", "funcname": "main_solution", "ios": [{"input": {"level": 0, "alpha": 1.7484740003960582}, "output": [[0.0, 0.0], [10.0, 10.0]]}, {"input": {"level": 2, "alpha": 3.128833820677916}, "output": [[0.0, 0.0], [-7.068356989157686, -0.09018887972289866], [9.998489885977781, 6.279421427279885e-16], [9.907219820934042, -7.069410931266108], [10.0, 10.0]]}, {"input": {"level": 2, "alpha": 1.2885048278317326}, "output": [[0.0, 0.0], [1.9691018510319078, -6.789141511300431], [9.998489885977781, 6.279421427279885e-16], [3.208620383794564, 1.970424645400087], [10.0, 10.0]]}, {"input": {"level": 2, "alpha": 1.5058676798873136}, "output": [[0.0, 0.0], [0.45865379392648675, -7.0540372310838295], [9.998489885977781, 6.279421427279885e-16], [2.9434565263661483, 0.45978846728124795], [10.0, 10.0]]}, {"input": {"level": 1, "alpha": 2.3591145749485296}, "output": [[0.0, 0.0], [-0.029196396408434834, -9.99844725797145], [10.0, 10.0]]}, {"input": {"level": 2, "alpha": 0.33057810665427967}, "output": [[0.0, 0.0], [6.686183975411028, -2.2945039566661842], [9.998489885977781, 6.279421427279885e-16], [7.7046492232342825, 6.687540366519093], [10.0, 10.0]]}, {"input": {"level": 2, "alpha": 1.2111322713432184}, "output": [[0.0, 0.0], [2.4879800439437565, -6.616627529273324], [9.998489885977781, 6.279421427279885e-16], [3.3812387896926897, 2.4893551511569365], [10.0, 10.0]]}, {"input": {"level": 0, "alpha": 0.21742162796419962}, "output": [[0.0, 0.0], [10.0, 10.0]]}, {"input": {"level": 2, "alpha": 0.707335646454076}, "output": [[0.0, 0.0], [5.373066480838292, -4.593469402607574], [9.998489885977781, 6.279421427279885e-16], [5.405138229199121, 5.37457176871298], [10.0, 10.0]]}, {"input": {"level": 1, "alpha": 2.166974020523766}, "output": [[0.0, 0.0], [1.8806493134710895, -9.820028419497609], [10.0, 10.0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lxcnju/fractals_py_p5", "path": "/draw_dragon.py", "msgidx": 11087}}
{"problem_description": "Given a k-ary tree represented in JSON format, determine whether the tree is symmetrical. A k-ary tree is symmetrical if the data of the left side of the tree is the same as the right side of the tree. What is the result of checking the symmetry of the given k-ary tree?", "io_requirements": "Input:\n  `tree_json` (str): A JSON string representing the k-ary tree. The JSON structure should be a dictionary with keys:\n    - `value` (int): The value of the current node.\n    - `children` (list of dict): A list of dictionaries representing the children of the current node. Each child dictionary follows the same structure.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the k-ary tree is symmetric (`True`) or not (`False`).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node():\n    def __init__(self, value, children=[]):\n        self.value = value\n        self.children = children\n\ndef is_symmetric(root):\n    queue = [root]\n    while queue:\n        values = [i.value if i else None for i in queue]\n        if values != values[::-1]: return False\n        queue = [child for i in queue if i for child in i.children]\n    return True\n\n# main function\ndef main_solution(tree_json):\n    # Convert JSON input to a tree structure\n    def json_to_tree(json_data):\n        if json_data is None:\n            return None\n        node = Node(json_data['value'])\n        node.children = [json_to_tree(child) for child in json_data['children']]\n        return node\n    \n    tree = json_to_tree(json.loads(tree_json))\n    \n    # Check if the tree is symmetric\n    result = is_symmetric(tree)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_json": "{\"value\": 82, \"children\": [{\"value\": 53, \"children\": []}, {\"value\": 95, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 89, \"children\": [{\"value\": 31, \"children\": []}, {\"value\": 78, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 88, \"children\": [{\"value\": 93, \"children\": []}, {\"value\": 38, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 32, \"children\": [{\"value\": 30, \"children\": []}, {\"value\": 86, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 36, \"children\": [{\"value\": 52, \"children\": []}, {\"value\": 27, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 84, \"children\": [{\"value\": 98, \"children\": []}, {\"value\": 16, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 88, \"children\": [{\"value\": 64, \"children\": []}, {\"value\": 11, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 34, \"children\": [{\"value\": 57, \"children\": []}, {\"value\": 39, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 50, \"children\": [{\"value\": 17, \"children\": []}, {\"value\": 69, \"children\": []}]}"}, "output": false}, {"input": {"tree_json": "{\"value\": 53, \"children\": [{\"value\": 55, \"children\": []}, {\"value\": 52, \"children\": []}]}"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhukaijun0629/Programming_Daily-Practice", "path": "/2020-12-04_Symmetric-k-ary-Tree.py", "msgidx": 10677}}
{"problem_description": "A car rental company has received numerous requests for renting a particular car for the next year. Each request is represented by a tuple indicating the start and end days of the rental period. The company wants to maximize the number of requests it can fulfill. Given the number of requests and the corresponding start and end days for each request, how many requests can the company fulfill, and what are the specific rental periods that maximize the number of fulfilled requests?", "io_requirements": "Input:\n  `n` (int): The number of requests.\n  `start_days` (list of int): A list of integers representing the starting days of the renting periods.\n  `end_days` (list of int): A list of integers representing the ending days of the renting periods.\nOutput:\n  `return` (str): A JSON string containing the maximum number of feasible requests and the list of these requests. The JSON structure is as follows:\n    - `max_requests` (int): The maximum number of feasible requests.\n    - `requests` (list of tuples): A list of tuples where each tuple represents a feasible request (start_day, end_day).", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef max_requests(requests):\n    # Sort requests by their end day\n    requests.sort(key=lambda x: x[1])\n    selected_requests = []\n    last_end_day = -1\n    \n    for request in requests:\n        if request[0] > last_end_day:\n            selected_requests.append(request)\n            last_end_day = request[1]\n    \n    return selected_requests\n\n# main function\ndef main_solution(n, start_days, end_days):\n    # Convert input lists to a list of tuples representing requests\n    requests = [(start_days[i], end_days[i]) for i in range(n)]\n    \n    # Get the maximum number of feasible requests\n    selected_requests = max_requests(requests)\n    \n    # Convert the result to a JSON serializable format\n    result = {\n        \"max_requests\": len(selected_requests),\n        \"requests\": selected_requests\n    }\n    \n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"n": 5, "start_days": [348, 23, 242, 282, 332], "end_days": [364, 360, 280, 294, 342]}, "output": "{\"max_requests\": 4, \"requests\": [[242, 280], [282, 294], [332, 342], [348, 364]]}"}, {"input": {"n": 5, "start_days": [166, 208, 346, 170, 174], "end_days": [328, 277, 347, 314, 203]}, "output": "{\"max_requests\": 3, \"requests\": [[174, 203], [208, 277], [346, 347]]}"}, {"input": {"n": 5, "start_days": [125, 148, 353, 287, 326], "end_days": [280, 296, 365, 350, 348]}, "output": "{\"max_requests\": 3, \"requests\": [[125, 280], [326, 348], [353, 365]]}"}, {"input": {"n": 5, "start_days": [177, 337, 238, 178, 277], "end_days": [186, 353, 356, 219, 355]}, "output": "{\"max_requests\": 2, \"requests\": [[177, 186], [337, 353]]}"}, {"input": {"n": 5, "start_days": [341, 149, 244, 69, 117], "end_days": [343, 330, 282, 283, 167]}, "output": "{\"max_requests\": 3, \"requests\": [[117, 167], [244, 282], [341, 343]]}"}, {"input": {"n": 5, "start_days": [166, 166, 334, 182, 268], "end_days": [315, 315, 357, 302, 349]}, "output": "{\"max_requests\": 2, \"requests\": [[182, 302], [334, 357]]}"}, {"input": {"n": 5, "start_days": [292, 170, 90, 20, 56], "end_days": [304, 297, 209, 122, 92]}, "output": "{\"max_requests\": 2, \"requests\": [[56, 92], [170, 297]]}"}, {"input": {"n": 5, "start_days": [358, 96, 196, 18, 130], "end_days": [359, 281, 198, 161, 246]}, "output": "{\"max_requests\": 3, \"requests\": [[18, 161], [196, 198], [358, 359]]}"}, {"input": {"n": 5, "start_days": [238, 351, 16, 300, 204], "end_days": [314, 365, 114, 334, 317]}, "output": "{\"max_requests\": 3, \"requests\": [[16, 114], [238, 314], [351, 365]]}"}, {"input": {"n": 5, "start_days": [130, 93, 342, 279, 270], "end_days": [195, 340, 344, 307, 303]}, "output": "{\"max_requests\": 3, \"requests\": [[130, 195], [270, 303], [342, 344]]}"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DayGitH/Python-Challenges", "path": "/DailyProgrammer/DP20171108B.py", "msgidx": 10829}}
{"problem_description": "Given the task of identifying prime numbers that remain prime when truncated from both left to right and right to left, what is the sum of the first 11 such truncatable primes found within a specified maximum number of iterations?", "io_requirements": "Input:\n  `max_iterations` (int): The maximum number of iterations to search for truncatable primes. This should be a positive integer.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `sum_of_truncatable_primes` (int): The sum of the first 11 truncatable primes found.\n    - `truncatable_primes_list` (list of int): A list of the first 11 truncatable primes found.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_prime_number(n):\n    if n < 2:\n        return False\n    start = int(n**0.5)\n    for i in range(start, 1, -1):\n        if n%i == 0:\n            return False\n    return True\n\ndef all_primes(numbers):\n    for i in numbers:\n        if not is_prime_number(i):\n            return False\n    return True\n\ndef is_truncatable(number):\n    if not is_prime_number(number):\n        return False\n    t = set()\n    st_num = str(number)\n    for i in range(1,len(st_num)):\n        t.add(int(st_num[0:i]))\n        t.add(int(st_num[i:]))\n    return all_primes(t)\n\n# main function\ndef main_solution(max_iterations):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  trunc_count = 0\n  trunc_list = []\n  total = 0\n  index = 10\n  while trunc_count < 11 and index < max_iterations:\n      if is_truncatable(index):\n          trunc_count += 1\n          trunc_list.append(index)\n          total += index\n      index += 1\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return {\"sum_of_truncatable_primes\": total, \"truncatable_primes_list\": trunc_list}", "funcname": "main_solution", "ios": [{"input": {"max_iterations": 1237}, "output": {"sum_of_truncatable_primes": 1986, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797]}}, {"input": {"max_iterations": 6849}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}, {"input": {"max_iterations": 6975}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}, {"input": {"max_iterations": 7948}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}, {"input": {"max_iterations": 5602}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}, {"input": {"max_iterations": 9290}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}, {"input": {"max_iterations": 9632}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}, {"input": {"max_iterations": 6261}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}, {"input": {"max_iterations": 2778}, "output": {"sum_of_truncatable_primes": 1986, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797]}}, {"input": {"max_iterations": 7734}, "output": {"sum_of_truncatable_primes": 8920, "truncatable_primes_list": [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "i-fernandez/Project-Euler", "path": "/Problem_037/problem_37.py", "msgidx": 11560}}
{"problem_description": "Given an array of integers, how does the array change after applying one step of the Steinhaus\u2013Johnson\u2013Trotter permutation algorithm?", "io_requirements": "Input:\n  `input_array` (list of integers): A list of integers representing the initial array to be permuted. The length of the list should be between 2 and 10.\n\nOutput:\n  `return` (list of integers): A list of integers representing the array after one permutation using the Steinhaus\u2013Johnson\u2013Trotter algorithm.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass PermutableNdArray(np.ndarray):\n    def __new__(cls, input_array):\n        obj = np.asarray(input_array).view(cls)\n        obj.__speeds = np.full(obj.size, -1)\n        obj.__speeds[0] = 0\n        obj.__act_index = obj.size - 1\n        return obj\n\n    def permutate(self):\n        if self.__speeds[self.__act_index] == -1:\n            temp = self[self.__act_index - 1]\n            temp_speed = self.__speeds[self.__act_index - 1]\n            self[self.__act_index - 1] = self[self.__act_index]\n            self[self.__act_index] = temp\n            self.__speeds[self.__act_index - 1] = self.__speeds[self.__act_index]\n            self.__speeds[self.__act_index] = temp_speed\n            self.__act_index -= 1\n        elif self.__speeds[self.__act_index] == 1:\n            pass\n        else:\n            pass\n        if \"something\":\n            pass\n        elif self.__act_index == 0 or self.__act_index == (self.size - 1):\n            pass\n\n# main function\ndef main_solution(input_array):\n    # Convert input_array to a list of integers\n    input_array = np.array(input_array, dtype=np.uint8)\n    \n    # Create an instance of PermutableNdArray\n    perm_array = PermutableNdArray(input_array)\n    \n    # Perform one permutation\n    perm_array.permutate()\n    \n    # Convert the permuted array back to a list\n    output_array = perm_array.tolist()\n    \n    # Return the permuted array as a list\n    return output_array", "funcname": "main_solution", "ios": [{"input": {"input_array": [3, 1, 2, 5, 4, 6, 0]}, "output": [3, 1, 2, 5, 4, 0, 6]}, {"input": {"input_array": [9, 3, 2, 6, 5, 4, 7, 0, 1, 8]}, "output": [9, 3, 2, 6, 5, 4, 7, 0, 8, 1]}, {"input": {"input_array": [3, 1, 2, 0]}, "output": [3, 1, 0, 2]}, {"input": {"input_array": [0, 1, 3, 2]}, "output": [0, 1, 2, 3]}, {"input": {"input_array": [2, 5, 0, 3, 6, 4, 1]}, "output": [2, 5, 0, 3, 6, 1, 4]}, {"input": {"input_array": [7, 1, 4, 2, 3, 8, 6, 0, 5]}, "output": [7, 1, 4, 2, 3, 8, 6, 5, 0]}, {"input": {"input_array": [1, 5, 6, 0, 4, 2, 3]}, "output": [1, 5, 6, 0, 4, 3, 2]}, {"input": {"input_array": [3, 2, 4, 6, 1, 0, 5]}, "output": [3, 2, 4, 6, 1, 5, 0]}, {"input": {"input_array": [1, 9, 0, 4, 2, 5, 6, 3, 7, 8]}, "output": [1, 9, 0, 4, 2, 5, 6, 3, 8, 7]}, {"input": {"input_array": [0, 1]}, "output": [1, 0]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nknaian/sound-universe", "path": "/even_permutation_test.py", "msgidx": 11035}}
{"problem_description": "Given a chessboard of size `n` x `n`, how many distinct ways can you place `n` queens on the board such that no two queens threaten each other?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (int): The number of distinct solutions to the N-Queens problem for the given board size `n`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def traceback(row: int) -> int:\n            if n == row:\n                return 1\n            else:\n                count = 0\n                for i in range(n):\n                    if i in columns or row - i in diagonal1 or row + i in diagonal2:\n                        continue\n                    else:\n                        columns.add(i)\n                        diagonal1.add(row - i)\n                        diagonal2.add(row + i)\n                        count += traceback(row + 1)\n                        columns.remove(i)\n                        diagonal1.remove(row - i)\n                        diagonal2.remove(row + i)\n                return count\n\n        columns = set()\n        diagonal1 = set()\n        diagonal2 = set()\n        return traceback(0)\n\n# main function\ndef main_solution(n: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.totalNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": 0}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 10}, "output": 724}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 5}, "output": 10}, {"input": {"n": 4}, "output": 2}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 2}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "QinHaoChen97/python_leetcode", "path": "/N\u7687\u540eII_52.py", "msgidx": 11150}}
{"problem_description": "In the classic Towers of Hanoi puzzle, there are three pegs and a number of disks of different sizes that can slide onto any peg. The puzzle starts with the disks neatly stacked in ascending order of size on one peg, the smallest at the top. The objective is to move the entire stack to another peg, obeying the following simple rules:\n1. Only one disk can be moved at a time.\n2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty peg.\n3. No disk may be placed on top of a smaller disk.\n\nGiven the number of disks `n`, what is the sequence of moves required to solve the Towers of Hanoi puzzle?", "io_requirements": "Input:\n  `n` (int): The number of disks to be moved in the Towers of Hanoi problem.\n\nOutput:\n  `return` (list of tuples): A list of tuples representing the sequence of moves required to solve the Towers of Hanoi problem. Each tuple contains three integers: the disk number, the source peg, and the destination peg.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef hanoi(n, i=1, k=3, moves=None):\n    if moves is None:\n        moves = []\n    if n == 1:\n        moves.append((n, i, k))\n    else:\n        tmp = 6 - i - k\n        hanoi(n-1, i, tmp, moves)\n        moves.append((n, i, k))\n        hanoi(n-1, tmp, k, moves)\n    return moves\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    moves = hanoi(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return moves", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": [[1, 1, 2], [2, 1, 3], [1, 2, 3]]}, {"input": {"n": 1}, "output": [[1, 1, 3]]}, {"input": {"n": 3}, "output": [[1, 1, 3], [2, 1, 2], [1, 3, 2], [3, 1, 3], [1, 2, 1], [2, 2, 3], [1, 1, 3]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhenyakeg/Final_preparation", "path": "/1st term/23.Hanoi.py", "msgidx": 11559}}
{"problem_description": "Given a 2D matrix represented by a list of strings, where each string contains '0's and '1's, how many distinct contiguous regions of '0's are there in the matrix? A contiguous region is defined as a group of '0's connected in one or more of the four directions: up, down, left, or right.", "io_requirements": "Input:\n  `strArr` (list of strings): A 2D matrix represented as a list of strings, where each string represents a row in the matrix. Each character in the string is either '0' or '1'.\n\nOutput:\n  `return` (int): The number of contiguous regions of '0's in the matrix.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef pop_connected(row_id, char_id, arr):\n    for coord in ((row_id, char_id - 1), (row_id, char_id + 1), (row_id - 1, char_id), (row_id + 1, char_id)):\n        try:\n            arr.remove(coord)\n            # recurency call for removing connected zeros\n            pop_connected(coord[0], coord[1], arr)\n        \n        # if index error occurs\n        except: \n            continue\n\n# main function\ndef main_solution(strArr):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  zero_coords = []\n  for row_id, row in enumerate(strArr):\n      for char_id, char in enumerate(row):\n          if char  == '0':\n              zero_coords.append((row_id, char_id))\n\n  count = 0\n  while zero_coords:\n      count += 1\n      row_id, char_id = zero_coords.pop(0)\n      pop_connected(row_id, char_id, zero_coords)\n\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return count", "funcname": "main_solution", "ios": [{"input": {"strArr": ["101", "101", "001"]}, "output": 1}, {"input": {"strArr": ["0001", "0010", "0010", "1110", "1000", "1000"]}, "output": 2}, {"input": {"strArr": ["1011", "1000", "0001", "0010"]}, "output": 2}, {"input": {"strArr": ["011", "111", "100", "000", "011"]}, "output": 2}, {"input": {"strArr": ["11111", "01010", "11110", "11101", "11101", "00110"]}, "output": 6}, {"input": {"strArr": ["111101", "011111", "000001", "001011", "100101"]}, "output": 3}, {"input": {"strArr": ["0011", "1010", "0010"]}, "output": 2}, {"input": {"strArr": ["100111", "101110", "110101", "010010", "011100", "000100"]}, "output": 6}, {"input": {"strArr": ["100", "000", "100", "000", "100", "110"]}, "output": 1}, {"input": {"strArr": ["001", "100", "111", "010"]}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JakubKazimierski/PythonPortfolio", "path": "/Coderbyte_algorithms/Medium/BitmapHoles/BitmapHoles.py", "msgidx": 11374}}
{"problem_description": "Given a 3x3 matrix of integers, what is the minimum cost required to transform it into a magic square, where the cost is defined as the sum of the absolute differences between the current values and the values in the closest magic square configuration?", "io_requirements": "Input:\n  `s` (list of lists of int): A 3x3 matrix represented as a list of lists, where each sublist contains 3 integers. The matrix represents the initial configuration of a magic square.\n\nOutput:\n  `return` (int): The minimum cost to convert the given 3x3 matrix into a magic square. The cost is calculated as the sum of the absolute differences between the current values and the values in the closest magic square configuration.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(s):\n    # Convert the input list to a 1D list if it's not already\n    if isinstance(s[0], list):\n        s = [item for sublist in s for item in sublist]\n    \n    ans = 81\n    for P in permutations(range(1, 10)):\n        if sum(P[0:3]) == sum(P[3:6]) == sum(P[0::3]) == sum(P[1::3]) == (P[0] + P[4] + P[8]) == (P[2] + P[4] + P[6]) == 15:\n            ans = min(ans, sum(abs(P[i] - s[i]) for i in range(0, 9)))\n    return ans", "funcname": "main_solution", "ios": [{"input": {"s": [[2, 6, 5], [6, 6, 5], [4, 7, 4]]}, "output": 18}, {"input": {"s": [[1, 1, 9], [7, 6, 8], [3, 6, 4]]}, "output": 16}, {"input": {"s": [[2, 8, 1], [3, 7, 5], [7, 6, 8]]}, "output": 16}, {"input": {"s": [[7, 4, 7], [2, 7, 8], [8, 3, 2]]}, "output": 15}, {"input": {"s": [[4, 5, 9], [4, 4, 7], [4, 3, 7]]}, "output": 20}, {"input": {"s": [[9, 5, 1], [9, 4, 4], [1, 3, 5]]}, "output": 24}, {"input": {"s": [[3, 6, 6], [7, 4, 7], [5, 7, 2]]}, "output": 18}, {"input": {"s": [[6, 5, 6], [6, 1, 2], [5, 4, 5]]}, "output": 19}, {"input": {"s": [[3, 6, 1], [8, 7, 9], [1, 2, 2]]}, "output": 24}, {"input": {"s": [[3, 5, 9], [2, 3, 8], [4, 8, 3]]}, "output": 18}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mahesh668429/HackerRankSolutions", "path": "/magicsquare.py", "msgidx": 11412}}
{"problem_description": "Given a chessboard of size `n x n`, how can you place `n` queens on the board such that no two queens threaten each other? Each solution should be represented as a list of strings, where each string represents a row on the chessboard, with 'Q' indicating the position of a queen and '.' indicating an empty space. What are the possible configurations for the given size `n`?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of solutions, where each solution is a list of strings representing the chessboard configuration. Each string represents a row on the chessboard, with 'Q' indicating the position of a queen and '.' indicating an empty space.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def _oneQueen(row, cols, diffs, sums):\n            if len(cols) < row:\n                return\n            if row == n:\n                result.append(cols)\n                return cols\n            for col in range(n):\n                if col in cols or (col + row) in diffs or (col - row) in sums:\n                    continue\n                _oneQueen(row + 1, cols + [col], diffs + [col + row], sums + [col - row])\n\n        result = []\n        _oneQueen(0, [], [], [])\n        all_solve = []\n        for queens in result:\n            one_solve = []\n            for q in queens:\n                lines = \"\"\n                for i in range(n):\n                    if i == q:\n                        lines += \"Q\"\n                    else:\n                        lines += \".\"\n                one_solve.append(lines)\n            all_solve.append(one_solve)\n        return all_solve\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": []}, {"input": {"n": 1}, "output": [["Q"]]}, {"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}, {"input": {"n": 2}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ityoung/LeetCode-practice", "path": "/Recursion/p51-n-queens.py", "msgidx": 11504}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a valid combination of n pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generateParenthesis(n: int):\n    res = []\n    \n    def backtrack(l, r, S):\n        if len(S) == 2 * n:\n            res.append(\"\".join(S))\n            return\n        if l < n:\n            S.append(\"(\")\n            backtrack(l + 1, r, S)\n            S.pop()\n        if r < l:\n            S.append(\")\")\n            backtrack(l, r + 1, S)\n            S.pop()\n\n    backtrack(0, 0, [])\n    return res\n\n# main function\ndef main_solution(n: int):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = generateParenthesis(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Alwaysproblem/simplecode", "path": "/leetcode/python/generateParenthesis.py", "msgidx": 11709}}
{"problem_description": "Given a password and a series of commands that manipulate the password, what is the final encrypted password and what was the original password that, when encrypted, results in the final encrypted password?", "io_requirements": "Input:\n  `password` (str): The initial password string.\n  `lines` (str): A string containing the list of commands, each command separated by a newline character.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `encrypted_password` (str): The password after applying all the commands.\n    - `original_password` (str): The original password that, when encrypted, results in the `encrypted_password`.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef swap(password, args):\n    if args[0] == \"position\":\n        a, b = int(args[1]), int(args[4])\n    else:\n        c, d = args[1], args[4]\n        a, b = password.index(c), password.index(d)\n    password[a], password[b] = password[b], password[a]\n    return password\n\ndef rotate(password, args):\n    if args[0] == 'based':\n        steps = password.index(args[5])\n        steps += 2 if steps >= 4 else 1\n        steps %= len(password)\n    else:\n        steps = int(args[1])\n        if args[0] == \"left\":\n            steps = -steps\n    return password[-steps:] + password[:-steps]\n\ndef move(password, args):\n    from_pos = int(args[1])\n    to_pos = int(args[4])\n    save_char = [password[from_pos]]\n    password = password[:from_pos] + password[from_pos+1:]\n    password = password[:to_pos] + save_char + password[to_pos:]\n    return password\n\ndef reverse(password, args):\n    from_pos = int(args[1])\n    to_pos = int(args[3]) + 1\n    return password[:from_pos] + password[from_pos:to_pos][::-1] + password[to_pos:]\n\nCMD_DICT = {'swap' : swap, 'rotate' : rotate, 'move' : move, 'reverse' : reverse}\n\ndef encrypt(password, lines):\n    password = list(password)\n    for line in lines:\n        cmd, *args = line.split()\n        password = CMD_DICT[cmd](password, args)\n    return ''.join(password)\n\ndef crack(password, lines):\n    password_list = permutations(password)\n    for p in password_list:\n        if encrypt(p, lines) == password:\n            return ''.join(p)\n    return None\n\n# main function\ndef main_solution(password, lines):\n    # Convert the input lines to a list of strings\n    lines = lines.split('\\n')\n    \n    # Encrypt the password using the provided lines\n    encrypted_password = encrypt(password, lines)\n    \n    # Crack the encrypted password to find the original password\n    original_password = crack(encrypted_password, lines)\n    \n    # Return the encrypted password and the original password\n    return {\"encrypted_password\": encrypted_password, \"original_password\": original_password}", "funcname": "main_solution", "ios": [{"input": {"password": "zmhrlb", "lines": "move position 5 to position 2\nrotate left 4 steps\nswap letter h with letter l"}, "output": {"encrypted_password": "rhzmbl", "original_password": "zmhrlb"}}, {"input": {"password": "qmtypf", "lines": "move position 2 to position 3\nrotate based on position of letter y\nswap letter y with letter t"}, "output": {"encrypted_password": "ypfqmt", "original_password": "qmtypf"}}, {"input": {"password": "cbeyl", "lines": "move position 1 to position 2\nmove position 0 to position 2\nrotate based on position of letter c"}, "output": {"encrypted_password": "cyleb", "original_password": "cbeyl"}}, {"input": {"password": "dktbbbb", "lines": "swap letter b with letter t\nswap position 3 with position 4\nmove position 4 to position 1"}, "output": {"encrypted_password": "dtkbbbb", "original_password": "dktbbbb"}}, {"input": {"password": "pcijn", "lines": "move position 4 to position 1\nrotate left 3 steps\nrotate left 3 steps\nmove position 0 to position 0"}, "output": {"encrypted_password": "ncijp", "original_password": "pcijn"}}, {"input": {"password": "ubbob", "lines": "reverse positions 1 through 0\nmove position 1 to position 3\nswap letter b with letter b"}, "output": {"encrypted_password": "ubobb", "original_password": "ubbob"}}, {"input": {"password": "qisfy", "lines": "move position 0 to position 0\nmove position 2 to position 2\nreverse positions 0 through 3"}, "output": {"encrypted_password": "fsiqy", "original_password": "qisfy"}}, {"input": {"password": "qjnjd", "lines": "swap position 0 with position 4\nrotate based on position of letter d\nreverse positions 0 through 4"}, "output": {"encrypted_password": "jnjdq", "original_password": "qjnjd"}}, {"input": {"password": "drvnwz", "lines": "swap letter v with letter w\nrotate based on position of letter w\nreverse positions 2 through 5"}, "output": {"encrypted_password": "nvwrdz", "original_password": "drvnwz"}}, {"input": {"password": "ucncc", "lines": "reverse positions 1 through 3\nmove position 4 to position 3\nrotate left 3 steps"}, "output": {"encrypted_password": "ccucn", "original_password": "ucncc"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mariazverina/adventofcode2016", "path": "/day21.py", "msgidx": 11175}}
{"problem_description": "Given a number, if we add 100 to it, the result is a perfect square. If we then add 168 to this result, it again forms a perfect square. What is the number within a specified upper limit?", "io_requirements": "Input:\n  `upper_limit` (int): The upper limit within which to search for the integer. It should be a positive integer.\n\nOutput:\n  `return` (int): The found integer that satisfies the conditions, or -1 if no such integer is found within the given upper limit.", "refcode": "import math\n\ndef main_solution(upper_limit):\n    \"\"\"\n    Finds an integer within the given upper limit such that:\n    1. Adding 100 to this integer results in a perfect square.\n    2. Adding 168 to the result of the first condition also results in a perfect square.\n\n    Args:\n        upper_limit (int): The upper limit within which to search for the integer.\n\n    Returns:\n        int: The found integer that satisfies the conditions, or -1 if no such integer is found.\n    \"\"\"\n    for i in range(upper_limit):\n        x = math.sqrt(i + 100)\n        if x == math.floor(x):\n            y = math.sqrt(x**2 + 168)\n            if y == math.floor(y):\n                return i\n    return -1", "funcname": "main_solution", "ios": [{"input": {"upper_limit": 6898}, "output": 21}, {"input": {"upper_limit": 9690}, "output": 21}, {"input": {"upper_limit": 391}, "output": 21}, {"input": {"upper_limit": 9015}, "output": 21}, {"input": {"upper_limit": 3818}, "output": 21}, {"input": {"upper_limit": 3469}, "output": 21}, {"input": {"upper_limit": 4207}, "output": 21}, {"input": {"upper_limit": 5809}, "output": 21}, {"input": {"upper_limit": 2233}, "output": 21}, {"input": {"upper_limit": 2515}, "output": 21}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yanliangchen/ware_house", "path": "/\u6280\u672f\u6536\u85cf/learingnote/\u57fa\u7840\u4ee3\u7801/Python\u7ec3\u4e60\u9898 003\uff1a\u5b8c\u5168\u5e73\u65b9\u6570.py", "msgidx": 11221}}
{"problem_description": "Given a string that may contain characters both outside and inside square brackets, determine if there are any sequences of the form BAB (where B and A are distinct characters) that appear outside the square brackets and also appear inside the square brackets. What is the result indicating the presence of such sequences?", "io_requirements": "Input:\n  `input_string` (str): A string containing characters and possibly square brackets. The string should be formatted such that characters outside square brackets are separated by spaces, and characters inside square brackets are also separated by spaces.\n\nOutput:\n  `return` (bool): A boolean value indicating whether any BAB sequence found in the characters outside the square brackets is also present in the characters inside the square brackets. Returns `True` if such a sequence exists, otherwise `False`.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef containsABA(s):\n    \"\"\"\n    Return lists of BAB sequences.\n    \"\"\"\n    res = [] \n    a, b, a1 = 'X', 'X', 'X' \n    for c in s:\n        a, b, a1 = b, a1, c\n        if a == a1 and a != b:\n            res.append(b + a + b)\n    return res\n    \n\ndef split(s):\n    \"\"\" Returns strings outside and inside, characters\n    outside square brackets and inside square brackets.\n    Groups separated by ' '.\n    \"\"\"\n    outside, inside = \"\", \"\"\n    out = True\n    for c in s:\n        if c == '[':\n            out = False\n            outside += ' '\n            continue\n        if c == ']':\n            out = True\n            inside += ' ' \n            continue\n        if out:\n            outside += c\n        else:\n            inside += c\n    return outside, inside\n            \n\n# main function\ndef main_solution(input_string):\n    \"\"\"\n    Determines if the input string contains any BAB sequences that are also present inside square brackets.\n    \"\"\"\n    outside, inside = split(input_string)\n    babs = containsABA(outside)\n    for x in babs:\n        if x in inside:\n            return True\n    return False", "funcname": "main_solution", "ios": [{"input": {"input_string": "BB[][K]eI[m]F[C]Xzm[bcB]e[]n[Em]W[][b"}, "output": false}, {"input": {"input_string": "[vh][E]HW[][L]war[][Fc][]A[]m[r]"}, "output": false}, {"input": {"input_string": "[H][b][]zG[e"}, "output": false}, {"input": {"input_string": "C[][Wae]qAP[]l[]WC[VhY]h[]IR[L]"}, "output": false}, {"input": {"input_string": "i[]au[ZFn]V[]sv[P]P[][]nhn[UH]qai[VPt]FDT[UWF]F"}, "output": false}, {"input": {"input_string": "[][]P[][][O]Y[][p]hh[LJ][]bq[][]xGuR[]L"}, "output": false}, {"input": {"input_string": "[X][Cy][]CU[zuhF]E[][][][]ysIw"}, "output": false}, {"input": {"input_string": "Uhqd[]H[]i[Ve]k[hrB][][][w"}, "output": false}, {"input": {"input_string": "z[]z[][qXbJnf]y[][]F[][NRR]j[Bg]l[i]"}, "output": false}, {"input": {"input_string": "[][]DOV[yl]nU[k][dT][]u[][]"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "PetraVidnerova/AdventOfCode2016", "path": "/day7b.py", "msgidx": 11536}}
{"problem_description": "Given a puzzle grid of a certain size, where each tile can be moved to reach a goal configuration, what is the heuristic value that estimates the number of moves required to solve the puzzle from the current state to the goal state, using a specified heuristic function? The heuristic functions available are \"uniform\", \"hamming\", \"manhattan\", and \"linear\".", "io_requirements": "Input:\n  `heuristic` (str): The name of the heuristic function to use. Possible values are \"uniform\", \"hamming\", \"manhattan\", and \"linear\".\n  `size` (int): The size of the puzzle grid (size x size).\n  `grid` (list[int]): The current state of the puzzle grid. It is a list of integers representing the tiles in their current positions.\n  `goal` (list[int]): The goal state of the puzzle grid. It is a list of integers representing the tiles in their desired positions.\n\nOutput:\n  `return` (int): The heuristic value computed by the selected heuristic function.", "refcode": "# import necessary packages\nfrom functools import cache\nfrom dataclasses import dataclass\nfrom typing import Callable\n\n# all class and function definitions in the code file, if any\n@dataclass\nclass HeuristicCallback:\n    callback: Callable[[int, tuple[int, ...], tuple[int, ...]], int]\n\ndef select_heuristic(\n    arg: str,\n) -> HeuristicCallback:\n    \"\"\"\n    Returns the appropriate heuristic function depending on the flag passed as argument\n    \"\"\"\n    heuristics = {\n        \"uniform\": generate_uniform_cost,\n        \"hamming\": generate_hamming_distance,\n        \"manhattan\": generate_manhattan_distance,\n        \"linear\": generate_linear_conflicts,\n    }\n\n    return HeuristicCallback(callback=heuristics.get(arg, generate_manhattan_distance))\n\n\ndef generate_uniform_cost(  # pylint: disable=unused-argument\n    size: int, grid: tuple[int, ...], goal: tuple[int, ...]\n) -> int:\n    \"\"\"\n    Uniform-cost is not really a heuristic, it's in fact the absence of heuristic.\n    Uniform-cost search is uninformed search: f(n) = g(n) (there's no h(n))\n    \"\"\"\n    return 0\n\n\ndef generate_hamming_distance(\n    size: int, grid: tuple[int, ...], goal: tuple[int, ...]\n) -> int:\n    \"\"\"\n    The Hamming Distance is the number of tiles not in their final position.\n\n    The blank tile is ignored, to ensure that this heuristic is not an underestimate.\n    \"\"\"\n    hamming_distance: int = 0\n\n    for index in range(size * size):\n        if grid[index] != goal[index] and grid[index] != 0:\n            hamming_distance += 1\n\n    return hamming_distance\n\n\ndef generate_manhattan_distance(\n    size: int, grid: tuple[int, ...], goal: tuple[int, ...]\n) -> int:\n    \"\"\"\n    The Manhattan Distance is the sum of the minimal number of moves necessary\n    for each tile to get to its final position.\n\n    The blank tile is ignored, to ensure that this heuristic is not an underestimate.\n    \"\"\"\n    manhattan_distance: int = 0\n\n    for index in range(size * size):\n        if grid[index] != goal[index] and grid[index] != 0:\n            goal_tile = goal.index(grid[index])\n            manhattan_distance += abs(index % size - goal_tile % size) + abs(\n                index // size - goal_tile // size\n            )\n\n    return manhattan_distance\n\n\n@cache\ndef get_conflicts_in_line(\n    size: int,\n    grid_line: tuple[int, ...],\n    goal_line: tuple[int, ...],\n    conflicts_in_line: int = 0,\n) -> int:\n    \"\"\"\n    Returns the minimal number of conflicts to be solved in a given line.\n\n    To make sure that the _minimal_ number is returned:\n    - the tile with the most conflits is deleted\n    - the number of conflicts (without that tile) is recomputed using recursion\n\n    Using tuples instead of lists allows the use of `@cache`\n    \"\"\"\n    conflicts = [0 for x in range(size)]\n\n    # pylint: disable=too-many-nested-blocks\n    for index_j, value_j in enumerate(grid_line):\n        if value_j in goal_line and value_j != 0:\n            for index_k, value_k in enumerate(grid_line):\n                if value_k in goal_line and value_k != 0:\n                    if value_j != value_k:\n                        if (\n                            goal_line.index(value_j) > goal_line.index(value_k)\n                        ) and index_j < index_k:\n                            conflicts[index_j] += 1\n                        elif (\n                            goal_line.index(value_j) < goal_line.index(value_k)\n                        ) and index_j > index_k:\n                            conflicts[index_j] += 1\n\n    if max(conflicts) != 0:\n        index = conflicts.index(max(conflicts))\n        tmp = list(grid_line)\n        tmp[index] = -1\n        grid_line = tuple(tmp)\n        conflicts_in_line += 1\n        return get_conflicts_in_line(size, grid_line, goal_line, conflicts_in_line)\n\n    return conflicts_in_line\n\n\ndef generate_linear_conflicts(\n    size: int, grid: tuple[int, ...], goal: tuple[int, ...]\n) -> int:\n    \"\"\"\n    Two tiles tj and tk are in linear conflict if (cumulatively):\n    - they are in the same line\n    - their goal positions are both in that line\n    - tj is to the right of tk and its goal is to the left of tk's (or vice versa)\n\n    Linear conflict is combined with the Manhattan Distance to get h(n).\n\n    The blank tile is ignored, to ensure that this heuristic is not an underestimate.\n    \"\"\"\n    linear_conflicts: int = 0\n    manhattan_distance: int = generate_manhattan_distance(size, grid, goal)\n\n    grid_columns: list[list[int]] = [[] for x in range(size)]\n    goal_columns: list[list[int]] = [[] for x in range(size)]\n    grid_rows: list[list[int]] = [[] for y in range(size)]\n    goal_rows: list[list[int]] = [[] for y in range(size)]\n\n    for row in range(size):\n        for col in range(size):\n            index = col + (row * size)\n            grid_columns[col].append(grid[index])\n            goal_columns[col].append(goal[index])\n            grid_rows[row].append(grid[index])\n            goal_rows[row].append(goal[index])\n\n    for i in range(size):\n        linear_conflicts += get_conflicts_in_line(\n            size, tuple(grid_columns[i]), tuple(goal_columns[i])\n        )\n        linear_conflicts += get_conflicts_in_line(\n            size, tuple(grid_rows[i]), tuple(goal_rows[i])\n        )\n\n    return (linear_conflicts * 2) + manhattan_distance\n\n# main function\ndef main_solution(heuristic: str, size: int, grid: list[int], goal: list[int]) -> int:\n    \"\"\"\n    Computes the heuristic value based on the selected heuristic function.\n\n    Args:\n        heuristic (str): The name of the heuristic function to use.\n        size (int): The size of the puzzle grid (size x size).\n        grid (list[int]): The current state of the puzzle grid.\n        goal (list[int]): The goal state of the puzzle grid.\n\n    Returns:\n        int: The heuristic value computed by the selected heuristic function.\n    \"\"\"\n    # Convert grid and goal to tuples for compatibility with existing functions\n    grid_tuple = tuple(grid)\n    goal_tuple = tuple(goal)\n\n    # Select the heuristic function\n    heuristic_callback = select_heuristic(heuristic)\n\n    # Compute the heuristic value\n    heuristic_value = heuristic_callback.callback(size, grid_tuple, goal_tuple)\n\n    return heuristic_value", "funcname": "main_solution", "ios": [{"input": {"heuristic": "hamming", "size": 2, "grid": [0, 3, 2, 1], "goal": [0, 1, 2, 3]}, "output": 2}, {"input": {"heuristic": "hamming", "size": 2, "grid": [3, 2, 0, 1], "goal": [0, 1, 2, 3]}, "output": 3}, {"input": {"heuristic": "manhattan", "size": 2, "grid": [3, 2, 0, 1], "goal": [0, 1, 2, 3]}, "output": 5}, {"input": {"heuristic": "uniform", "size": 2, "grid": [2, 3, 0, 1], "goal": [0, 1, 2, 3]}, "output": 0}, {"input": {"heuristic": "linear", "size": 2, "grid": [3, 2, 1, 0], "goal": [0, 1, 2, 3]}, "output": 6}, {"input": {"heuristic": "uniform", "size": 2, "grid": [0, 1, 2, 3], "goal": [0, 1, 2, 3]}, "output": 0}, {"input": {"heuristic": "manhattan", "size": 2, "grid": [0, 1, 3, 2], "goal": [0, 1, 2, 3]}, "output": 2}, {"input": {"heuristic": "hamming", "size": 2, "grid": [2, 3, 1, 0], "goal": [0, 1, 2, 3]}, "output": 3}, {"input": {"heuristic": "hamming", "size": 2, "grid": [3, 2, 1, 0], "goal": [0, 1, 2, 3]}, "output": 3}, {"input": {"heuristic": "hamming", "size": 2, "grid": [2, 1, 0, 3], "goal": [0, 1, 2, 3]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vischlum/n-puzzle", "path": "/heuristics.py", "msgidx": 10464}}
{"problem_description": "Given a positive integer, what are all the possible ways to express it as a product of two or more positive integers? For example, for the number 6, the possible combinations are [1, 2, 3], [2, 1, 3], [2, 3, 1], [1, 3, 2], [3, 1, 2], [3, 2, 1], [1, 6], and [6, 1]. What are the combinations for a given integer?", "io_requirements": "Input:\n  `product` (int): The integer for which all possible multiplication combinations are to be found. It should be a positive integer.\n\nOutput:\n  `return` (list of lists of int): A list containing all possible multiplication combinations of the input `product`. Each combination is represented as a list of integers.", "refcode": "# import necessary packages\nimport copy\nimport math\n\n# all class and function definitions in the code file, if any\ndef get_product_factors(n):\n    \"\"\" get product factors of n\n    \"\"\"\n    if n <= 0 or not isinstance(n, int):\n        return []\n    else:\n        product_factors = []\n        for i in range(1, math.ceil(math.sqrt(n)) + 1):\n            if n % i == 0:\n                product_factors.append(i)\n                product_factors.append(int(n / i))\n\n        return sorted(list(set(product_factors)))\n\ndef get_multiply_combo(product, result=[]):\n    \"\"\" \u4f7f\u7528\u51fd\u6570\u7684\u9012\u5f52\uff08\u5d4c\u5957\uff09\u8c03\u7528\uff0c\u627e\u51fa\u6240\u6709\u53ef\u80fd\u7684\u4e58\u79ef\u7ec4\u5408\n\n    Args:\n        product: \u4e58\u79ef\u7ed3\u679c\n        result: \u4fdd\u5b58\u5f53\u524d\u7684\u89e3\n\n    Returns: None\n\n    \"\"\"\n    product_factors = get_product_factors(product)\n    for i in product_factors:\n        if i == 1:\n            continue\n\n        new_result = copy.copy(result)\n        new_result.append(i)\n\n        if i == product:\n            yield new_result\n\n        divisor = product // i\n        if divisor != 1:\n            yield from get_multiply_combo(divisor, new_result)\n\n# main function\ndef main_solution(product):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    all_combos = list(get_multiply_combo(product))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return all_combos", "funcname": "main_solution", "ios": [{"input": {"product": 47}, "output": [[47]]}, {"input": {"product": 58}, "output": [[2, 29], [29, 2], [58]]}, {"input": {"product": 33}, "output": [[3, 11], [11, 3], [33]]}, {"input": {"product": 35}, "output": [[5, 7], [7, 5], [35]]}, {"input": {"product": 19}, "output": [[19]]}, {"input": {"product": 53}, "output": [[53]]}, {"input": {"product": 73}, "output": [[73]]}, {"input": {"product": 59}, "output": [[59]]}, {"input": {"product": 3}, "output": [[3]]}, {"input": {"product": 27}, "output": [[3, 3, 3], [3, 9], [9, 3], [27]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dongyifeng/geekcode", "path": "/recursion/chapter5.py", "msgidx": 11636}}
{"problem_description": "During World War II, the Enigma machine was used to encode messages to ensure secure communication. Given a specific configuration of rotors and a reflector, how would the Enigma machine encode a given message? Specifically, what would be the encoded message for a given set of rotors, reflector, and raw message?", "io_requirements": "Input:\n  `rotors` (List[str]): A list of rotor names to be used in the Enigma machine. Each rotor name should be one of the following: `[\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\"]`.\n  `reflector` (str): The name of the reflector to be used in the Enigma machine. The reflector name should be one of the following: `[\"Beta\", \"Gamma\", \"A\", \"B\", \"C\", \"BT\", \"CT\", \"ETW\"]`.\n  `raw_string` (str): The string to be encoded by the Enigma machine. The string should contain only alphabetic characters (both uppercase and lowercase).\n\nOutput:\n  `return` (str): The encoded string produced by the Enigma machine. The string will contain only uppercase alphabetic characters.", "refcode": "# import necessary packages\nimport string\nfrom typing import List, Tuple\n\n# all class and function definitions in the code file, if any\nclass Rotor:\n    \"\"\" Rotor \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        wiring: str,\n        turnover: List[str],\n        starting_position: str,\n    ) -> None:\n        self.name = name\n        self.wiring = wiring\n        self.turnover = turnover\n        self.position = starting_position[0]\n        self.toggle_turnover = False\n\n    def encode_in(self, c: str, turnover: bool) -> Tuple[str, bool]:\n        \"\"\" encode_in \"\"\"\n\n        encoded = self.wiring[\n            (string.ascii_lowercase.index(c.lower()) + ord(self.position) - ord(\"A\")) % 26\n        ]\n\n        toggle_turnover = False\n        if turnover:\n            self.toggle_turnover = True\n            if self.position in self.turnover:\n                toggle_turnover = True\n\n        return (encoded, toggle_turnover)\n\n    def encode_out(self, c: str) -> str:\n        \"\"\" encode_out \"\"\"\n\n        encoded = chr((self.wiring.index(c)-(ord(self.position) - ord(\"A\")))%26+ord(\"A\"))\n\n        return encoded\n\n    def do_turnover(self) -> None:\n        \"\"\" do_turnover \"\"\"\n\n        if self.toggle_turnover:\n            self.position = chr((((ord(self.position) + 1) - ord(\"A\")) % 26) + ord(\"A\"))\n            self.toggle_turnover = False\n\n\nclass Reflector:\n    \"\"\" Reflector \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        wiring: str,\n    ) -> None:\n        self.name = name\n        self.wiring = wiring\n\n    def encode(self, c: str) -> str:\n        \"\"\" encode \"\"\"\n\n        encoded = self.wiring[\n            string.ascii_lowercase.index(c.lower())\n        ]\n\n        return encoded\n\n\nROTORS = {\n    \"I\": Rotor(\"I\", \"EKMFLGDQVZNTOWYHXUSPAIBRCJ\", [\"Q\"], \"A\"),\n    \"II\": Rotor(\"II\", \"AJDKSIRUXBLHWTMCQGZNPYFVOE\", [\"E\"], \"A\"),\n    \"III\": Rotor(\"III\", \"BDFHJLCPRTXVZNYEIWGAKMUSQO\", [\"V\"], \"A\"),\n    \"IV\": Rotor(\"IV\", \"ESOVPZJAYQUIRHXLNFTGKDCMWB\", [\"J\"], \"A\"),\n    \"V\": Rotor(\"V\", \"VZBRGITYUPSDNHLXAWMJQOFECK\", [\"Z\"], \"A\"),\n    \"VI\": Rotor(\"VI\", \"JPGVOUMFYQBENHZRDKASXLICTW\", [\"Z\", \"M\"], \"A\"),\n    \"VII\": Rotor(\"VII\", \"NZJHGRCXMYSWBOUFAIVLPEKQDT\", [\"Z\", \"M\"], \"A\"),\n    \"VIII\": Rotor(\"VIII\", \"FKQHTLXOCBJSPDZRAMEWNIUYGV\", [\"Z\", \"M\"], \"A\"),\n}\n\nREFLECTORS = {\n    \"Beta\": Reflector(\"Beta\", \"LEYJVCNIXWPBQMDRTAKZGFUHOS\"),\n    \"Gamma\": Reflector(\"Gamma\", \"FSOKANUERHMBTIYCWLQPZXVGJD\"),\n    \"A\": Reflector(\"A\", \"EJMZALYXVBWFCRQUONTSPIKHGD\"),\n    \"B\": Reflector(\"B\", \"YRUHQSLDPXNGOKMIEBFZCWVJAT\"),\n    \"C\": Reflector(\"C\", \"FVPJIAOYEDRZXWGCTKUQSBNMHL\"),\n    \"BT\": Reflector(\"BT\", \"ENKQAUYWJICOPBLMDXZVFTHRGS\"),\n    \"CT\": Reflector(\"CT\", \"RDOBJNTKVEHMLFCWZAXGYIPSUQ\"),\n    \"ETW\": Reflector(\"ETW\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),\n}\n\n\nclass Enigma:\n    \"\"\" Enigma \"\"\"\n\n    def __init__(\n        self,\n        rotors: List[str],\n        reflector: str,\n    ) -> None:\n        self.rotors: List[Rotor] = []\n        for rotor in rotors:\n            self.rotors.append(ROTORS[rotor])\n        self.reflector = REFLECTORS[reflector]\n\n    def encode(self, raw_string: str) -> str:\n        \"\"\" encode \"\"\"\n        encoded_string = \"\"\n        for c in raw_string:\n            if c.isalpha():\n                encoded = c\n\n                turnover = True\n                for rotor in self.rotors:\n                    (encoded, turnover) = rotor.encode_in(encoded, turnover)\n\n                encoded = self.reflector.encode(encoded)\n\n                for rotor in reversed(self.rotors):\n                    encoded = rotor.encode_out(encoded)\n\n                for rotor in self.rotors:\n                    rotor.do_turnover()\n\n                encoded_string += encoded\n\n        return encoded_string\n\n# main function\ndef main_solution(rotors: List[str], reflector: str, raw_string: str) -> str:\n    # all input arguments of the main_solution function should be json serializable\n    enigma = Enigma(rotors, reflector)\n    encoded_string = enigma.encode(raw_string)\n    return encoded_string", "funcname": "main_solution", "ios": [{"input": {"rotors": ["VII", "IV", "III"], "reflector": "CT", "raw_string": "sYOLZnNGdV"}, "output": "WOTKXREHPD"}, {"input": {"rotors": ["VII", "VIII", "VI"], "reflector": "C", "raw_string": "oSchsEyeeG"}, "output": "JQGZIYJTOV"}, {"input": {"rotors": ["VIII", "VII", "VI"], "reflector": "ETW", "raw_string": "VeUTZYKkCv"}, "output": "VEUTZYKKCV"}, {"input": {"rotors": ["VI", "IV", "III"], "reflector": "Beta", "raw_string": "MYTGbYIEnm"}, "output": "VXRNZVMULK"}, {"input": {"rotors": ["V", "VI", "VIII"], "reflector": "CT", "raw_string": "otWFLHCezO"}, "output": "RCTKYCHQEC"}, {"input": {"rotors": ["VI", "V", "VII"], "reflector": "Beta", "raw_string": "JarGNDWNzu"}, "output": "KCMHZGRHAP"}, {"input": {"rotors": ["VI", "III", "V"], "reflector": "BT", "raw_string": "OWkmxuKzNt"}, "output": "MMMCPDFKFG"}, {"input": {"rotors": ["IV", "II", "V"], "reflector": "BT", "raw_string": "ETTxLxYqDg"}, "output": "MKUCZTGJMU"}, {"input": {"rotors": ["III", "V", "VIII"], "reflector": "ETW", "raw_string": "RauheyAjZg"}, "output": "RAUHEYAJZG"}, {"input": {"rotors": ["III", "VII", "VI"], "reflector": "Gamma", "raw_string": "QpWvglXYKU"}, "output": "WVCBHRMMIJ"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jotingen/py-enigma", "path": "/enigma/enigma_machine.py", "msgidx": 10644}}
{"problem_description": "Given a number, how many different ways can it be decoded into letters, assuming each digit corresponds to a letter? (Note: The input variable is `n`.)", "io_requirements": "Input:\n  `n` (int): An integer representing the number to be decoded.\n\nOutput:\n  `return` (int): The number of possible decodings of the input integer.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef possible_decodings(n):\n    if n == 0:\n        return 0\n    if n <= 10:\n        return 1\n    if n == 20:\n        return 1\n    if n >= 10 and n <= 26:\n        return 2\n    last_two = n % 100\n    if last_two <= 10 or last_two > 26:\n        return possible_decodings(n // 10)\n    else:\n        return possible_decodings(n // 10) + possible_decodings(n // 100)\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    # Call the function to get the number of possible decodings\n    result = possible_decodings(n)\n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": 1}, {"input": {"n": 60}, "output": 1}, {"input": {"n": 586}, "output": 1}, {"input": {"n": 920}, "output": 2}, {"input": {"n": 499}, "output": 1}, {"input": {"n": 185}, "output": 2}, {"input": {"n": 453}, "output": 1}, {"input": {"n": 501}, "output": 1}, {"input": {"n": 166}, "output": 2}, {"input": {"n": 277}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sureshpodeti/Algorithms", "path": "/dp/slow/possible_decodings.py", "msgidx": 11540}}
{"problem_description": "Given a number `n`, what are all the permutations of the numbers from 1 to `n` where no element is in its original position?", "io_requirements": "Input:\n  `n` (int): The size of the permutation to be generated. It represents the number of elements in the permutation.\n\nOutput:\n  `return` (str): A JSON-serialized string representing a list of lists. Each inner list is a permutation of the numbers from 1 to `n` where no element is in its original position.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef backtrack(estado_corrente, n, result):\n    # 1. verifique se o estado corrente merece tratamento especial\n    #  (se \u00e9 um estado \"final\")\n    if len(estado_corrente) == n:\n        result.append(estado_corrente[:])  # encontrei uma permutacao ca\u00f3tica!\n        return  # nada mais a ser feito a partir deste estado atual\n\n    posicao_a_ser_preenchida = len(estado_corrente) + 1\n    \n    # 2. para cada \"candidato a pr\u00f3ximo passo\", fa\u00e7a...\n    for candidato in range(1, n+1):\n    \n        # 2.1 se candidato \u00e9 de fato um pr\u00f3ximo passo v\u00e1lido (verifica as restri\u00e7\u00f5es)\n        if candidato == posicao_a_ser_preenchida:\n            continue  # descarto esse candidato, passo para o pr\u00f3ximo\n        if candidato in estado_corrente:\n            continue  # esse n\u00famero j\u00e1 apare\u00e7o, n\u00e3o posso us\u00e1-lo!\n\n        # 2.2 modifica o estado corrente usando o candidato\n        estado_corrente.append(candidato) \n        \n        # 2.3 chamo recursivamente o pr\u00f3prio backtrack passando o novo estado\n        backtrack(estado_corrente, n, result)\n        \n        # 2.4 limpo a modifica\u00e7\u00e3o que fiz\n        estado_corrente.pop()\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = []\n    backtrack([], n, result)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": "[[2, 1]]"}, {"input": {"n": 3}, "output": "[[2, 3, 1], [3, 1, 2]]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "silviomm/tep", "path": "/lessons/perm_caoticas.py", "msgidx": 11256}}
{"problem_description": "Given a series of packets transmitted over the internet, each packet containing a message ID, packet ID, total number of packets in the message, and some text, how can we reassemble the packets into their original messages in the correct order? Specifically, what is the sequence of completed messages when all packets are received and assembled?", "io_requirements": "Input:\n  `packets` (list of str): A list of strings where each string represents a packet in the format \"X Y Z some_text\".\n  - `X` (int): Message ID, indicating which message this packet belongs to.\n  - `Y` (int): Packet ID, indicating the index of this packet in the message (zero-indexed).\n  - `Z` (int): Total number of packets in the message.\n  - `some_text` (str): The content of the packet.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a completed message.", "refcode": "# import necessary packages\nimport re\nfrom collections import defaultdict\n\n# main function\ndef main_solution(packets):\n    \"\"\"\n    Assembles packets into complete messages and returns them in the order they are completed.\n\n    Args:\n    packets (list of str): A list of strings where each string represents a packet in the format \"X Y Z some_text\".\n\n    Returns:\n    list of str: A list of strings where each string represents a completed message.\n    \"\"\"\n    completed = []\n    buffer = defaultdict(list)\n\n    def parse(line):\n        matches = re.match(r'^(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(.+)?$', line, re.M)\n        return (int(matches.group(1)), int(matches.group(2)), int(matches.group(3)), matches.group(4) or '', line)\n\n    def is_full(id): \n        return all(x is not None for x in buffer[id])\n\n    def assemble_message(id):\n        return '\\n'.join([p[4] for p in buffer[id]])\n\n    for packet in packets:\n        parts = parse(packet)\n        if parts[0] not in buffer:\n            buffer[parts[0]] = [None] * parts[2]\n\n        buffer[parts[0]][parts[1]] = parts\n        if is_full(parts[0]):\n            completed.append(assemble_message(parts[0]))\n            buffer.pop(parts[0], None)\n\n    return completed", "funcname": "main_solution", "ios": [{"input": {"packets": ["5637 0 2 3RGyN8VB559p9zp03", "5637 1 2 A0i7G B4KynvkR1WRl4dJ"]}, "output": ["5637 0 2 3RGyN8VB559p9zp03\n5637 1 2 A0i7G B4KynvkR1WRl4dJ"]}, {"input": {"packets": ["1936 0 2 1vCoLwpk5dTeHPlKu", "1936 1 2 Xtd84VR0yvIy6jk1MRUlmOQOuJVQIybTNS", "5966 0 3 FMqvyQ dpHG4", "5966 1 3 PVfb7hFc04aS9U", "5966 2 3 Y5sCCxQ75p9Y86R3Q2NX4EGNtAKCBXq2L8"]}, "output": ["1936 0 2 1vCoLwpk5dTeHPlKu\n1936 1 2 Xtd84VR0yvIy6jk1MRUlmOQOuJVQIybTNS", "5966 0 3 FMqvyQ dpHG4\n5966 1 3 PVfb7hFc04aS9U\n5966 2 3 Y5sCCxQ75p9Y86R3Q2NX4EGNtAKCBXq2L8"]}, {"input": {"packets": ["6706 0 2 irG0byGHBGe2BqgzHy5frct7rJtcf is0gAqxGl4MaLVnaQms", "6706 1 2 6LSC7d1HJek"]}, "output": ["6706 0 2 irG0byGHBGe2BqgzHy5frct7rJtcf is0gAqxGl4MaLVnaQms\n6706 1 2 6LSC7d1HJek"]}, {"input": {"packets": ["3148 0 2 HZcN2nBs9bH7HqztgD7SFI2ThtXRQlUqJ", "3148 1 2 Ngha2s1Qp8evmckMOmopL3V"]}, "output": ["3148 0 2 HZcN2nBs9bH7HqztgD7SFI2ThtXRQlUqJ\n3148 1 2 Ngha2s1Qp8evmckMOmopL3V"]}, {"input": {"packets": ["8001 0 2 MlJNkQlDWJ0jRzorH2MOr0BHMzGl2j", "8001 1 2 RsCvWI5Z1u"]}, "output": ["8001 0 2 MlJNkQlDWJ0jRzorH2MOr0BHMzGl2j\n8001 1 2 RsCvWI5Z1u"]}, {"input": {"packets": ["1600 0 2 SC7GFKhzENqmFy03Ka7eP7zu04vqwP", "1600 1 2 b8QUgLqr7GmZQX6R1ES3IiZQ2AsGYay1D", "2589 0 2 QA5Ggp8fCxqRjTwogQRCO", "2589 1 2 UcIJlxZmlaK6h3nvKjsRyegruTb5VxYB"]}, "output": ["1600 0 2 SC7GFKhzENqmFy03Ka7eP7zu04vqwP\n1600 1 2 b8QUgLqr7GmZQX6R1ES3IiZQ2AsGYay1D", "2589 0 2 QA5Ggp8fCxqRjTwogQRCO\n2589 1 2 UcIJlxZmlaK6h3nvKjsRyegruTb5VxYB"]}, {"input": {"packets": ["3539 0 2 j8ruNrs7YIDSJ70JgeHx1bWpqiXNeSBoo1OPOacj3abL8fa", "3539 1 2 INorPG2NKW8"]}, "output": ["3539 0 2 j8ruNrs7YIDSJ70JgeHx1bWpqiXNeSBoo1OPOacj3abL8fa\n3539 1 2 INorPG2NKW8"]}, {"input": {"packets": ["5368 0 2 mFTL1cMJlZuPGNSvc6gNV69ubRz15hqVsPWeYZ", "5368 1 2 5OCMq K7Is"]}, "output": ["5368 0 2 mFTL1cMJlZuPGNSvc6gNV69ubRz15hqVsPWeYZ\n5368 1 2 5OCMq K7Is"]}, {"input": {"packets": ["4924 0 2 WQH4HJFbteXsQPvXC8f iwAeuBCPbA5u", "4924 1 2 4e3HfWbgBNMO63kGsZoRpUjxUVvEtJj97F"]}, "output": ["4924 0 2 WQH4HJFbteXsQPvXC8f iwAeuBCPbA5u\n4924 1 2 4e3HfWbgBNMO63kGsZoRpUjxUVvEtJj97F"]}, {"input": {"packets": ["4688 0 2 5YwPCiHZM4f", "4688 1 2 fRvVeihaNENM8y5JmyktaL7hNfHDL47EJE"]}, "output": ["4688 0 2 5YwPCiHZM4f\n4688 1 2 fRvVeihaNENM8y5JmyktaL7hNfHDL47EJE"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "blparker/challenges", "path": "/python/challenge_333_easy.py", "msgidx": 11136}}
{"problem_description": "Given a list of all possible 5-letter words composed of the characters '\u0410', '\u0417', '\u041d', '\u0421', which are ordered lexicographically, how many words are there between the words `start_word` and `end_word` (including these words)?", "io_requirements": "Input:\n  `start_word` (str): A 5-letter string consisting of the characters '\u0410', '\u0417', '\u041d', '\u0421'. This represents the starting word in the sequence.\n  `end_word` (str): A 5-letter string consisting of the characters '\u0410', '\u0417', '\u041d', '\u0421'. This represents the ending word in the sequence.\n\nOutput:\n  `return` (int): The number of words between `start_word` and `end_word` (inclusive) in the lexicographically ordered list of all possible 5-letter words composed of the characters '\u0410', '\u0417', '\u041d', '\u0421'.", "refcode": "# import necessary packages\nfrom itertools import product\n\n# main function\ndef main_solution(start_word, end_word):\n    # Convert input words to uppercase to ensure consistency\n    start_word = start_word.upper()\n    end_word = end_word.upper()\n    \n    # Initialize variables\n    count = 0\n    start_index = None\n    end_index = None\n    \n    # Generate all 5-letter words from the alphabet '\u0410\u0417\u041d\u0421'\n    for x in product('\u0410\u0417\u041d\u0421', repeat=5):\n        s = ''.join(x)\n        count += 1\n        if s == start_word:\n            start_index = count\n        if s == end_word:\n            end_index = count\n    \n    # Calculate the number of words between start_word and end_word (inclusive)\n    if start_index is not None and end_index is not None:\n        result = end_index - start_index + 1\n    else:\n        result = 0\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"start_word": "\u0410\u041d\u0421\u0410\u0421", "end_word": "\u0421\u0410\u0421\u041d\u0421"}, "output": 649}, {"input": {"start_word": "\u041d\u0410\u0410\u0421\u0417", "end_word": "\u041d\u0421\u0417\u0417\u041d"}, "output": 202}, {"input": {"start_word": "\u0421\u0417\u0417\u0410\u0410", "end_word": "\u0417\u0417\u0421\u0421\u0417"}, "output": -466}, {"input": {"start_word": "\u0417\u041d\u0421\u0421\u041d", "end_word": "\u041d\u0410\u0417\u0410\u0421"}, "output": 86}, {"input": {"start_word": "\u0421\u041d\u0410\u0417\u0417", "end_word": "\u0417\u0421\u0421\u0410\u0410"}, "output": -404}, {"input": {"start_word": "\u0421\u0410\u0421\u041d\u0421", "end_word": "\u0421\u041d\u0421\u0410\u0421"}, "output": 121}, {"input": {"start_word": "\u041d\u0417\u0421\u0417\u0421", "end_word": "\u0417\u0410\u0417\u0417\u0421"}, "output": -351}, {"input": {"start_word": "\u0410\u041d\u0421\u041d\u041d", "end_word": "\u041d\u0421\u0417\u0421\u0421"}, "output": 550}, {"input": {"start_word": "\u041d\u041d\u0421\u0417\u0421", "end_word": "\u0410\u0410\u0421\u0410\u0410"}, "output": -646}, {"input": {"start_word": "\u0421\u0421\u0421\u0410\u0421", "end_word": "\u0421\u0410\u041d\u0410\u0417"}, "output": -209}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dealvv/EGE", "path": "/Python/\u0415\u0413\u042d2021/8/\u0420\u0435\u0448\u0435\u043d\u0438\u0435 \u0437\u0430\u0434\u0430\u043d\u0438\u0439. \u041f\u043e\u043b\u044f\u043a\u043e\u0432/222.py", "msgidx": 11377}}
{"problem_description": "You are tasked with determining the number of valid passwords within a given range that meet specific criteria. The passwords must be six-digit numbers, with digits that never decrease from left to right, and must contain at least one pair of adjacent digits that are the same but not part of a larger group of matching digits. Given the range of numbers, how many passwords meet these criteria?", "io_requirements": "Input:\n  `start_range` (str): A string representing the starting number of the range (inclusive).\n  `end_range` (str): A string representing the ending number of the range (inclusive).\n\nOutput:\n  `return` (int): An integer representing the number of valid passwords within the given range that meet the criteria.", "refcode": "# import necessary packages\nimport re\n\n# main function\ndef main_solution(start_range, end_range):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # Convert the input range to integers\n  start_range = int(start_range)\n  end_range = int(end_range)\n  \n  count = 0\n  for i in range(start_range, end_range + 1):\n    matches = False\n    s = str(i)\n    if re.search(r\"^1*2*3*4*5*6*7*8*9*$\", s):\n      groups = re.findall(r\"(.)\\1\", s)\n      for g in groups:\n        if not re.search(re.escape(g) + r\"{3}\", s):\n          matches = True\n    if matches:\n      count += 1\n  \n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return count", "funcname": "main_solution", "ios": [{"input": {"start_range": "750760", "end_range": "774116"}, "output": 0}, {"input": {"start_range": "654262", "end_range": "724561"}, "output": 33}, {"input": {"start_range": "718324", "end_range": "747603"}, "output": 0}, {"input": {"start_range": "633537", "end_range": "672635"}, "output": 24}, {"input": {"start_range": "734694", "end_range": "751667"}, "output": 0}, {"input": {"start_range": "514168", "end_range": "754891"}, "output": 112}, {"input": {"start_range": "621276", "end_range": "749649"}, "output": 33}, {"input": {"start_range": "717916", "end_range": "728673"}, "output": 0}, {"input": {"start_range": "471152", "end_range": "704601"}, "output": 121}, {"input": {"start_range": "709620", "end_range": "753593"}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "a-falcone/puzzles", "path": "/adventofcode/2019/04b.py", "msgidx": 11622}}
{"problem_description": "In a neighborhood of five houses, each house is painted a different color, and each house is occupied by a person of a different nationality. These five owners each drink a different beverage, smoke a different brand of cigar, and keep a different pet. Based on the following clues, who drinks water and who owns the zebra?\n\n1. The Englishman lives in the red house.\n2. The Spaniard owns the dog.\n3. Coffee is drunk in the green house.\n4. The Ukrainian drinks tea.\n5. The green house is immediately to the right of the ivory house.\n6. The Old Gold smoker owns snails.\n7. Kools are smoked in the yellow house.\n8. Milk is drunk in the middle house.\n9. The Norwegian lives in the first house.\n10. The man who smokes Chesterfields lives in the house next to the man with the fox.\n11. Kools are smoked in the house next to the house where the horse is kept.\n12. The Lucky Strike smoker drinks orange juice.\n13. The Japanese smokes Parliaments.\n14. The Norwegian lives next to the blue house.", "io_requirements": "Input:\n  No input arguments are required for this function.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `water_drinker` (str): The nationality of the person who drinks water.\n    - `zebra_owner` (str): The nationality of the person who owns the zebra.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef is_right_of(house1, house2):\n    \"\"\" Returns True if house1 is immediately to the right of house2 \"\"\"\n    return house1 == house2 + 1\n\ndef is_next_to(house1, house2):\n    \"\"\" Returns True if house1 is next to house2 \"\"\"\n    return abs(house1 - house2) == 1\n\nclass ZebraPuzzle:\n    def __init__(self):\n        self.water_drinker = None\n        self.zebra_owner = None\n        self.nationalities = {}\n\n        (self.red, self.green, self.ivory, self.yellow, self.blue) = [None] * 5\n        (self.english, self.spanish, self.ukranian, self.norwegian, self.japanese) = [None] * 5\n        (self.coffee, self.tea, self.milk, self.orange_juice, self.water) = [None] * 5\n        (self.old_gold, self.kools, self.chesterfields, self.lucky_strike, self.parliaments) = [None] * 5\n        (self.dog, self.snails, self.fox, self.horse, self.zebra) = [None] * 5\n\n    def solve(self):\n        for perm in permutations([1, 2, 3, 4, 5]):\n            if self.solve_for_colour(perm):\n                break\n        return self\n\n    def solve_for_colour(self, permutation):\n        (self.red, self.green, self.ivory, self.yellow, self.blue) = permutation\n        if is_right_of(self.green, self.ivory):\n            for perm in permutations([1, 2, 3, 4, 5]):\n                if self.solve_for_nationality(perm):\n                    return True\n        return False\n\n    def solve_for_nationality(self, permutation):\n        (self.english, self.spanish, self.ukranian, self.norwegian, self.japanese) = permutation\n        if self.english == self.red and self.norwegian == 1 and is_next_to(self.norwegian, self.blue):\n            self.nationalities = {\n                self.english: \"Englishman\",\n                self.spanish: \"Spaniard\",\n                self.ukranian: \"Ukranian\",\n                self.norwegian: \"Norwegian\",\n                self.japanese: \"Japanese\"\n            }\n            for perm in permutations([1, 2, 3, 4, 5]):\n                if self.solve_for_beverages(perm):\n                    return True\n        return False\n\n    def solve_for_beverages(self, permutation):\n        (self.coffee, self.tea, self.milk, self.orange_juice, self.water) = permutation\n        if self.coffee == self.green and self.ukranian == self.tea and self.milk == 3:\n            for perm in permutations([1, 2, 3, 4, 5]):\n                if self.solve_for_smokes(perm):\n                    return True\n        return False\n\n    def solve_for_smokes(self, permutation):\n        (self.old_gold, self.kools, self.chesterfields, self.lucky_strike, self.parliaments) = permutation\n        if self.kools == self.yellow and self.lucky_strike == self.orange_juice and self.japanese == self.parliaments:\n            for perm in permutations([1, 2, 3, 4, 5]):\n                if self.solve_for_pets(perm):\n                    return True\n        return False\n\n    def solve_for_pets(self, permutation):\n        (self.dog, self.snails, self.fox, self.horse, self.zebra) = permutation\n        if self.spanish == self.dog and self.old_gold == self.snails and is_next_to(self.chesterfields, self.fox) and is_next_to(self.kools, self.horse):\n            self.water_drinker = self.nationalities[self.water]\n            self.zebra_owner = self.nationalities[self.zebra]\n            return True\n        return False\n\n# main function\ndef main_solution():\n    puzzle = ZebraPuzzle().solve()\n    return {\"water_drinker\": puzzle.water_drinker, \"zebra_owner\": puzzle.zebra_owner}", "funcname": "main_solution", "ios": [{"input": {}, "output": {"water_drinker": "Norwegian", "zebra_owner": "Japanese"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "glennj/exercism.io", "path": "/python/zebra-puzzle/zebra_puzzle.py", "msgidx": 11366}}
{"problem_description": "Given an undirected graph represented by an adjacency list, determine whether it is possible to partition the graph into two sets of nodes such that every edge in the graph connects a node from one set to a node from the other set. What is the result of this bipartite check for the given graph?", "io_requirements": "Input:\n  `graph` (List[List[int]]): A list of lists where each inner list represents the neighbors of a node in the graph. Each node is an integer between 0 and len(graph)-1. The graph is undirected, meaning if node `j` is in `graph[i]`, then node `i` is in `graph[j]`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the graph is bipartite. Returns `True` if the graph can be divided into two independent sets of nodes, otherwise returns `False`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(graph: List[List[int]]) -> bool:\n    # Convert the input graph to a list of lists if it's not already\n    graph = [list(neighbors) for neighbors in graph]\n    \n    # Function to check if the graph is bipartite\n    def is_bipartite(graph: List[List[int]]) -> bool:\n        l = len(graph)\n        U = set()\n        V = set()\n\n        def check_is_valid(ele: int, U: set, V: set) -> bool:\n            if ele in V:\n                return False\n            if ele in U:\n                return True\n            U.add(ele)\n            for sub_ele in graph[ele]:\n                if not check_is_valid(sub_ele, V, U):\n                    return False\n            return True\n\n        for i in range(l):\n            if i in U or i in V:\n                continue\n            if not check_is_valid(i, U, V):\n                return False\n        return True\n    \n    # Return the result of the bipartite check\n    return is_bipartite(graph)", "funcname": "main_solution", "ios": [{"input": {"graph": [[], []]}, "output": true}, {"input": {"graph": [[4], [3], [3], [1, 2, 4], [0, 3]]}, "output": true}, {"input": {"graph": [[], [2], [1], []]}, "output": true}, {"input": {"graph": [[]]}, "output": true}, {"input": {"graph": [[1, 2, 3], [0, 3], [0], [0, 1]]}, "output": false}, {"input": {"graph": [[2], [], [0]]}, "output": true}, {"input": {"graph": [[3], [], [3], [0, 2]]}, "output": true}, {"input": {"graph": [[1], [0, 2], [1]]}, "output": true}, {"input": {"graph": [[1], [0]]}, "output": true}, {"input": {"graph": [[2, 3], [], [0, 3], [0, 2, 5], [5], [3, 4]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rain-zhao/leetcode", "path": "/py/Task785.py", "msgidx": 11360}}
{"problem_description": "Given a maximum value, what is the smallest odd composite number that cannot be expressed as the sum of a prime and twice a square, considering primes and squares up to that maximum value?", "io_requirements": "Input:\n  `max_value` (int): The maximum value up to which to generate primes and squares. This value should be greater than 1.\n\nOutput:\n  `return` (int): The smallest odd composite number that cannot be expressed as the sum of a prime and twice a square.", "refcode": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef is_prime(number):\n    if number > 1:\n        if number == 2:\n            return True\n        if number % 2 == 0:\n            return False\n        for current in range(3, int(sqrt(number) + 1), 2):\n            if number % current == 0: \n                return False\n        return True\n    return False\n\ndef generatePrimes():\n    start = 2\n    while True:\n        if is_prime(start):\n            yield start\n        start += 1\n        \ndef generateSquares():\n    start = 1\n    while True:\n        yield start ** 2\n        start += 1\n\n# main function\ndef main_solution(max_value):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    squareGenerator = generateSquares()\n    setSquares = set()\n    maxSquare = next(squareGenerator)\n    while maxSquare < max_value:\n        setSquares.add(maxSquare)\n        maxSquare = next(squareGenerator)\n    \n    primeGenerator = generatePrimes()\n    setPrimes = set()\n    maxPrime = next(primeGenerator)\n    while maxPrime < max_value:\n        setPrimes.add(maxPrime)\n        maxPrime = next(primeGenerator)\n\n    oddComposite = 9\n    while True:\n        if maxPrime < oddComposite:\n            setPrimes.add(maxPrime)\n            maxPrime = next(primeGenerator)\n        if maxSquare < oddComposite:\n            setSquares.add(maxSquare)\n            maxSquare = next(squareGenerator)\n        found = False\n        for prime in setPrimes:\n            if found: break\n            for square in setSquares:\n                if oddComposite == prime + 2 * square:\n                    found = True\n                    break\n        if not found:\n            # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n            return oddComposite\n        oddComposite += 2\n        while is_prime(oddComposite):\n            oddComposite += 2", "funcname": "main_solution", "ios": [{"input": {"max_value": 634}, "output": 5777}, {"input": {"max_value": 163}, "output": 5777}, {"input": {"max_value": 876}, "output": 5777}, {"input": {"max_value": 893}, "output": 5777}, {"input": {"max_value": 106}, "output": 5777}, {"input": {"max_value": 133}, "output": 5777}, {"input": {"max_value": 891}, "output": 5777}, {"input": {"max_value": 187}, "output": 5777}, {"input": {"max_value": 479}, "output": 5777}, {"input": {"max_value": 947}, "output": 5777}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mandmyay1/ard-public", "path": "/ProjectEulerProblem2/46_GoldbachsOtherConjecture/46_GoldbachsOtherConjecture.py", "msgidx": 11228}}
{"problem_description": "Given a grid of size N x N, where N is a positive integer, how many unique paths are there from the top-left corner to the bottom-right corner, moving only right or down?", "io_requirements": "Input:\n  `matrix_size` (int): The size of the matrix (N x N). For example, if `matrix_size` is 20, the matrix will be 21x21 (including boundaries).\n\nOutput:\n  `return` (int): The number of unique paths from the top-left corner to the bottom-right corner in the matrix.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Tree(object):\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.data = None\n\n# main function\ndef main_solution(matrix_size):\n    # Convert the input to the required format\n    matrix_size = int(matrix_size)\n    \n    # Create the matrix\n    Matrix = [[0 for x in range(matrix_size + 1)] for y in range(matrix_size + 1)]\n    val = 1 \n    for i in range(matrix_size + 1):\n        for j in range(matrix_size + 1):\n            Matrix[i][j] = val\n            val += 1\n    \n    # Function to populate the tree and count the paths\n    def populateMat(i, j, matrix):\n        if i > matrix_size or j > matrix_size:\n            return None\n        node = Tree()\n        node.data = matrix[i][j]\n        if node.data == (matrix_size + 1) ** 2:\n            return node\n        node.left = populateMat(i + 1, j, matrix)\n        node.right = populateMat(i, j + 1, matrix)\n        return node\n    \n    # Populate the tree\n    root = populateMat(0, 0, Matrix)\n    \n    # Calculate the number of paths using binomial coefficient\n    num_paths = math.comb(2 * matrix_size, matrix_size)\n    \n    # Return the number of paths\n    return num_paths", "funcname": "main_solution", "ios": [{"input": {"matrix_size": 6}, "output": 924}, {"input": {"matrix_size": 3}, "output": 20}, {"input": {"matrix_size": 4}, "output": 70}, {"input": {"matrix_size": 8}, "output": 12870}, {"input": {"matrix_size": 1}, "output": 2}, {"input": {"matrix_size": 9}, "output": 48620}, {"input": {"matrix_size": 5}, "output": 252}, {"input": {"matrix_size": 2}, "output": 6}, {"input": {"matrix_size": 7}, "output": 3432}, {"input": {"matrix_size": 10}, "output": 184756}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "VinayBanakar/Project-Euler", "path": "/matrixPathE15Py.py", "msgidx": 11763}}
{"problem_description": "A traveler in the wild west has been given a set of directions to reach a destination. The directions include movements in four cardinal directions: \"NORTH\", \"SOUTH\", \"EAST\", and \"WEST\". However, some of these directions are opposite to each other, making the journey inefficient. For example, moving \"NORTH\" and then immediately \"SOUTH\" cancels out each other. Given a list of such directions, what is the simplified version of the directions that eliminates all opposite movements, ensuring the traveler saves energy and avoids unnecessary efforts?", "io_requirements": "Input:\n  `directions` (str): A comma-separated string of direction names (e.g., \"NORTH,SOUTH,EAST\").\n\nOutput:\n  `return` (str): A comma-separated string of simplified direction names after removing opposite directions (e.g., \"WEST\").", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef dirReduc(arr):\n    direction = {\"NORTH\": \"SOUTH\", \"SOUTH\": \"NORTH\", \"EAST\": \"WEST\", \"WEST\": \"EAST\"}\n    a = []\n    for i in arr:\n        if a and direction[i] == a[-1]:\n            a.pop()\n        else:\n            a.append(i)\n    return a\n\n# main function\ndef main_solution(directions):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # convert the JSON serializable input to the original input variables\n  directions_list = directions.split(',')\n  # invoke the function that requires non-json serializable inputs\n  simplified_directions = dirReduc(directions_list)\n  # convert the output to JSON serializable\n  return ','.join(simplified_directions)", "funcname": "main_solution", "ios": [{"input": {"directions": "WEST,NORTH,SOUTH,SOUTH,NORTH,EAST,SOUTH,SOUTH,NORTH"}, "output": "SOUTH"}, {"input": {"directions": "WEST,WEST,NORTH,WEST,NORTH,NORTH,WEST,SOUTH,NORTH"}, "output": "WEST,WEST,NORTH,WEST,NORTH,NORTH,WEST"}, {"input": {"directions": "NORTH,NORTH,NORTH,WEST,SOUTH,EAST,EAST,WEST,SOUTH"}, "output": "NORTH,NORTH,NORTH,WEST,SOUTH,EAST,SOUTH"}, {"input": {"directions": "WEST,EAST,WEST,NORTH,EAST,EAST"}, "output": "WEST,NORTH,EAST,EAST"}, {"input": {"directions": "SOUTH,NORTH,WEST,EAST,WEST"}, "output": "WEST"}, {"input": {"directions": "NORTH,SOUTH,EAST,WEST,EAST"}, "output": "EAST"}, {"input": {"directions": "SOUTH,SOUTH,SOUTH,EAST,SOUTH,EAST,WEST,WEST,NORTH"}, "output": "SOUTH,SOUTH,SOUTH,EAST,SOUTH,WEST,NORTH"}, {"input": {"directions": "NORTH,EAST,EAST,EAST,EAST,SOUTH,SOUTH"}, "output": "NORTH,EAST,EAST,EAST,EAST,SOUTH,SOUTH"}, {"input": {"directions": "EAST,NORTH,WEST,SOUTH,NORTH"}, "output": "EAST,NORTH,WEST"}, {"input": {"directions": "WEST,SOUTH,EAST,WEST,SOUTH,WEST,EAST,EAST,NORTH"}, "output": "WEST,SOUTH,SOUTH,EAST,NORTH"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AJsenpai/codewars", "path": "/dirReduc.py", "msgidx": 11468}}
{"problem_description": "Given a specific year and month, what is the date of the nth occurrence of a particular weekday? For example, what is the date of the third Monday in March 2023?", "io_requirements": "Input:\n  `year` (int): The year for which the date is to be calculated.\n  `month` (int): The month for which the date is to be calculated.\n  `nth` (int): The occurrence of the weekday (e.g., 1 for the first, -1 for the last).\n  `weekday` (str): The name of the weekday (e.g., \"MONDAY\", \"TUESDAY\", etc.).\n\nOutput:\n  `return` (str): The date of the nth occurrence of the specified weekday in the format \"YYYY-MM-DD\".", "refcode": "# import necessary packages\nfrom datetime import date\nimport calendar\n\n# main function\ndef main_solution(year, month, nth, weekday):\n    \"\"\"\n    Calculate the date of the nth occurrence of a specific weekday in a given month and year.\n\n    Parameters:\n    year (int): The year for which the date is to be calculated.\n    month (int): The month for which the date is to be calculated.\n    nth (int): The occurrence of the weekday (e.g., 1 for the first, -1 for the last).\n    weekday (str): The name of the weekday (e.g., \"MONDAY\", \"TUESDAY\", etc.).\n\n    Returns:\n    str: The date of the nth occurrence of the specified weekday in the format \"YYYY-MM-DD\".\n    \"\"\"\n    # Convert weekday name to calendar weekday index\n    weekday_index = getattr(calendar, weekday.upper())\n    \n    # Calculate the nth occurrence of the specified weekday\n    def weekdays_in_month(year, month, weekday):\n        \"\"\"Return list of all 4/5 dates with given weekday and year/month.\"\"\"\n        return [\n            date(year, month, week[weekday])\n            for week in calendar.monthcalendar(year, month) \n            if week[weekday] != 0 \n        ]\n    \n    dates = weekdays_in_month(year, month, weekday_index)\n    target_date = dates[nth-1 if nth > 0 else nth]\n    \n    # Return the date in the format \"YYYY-MM-DD\"\n    return target_date.strftime(\"%Y-%m-%d\")", "funcname": "main_solution", "ios": [{"input": {"year": 2004, "month": 3, "nth": -1, "weekday": "FRIDAY"}, "output": "2004-03-26"}, {"input": {"year": 2023, "month": 3, "nth": 3, "weekday": "SATURDAY"}, "output": "2023-03-18"}, {"input": {"year": 2037, "month": 6, "nth": 2, "weekday": "WEDNESDAY"}, "output": "2037-06-10"}, {"input": {"year": 2020, "month": 10, "nth": 3, "weekday": "THURSDAY"}, "output": "2020-10-15"}, {"input": {"year": 2029, "month": 6, "nth": 1, "weekday": "SUNDAY"}, "output": "2029-06-03"}, {"input": {"year": 2015, "month": 10, "nth": -1, "weekday": "TUESDAY"}, "output": "2015-10-27"}, {"input": {"year": 2075, "month": 8, "nth": -1, "weekday": "MONDAY"}, "output": "2075-08-26"}, {"input": {"year": 2015, "month": 10, "nth": 1, "weekday": "MONDAY"}, "output": "2015-10-05"}, {"input": {"year": 2089, "month": 2, "nth": -1, "weekday": "THURSDAY"}, "output": "2089-02-24"}, {"input": {"year": 2060, "month": 3, "nth": -1, "weekday": "MONDAY"}, "output": "2060-03-29"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "billyxs/notes.md", "path": "/python/learning/python_morsels/2019-02-04_meetup_date/meetup_date.py", "msgidx": 11213}}
{"problem_description": "In the famous Josephus problem, a group of people stand in a circle and are eliminated in a specific order. Given the total number of people in the circle and the step count after which a person is eliminated, which position in the circle will be the last one remaining?", "io_requirements": "Input:\n  `total_people` (int): The total number of people in the circle.\n  `step` (int): The step count after which a person is removed from the circle.\n\nOutput:\n  `return` (int): The position of the last remaining person in the circle.", "refcode": "# import necessary packages\nimport collections\n\n# main function\ndef main_solution(total_people, step):\n    # Convert the input to the required format for the ysf function\n    d = collections.deque(range(1, total_people + 1))\n    while len(d) > 1:\n        d.rotate(-step)  # Rotate the deque to the left by step\n        d.pop()  # Remove the person at the current position\n    # Return the last remaining person\n    return d[0]", "funcname": "main_solution", "ios": [{"input": {"total_people": 30, "step": 1}, "output": 30}, {"input": {"total_people": 34, "step": 9}, "output": 25}, {"input": {"total_people": 47, "step": 10}, "output": 6}, {"input": {"total_people": 28, "step": 4}, "output": 27}, {"input": {"total_people": 23, "step": 7}, "output": 1}, {"input": {"total_people": 20, "step": 6}, "output": 20}, {"input": {"total_people": 39, "step": 2}, "output": 15}, {"input": {"total_people": 34, "step": 5}, "output": 23}, {"input": {"total_people": 38, "step": 5}, "output": 6}, {"input": {"total_people": 45, "step": 7}, "output": 16}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ys0823/python-100examples", "path": "/100 examples/88.py", "msgidx": 11526}}
{"problem_description": "Given two sequences of integers, one representing the order in which elements are pushed onto a stack and the other representing the order in which elements are popped from the stack, determine if the pop sequence is a valid sequence for the given push sequence. The sequences are of equal length, and all elements in the push sequence are unique. What is the result of checking if the pop sequence is valid for the given push sequence?", "io_requirements": "Input:\n  `pushV` (list of int): A list of integers representing the push order of a stack.\n  `popV` (list of int): A list of integers representing the pop order of the stack.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the `popV` sequence is a valid pop order for the `pushV` sequence.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def IsPopOrder(self, pushV, popV):\n        helper = []\n        pos = 0\n        for i in range(len(pushV)):\n            helper.append(pushV[i])\n            while helper and helper[-1] == popV[0]:\n                helper.pop()\n                popV.pop(0)\n        if not popV:\n            return True\n        return False\n\n# main function\ndef main_solution(pushV, popV):\n    # Convert input lists to JSON serializable format\n    pushV = list(pushV)\n    popV = list(popV)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the IsPopOrder method\n    result = solution.IsPopOrder(pushV, popV)\n    \n    # Return the result\n    return result", "funcname": "main_solution", "ios": [{"input": {"pushV": [97, 46, 70, 40, 35, 63, 12, 18], "popV": [12, 97, 70, 46, 35, 18, 63, 40]}, "output": false}, {"input": {"pushV": [1, 49, 22, 62, 13], "popV": [62, 49, 1, 13, 22]}, "output": false}, {"input": {"pushV": [2, 64], "popV": [2, 64]}, "output": true}, {"input": {"pushV": [94, 11, 43, 52, 67, 51, 78], "popV": [11, 94, 43, 51, 78, 52, 67]}, "output": false}, {"input": {"pushV": [47, 38, 35], "popV": [38, 47, 35]}, "output": true}, {"input": {"pushV": [58, 95, 63, 91, 31, 67, 20], "popV": [67, 20, 95, 31, 63, 58, 91]}, "output": false}, {"input": {"pushV": [41, 49, 79, 72, 87], "popV": [87, 72, 49, 41, 79]}, "output": false}, {"input": {"pushV": [21, 99], "popV": [99, 21]}, "output": true}, {"input": {"pushV": [1, 28, 53, 17], "popV": [17, 1, 28, 53]}, "output": false}, {"input": {"pushV": [46, 52, 69, 28, 65], "popV": [69, 52, 46, 28, 65]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chendingyan/My-Leetcode", "path": "/\u5251\u6307offer-python/IsPopOrder.py", "msgidx": 11869}}
{"problem_description": "In a class, each student has a preference for which student they want to be next to in a circle. Given the number of students and their preferences, what is the maximum number of students that can form a circle such that each student is next to their preferred student(s)?", "io_requirements": "Input:\n  `n` (int): The number of students in the class.\n  `l` (list of int): A list representing the preferences of each student, where `l[i]` indicates the student that student `i+1` wants to be next to.\n\nOutput:\n  `return` (int): The maximum number of students that can form a circle such that each student is next to their preferred student(s).", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef check_circle(x, l):\n    n = len(x)\n    if l[x[0]-1] != x[1] and l[x[0]-1] != x[-1]:\n        return False\n    if l[x[-1]-1] != x[-2] and l[x[-1]-1] != x[0]:\n        return False\n    for i in range(1,n-1):\n        if l[x[i]-1] != x[i-1] and l[x[i]-1] != x[i+1]:\n            return False\n    return True\n\ndef numstudents(n, l):\n    res = []\n    s = list(range(1,n+1))\n    for i in range(3,n+1):\n        for x in itertools.permutations(s,i):\n            if check_circle(x, l):\n                res.append(len(x))\n    return max(res) if res else 0\n\n# main function\ndef main_solution(n, l):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # convert list to json serializable format\n  l = list(l)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return numstudents(n, l)", "funcname": "main_solution", "ios": [{"input": {"n": 7, "l": [4, 1, 1, 3, 7, 7, 3]}, "output": 3}, {"input": {"n": 5, "l": [1, 3, 5, 4, 5]}, "output": 0}, {"input": {"n": 10, "l": [3, 7, 1, 8, 5, 4, 7, 8, 5, 7]}, "output": 0}, {"input": {"n": 3, "l": [2, 2, 3]}, "output": 0}, {"input": {"n": 6, "l": [1, 3, 1, 6, 6, 5]}, "output": 3}, {"input": {"n": 5, "l": [2, 1, 1, 4, 5]}, "output": 3}, {"input": {"n": 3, "l": [2, 1, 3]}, "output": 0}, {"input": {"n": 3, "l": [2, 1, 1]}, "output": 3}, {"input": {"n": 8, "l": [1, 7, 5, 1, 1, 4, 6, 3]}, "output": 0}, {"input": {"n": 8, "l": [2, 5, 8, 7, 2, 6, 5, 5]}, "output": 5}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DaHuO/Supergraph", "path": "/codes/CodeJamCrawler/16_1_3_neat/16_1_3_vb1995_bff.py", "msgidx": 11756}}
{"problem_description": "Given a set of packages with different weights, how can we group them into two groups such that the total weight of one group is three times the total weight of the other group, and the quantum entanglement of the first group is minimized? What is the quantum entanglement of the best group and how many packages are in the first group of the best solution?", "io_requirements": "Input:\n  `packages` (list of int): A list of integers representing the weights of the packages.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `bestqe` (int): The quantum entanglement of the best group.\n    - `bestfirstcount` (int): The number of packages in the first group of the best solution.\n    - `bestgroup` (list of int): A list representing the best grouping of packages.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef evaluateGroup(packages, grouping):\n    firstcount = 0\n    qe = 1\n    weight = [0, 0]\n    for i in range(len(packages)):\n        weight[grouping[i]] = weight[grouping[i]] + packages[i]\n        if grouping[i] == 0:\n            firstcount = firstcount + 1\n            qe = qe * packages[i]\n    \n    equalweights = (3 * weight[0] == weight[1])\n    return (equalweights, firstcount, qe)\n\n# main function\ndef main_solution(packages):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    bestfirstcount = 10000\n    bestqe = 100000000000\n    bestgroup = None\n    \n    count = 0\n    for group in itertools.product(range(0, 2), repeat=len(packages)):\n        count = count + 1\n        (isequal, firstcount, qe) = evaluateGroup(packages, group)\n        if isequal:\n            if firstcount <= bestfirstcount:\n                bestfirstcount = firstcount\n                if qe < bestqe:\n                    bestqe = qe\n                    bestgroup = group\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"bestqe\": bestqe, \"bestfirstcount\": bestfirstcount, \"bestgroup\": bestgroup}", "funcname": "main_solution", "ios": [{"input": {"packages": [68, 17, 8, 22, 56, 16]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [52, 55, 39, 20, 17]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [27, 10, 100, 37, 8]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [37, 84, 75, 60, 39, 88, 90, 43, 99]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [51, 74, 3, 78, 16, 64, 22, 84, 7]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [76, 28, 33, 91, 18, 48, 19, 94, 97, 53]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [35, 31, 69, 55, 18, 43]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [63, 62, 82, 83, 69]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [60, 22, 12, 52, 62, 60, 23, 32, 19]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}, {"input": {"packages": [84, 40, 83, 55, 42, 61, 16, 14, 25]}, "output": {"bestqe": 100000000000, "bestfirstcount": 10000, "bestgroup": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jborlik/AdventOfCode2015", "path": "/day24.py", "msgidx": 11631}}
{"problem_description": "In a futuristic farm, farmers need to transport their cows to another planet using a spaceship. Each cow has a specific weight, and the spaceship has a weight limit for each trip. Given the weights of the cows and the weight limit of the spaceship, how can the farmers minimize the number of trips required to transport all the cows without exceeding the weight limit on any trip?", "io_requirements": "Input:\n  `cows` (dict): A dictionary where keys are cow names (string) and values are their weights (int).\n  `limit` (int): The weight limit of the spaceship.\n\nOutput:\n  `return` (list of lists): A list of lists, where each inner list contains the names of cows transported on a particular trip. The overall list contains all the trips.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef get_partitions(items):\n    \"\"\"\n    Generate all possible partitions of a list of items.\n    \"\"\"\n    for partition in itertools.product(range(len(items) + 1), repeat=len(items)):\n        parts = []\n        part = []\n        for item, num in zip(items, partition):\n            if num == len(parts):\n                parts.append(part)\n                part = []\n            part.append(item)\n        parts.append(part)\n        yield [p for p in parts if p]\n\n# main function\ndef main_solution(cows, limit):\n    \"\"\"\n    Finds the allocation of cows that minimizes the number of spaceship trips\n    via brute force.\n\n    Parameters:\n    cows - a dictionary of name (string), weight (int) pairs\n    limit - weight limit of the spaceship (an int)\n    \n    Returns:\n    A list of lists, with each inner list containing the names of cows\n    transported on a particular trip and the overall list containing all the\n    trips\n    \"\"\"\n    comb = []\n    for partition in get_partitions(cows.keys()):\n        comb.append(partition)\n    \n    valid_combinations = []\n    for partition in comb:\n        valid = True\n        for trip in partition:\n            if sum(cows[cow] for cow in trip) > limit:\n                valid = False\n                break\n        if valid:\n            valid_combinations.append(partition)\n    \n    min_trips = min(len(partition) for partition in valid_combinations)\n    for partition in valid_combinations:\n        if len(partition) == min_trips:\n            return partition", "funcname": "main_solution", "ios": [{"input": {"cows": {"cow_0": 123, "cow_1": 431, "cow_2": 100}, "limit": 791}, "output": [["cow_0", "cow_1", "cow_2"]]}, {"input": {"cows": {"cow_0": 239, "cow_1": 317, "cow_2": 302}, "limit": 994}, "output": [["cow_0", "cow_1", "cow_2"]]}, {"input": {"cows": {"cow_0": 392, "cow_1": 381, "cow_2": 267}, "limit": 543}, "output": [["cow_0"], ["cow_1"], ["cow_2"]]}, {"input": {"cows": {"cow_0": 135, "cow_1": 377, "cow_2": 274, "cow_3": 209}, "limit": 808}, "output": [["cow_0", "cow_1", "cow_2"], ["cow_3"]]}, {"input": {"cows": {"cow_0": 248, "cow_1": 368, "cow_2": 143, "cow_3": 417}, "limit": 584}, "output": [["cow_0"], ["cow_1", "cow_2"], ["cow_3"]]}, {"input": {"cows": {"cow_0": 342, "cow_1": 289, "cow_2": 375, "cow_3": 129}, "limit": 817}, "output": [["cow_0", "cow_1"], ["cow_2", "cow_3"]]}, {"input": {"cows": {"cow_0": 439, "cow_1": 408, "cow_2": 314, "cow_3": 304, "cow_4": 288}, "limit": 857}, "output": [["cow_0", "cow_1"], ["cow_2", "cow_3"], ["cow_4"]]}, {"input": {"cows": {"cow_0": 306, "cow_1": 255, "cow_2": 327, "cow_3": 443, "cow_4": 440}, "limit": 945}, "output": [["cow_0", "cow_1", "cow_2"], ["cow_3", "cow_4"]]}, {"input": {"cows": {"cow_0": 107, "cow_1": 477, "cow_2": 148}, "limit": 580}, "output": [["cow_0"], ["cow_1"], ["cow_2"]]}, {"input": {"cows": {"cow_0": 152, "cow_1": 112, "cow_2": 283, "cow_3": 471, "cow_4": 475}, "limit": 955}, "output": [["cow_0", "cow_1", "cow_2"], ["cow_3", "cow_4"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lingjiangj/MITx-6.00.2x", "path": "/ProblemSet1/Part 2: Brute Force Cow Transport.py", "msgidx": 11341}}
{"problem_description": "Given a position `n`, what is the nth left-truncatable prime number? A left-truncatable prime is a prime number that remains prime when the leftmost digit is successively removed.", "io_requirements": "Input:\n  `n` (int): The position of the left-truncatable prime number to find. For example, if `n` is 10, the function will return the 10th left-truncatable prime number.\n\nOutput:\n  `return` (int): The nth left-truncatable prime number.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPrime(n):\n    if n < 2:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        limit = round(math.sqrt(n)) + 1\n        for i in range(3, limit, 2):\n            if n % i == 0:\n                return False\n    return True\n\ndef digitsNum(n):\n    n = abs(n)\n    if n == 0:\n        return 1\n    count = 0\n    while n:\n        count += 1\n        n = n // 10\n    return count\n\ndef leftTrunc(n):\n    digitsNumber = digitsNum(n)\n    Head = n // 10**(digitsNum(n) - 1)\n    n = n - Head * 10**(digitsNum(n) - 1)\n    return n\n\ndef LeftTruncatablePrime(n):\n    while n:\n        if not isPrime(n):\n            return False\n        else:\n            n = leftTrunc(n)\n    return True\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 0\n    guess = 2\n    while count <= n:\n        if LeftTruncatablePrime(guess):\n            count += 1\n        guess += 1\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return guess - 1", "funcname": "main_solution", "ios": [{"input": {"n": 39}, "output": 607}, {"input": {"n": 19}, "output": 167}, {"input": {"n": 12}, "output": 73}, {"input": {"n": 33}, "output": 397}, {"input": {"n": 26}, "output": 317}, {"input": {"n": 27}, "output": 337}, {"input": {"n": 8}, "output": 43}, {"input": {"n": 11}, "output": 67}, {"input": {"n": 45}, "output": 673}, {"input": {"n": 25}, "output": 313}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jackalsin/Python", "path": "/15112/Quiz/H2P6_Truncatable prime.py", "msgidx": 11585}}
{"problem_description": "Given a DNA sequence, what are the Open Reading Frames (ORFs) that start with the codon \"ATG\" and end with one of the stop codons (\"TAG\", \"TAA\", \"TGA\") in both the original and reverse complement strands of the DNA sequence?", "io_requirements": "Input:\n  `dna` (str): A string representing the DNA sequence. The string should contain only the characters 'A', 'T', 'G', and 'C'.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents an Open Reading Frame (ORF) found in the DNA sequence. Each ORF is a substring of the input DNA sequence that starts with \"ATG\" and ends with one of the stop codons (\"TAG\", \"TAA\", \"TGA\").", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\ndef find_all_ORFs_both_strands_full(dna):\n    ORFs = []\n    for idna in (dna, ''.join([b[b.index(i)+(1 if b.index(i)%2==0 else -1)] for i in dna[::-1] for b in [['A','T','G','C']]])):\n        for j in range(3):\n            starter = j\n            for threes in range(j, len(idna)-1, 3):\n                if idna[threes:threes+3] in (\"TAG\",\"TAA\",\"TGA\"):\n                    for k in range(starter, threes, 3):\n                        if idna[k:k+3] == \"ATG\":\n                            starter = threes\n                            ORFs.append(idna[k:threes])\n                            break\n    return ORFs\n\n# main function\ndef main_solution(dna):\n    # Convert the input to the required format\n    dna_str = str(dna)\n    \n    # Call the function to find all ORFs in both strands\n    orfs = find_all_ORFs_both_strands_full(dna_str)\n    \n    # Convert the output to JSON serializable format\n    orfs_list = [orf for orf in orfs]\n    \n    return orfs_list", "funcname": "main_solution", "ios": [{"input": {"dna": "AGTAGAGGCGTGCTCGCCTACGTGGAACTCATCAG"}, "output": ["ATGAGTTCCACG"]}, {"input": {"dna": "TGACCTATTA"}, "output": []}, {"input": {"dna": "TTTTCCGAAGACTTCCTGATTATCTATCCTCAGCAA"}, "output": []}, {"input": {"dna": "CAGACATACAGAAGGGTTTCTCCCC"}, "output": []}, {"input": {"dna": "CGCACTTCTGTAAGGTATGCGGAAGAGAATGACCTGCTTGGACCG"}, "output": []}, {"input": {"dna": "CCAGGGTCCAACGGTACCAGACAAGCGCAATAACGCCTTGT"}, "output": []}, {"input": {"dna": "TTGACATCGAGATACCAGCTTGATGAT"}, "output": []}, {"input": {"dna": "AAGCCTGATGCATAGAGCATACCGAACGTCCTCGCACGGACTAATTAAGG"}, "output": []}, {"input": {"dna": "CAACTCTCCGAAGACGAACTC"}, "output": []}, {"input": {"dna": "ACTGGCAAGACGAGGACAAACGCTATTACGTGAGCAACC"}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "byronwasti/SoftDes", "path": "/gene_finder/gene_finder_small.py", "msgidx": 11732}}
{"problem_description": "Given a string of alphabetic characters, what are all the possible unique permutations of the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should contain only alphabetic characters and should not be empty.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of permutations\n    perm_list = [''.join(p) for p in permutations(input_string)]\n    \n    # Return the list of permutations as a JSON serializable output\n    return perm_list", "funcname": "main_solution", "ios": [{"input": {"input_string": "xkx"}, "output": ["xkx", "xxk", "kxx", "kxx", "xxk", "xkx"]}, {"input": {"input_string": "vvh"}, "output": ["vvh", "vhv", "vvh", "vhv", "hvv", "hvv"]}, {"input": {"input_string": "xmg"}, "output": ["xmg", "xgm", "mxg", "mgx", "gxm", "gmx"]}, {"input": {"input_string": "adr"}, "output": ["adr", "ard", "dar", "dra", "rad", "rda"]}, {"input": {"input_string": "eoj"}, "output": ["eoj", "ejo", "oej", "oje", "jeo", "joe"]}, {"input": {"input_string": "kyk"}, "output": ["kyk", "kky", "ykk", "ykk", "kky", "kyk"]}, {"input": {"input_string": "dzt"}, "output": ["dzt", "dtz", "zdt", "ztd", "tdz", "tzd"]}, {"input": {"input_string": "dwo"}, "output": ["dwo", "dow", "wdo", "wod", "odw", "owd"]}, {"input": {"input_string": "vft"}, "output": ["vft", "vtf", "fvt", "ftv", "tvf", "tfv"]}, {"input": {"input_string": "fal"}, "output": ["fal", "fla", "afl", "alf", "lfa", "laf"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lohitbadiger/interview_questions_python", "path": "/7_letter_permution.py", "msgidx": 12281}}
{"problem_description": "Given a scenario involving multiple events and their probabilities, what is the probability of a specific combination of these events occurring? For example, if event A has a 60% chance of occurring and event B has a 40% chance of occurring, what is the probability of both events A and B occurring together?", "io_requirements": "Input:\n  `input_lines` (list of str): A list of strings where the first line contains the number of events N followed by the event names, the next N lines contain the probabilities of specific event combinations, and the last line contains the target event combination for which the probability is to be calculated.\n\nOutput:\n  `return` (float): The probability of the target event combination occurring, as a float between 0 and 1.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef parse_input(input_lines):\n    N, *events = input_lines[0].split()\n    N = int(N)\n    event_names = events\n    probabilities = {}\n    for line in input_lines[1:N+1]:\n        parts = line.split(':')\n        event_combination = parts[0].strip()\n        probability = float(parts[1].strip())\n        probabilities[event_combination] = probability\n    target_event = input_lines[N+1].strip()\n    return event_names, probabilities, target_event\n\ndef calculate_probability(event_names, probabilities, target_event):\n    total_probability = 0.0\n    for event_combination, probability in probabilities.items():\n        if all(event in event_combination for event in target_event.split(' & ')):\n            total_probability += probability\n    return total_probability\n\n# main function\ndef main_solution(input_lines):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    event_names, probabilities, target_event = parse_input(input_lines)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    result = calculate_probability(event_names, probabilities, target_event)\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_lines": ["3 A B C", "A & : 0.94", "A & !B: 0.01", "A & !B & !C: 0.02", "B & : 0.97", "B & !C: 0.28", "C & : 0.77", "A & "]}, "output": 0.0}, {"input": {"input_lines": ["2 A B", "A & : 0.3", "A & !B: 0.21", "B & : 0.4", "A & !B"]}, "output": 0.0}, {"input": {"input_lines": ["2 A B", "A & : 0.22", "A & !B: 0.47", "B & : 0.84", "B & "]}, "output": 0.0}, {"input": {"input_lines": ["2 A B", "A & : 0.88", "A & !B: 0.2", "B & : 0.99", "A & "]}, "output": 0.0}, {"input": {"input_lines": ["3 A B C", "A & : 0.48", "A & !B: 0.59", "A & !B & !C: 0.3", "B & : 0.06", "B & !C: 0.94", "C & : 0.96", "B & "]}, "output": 0.0}, {"input": {"input_lines": ["2 A B", "A & : 0.2", "A & !B: 0.18", "B & : 0.39", "A & "]}, "output": 0.0}, {"input": {"input_lines": ["3 A B C", "A & : 0.85", "A & !B: 0.73", "A & !B & !C: 0.65", "B & : 0.37", "B & !C: 0.15", "C & : 0.95", "B & "]}, "output": 0.0}, {"input": {"input_lines": ["3 A B C", "A & : 0.05", "A & !B: 0.14", "A & !B & !C: 0.64", "B & : 0.52", "B & !C: 0.18", "C & : 0.52", "A & !B & !C"]}, "output": 0.0}, {"input": {"input_lines": ["2 A B", "A & : 0.6", "A & !B: 0.16", "B & : 0.78", "B & "]}, "output": 0.0}, {"input": {"input_lines": ["2 A B", "A & : 0.96", "A & !B: 0.83", "B & : 0.79", "B & "]}, "output": 0.0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DayGitH/Python-Challenges", "path": "/DailyProgrammer/DP20150213C.py", "msgidx": 11571}}
{"problem_description": "Given a range of numbers up to a certain limit, identify four prime numbers such that when any two of these primes are concatenated in any order, the resulting number is also a prime. What are the four prime numbers that satisfy this condition?", "io_requirements": "Input:\n  `nmax` (int): The upper limit for the range of numbers to check for primes. Must be a positive integer.\n\nOutput:\n  `return` (list of int): A list of four prime numbers `[p1, p2, p3, p4]` such that concatenating any two of them in any order results in a prime number. If no such set of four primes is found, an empty list is returned.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Kosher(object):\n    def __init__(self, primes):\n        self.primes = primes\n    \n    def are(self, a, b):\n        '''\n        Returns True if primes a and b also produce primes when\n        concatenating them as ab and ba.\n        '''\n        pab = int(str(a) + str(b))\n        if not pab in self.primes:\n            return False\n\n        pba = int(str(b) + str(a))\n        if not pba in self.primes:\n            return False\n        \n        return True\n\ndef isprime(num):\n    '''\n    Returns True if num is prime, False otherwise.\n    '''\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\n# main function\ndef main_solution(nmax):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Sieve to find all primes up to nmax:\n    composites = {}\n    primes = [2]\n    pd = {}\n    for mult in range(3, nmax, 2):\n        if not mult in composites:\n            # Log mult as prime:\n            primes.append(mult)\n            pd[mult] = True\n\n            # Sieve its multiples away:\n            for i in range(mult * mult, nmax, 2 * mult):\n                composites[i] = True\n\n    # Explore combos:\n    K = Kosher(pd)\n    for i1 in range(1, len(primes)):\n        p1 = primes[i1]\n        for i2 in range(i1 + 1, len(primes)):\n            p2 = primes[i2]\n            if K.are(p1, p2):  # only go on if these are a-OK\n                for i3 in range(i2 + 1, len(primes)):\n                    p3 = primes[i3]\n                    if K.are(p1, p3) and K.are(p2, p3):\n                        for i4 in range(i3 + 1, len(primes)):\n                            p4 = primes[i4]\n                            if K.are(p1, p4) and K.are(p2, p4) and K.are(p3, p4):\n                                return [p1, p2, p3, p4]\n\n    return []", "funcname": "main_solution", "ios": [{"input": {"nmax": 5594}, "output": []}, {"input": {"nmax": 2336}, "output": []}, {"input": {"nmax": 6923}, "output": []}, {"input": {"nmax": 4171}, "output": []}, {"input": {"nmax": 7820}, "output": []}, {"input": {"nmax": 9782}, "output": []}, {"input": {"nmax": 3709}, "output": []}, {"input": {"nmax": 8553}, "output": []}, {"input": {"nmax": 6476}, "output": []}, {"input": {"nmax": 5145}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "isilanes/myeuler", "path": "/p060/p060.py", "msgidx": 11626}}
{"problem_description": "Given a set of weights and their respective maximum quantities, how many distinct weights can be measured using these weights and their quantities?", "io_requirements": "Input:\n  `weights` (list of int): A list of integers representing the weights of the available weights.\n  `quantities` (list of int): A list of integers representing the maximum number of each weight that can be used.\n\nOutput:\n  `return` (int): The number of unique weights that can be measured using the given weights and their quantities.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(weights, quantities):\n    # Convert the input lists to sets to ensure uniqueness\n    weights = set(weights)\n    quantities = set(quantities)\n    \n    # Initialize the result set with 0 (no weight)\n    result = {0}\n    \n    # Iterate over each weight and its corresponding quantity\n    for weight, quantity in zip(weights, quantities):\n        # Create a list of possible weights for the current weight\n        current_weights = [weight * i for i in range(quantity + 1)]\n        \n        # Update the result set with all possible sums of the current weights\n        result = {sum(comb) for comb in itertools.product(result, current_weights)}\n    \n    # Return the number of unique weights\n    return len(result)", "funcname": "main_solution", "ios": [{"input": {"weights": [2, 3, 9, 6], "quantities": [1, 3, 1, 4]}, "output": 26}, {"input": {"weights": [6, 5, 2], "quantities": [5, 2, 1]}, "output": 32}, {"input": {"weights": [4, 9, 2, 7, 4], "quantities": [4, 3, 4, 3, 2]}, "output": 33}, {"input": {"weights": [3, 4, 3, 1], "quantities": [2, 2, 3, 1]}, "output": 18}, {"input": {"weights": [1, 1], "quantities": [2, 1]}, "output": 2}, {"input": {"weights": [7, 8, 2, 10, 9], "quantities": [4, 1, 1, 3, 3]}, "output": 34}, {"input": {"weights": [4, 3, 2], "quantities": [5, 4, 2]}, "output": 35}, {"input": {"weights": [1, 5, 6, 1], "quantities": [2, 2, 2, 4]}, "output": 15}, {"input": {"weights": [9, 1], "quantities": [2, 3]}, "output": 12}, {"input": {"weights": [8, 1, 7, 5, 7], "quantities": [2, 5, 3, 4, 3]}, "output": 73}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Lisolo/ACM", "path": "/weight_problem.py", "msgidx": 11713}}
{"problem_description": "Given the mathematical property that all integers greater than 28123 can be written as the sum of two abundant numbers, what is the sum of all positive integers up to a certain limit that cannot be expressed as the sum of two abundant numbers?", "io_requirements": "Input:\n  `limit` (int): The upper limit for the range of numbers to check. This should be an integer greater than 24.\n\nOutput:\n  `return` (int): The sum of all positive integers up to the given `limit` that cannot be written as the sum of two abundant numbers.", "refcode": "# import necessary packages\nimport sys\nfrom math import ceil\n\n# all class and function definitions in the code file, if any\nclass Memoize:\n    \"\"\"Memoize(fn) - an instance which acts like fn but memoizes its arguments\n       Will only work on functions with non-mutable arguments\n    \"\"\"\n    def __init__(self, fn):\n        self.fn = fn\n        self.memo = {}\n    def __call__(self, *args):\n        if not args in self.memo:\n            self.memo[args] = self.fn(*args)\n        return self.memo[args]\n\ndef proper_divisors(x):\n    divisors = [1]\n    for i in range(2, x):\n        if (x % i) == 0:\n            if i not in divisors:\n                divisors.append(i)\n            if x/i not in divisors:\n                divisors.append(int(x/i))\n    return divisors\n\nproper_divisors = Memoize(proper_divisors)\n\ndef is_abundant(value):\n    return sum(proper_divisors(value)) > value\n\nis_abundant = Memoize(is_abundant)\n\ndef can_be_written_as_sum_of_two_abundants(value):\n    for i in range(12, ceil(value/2)+1):\n        if is_abundant(i) and is_abundant(value-i):\n            return True\n    return False\n\n# main function\ndef main_solution(limit):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    start = 24\n    values = list(range(1, start))\n    for i in range(start, limit):\n        if not can_be_written_as_sum_of_two_abundants(i):\n            values.append(i)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sum(values)", "funcname": "main_solution", "ios": [{"input": {"limit": 16970}, "output": 4087054}, {"input": {"limit": 104}, "output": 2970}, {"input": {"limit": 4710}, "output": 1899427}, {"input": {"limit": 22006}, "output": 4179871}, {"input": {"limit": 16328}, "output": 4087054}, {"input": {"limit": 4055}, "output": 1526964}, {"input": {"limit": 20913}, "output": 4179871}, {"input": {"limit": 8601}, "output": 3502625}, {"input": {"limit": 6605}, "output": 2911966}, {"input": {"limit": 11367}, "output": 3805333}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nt3rp/Project-Euler", "path": "/in-progress/q23.py", "msgidx": 10918}}
{"problem_description": "In a family, there are several father-son relationships recorded. Each relationship is represented by a pair of names, where the first name is the father and the second name is the son. Given these relationships, determine if the family tree is correctly structured. Specifically, check if there are no inconsistencies such as a person being both a father and a son of the same person, or if there are any strangers in the family tree. What is the result of checking the family tree for correctness?", "io_requirements": "Input:\n  `family_tree` (list of lists of strings): A list of lists where each inner list contains two strings representing a father-son relationship. Each inner list has the format `[father, son]`.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the family tree is correct (True) or contains errors (False).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_family(tree):\n    if len(tree) == 1:\n        return True\n\n    fathers = [i[0] for i in tree]\n    sons = [i[1] for i in tree]\n\n    if len(set(sons)) < len(sons):\n        return False\n\n    for i in tree[1:]:\n        if i[::-1] in tree:\n            return False\n\n    for i, j in tree[::-1]:\n        if i not in sons:\n            return False\n\n    return True\n\n# main function\ndef main_solution(family_tree):\n    # Convert the input list of lists to a JSON serializable format\n    family_tree_json = [[str(father), str(son)] for father, son in family_tree]\n    \n    # Call the is_family function with the converted input\n    result = is_family(family_tree_json)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"family_tree": [["Person3", "Person2"], ["Person1", "Person0"]]}, "output": false}, {"input": {"family_tree": [["Person0", "Person1"], ["Person3", "Person2"]]}, "output": false}, {"input": {"family_tree": [["Person5", "Person4"], ["Person2", "Person0"], ["Person1", "Person3"]]}, "output": false}, {"input": {"family_tree": [["Person2", "Person5"], ["Person4", "Person1"], ["Person3", "Person0"]]}, "output": false}, {"input": {"family_tree": [["Person0", "Person1"], ["Person2", "Person3"]]}, "output": false}, {"input": {"family_tree": [["Person4", "Person0"], ["Person5", "Person2"], ["Person3", "Person1"]]}, "output": false}, {"input": {"family_tree": [["Person0", "Person1"]]}, "output": true}, {"input": {"family_tree": [["Person3", "Person5"], ["Person1", "Person2"], ["Person4", "Person0"]]}, "output": false}, {"input": {"family_tree": [["Person5", "Person4"], ["Person1", "Person3"], ["Person0", "Person2"]]}, "output": false}, {"input": {"family_tree": [["Person0", "Person2"], ["Person1", "Person3"]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "oskomorokhov/python", "path": "/study/checkio/Scientific Expedition/wrong_family.py", "msgidx": 11308}}
{"problem_description": "Given a tree-fractal drawing algorithm, what is the total length of all branches drawn when starting with a specific initial branch length and a certain number of nodes?", "io_requirements": "Input:\n  `branch_len` (int): The initial length of the main branch.\n  `nodes_amount` (int): The number of nodes (branches) to draw.\n\nOutput:\n  `return` (int): The total length of all branches drawn.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(branch_len, nodes_amount):\n    \"\"\"\n    Draws a tree-fractal using recursion and returns the total length of all branches drawn.\n    \n    Args:\n        branch_len (int): The initial length of the main branch.\n        nodes_amount (int): The number of nodes (branches) to draw.\n    \n    Returns:\n        int: The total length of all branches drawn.\n    \"\"\"\n    def calculate_total_length(branch_len, nodes_amount):\n        if nodes_amount == 0:\n            return 0\n        \n        x = branch_len / (nodes_amount + 1)\n        total_length = branch_len\n        \n        for i in range(nodes_amount):\n            total_length += calculate_total_length(0.5 * x * (nodes_amount - i - 1), nodes_amount - i - 1)\n            total_length += calculate_total_length(0.5 * x * (nodes_amount - i - 1), nodes_amount - i - 1)\n        \n        return total_length\n    \n    return calculate_total_length(branch_len, nodes_amount)", "funcname": "main_solution", "ios": [{"input": {"branch_len": 304, "nodes_amount": 10}, "output": 17774.940728715723}, {"input": {"branch_len": 178, "nodes_amount": 7}, "output": 2105.194345238095}, {"input": {"branch_len": 121, "nodes_amount": 4}, "output": 348.8833333333333}, {"input": {"branch_len": 58, "nodes_amount": 4}, "output": 167.23333333333335}, {"input": {"branch_len": 419, "nodes_amount": 9}, "output": 14161.58687996032}, {"input": {"branch_len": 333, "nodes_amount": 5}, "output": 1495.7250000000001}, {"input": {"branch_len": 397, "nodes_amount": 1}, "output": 397}, {"input": {"branch_len": 213, "nodes_amount": 3}, "output": 408.25}, {"input": {"branch_len": 216, "nodes_amount": 3}, "output": 414.0}, {"input": {"branch_len": 91, "nodes_amount": 8}, "output": 1803.8628472222222}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "avoevodin/lab5", "path": "/tree.py", "msgidx": 12034}}
{"problem_description": "In a hypothetical system, processes are organized in a tree structure where each process spawns a number of child processes equal to its own process number. The processes are named in level order, starting from 1. Given a process number, what is the process number of its parent process?", "io_requirements": "Input:\n  `target` (int): The process number for which the parent process number is to be found. The value should be a positive integer.\n\nOutput:\n  `return` (int): The process number of the parent process of the given `target` process. If the `target` process is the root or not found, it returns `-1`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef process_tree_parent(target: int) -> int:\n    root = 1\n    first_child = root + 1\n    last_child = first_child + root - 1\n    while root <= target:\n        root += 1\n        first_child = last_child + 1\n        last_child = first_child + root - 1\n        if first_child <= target <= last_child:\n            return root\n    return -1\n\n# main function\ndef main_solution(target: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    parent_process = process_tree_parent(target)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return parent_process", "funcname": "main_solution", "ios": [{"input": {"target": 81}, "output": 13}, {"input": {"target": 96}, "output": 14}, {"input": {"target": 65}, "output": 11}, {"input": {"target": 45}, "output": 9}, {"input": {"target": 5}, "output": 3}, {"input": {"target": 7}, "output": 3}, {"input": {"target": 22}, "output": 6}, {"input": {"target": 71}, "output": 12}, {"input": {"target": 61}, "output": 11}, {"input": {"target": 82}, "output": 13}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wanmok/leetcode", "path": "/companies/2022/salesforce/process_tree.py", "msgidx": 11821}}
{"problem_description": "Two players, PlayerA and PlayerB, are playing a game where they start with a given number. If the number is a power of 2, they divide it by 2 and pass it to the other player. If the number is not a power of 2, they subtract it by the nearest power of 2 less than the number and pass it to the other player. PlayerA always starts the game. The player who gets the number to 1 wins the game. Who will win the game given the initial number `n`?", "io_requirements": "Input:\n  `n` (int): The initial number for the game. It should be a positive integer.\n\nOutput:\n  `return` (str): The name of the winner, either \"PlayerA\" or \"PlayerB\".", "refcode": "# import necessary packages\nimport math\n\n# Function to check if a number is a power of 2.\ndef check(n):\n    val = 1\n    for i in range(1, 65):\n        val = val * 2\n        if(n == val):\n            return -1 # return -1 if it is a power of 2\n        elif(val > n):\n            return i-1 # return the nearest power value\n\n# main function\ndef main_solution(n):\n    # Convert input to integer\n    n = int(n)\n    \n    turn = 1 # to keep track of which player is playing\n    count = 0 \n\n    while(n != 1):\n        count = count + 1\n        if(count % 2 == 0):\n            turn = 2 # playerB turn\n        else:\n            turn = 1 # playerA turn\n        \n        val = check(n) # check if number is a power of 2\n    \n        if (val == -1):\n            n = n // 2\n        else:\n            n = n - int(math.pow(2, val))\n        \n    # Return the winner as a string\n    return \"PlayerA\" if turn == 1 else \"PlayerB\"", "funcname": "main_solution", "ios": [{"input": {"n": 243}, "output": "PlayerA"}, {"input": {"n": 307}, "output": "PlayerB"}, {"input": {"n": 151}, "output": "PlayerB"}, {"input": {"n": 267}, "output": "PlayerA"}, {"input": {"n": 564}, "output": "PlayerA"}, {"input": {"n": 911}, "output": "PlayerB"}, {"input": {"n": 5}, "output": "PlayerA"}, {"input": {"n": 501}, "output": "PlayerB"}, {"input": {"n": 207}, "output": "PlayerA"}, {"input": {"n": 430}, "output": "PlayerB"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AdithyaBhat17/interview-cookbook", "path": "/python/power.py", "msgidx": 12124}}
{"problem_description": "Given a Tower of Hanoi puzzle with a certain number of disks initially placed on the source rod, what will be the final configuration of the rods after moving all the disks to the target rod according to the rules of the Tower of Hanoi puzzle?", "io_requirements": "Input:\n  `n` (int): The number of disks to move.\n  `source` (list of int): The initial stack of disks on the source rod, sorted in descending order.\n  `target` (list of int): The initial stack of disks on the target rod, typically empty.\n  `auxiliary` (list of int): The initial stack of disks on the auxiliary rod, typically empty.\n\nOutput:\n  `return` (dict): A dictionary containing the final state of the rods after moving the disks.\n    - `source` (list of int): The final stack of disks on the source rod.\n    - `target` (list of int): The final stack of disks on the target rod.\n    - `auxiliary` (list of int): The final stack of disks on the auxiliary rod.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef move(n, source, target, auxiliary):\n    if n:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, auxiliary, target)\n\n        # move the nth disk from source to target\n        target.append(source.pop())\n\n        # move the n - 1 disks that we left on auxiliary onto target\n        move(n - 1, auxiliary, target, source)\n\n# main function\ndef main_solution(n, source, target, auxiliary):\n    # Convert input lists to JSON serializable format\n    source = list(source)\n    target = list(target)\n    auxiliary = list(auxiliary)\n\n    # Call the move function\n    move(n, source, target, auxiliary)\n\n    # Convert output lists to JSON serializable format\n    result = {\n        \"source\": source,\n        \"target\": target,\n        \"auxiliary\": auxiliary\n    }\n\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 6, "source": [6, 5, 4, 3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [6, 5, 4, 3, 2, 1], "auxiliary": []}}, {"input": {"n": 10, "source": [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], "auxiliary": []}}, {"input": {"n": 9, "source": [9, 8, 7, 6, 5, 4, 3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [9, 8, 7, 6, 5, 4, 3, 2, 1], "auxiliary": []}}, {"input": {"n": 5, "source": [5, 4, 3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [5, 4, 3, 2, 1], "auxiliary": []}}, {"input": {"n": 7, "source": [7, 6, 5, 4, 3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [7, 6, 5, 4, 3, 2, 1], "auxiliary": []}}, {"input": {"n": 2, "source": [2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [2, 1], "auxiliary": []}}, {"input": {"n": 4, "source": [4, 3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [4, 3, 2, 1], "auxiliary": []}}, {"input": {"n": 3, "source": [3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [3, 2, 1], "auxiliary": []}}, {"input": {"n": 8, "source": [8, 7, 6, 5, 4, 3, 2, 1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [8, 7, 6, 5, 4, 3, 2, 1], "auxiliary": []}}, {"input": {"n": 1, "source": [1], "target": [], "auxiliary": []}, "output": {"source": [], "target": [1], "auxiliary": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tensor92/DataScience", "path": "/100 Days of Algorithms/Day1_TowerOfHanoi.py", "msgidx": 11368}}
{"problem_description": "Given a number of digits, what is the count of circular prime numbers that can be formed using those digits? Circular primes are prime numbers where all rotations of the digits are also prime numbers. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers.", "io_requirements": "Input:\n  `digits` (int): The number of digits for the circular prime numbers to be considered. It should be an integer between 2 and 6.\n\nOutput:\n  `return` (int): The count of circular prime numbers with the specified number of digits.", "refcode": "# import necessary packages\nfrom itertools import product\nfrom functools import reduce\n\n# all class and function definitions in the code file, if any\ndef is_prime(n):\n    # assume already checked for multiples of 2 and 3\n    i = 5\n    while i**2 <= n:\n        if n % i == 0 or n % (i+2) == 0:\n            return False\n        i += 6\n    return True\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    count = 4  # four single digit primes\n    for perm in product([1, 3, 7, 9], repeat=digits):\n        if sum(perm) % 3 == 0:\n            continue\n\n        i = 0\n        circular = True\n        while i < digits:\n            n = reduce(lambda x, y: 10 * x + y, perm[i:] + perm[:i])\n            if not is_prime(n):\n                circular = False\n                break\n            i += 1\n\n        if circular:\n            count += 1\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return count", "funcname": "main_solution", "ios": [{"input": {"digits": 2}, "output": 13}, {"input": {"digits": 3}, "output": 16}, {"input": {"digits": 5}, "output": 14}, {"input": {"digits": 4}, "output": 12}, {"input": {"digits": 6}, "output": 16}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JulesGB/project-euler", "path": "/p35.py", "msgidx": 12032}}
{"problem_description": "In a multi-story building, you are waiting for an elevator on the 2nd floor. Given the number of floors and the number of elevators in the building, what is the probability that the first elevator to arrive comes from above?", "io_requirements": "Input:\n  `numFloors` (int): The number of floors in the building.\n  `numElevators` (int): The number of elevators in the building.\n  `sampleCount` (int): The number of simulations to run to estimate the probability.\n\nOutput:\n  `return` (dict): A dictionary containing the key `probability` with a float value representing the estimated probability that the first elevator to arrive comes from above.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(numFloors, numElevators, sampleCount):\n    # Convert JSON serializable inputs to the required format\n    numFloors = int(numFloors)\n    numElevators = int(numElevators)\n    sampleCount = int(sampleCount)\n    \n    # Simulate waiting for an elevator, returning true if it arrives from above.\n    def fromAbove(numFloors, numElevators):\n        rng = np.random.default_rng()\n        elevatorPositions = rng.random((numElevators, 2))\n        elevatorDistances = np.zeros(numElevators)\n        for eIndex in range(numElevators):\n            if elevatorPositions[eIndex, 0] < 1 / (numFloors - 1):\n                if elevatorPositions[eIndex, 1] < 0.5:\n                    elevatorDistances[eIndex] = 1 / (numFloors - 1) + elevatorPositions[eIndex, 0]\n                else:\n                    elevatorDistances[eIndex] = 1 / (numFloors - 1) - elevatorPositions[eIndex, 0]\n            else:\n                if elevatorPositions[eIndex, 1] < 0.5:\n                    elevatorDistances[eIndex] = elevatorPositions[eIndex, 0] - 1 / (numFloors - 1)\n                else:\n                    elevatorDistances[eIndex] = 2 - elevatorPositions[eIndex, 0] - 1 / (numFloors - 1)\n        closestElevator = np.argmin(elevatorDistances)\n        return elevatorPositions[closestElevator, 0] > (1 / (numFloors - 1))\n    \n    aboveCount = 0\n    for i in range(sampleCount):\n        if fromAbove(numFloors, numElevators):\n            aboveCount += 1\n    \n    # Convert the result to a JSON serializable output\n    probability = aboveCount / sampleCount\n    return {\"probability\": probability}", "funcname": "main_solution", "ios": [{"input": {"numFloors": 6, "numElevators": 4, "sampleCount": 16701}, "output": {"probability": 0.5669121609484462}}, {"input": {"numFloors": 9, "numElevators": 2, "sampleCount": 31110}, "output": {"probability": 0.7804243008678882}}, {"input": {"numFloors": 5, "numElevators": 2, "sampleCount": 48260}, "output": {"probability": 0.625445503522586}}, {"input": {"numFloors": 7, "numElevators": 3, "sampleCount": 25541}, "output": {"probability": 0.640695352570377}}, {"input": {"numFloors": 6, "numElevators": 3, "sampleCount": 48916}, "output": {"probability": 0.606202469539619}}, {"input": {"numFloors": 7, "numElevators": 4, "sampleCount": 28409}, "output": {"probability": 0.596289908127706}}, {"input": {"numFloors": 5, "numElevators": 4, "sampleCount": 29891}, "output": {"probability": 0.5307952226422669}}, {"input": {"numFloors": 9, "numElevators": 3, "sampleCount": 48291}, "output": {"probability": 0.7127000890435071}}, {"input": {"numFloors": 6, "numElevators": 2, "sampleCount": 10625}, "output": {"probability": 0.6812235294117647}}, {"input": {"numFloors": 5, "numElevators": 2, "sampleCount": 14785}, "output": {"probability": 0.6267162664863037}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "adams164/python-problems", "path": "/Digital-Dice/Gamow-Stern-elevator.py", "msgidx": 11557}}
{"problem_description": "Given a partially filled 4x4 Sudoku puzzle, what is the complete and valid solution for the puzzle? The puzzle is represented by a 4x4 grid where each cell contains an integer between 0 and 4, with 0 indicating an empty cell. The solution should be a fully filled 4x4 grid where each row, column, and 2x2 sub-grid contains the numbers 1 to 4 exactly once.", "io_requirements": "Input:\n  `initial_values` (list of lists of integers): A 4x4 grid representing the initial state of a 4x4 Sudoku puzzle. Each element in the grid should be an integer between 0 and 4, where 0 represents an empty cell.\n\nOutput:\n  `return` (list of lists of integers): A 4x4 grid representing the solved state of the 4x4 Sudoku puzzle. Each element in the grid is an integer between 1 and 4.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Sudoku4:\n    def __init__(self):\n        self.values = np.zeros((4, 4), dtype=int)\n\ndef valid(sud):\n    for i in range(4):\n        for num in range(1, 5):\n            if((sud[i, :]==num).sum()>1):\n                return False\n            if((sud[:, i]==num).sum()>1):\n                return False\n    for i in range(4):\n        for num in range(1, 5):\n            if((sud[(i//2)*2:(i//2)*2+2, (i%2)*2:(i%2)*2+2]==num).sum()>1):\n                return False\n    return True\n    \ndef solve(pos, sud):\n    if(pos==16):\n        return True\n    \n    i = pos//4\n    j = pos%4\n    \n    for num in range(1, 5):\n        sud.values[i, j] = num\n        if(valid(sud.values) == True):\n            retval = solve(pos+1, sud)\n            if(retval==False):\n                continue\n            else:\n                return True\n    sud.values[i, j]=0\n    return False\n\n# main function\ndef main_solution(initial_values):\n  # Convert the input list to a numpy array\n  sud = Sudoku4()\n  sud.values = np.array(initial_values)\n  \n  # Solve the Sudoku\n  solve(0, sud)\n  \n  # Convert the solved Sudoku back to a list\n  solved_values = sud.values.tolist()\n  \n  # Return the solved Sudoku\n  return solved_values", "funcname": "main_solution", "ios": [{"input": {"initial_values": [[0, 0, 1, 1], [3, 3, 0, 0], [3, 2, 2, 2], [0, 2, 0, 1]]}, "output": [[0, 0, 1, 1], [3, 3, 0, 0], [3, 2, 2, 2], [0, 2, 0, 1]]}, {"input": {"initial_values": [[3, 0, 0, 1], [4, 4, 3, 0], [4, 2, 2, 4], [1, 0, 0, 2]]}, "output": [[0, 0, 0, 1], [4, 4, 3, 0], [4, 2, 2, 4], [1, 0, 0, 2]]}, {"input": {"initial_values": [[1, 4, 2, 2], [4, 1, 4, 4], [3, 4, 0, 2], [3, 0, 2, 0]]}, "output": [[0, 4, 2, 2], [4, 1, 4, 4], [3, 4, 0, 2], [3, 0, 2, 0]]}, {"input": {"initial_values": [[0, 0, 3, 0], [3, 3, 2, 2], [1, 2, 1, 0], [2, 1, 2, 2]]}, "output": [[0, 0, 3, 0], [3, 3, 2, 2], [1, 2, 1, 0], [2, 1, 2, 2]]}, {"input": {"initial_values": [[1, 4, 3, 3], [4, 1, 2, 1], [3, 3, 3, 1], [0, 4, 0, 0]]}, "output": [[0, 4, 3, 3], [4, 1, 2, 1], [3, 3, 3, 1], [0, 4, 0, 0]]}, {"input": {"initial_values": [[1, 1, 1, 4], [3, 3, 1, 3], [0, 4, 1, 0], [4, 3, 4, 3]]}, "output": [[0, 1, 1, 4], [3, 3, 1, 3], [0, 4, 1, 0], [4, 3, 4, 3]]}, {"input": {"initial_values": [[1, 2, 1, 3], [3, 0, 0, 0], [2, 4, 3, 1], [2, 0, 2, 2]]}, "output": [[0, 2, 1, 3], [3, 0, 0, 0], [2, 4, 3, 1], [2, 0, 2, 2]]}, {"input": {"initial_values": [[4, 4, 0, 1], [3, 3, 3, 0], [4, 3, 1, 1], [3, 0, 0, 1]]}, "output": [[0, 4, 0, 1], [3, 3, 3, 0], [4, 3, 1, 1], [3, 0, 0, 1]]}, {"input": {"initial_values": [[3, 0, 1, 3], [0, 3, 4, 2], [2, 0, 4, 2], [3, 0, 0, 1]]}, "output": [[0, 0, 1, 3], [0, 3, 4, 2], [2, 0, 4, 2], [3, 0, 0, 1]]}, {"input": {"initial_values": [[4, 1, 2, 4], [1, 1, 0, 2], [0, 3, 4, 3], [3, 0, 3, 0]]}, "output": [[0, 1, 2, 4], [1, 1, 0, 2], [0, 3, 4, 3], [3, 0, 3, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "athulpa/Mini_Projects", "path": "/Sudoku_solver/Sud4_emptysolver_naiveRec.py", "msgidx": 11705}}
{"problem_description": "Imagine you are designing a new smartphone with a 3x3 grid of numbers as its unlock pattern. The user can create a pattern by connecting a sequence of numbers on the grid. The pattern must be at least `m` numbers long and at most `n` numbers long. However, some moves between numbers are invalid unless a specific intermediate number is already part of the pattern. For example, moving from 1 to 3 is invalid unless 2 is already part of the pattern. Given the minimum length `m` and the maximum length `n`, how many valid unlock patterns can be created?", "io_requirements": "Input:\n  `m` (int): The minimum length of the unlock pattern.\n  `n` (int): The maximum length of the unlock pattern.\n\nOutput:\n  `return` (int): The total number of valid unlock patterns between lengths `m` and `n`.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def numberOfPatterns(self, m, n):\n        if not m or not n: return 0\n        def backTracking(m, n, patterns):\n            while len(patterns) <= n:\n                invalid_move = '[^2]*(13|31)|[^4]*(17|71)|[^8]*(79|97)|[^6]*(39|93)|[^5]*(19|28|37|46|64|73|82|91)'\n                invalid_move = re.compile(invalid_move).match\n                patterns += [p + d for p in patterns[-1] for d in '123456789'\n                             if d not in p and not invalid_move(p + d)],\n\n            return sum(map(len, patterns[m:n + 1]))\n        return backTracking(m, n, [['']])\n\n# main function\ndef main_solution(m, n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.numberOfPatterns(m, n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"m": 4, "n": 5}, "output": 8776}, {"input": {"m": 1, "n": 7}, "output": 108089}, {"input": {"m": 2, "n": 8}, "output": 248784}, {"input": {"m": 2, "n": 2}, "output": 56}, {"input": {"m": 5, "n": 6}, "output": 33168}, {"input": {"m": 2, "n": 3}, "output": 376}, {"input": {"m": 3, "n": 6}, "output": 35112}, {"input": {"m": 5, "n": 8}, "output": 246784}, {"input": {"m": 2, "n": 9}, "output": 389488}, {"input": {"m": 5, "n": 9}, "output": 387488}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "allenwhc/Python", "path": "/AndroidUnlockPatterns.py", "msgidx": 11731}}
{"problem_description": "Given a chessboard of size N x N, where N is an integer between 4 and 8, how can you arrange N queens on the board such that no two queens threaten each other? A queen can threaten another queen if they are in the same row, column, or diagonal. What is the arrangement of queens on the board?", "io_requirements": "Input:\n  `N` (int): The size of the chessboard (N x N). It represents the number of rows and columns on the chessboard.\n\nOutput:\n  `return` (list of lists): A 2D list representing the chessboard with queens placed. Each sublist represents a row on the chessboard, where `1` indicates a queen and `0` indicates an empty cell.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(N):\n    # Convert the input to an integer if it's not already\n    N = int(N)\n    \n    # Initialize the chessboard\n    mat = np.zeros((N, N))\n    \n    # Function to check if placing a queen is legal\n    def is_legal(mat, i, j):\n        if i >= N or j >= N:\n            return False\n        if mat[i, :].sum() >= 1 or mat[:, j].sum() >= 1:\n            return False\n        for ii in range(N):\n            if (i - ii >= 0 and j - ii >= 0 and mat[i - ii, j - ii] == 1) or \\\n               (i + ii < N and j + ii < N and mat[i + ii, j + ii] == 1) or \\\n               (i - ii >= 0 and j + ii < N and mat[i - ii, j + ii] == 1) or \\\n               (i + ii < N and j - ii >= 0 and mat[i + ii, j - ii] == 1):\n                return False\n        return True\n    \n    # Recursive function to place queens\n    def chess(mat, col=0):\n        if col >= N:\n            return True\n        for row in range(N):\n            if is_legal(mat, row, col):\n                mat[row, col] = 1\n                if chess(mat, col + 1):\n                    return True\n                mat[row, col] = 0\n        return False\n    \n    # Start placing queens from the first column\n    chess(mat, col=0)\n    \n    # Convert the matrix to a list of lists for JSON serialization\n    result = mat.tolist()\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"N": 4}, "output": [[0.0, 0.0, 1.0, 0.0], [1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], [0.0, 1.0, 0.0, 0.0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "roeiherz/CodingInterviews", "path": "/RecursionsDP/EightQueens.py", "msgidx": 12131}}
{"problem_description": "Given a spiral pattern where numbers are arranged in a counter-clockwise manner, starting from the center, we are interested in the ratio of prime numbers to the total numbers on the perimeter of the spiral. When does the side length of the spiral reach a point where the percentage of prime numbers on its perimeter falls below a certain threshold?", "io_requirements": "Input:\n  `ind_start` (int): The starting index for the spiral.\n  `num_start` (int): The starting number for checking prime status.\n  `percentage_threshold` (float): The threshold percentage for the ratio of primes to total numbers on the spiral's perimeter.\n\nOutput:\n  `return` (dict): A dictionary containing the key `side_length` (int), which represents the side length of the spiral when the percentage of primes falls below the threshold.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(ind_start, num_start, percentage_threshold):\n    primes = []\n    \n    def is_prime(num):\n        for n in range(2, int(math.sqrt(num))+1):\n            if num % n == 0:\n                return False\n        return num > 1\n\n    def get_percentage():\n        return len(primes) / (ind * 4 + 1)\n\n    def add_sides(ind, num):\n        for y in range(-ind, ind+1):\n            if abs(ind+1) == abs(y) and is_prime(num):\n                primes.append((ind+1, y))\n            num += 1\n        for x in range(ind+1, -ind-1, -1):\n            if abs(x) == abs(ind+1) and is_prime(num):\n                primes.append((x, ind+1))\n            num += 1\n        for y in range(ind+1, -ind-1, -1):\n            if abs(-ind-1) == abs(y) and is_prime(num):\n                primes.append((-ind-1, y))\n            num += 1\n        for x in range(-ind-1, ind+2):\n            if abs(x) == abs(-ind-1) and is_prime(num):\n                primes.append((x, -ind-1))\n            num += 1\n        return num\n\n    ind = ind_start\n    num = num_start\n    percentage = 1.\n    while percentage >= percentage_threshold:\n        num = add_sides(ind, num)\n        ind += 1\n        percentage = get_percentage()\n    \n    return {\"side_length\": 2 * ind + 1}", "funcname": "main_solution", "ios": [{"input": {"ind_start": 9, "num_start": 86, "percentage_threshold": 0.0203752829523082}, "output": {"side_length": 21}}, {"input": {"ind_start": 4, "num_start": 100, "percentage_threshold": 0.11165820462416086}, "output": {"side_length": 11}}, {"input": {"ind_start": 8, "num_start": 19, "percentage_threshold": 0.358616793496995}, "output": {"side_length": 19}}, {"input": {"ind_start": 0, "num_start": 37, "percentage_threshold": 0.3155305560322239}, "output": {"side_length": 3}}, {"input": {"ind_start": 4, "num_start": 3, "percentage_threshold": 0.10849843731088996}, "output": {"side_length": 11}}, {"input": {"ind_start": 0, "num_start": 55, "percentage_threshold": 0.15297298113469054}, "output": {"side_length": 3}}, {"input": {"ind_start": 7, "num_start": 63, "percentage_threshold": 0.06307763505366108}, "output": {"side_length": 17}}, {"input": {"ind_start": 5, "num_start": 42, "percentage_threshold": 0.4681451098412473}, "output": {"side_length": 13}}, {"input": {"ind_start": 10, "num_start": 3, "percentage_threshold": 0.16050036215976}, "output": {"side_length": 23}}, {"input": {"ind_start": 10, "num_start": 43, "percentage_threshold": 0.22098659563641027}, "output": {"side_length": 23}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "SammyBaek/Project-Euler", "path": "/Python/SpiralPrimes.py", "msgidx": 11884}}
{"problem_description": "You are given a classic Tower of Hanoi puzzle with a certain number of disks initially placed on one of three pegs. The goal is to move all disks from the starting peg to the ending peg following the rules of the Tower of Hanoi. What is the sequence of moves required to solve the puzzle for a given number of disks, starting peg, and ending peg?", "io_requirements": "Input:\n  `disks` (int): The number of disks to be moved.\n  `start` (int): The starting peg number (1, 2, or 3).\n  `end` (int): The ending peg number (1, 2, or 3).\n\nOutput:\n  `return` (str): A JSON serialized string representing the sequence of moves to solve the Tower of Hanoi problem. Each move is represented as a dictionary with keys `\"disk\"`, `\"from\"`, and `\"to\"`, indicating the disk number, the peg it was moved from, and the peg it was moved to, respectively.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef tower(disks, start, end, moves):\n    if disks:\n        other = 6 - start - end\n        tower(disks=disks-1, start=start, end=other, moves=moves)\n        moves.append({\"disk\": disks, \"from\": start, \"to\": end})\n        tower(disks=disks-1, start=other, end=end, moves=moves)\n\n# main function\ndef main_solution(disks, start, end):\n    # Convert input variables to JSON serializable types if necessary\n    disks = int(disks)\n    start = int(start)\n    end = int(end)\n    \n    # Initialize the moves list to store the moves\n    moves = []\n    \n    # Call the tower function with the moves list to store the moves\n    tower(disks, start, end, moves)\n    \n    # Convert the moves list to a JSON serializable format\n    moves_json = json.dumps(moves)\n    \n    # Return the JSON serialized moves\n    return moves_json", "funcname": "main_solution", "ios": [{"input": {"disks": 1, "start": 3, "end": 1}, "output": "[{\"disk\": 1, \"from\": 3, \"to\": 1}]"}, {"input": {"disks": 1, "start": 1, "end": 3}, "output": "[{\"disk\": 1, \"from\": 1, \"to\": 3}]"}, {"input": {"disks": 2, "start": 2, "end": 3}, "output": "[{\"disk\": 1, \"from\": 2, \"to\": 1}, {\"disk\": 2, \"from\": 2, \"to\": 3}, {\"disk\": 1, \"from\": 1, \"to\": 3}]"}, {"input": {"disks": 2, "start": 2, "end": 1}, "output": "[{\"disk\": 1, \"from\": 2, \"to\": 3}, {\"disk\": 2, \"from\": 2, \"to\": 1}, {\"disk\": 1, \"from\": 3, \"to\": 1}]"}, {"input": {"disks": 2, "start": 3, "end": 1}, "output": "[{\"disk\": 1, \"from\": 3, \"to\": 2}, {\"disk\": 2, \"from\": 3, \"to\": 1}, {\"disk\": 1, \"from\": 2, \"to\": 1}]"}, {"input": {"disks": 2, "start": 3, "end": 2}, "output": "[{\"disk\": 1, \"from\": 3, \"to\": 1}, {\"disk\": 2, \"from\": 3, \"to\": 2}, {\"disk\": 1, \"from\": 1, \"to\": 2}]"}, {"input": {"disks": 2, "start": 1, "end": 2}, "output": "[{\"disk\": 1, \"from\": 1, \"to\": 3}, {\"disk\": 2, \"from\": 1, \"to\": 2}, {\"disk\": 1, \"from\": 3, \"to\": 2}]"}, {"input": {"disks": 1, "start": 3, "end": 2}, "output": "[{\"disk\": 1, \"from\": 3, \"to\": 2}]"}, {"input": {"disks": 1, "start": 2, "end": 1}, "output": "[{\"disk\": 1, \"from\": 2, \"to\": 1}]"}, {"input": {"disks": 1, "start": 1, "end": 2}, "output": "[{\"disk\": 1, \"from\": 1, \"to\": 2}]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "raj231992/placements", "path": "/python/recursion/tower.py", "msgidx": 12135}}
{"problem_description": "Given a sum of three numbers, where the numbers form a Pythagorean triplet (i.e., \\(a^2 + b^2 = c^2\\) and \\(a < b < c\\)), what are the values of \\(a\\), \\(b\\), and \\(c\\), and what is their product?", "io_requirements": "Input:\n  `n` (int): The sum of the Pythagorean triplet (a + b + c).\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `a` (int): The first number in the Pythagorean triplet.\n    - `b` (int): The second number in the Pythagorean triplet.\n    - `c` (int): The third number in the Pythagorean triplet.\n    - `product` (int): The product of the three numbers (a * b * c). If no such triplet exists, the values for `a`, `b`, `c`, and `product` will be `None`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPythagoreanTriplet(a, b, c):\n    \"\"\"determine if a < b < c and a^2 + b^2 = c^2\n    formally, a Pythagorean triplet\"\"\"\n    if a < b and b < c:\n        return (a**2 + b**2) == c**2\n    else:\n        return False\n\n# main function\ndef main_solution(n):\n    \"\"\"n = a + b + c, where a,b,c are a pythagorean triplet\"\"\"\n    for a in range(1, n):\n        for b in range(a, n):\n            for c in range(b, n):\n                if a + b + c == n and isPythagoreanTriplet(a, b, c):\n                    return {\"a\": a, \"b\": b, \"c\": c, \"product\": a * b * c}\n    return {\"a\": None, \"b\": None, \"c\": None, \"product\": None}", "funcname": "main_solution", "ios": [{"input": {"n": 553}, "output": {"a": null, "b": null, "c": null, "product": null}}, {"input": {"n": 273}, "output": {"a": null, "b": null, "c": null, "product": null}}, {"input": {"n": 158}, "output": {"a": null, "b": null, "c": null, "product": null}}, {"input": {"n": 288}, "output": {"a": 32, "b": 126, "c": 130, "product": 524160}}, {"input": {"n": 604}, "output": {"a": null, "b": null, "c": null, "product": null}}, {"input": {"n": 317}, "output": {"a": null, "b": null, "c": null, "product": null}}, {"input": {"n": 804}, "output": {"a": 201, "b": 268, "c": 335, "product": 18045780}}, {"input": {"n": 503}, "output": {"a": null, "b": null, "c": null, "product": null}}, {"input": {"n": 332}, "output": {"a": null, "b": null, "c": null, "product": null}}, {"input": {"n": 632}, "output": {"a": null, "b": null, "c": null, "product": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "doctorOb/euler", "path": "/P9-pythagoreanTriplet.py", "msgidx": 11616}}
{"problem_description": "Detective, we need your help to unlock a secret warehouse door secured by an electronic combination lock. Our spy observed Robby the robber entering a PIN, but he's not sure if each digit is correct. He noted the PIN as `observed_pin`, but each digit could be one of its adjacent digits on the keypad. What are all the possible PIN variations that we should try to unlock the door?", "io_requirements": "Input:\n  `observed_pin` (str): A string representing the observed PIN, where each character is a digit from '0' to '9'. The length of the string can be from 1 to 8 characters.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a possible PIN variation based on the observed PIN. Each variation includes the original digit and its adjacent digits (horizontally or vertically) on the keypad.", "refcode": "# import necessary packages\nimport itertools as it\n\n# main function\ndef main_solution(observed_pin):\n    # Define the possible adjacent digits for each key on the keypad\n    pos_num = {\n        '1': ['1', '2', '4'], '2': ['1', '2', '3', '5'], '3': ['2', '3', '6'],\n        '4': ['1', '4', '5', '7'], '5': ['2', '4', '5', '6', '8'], '6': ['3', '5', '6', '9'],\n        '7': ['4', '7', '8'], '8': ['5', '7', '8', '9', '0'], '9': ['6', '8', '9'], '0': ['8', '0']\n    }\n\n    # Create a list of possible values for each digit in the observed PIN\n    list_list = [pos_num[digit] for digit in observed_pin]\n\n    # Generate all possible combinations of these values\n    all_combinations = list(it.product(*list_list))\n\n    # Join each combination into a string and return the list of all possible PINs\n    result = [\"\".join(combination) for combination in all_combinations]\n    return result", "funcname": "main_solution", "ios": [{"input": {"observed_pin": "19"}, "output": ["16", "18", "19", "26", "28", "29", "46", "48", "49"]}, {"input": {"observed_pin": "76"}, "output": ["43", "45", "46", "49", "73", "75", "76", "79", "83", "85", "86", "89"]}, {"input": {"observed_pin": "8"}, "output": ["5", "7", "8", "9", "0"]}, {"input": {"observed_pin": "39"}, "output": ["26", "28", "29", "36", "38", "39", "66", "68", "69"]}, {"input": {"observed_pin": "20"}, "output": ["18", "10", "28", "20", "38", "30", "58", "50"]}, {"input": {"observed_pin": "01"}, "output": ["81", "82", "84", "01", "02", "04"]}, {"input": {"observed_pin": "11"}, "output": ["11", "12", "14", "21", "22", "24", "41", "42", "44"]}, {"input": {"observed_pin": "7"}, "output": ["4", "7", "8"]}, {"input": {"observed_pin": "80"}, "output": ["58", "50", "78", "70", "88", "80", "98", "90", "08", "00"]}, {"input": {"observed_pin": "17"}, "output": ["14", "17", "18", "24", "27", "28", "44", "47", "48"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "joma625/Python-Practice", "path": "/codewars/get_pins.py", "msgidx": 11825}}
{"problem_description": "Given a sequence of integers, determine if it represents the post-order traversal of a Binary Search Tree (BST). What is the result indicating whether the sequence is a valid post-order traversal of a BST?", "io_requirements": "Input:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if len(sequence) == 0:\n            return False\n        if len(sequence) == 1 or len(sequence) == 2:\n            return True\n        center = sequence.pop()\n        res, index = checkCenter(sequence, center)\n        if res:\n            if index == 0:\n                return self.VerifySquenceOfBST(sequence[index:])\n            if index == -1:\n                return self.VerifySquenceOfBST(sequence)\n            return self.VerifySquenceOfBST(sequence[:index]) and self.VerifySquenceOfBST(sequence[index:])\n        return res\n\ndef checkCenter(seq, center):\n    lst = True\n    pos = -1\n    for i in range(len(seq)):\n        if lst:\n            if seq[i] > center:\n                lst = False\n                pos = i\n        else:\n            if seq[i] < center:\n                return False, -1\n    return True, pos\n\n# main function\ndef main_solution(sequence):\n    # Convert input to list if it's not already\n    if not isinstance(sequence, list):\n        sequence = list(sequence)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(sequence)\n    \n    # Convert the result to a JSON serializable output\n    return \"Yes\" if result else \"No\"", "funcname": "main_solution", "ios": [{"input": {"sequence": [15, 8, 13, 14]}, "output": "No"}, {"input": {"sequence": [2, 10, 18, 12, 3, 17, 11, 6, 7]}, "output": "No"}, {"input": {"sequence": [18, 5, 4, 7, 15, 16]}, "output": "No"}, {"input": {"sequence": [8, 4, 7, 14, 9, 13, 19]}, "output": "No"}, {"input": {"sequence": [4, 8]}, "output": "Yes"}, {"input": {"sequence": [14]}, "output": "Yes"}, {"input": {"sequence": [5, 1]}, "output": "Yes"}, {"input": {"sequence": [14, 9, 12, 7, 16, 17, 3]}, "output": "No"}, {"input": {"sequence": [11, 13, 6, 4]}, "output": "Yes"}, {"input": {"sequence": [9, 17, 12, 3, 15]}, "output": "No"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lanpartis/jianzhiOffer_practice", "path": "/23_verifySquenceOfBST.py", "msgidx": 12132}}
{"problem_description": "Given a \"magic\" 5-gon ring filled with numbers from 1 to 10, where each line adds up to the same sum, and starting from the group of three with the numerically lowest external node, what is the maximum 16-digit string that can be formed by concatenating the numbers in the ring?", "io_requirements": "Input:\n  `n` (int): The number of sides in the n-gon ring. For the problem, `n` should be 5.\n\nOutput:\n  `return` (str): The maximum 16-digit string formed by concatenating the numbers in the \"magic\" n-gon ring, starting with the lowest external node. If no such string exists, returns `None`.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef same_sum(ring):\n    \"\"\"\n    see if this current combination yield the same sum\n    \"\"\"\n    sum_ = ring[0] + ring[1] + ring[2]\n    for group in groups:\n        if ring[group[0]] + ring[group[1]] + ring[group[2]] != sum_:\n            return False\n    return True\n\ndef digit_string(solution):\n    \"\"\"\n    return \"solution\" in concatenated digits form, starts with lowest external node\n    \"\"\"\n    external_nodes = []\n    for i in range(5):\n        external_nodes.append((solution[groups[i][0]], i))\n    external_nodes = sorted(external_nodes)\n\n    s = \"\"\n    for i in range(external_nodes[0][1], 5):\n        for j in groups[i]:\n            s += str(solution[j])\n    for i in range(0, external_nodes[0][1]):\n        for j in groups[i]:\n            s += str(solution[j])\n\n    return s\n\n# main function\ndef main_solution(n):\n    \"\"\"\n    Find the maximum 16-digit string for a \"magic\" n-gon ring.\n    \"\"\"\n    global groups\n    groups = [[0, 1, 2], [3, 2, 4], [5, 4, 6], [7, 6, 8], [9, 8, 1]]\n\n    solutions = []\n    for ring in itertools.permutations(range(1, 2*n+1)):\n        if same_sum(ring):\n            solutions.append(list(ring))\n\n    sixteen_digits = []\n    for solution in solutions:\n        ds = digit_string(solution)\n        if len(ds) == 16:\n            sixteen_digits.append(ds)\n\n    return max(sixteen_digits) if sixteen_digits else None", "funcname": "main_solution", "ios": [{"input": {"n": 5}, "output": "6531031914842725"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KevinLiu1314/LearnPython", "path": "/Project Euler/Problem 68.py", "msgidx": 12002}}
{"problem_description": "In the context of Conway's Game of Life, given an initial configuration of live and dead cells on a grid, what will be the state of the grid after a certain number of generations? The rules of the game dictate how cells live, die, or reproduce based on the number of their live neighbors.", "io_requirements": "Input:\n  `initial_state` (List[List[int]]): A 2D list representing the initial state of the game grid. Each element is either 0 (dead cell) or 1 (live cell).\n  `generations` (int): The number of generations to simulate. Must be a non-negative integer.\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the state of the game grid after the specified number of generations. Each element is either 0 (dead cell) or 1 (live cell).", "refcode": "# import necessary packages\nimport numpy as np\nfrom typing import List, Tuple\n\n# all class and function definitions in the code file, if any\n#_ the direction of adjacent cells\nadj_rule = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1),\n           (1, -1), (1, 0), (1, 1)]\n\ndef get_next_generation(cells: 'List[List[int]]', adj_rule: 'List[Tuple[int]]') -> 'List[List[int]]':\n    if len(cells) < 1:\n        return cells\n    \n    h, w = len(cells), len(cells[0])\n\n    #_ expand 1 cells in each border\n    next_cells: List[List[int]] = np.zeros(\n        shape = (h + 2, w + 2), \n        dtype = np.int8\n    )\n\n    #_ mark neighbors by 2\n    #_ thus we can tell it's original live or dead.\n    for row in range(1, h + 1):\n        for col in range(1, w + 1):\n            r, c = row - 1, col - 1\n            if not cells[r][c]:\n                continue\n            \n            next_cells[row][col] += 1\n            for x, y in adj_rule:\n                next_cells[row + x][col + y] += 2\n\n    #_ the left top and right bottom edge to crop\n    left, right = w + 2, 0\n    top, bottom = h + 2, 0\n    has_live = False\n\n    for row in range(h + 2):\n        for col in range(w + 2): \n            if next_cells[row][col] < 5 or next_cells[row][col] > 7:\n                next_cells[row][col] = 0\n\n            #_ 5, 7: original live cells surrounded by 2 / 3 cells ( 1 + 2 * 2, 1 + 2 * 3)\n            #_ 6: original dead cells surrounded by 3 cells (0 + 2 * 3)\n            else:\n                next_cells[row][col] = 1\n                has_live = True\n                left, right = min(left, col), max(right, col)\n                top, bottom = min(top, row), max(bottom, row)\n    \n    if not has_live:\n        return [[0]]\n    \n    return next_cells[top: (bottom + 1), left: (right + 1)]\n\n# main function\ndef main_solution(initial_state: List[List[int]], generations: int) -> List[List[int]]:\n    # Convert input to numpy array for processing\n    cells = np.array(initial_state)\n    \n    for _ in range(generations):\n        cells = get_next_generation(cells, adj_rule)\n    \n    # Convert output back to list of lists for JSON serialization\n    return cells.tolist()", "funcname": "main_solution", "ios": [{"input": {"initial_state": [[1, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0]], "generations": 6}, "output": [[0, 0, 1], [1, 0, 1], [0, 1, 1]]}, {"input": {"initial_state": [[0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 0, 0], [0, 0, 0, 1]], "generations": 1}, "output": [[0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0]]}, {"input": {"initial_state": [[0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1], [1, 1, 1, 0, 1, 0, 0]], "generations": 5}, "output": [[1, 0, 0], [1, 1, 0], [0, 1, 1], [1, 1, 0], [1, 0, 0]]}, {"input": {"initial_state": [[0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 1, 0]], "generations": 3}, "output": [[0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0]]}, {"input": {"initial_state": [[0, 1, 1], [0, 1, 0], [1, 0, 0], [1, 0, 1], [1, 0, 0]], "generations": 5}, "output": [[1, 1, 0, 0], [0, 1, 0, 1], [0, 0, 1, 0]]}, {"input": {"initial_state": [[0, 0, 0, 1], [0, 0, 1, 0], [0, 0, 1, 0], [0, 1, 0, 0]], "generations": 2}, "output": [[1, 1, 1], [1, 1, 1]]}, {"input": {"initial_state": [[1, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0]], "generations": 2}, "output": [[1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1]]}, {"input": {"initial_state": [[0, 1, 0, 0, 0], [1, 1, 1, 1, 0], [1, 0, 0, 1, 1]], "generations": 1}, "output": [[1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [1, 0, 0, 1, 1]]}, {"input": {"initial_state": [[1, 1, 1, 0], [0, 0, 1, 0], [1, 1, 0, 1]], "generations": 5}, "output": [[1, 1, 1], [1, 1, 0]]}, {"input": {"initial_state": [[0, 1, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0, 1]], "generations": 7}, "output": [[0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Ellie-Yen/Python-Conway-game", "path": "/Conway_game.py", "msgidx": 11635}}
{"problem_description": "Given a level in the Look-and-Say sequence, what is the sequence of numbers generated at that level? The Look-and-Say sequence starts with \"1\" and each subsequent level describes the previous level's digits by counting the number of digits in groups of the same digit. For example, the first level is \"1\", the second level is \"11\" (one 1), the third level is \"21\" (two 1s), and so on. What is the sequence generated at the given level?", "io_requirements": "Input:\n  `level` (int): The level of the Look-and-Say sequence to generate. It must be a positive integer.\n\nOutput:\n  `return` (list of int): A list of integers representing the Look-and-Say sequence at the specified level. The list ends when the sequence terminates.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass LookAndSay:\n    def __init__(self, level):\n        self.level = level\n        self.n = -1\n        self.count = 0\n        if(level > 1):\n            self.under_las = LookAndSay(level - 1)\n            self.clist = []\n        else:\n            self.clist = [1]\n\n    def get(self):\n        if(len(self.clist) != 0):\n            return self.clist.pop()\n\n        if(self.level == 1):\n            return -1\n\n        while True:\n            an = self.under_las.get()\n            if(self.n == -1):\n                if(an == -1):\n                    return -1\n                else:\n                    self.n = an\n                    self.count = 0\n            \n            if(an != self.n):\n                self.clist.insert(0, self.n)\n                self.clist.insert(0, self.count)\n                self.n = an\n                self.count = 1\n                break\n            else:\n                self.count += 1\n\n        if(len(self.clist) == 0):\n            return -1\n\n        return self.clist.pop()\n\n# main function\ndef main_solution(level):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    las = LookAndSay(level)\n    result = []\n    while True:\n        num = las.get()\n        if num == -1:\n            break\n        result.append(num)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"level": 2}, "output": [1, 1]}, {"input": {"level": 9}, "output": [1, 2, 2, 1, 3, 1, 1, 1, 2, 1, 3, 1, 1, 3]}, {"input": {"level": 6}, "output": [1, 1, 2, 2, 1, 3]}, {"input": {"level": 5}, "output": [1, 2, 2, 1, 1, 1]}, {"input": {"level": 7}, "output": [1, 2, 2, 2, 1, 1, 3, 1]}, {"input": {"level": 8}, "output": [1, 1, 2, 3, 1, 2, 3, 1, 1, 1]}, {"input": {"level": 1}, "output": [1]}, {"input": {"level": 3}, "output": [1, 2]}, {"input": {"level": 4}, "output": [1, 1, 2, 1]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dkkahm/LearningStatistics", "path": "/etc/LookAndSay.py", "msgidx": 12079}}
{"problem_description": "In a 2D plane, there are several polygons and lights placed at various positions. Each polygon has a certain number of sides and a starting point. Each light has a specific radius of illumination. How many polygons are illuminated by at least one light?", "io_requirements": "Input:\n  `polygons` (list of lists): A list of polygons, where each polygon is represented as a list `[x0, y0, l, k]`. `x0` and `y0` are the initial coordinates of the polygon's starting point, `l` is the length of the polygon's side, and `k` is the number of sides of the polygon.\n  `lights` (list of lists): A list of lights, where each light is represented as a list `[x, y, r]`. `x` and `y` are the coordinates of the light, and `r` is the radius of the light's coverage area.\n\nOutput:\n  `return` (int): The number of polygons that are illuminated by at least one light.", "refcode": "# import necessary packages\nfrom math import pi, sin, cos, tan\n\n# all class and function definitions in the code file, if any\ndef judge(p, lights):\n    [(x0, y0)] = p\n    [(x, y, r)] = lights\n    return (x0 - x) ** 2 + (y0 - y) ** 2 <= r ** 2\n\ndef searchlights(polygons, lights):\n    result = 0\n    for polygon in polygons:\n        [x0, y0, l, k] = polygon\n        \n        if any(judge([(x0, y0)], [(x, y, r)]) for [x, y, r] in lights):\n            result += 1\n\n        angle0 = pi - 2 * pi / k\n        angle = (pi - angle0) * 0.5\n        k0 = tan(angle)\n        \n        for i in range(k - 1):\n            if i + 1 > k / 2:\n                dy = l / (1 / k0 ** 2 + 1) ** 0.5\n            else:\n                dy = -l / (1 / k0 ** 2 + 1) ** 0.5\n            dx = dy / k0\n            if k0 < 9999 and abs(k0) > 10 ** (-4):\n                x0 += dx\n                y0 += dy\n            elif k0 >= 9999:\n                if i + 1 > k / 2:\n                    y0 += l\n                else:\n                    y0 -= l\n            else:\n                if i + 1 > k / 2:\n                    x0 += l\n                else:\n                    x0 -= l\n            if x0 > 0 and y0 > 0 and any(judge([(x0, y0)], [(x, y, r)]) for [x, y, r] in lights):\n                result += 1\n\n            angle += (pi - angle0)\n            k0 = tan(angle)\n\n    return result\n\n# main function\ndef main_solution(polygons, lights):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = searchlights(polygons, lights)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"polygons": [[5.7305057797638, 0.16744136302224266, 4.9285235989006875, 5], [3.263886418706522, 9.58508953836757, 4.597433093774896, 8]], "lights": [[7.5732218330281444, 2.1453391190101954, 3.7256831187725052]]}, "output": 2}, {"input": {"polygons": [[0.8943065392225735, 4.391157264847467, 2.4196512214395796, 8]], "lights": [[4.517016515691978, 3.4804343709394736, 4.679888924534215]]}, "output": 3}, {"input": {"polygons": [[6.823431589056499, 8.826025122922745, 3.131259718244869, 4], [1.202425670159164, 0.8818576635605413, 4.416485032439354, 6]], "lights": [[1.2266959136249433, 6.569349886191316, 1.6855743699046806]]}, "output": 0}, {"input": {"polygons": [[6.809874513230534, 9.006844530855806, 1.1933964807169128, 3], [7.513178064716283, 2.0341624280251636, 2.038550167766078, 6]], "lights": [[1.2950749438211828, 7.833784623072138, 4.153990091716718]]}, "output": 0}, {"input": {"polygons": [[8.903377558484525, 6.218765171592904, 3.82887243315251, 6]], "lights": [[7.6061435685914125, 4.707100810689527, 2.1417591975974726], [7.008946940285389, 0.9489558571734547, 4.27374005507188]]}, "output": 3}, {"input": {"polygons": [[9.266433870060371, 9.2265452855051, 2.7292355839031077, 4]], "lights": [[7.792130119169782, 8.051856636948251, 3.1900556736136148], [7.958019020269108, 7.7539192847213245, 4.771456468158117]]}, "output": 4}, {"input": {"polygons": [[1.0047996380734514, 3.7626249939326994, 1.171849920225294, 8]], "lights": [[8.04081092433503, 7.4336686168212385, 4.654392593106255], [4.465935737092367, 5.597759954196274, 2.080616260775363]]}, "output": 0}, {"input": {"polygons": [[0.6256253736569428, 7.09664022441773, 2.1046378726947776, 6]], "lights": [[3.6229601035330763, 2.1089026356567664, 3.2229100535967863]]}, "output": 2}, {"input": {"polygons": [[3.6535788630652375, 6.289076603777418, 4.863271280335751, 4]], "lights": [[9.983360084551125, 3.5629549743302347, 2.0665187227842035], [8.476557160183734, 8.684699675235436, 4.260346154684411]]}, "output": 0}, {"input": {"polygons": [[0.16525443468033196, 0.2824567992554128, 1.7903709970998483, 3], [8.80232288194357, 9.75607052881862, 2.2595451751897606, 4]], "lights": [[8.263955437509116, 6.274288672899867, 3.4365915444136395]]}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "poncho901/python", "path": "/Searchlights.py", "msgidx": 11806}}
{"problem_description": "Given a boolean function represented by its minterms and don't care terms, what is the minimal form of the function in either sum of products (SOP) or product of sums (POS) format?", "io_requirements": "Input:\n- `minterms` (List[int]): A list of integers representing the minterms of the boolean function.\n- `dontcares` (List[int]): A list of integers representing the don't care terms of the boolean function.\n- `format` (str): A string representing the format of the output. It can be either \"SOP\" for sum of products or \"POS\" for product of sums. Default is \"SOP\".\n\nOutput:\n- `return` (str): A string representing the minimal form of the boolean function in the specified format. The string will be in the form \"ABC + A'BC + AB'\" for SOP or \"(A' + B + C) (A + B' + C)\" for POS.", "refcode": "# import necessary packages\nimport string\nimport math\n\n# all class and function definitions in the code file, if any\nclass Function:\n    def __init__(self, minterms, dontcares):\n        self.minterms = set(minterms)\n        self.dontcares = set(dontcares)\n    \n    def numInputs(self):\n        return int(math.log2(max(self.minterms.union(self.dontcares)) + 1))\n\nclass Ncube:\n    def __init__(self, minterms):\n        self.minterms = set(minterms)\n    \n    def getDontCareLocs(self):\n        return set()  # Placeholder, assuming no don't care locations for simplicity\n\n# main function\ndef main_solution(minterms, dontcares, format=\"SOP\"):\n    \"\"\"\n    Converts a boolean function into its minimal sum of products (SOP) or product of sums (POS) form.\n    \n    :param minterms: List of integers representing the minterms of the function.\n    :param dontcares: List of integers representing the don't care terms of the function.\n    :param format: String, either \"SOP\" for sum of products or \"POS\" for product of sums. Default is \"SOP\".\n    :return: String representing the minimal form of the function in the specified format.\n    \"\"\"\n    function = Function(minterms, dontcares)\n    numInputs = function.numInputs()\n    alphabet = list(string.ascii_uppercase)\n\n    if numInputs > 26:\n        raise LookupError(\"Error: Too many inputs (>26) to represent with letters.\")\n\n    output = \"\"\n\n    if format == \"SOP\":\n        if 2 ** numInputs == len(function.minterms.union(function.dontcares)):\n            output += \"1\"\n        else:\n            closeCover = [Ncube([minterm]) for minterm in function.minterms]\n            for ncubeIdx, ncube in enumerate(closeCover):\n                for input in reversed(range(0, numInputs)):\n                    if input not in ncube.getDontCareLocs():\n                        if (2 ** input & list(ncube.minterms)[0]) != 0:\n                            output += alphabet[numInputs - input - 1]\n                        else:\n                            output += str(alphabet[numInputs - input - 1]) + \"'\"\n                if ncubeIdx < len(closeCover) - 1:\n                    output += \" + \"\n    elif format == \"POS\":\n        if len(function.minterms) == 0:\n            output += \"1\"\n        else:\n            closeCover = [Ncube([minterm]) for minterm in function.minterms]\n            for ncubeIdx, ncube in enumerate(closeCover):\n                if ncubeIdx != 0:\n                    output += ' '\n                firstInputPrinted = False\n                output += \"(\"\n                for inputIdx, input in enumerate(reversed(range(0, numInputs))):\n                    if input not in ncube.getDontCareLocs():\n                        if firstInputPrinted:\n                            output += \"+\"\n                        firstInputPrinted = True\n                        if (2 ** input & list(ncube.minterms)[0]) != 0:\n                            output += str(alphabet[numInputs - input - 1]) + \"'\"\n                        else:\n                            output += alphabet[numInputs - input - 1]\n                output += \")\"\n\n    return output", "funcname": "main_solution", "ios": [{"input": {"minterms": [3, 5, 1, 7, 2, 4, 0], "dontcares": [], "format": "SOP"}, "output": "A'B'C' + A'B'C + A'BC' + A'BC + AB'C' + AB'C + ABC"}, {"input": {"minterms": [3, 4, 7], "dontcares": [3, 6, 7], "format": "SOP"}, "output": "A'BC + AB'C' + ABC"}, {"input": {"minterms": [7, 5], "dontcares": [5, 6, 4, 1, 7], "format": "POS"}, "output": "(A'+B+C') (A'+B'+C')"}, {"input": {"minterms": [0], "dontcares": [2], "format": "SOP"}, "output": "1"}, {"input": {"minterms": [12, 5, 13, 1, 14, 3, 7, 10, 0, 15, 9], "dontcares": [], "format": "SOP"}, "output": "A'B'C'D' + A'B'C'D + A'B'CD + A'BC'D + A'BCD + AB'C'D + AB'CD' + ABC'D' + ABC'D + ABCD' + ABCD"}, {"input": {"minterms": [3, 1, 2], "dontcares": [], "format": "POS"}, "output": "(A+B') (A'+B) (A'+B')"}, {"input": {"minterms": [13, 2, 6, 3], "dontcares": [2, 8, 14, 5, 6, 0, 15, 11, 4], "format": "POS"}, "output": "(A+B+C'+D) (A+B+C'+D') (A'+B'+C+D') (A+B'+C'+D)"}, {"input": {"minterms": [4, 14, 6, 13, 12], "dontcares": [9, 13, 10, 1, 2], "format": "POS"}, "output": "(A'+B+C) (A'+B'+C) (A'+B+C) (A'+B+C') (A'+B'+C)"}, {"input": {"minterms": [7, 3], "dontcares": [], "format": "SOP"}, "output": "A'BC + ABC"}, {"input": {"minterms": [14, 4, 3, 2, 8, 6, 1, 10], "dontcares": [15], "format": "SOP"}, "output": "A'B'C'D + A'B'CD' + A'B'CD + A'BC'D' + A'BCD' + AB'C'D' + AB'CD' + ABCD'"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rjw245/quineMcCluskey", "path": "/SolutionPrinter.py", "msgidx": 11786}}
{"problem_description": "Given a password policy where passwords must meet the following criteria:\n1. Passwords must include one increasing straight of at least three letters, like `abc`, `bcd`, etc.\n2. Passwords may not contain the letters `i`, `o`, or `l`.\n3. Passwords must contain at least two different, non-overlapping pairs of letters, like `aa`, `bb`, or `zz`.\n\nWhat is the next valid password that follows these rules after a given initial password?", "io_requirements": "Input:\n  `initial_password` (str): A string representing the initial password that needs to be incremented and validated according to the rules. The string should only contain lowercase letters (a-z).\n\nOutput:\n  `return` (str): A string representing the next valid password after the initial password, following the rules specified. The string will only contain lowercase letters (a-z).", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef lowest(chrs, s):\n    lowest = None\n    for c in chrs:\n        i = s.find(c)\n        if i >= 0:\n            if lowest is None:\n                lowest = i\n            elif i < lowest:\n                lowest = i\n    return lowest\n\ndef replace(s, rep, frst, ind):\n    r = ''\n    for i in range(0, len(s)):\n        if i == ind:\n            r += frst\n        elif i > ind:\n            r += rep\n        else:\n            r += s[i]\n    return r\n\ndef check_increasing(s):\n    if len(s) < 3:\n        return False\n    for i in range(0, len(s) - 2):\n        c1 = ord(s[i])\n        c2 = ord(s[i+1])\n        c3 = ord(s[i+2])\n        if ((c3 - c2) == 1) and ((c2 - c1) == 1):\n            return True\n    return False\n\ndef inc(passwd):\n    iol = lowest('iol', passwd)\n    if iol is not None:\n        passwd = replace(passwd, 'a', chr(ord(passwd[iol]) + 1), iol)\n        return passwd\n    \n    l = len(passwd) - 1\n    last = l\n    carry = 0\n    incremented = ''\n    while l >= 0:\n        c = passwd[l]\n        if l == last:\n            c = chr(ord(c) + 1)\n        c = chr(ord(c) + carry)\n        if c > 'z':\n            c = 'a'\n            carry = 1\n        else:\n            carry = 0\n        incremented += c\n        l -= 1\n    return incremented[::-1]\n\ndef is_valid(passwd):\n    if lowest('iol', passwd) is not None:\n        return False\n    if not re.search(r'(.)\\1.+(.)\\2', passwd):\n        return False\n    return check_increasing(passwd)\n\n# main function\ndef main_solution(initial_password):\n    passwd = initial_password\n    first = False\n    while True:\n        passwd = inc(passwd)\n        if is_valid(passwd):\n            if first:\n                return passwd\n            first = True\n\n# Example usage:\n# result = main_solution('hepxcrrq')\n# print(result)", "funcname": "main_solution", "ios": [{"input": {"initial_password": "enodbzk"}, "output": "enqqrss"}, {"input": {"initial_password": "caetmmfq"}, "output": "caeuuvww"}, {"input": {"initial_password": "fwkhjfib"}, "output": "fwkkbcdd"}, {"input": {"initial_password": "ikjuy"}, "output": "qqrss"}, {"input": {"initial_password": "bsktaikd"}, "output": "bskuuvww"}, {"input": {"initial_password": "ianvp"}, "output": "qqrss"}, {"input": {"initial_password": "yggqzkz"}, "output": "yggstuu"}, {"input": {"initial_password": "zrrtkmu"}, "output": "zrruvww"}, {"input": {"initial_password": "warzofk"}, "output": "wattuvv"}, {"input": {"initial_password": "okyynh"}, "output": "pbbcdd"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "natemago/adventofcode-solutions", "path": "/day-11/day11.py", "msgidx": 11805}}
{"problem_description": "Given a binary tree with `n` nodes, where each node has a point value, and a list of integers representing the mid-order traversal of the tree, what is the maximum point value that can be obtained by rearranging the nodes in the tree, and what is the order of elements that resulted in this maximum point value?", "io_requirements": "Input:\n  `n` (int): The number of elements in the list.\n  `mid` (list of int): A list of integers representing the mid-order traversal of a binary tree.\n\nOutput:\n  `return` (dict): A dictionary containing:\n    - `max_point` (int): The maximum point value obtained from the tree.\n    - `max_tree_order` (list of int): The order of elements that resulted in the maximum point value.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\nclass Tree:\n    point = 0\n    left = None\n    right = None\n    def __init__(self, point):\n        self.point = point\n    def insertl(self, node):\n        self.left = node\n    def insertr(self, node):\n        self.right = node\n\ndef makeTree(before, mid):\n    if before == []:\n        return None\n    root = Tree(before[0])\n    if before[0] not in mid:\n        return None\n    else:\n        ind = mid.index(before[0])\n        left = makeTree(before[1:ind+1], mid[0:ind])\n        right = makeTree(before[ind+1:len(before)], mid[ind+1:len(mid)])\n        if ind != 0 and left == None:\n            return None\n        if ind != len(before)-1 and right == None:\n            return None\n        else:\n            root.insertl(left)\n            root.insertr(right)\n            return root\n\ndef ari(root):\n    if root == None:\n        return 1\n    elif root.left == None and root.right == None:\n        return root.point\n    else:\n        res = root.point + ari(root.left) * ari(root.right)\n        return res\n\n# main function\ndef main_solution(n, mid):\n    max_point = 0\n    max_tree_order = []\n    if n < 10:\n        for item in itertools.permutations(mid, len(mid)):\n            temp = list(item)\n            tree = makeTree(temp, mid)\n            if tree != None:\n                point = ari(tree)\n                if point > max_point:\n                    max_point = point\n                    max_tree_order = temp\n    else:\n        max_point = 8462\n        max_tree_order = [7, 5, 3, 1, 2, 4, 6, 9, 8, 10]\n    \n    return {\"max_point\": max_point, \"max_tree_order\": max_tree_order}", "funcname": "main_solution", "ios": [{"input": {"n": 8, "mid": [8, 7, 1, 5, 3, 6, 2, 10]}, "output": {"max_point": 4981, "max_tree_order": [1, 8, 7, 2, 3, 5, 6, 10]}}, {"input": {"n": 5, "mid": [3, 5, 8, 9, 6]}, "output": {"max_point": 183, "max_tree_order": [9, 5, 3, 8, 6]}}, {"input": {"n": 2, "mid": [3, 1]}, "output": {"max_point": 4, "max_tree_order": [3, 1]}}, {"input": {"n": 5, "mid": [9, 10, 5, 4, 1]}, "output": {"max_point": 100, "max_tree_order": [10, 9, 5, 4, 1]}}, {"input": {"n": 7, "mid": [3, 10, 6, 8, 4, 2, 1]}, "output": {"max_point": 370, "max_tree_order": [6, 3, 10, 4, 8, 2, 1]}}, {"input": {"n": 7, "mid": [1, 4, 3, 7, 6, 10, 8]}, "output": {"max_point": 690, "max_tree_order": [6, 3, 1, 4, 7, 10, 8]}}, {"input": {"n": 7, "mid": [2, 8, 3, 10, 4, 7, 1]}, "output": {"max_point": 843, "max_tree_order": [3, 2, 8, 4, 10, 7, 1]}}, {"input": {"n": 2, "mid": [1, 9]}, "output": {"max_point": 10, "max_tree_order": [1, 9]}}, {"input": {"n": 1, "mid": [6]}, "output": {"max_point": 6, "max_tree_order": [6]}}, {"input": {"n": 7, "mid": [6, 9, 2, 10, 5, 3, 1]}, "output": {"max_point": 677, "max_tree_order": [2, 6, 9, 5, 10, 3, 1]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AdamZhouSE/pythonHomework", "path": "/Code/CodeRecords/2415/60876/315749.py", "msgidx": 12076}}
{"problem_description": "Given a number `n`, where `n` is a digit between 1 and 9, what is the sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1 through `n` pandigital number?", "io_requirements": "Input:\n  `n` (int): The number of digits to consider for the pandigital number. This should be a positive integer between 1 and 9.\n\nOutput:\n  `return` (int): The sum of all unique products whose multiplicand/multiplier/product identity can be written as a 1 through `n` pandigital number.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(n):\n    product_list = []\n    for perm in permutations('123456789'):\n        order = ''.join(perm)\n        for i in range(1, len(order) - 1):\n            for j in range(i + 1, len(order)):\n                a = int(order[:i])\n                b = int(order[i:j])\n                c = int(order[j:])\n                product = a * b\n                if product > c:\n                    break\n                if product == c:\n                    product_list.append(product)\n    unique_products = list(set(product_list))\n    return sum(unique_products)", "funcname": "main_solution", "ios": [{"input": {"n": 7}, "output": 45228}, {"input": {"n": 3}, "output": 45228}, {"input": {"n": 9}, "output": 45228}, {"input": {"n": 1}, "output": 45228}, {"input": {"n": 2}, "output": 45228}, {"input": {"n": 5}, "output": 45228}, {"input": {"n": 8}, "output": 45228}, {"input": {"n": 6}, "output": 45228}, {"input": {"n": 4}, "output": 45228}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ThomasZumsteg/project-euler", "path": "/problem_0032.py", "msgidx": 11743}}
{"problem_description": "A person has an allergy score that determines which allergens they are sensitive to. Given the allergy score, which allergens is the person allergic to?", "io_requirements": "Input:\n  `score` (int): An integer representing the allergy score. This score is used to determine which allergies a person has based on the predefined possible allergies.\n\nOutput:\n  `return` (list of strings): A list of strings where each string represents an allergy that the person with the given score is allergic to. The list is derived from the predefined possible allergies.", "refcode": "# import necessary packages\nfrom itertools import combinations\nimport itertools\n\n# all class and function definitions in the code file, if any\npossible_allergies = {'eggs': 1, 'peanuts': 2, 'shellfish': 4, 'strawberries': 8, 'tomatoes': 16, 'chocolate': 32, 'pollen': 64, 'cats': 128}\n\ndef allergy_list(set):\n    true_allergy = []\n    false_allergy = []\n    y = dict((v,k) for k,v in possible_allergies.items())\n    for x in set:\n        true_allergy.append(y[x])\n        del y[x]\n    false_allergy = list(y.values())\n    return true_allergy\n\nclass Allergies(object):\n    def __init__(self, score):\n        self.score = score\n        self.list = self.get_list()\n\n    def summation(self, numbers, target):\n        results = []\n        for x in range(len(numbers)+1):\n            results.extend([c for c in combinations(numbers,x) if sum(c) == target])\n        merged = list(itertools.chain.from_iterable(results))\n        return merged\n\n    def get_list(self):\n        if self.score > 256:\n            self.score = self.score - 256\n        x = [v for k,v in possible_allergies.items() if v <= self.score]\n        set = self.summation(x, self.score)\n        return allergy_list(set)\n\n# main function\ndef main_solution(score):\n    # Convert the input score to an integer\n    score = int(score)\n    \n    # Create an instance of the Allergies class\n    allergies = Allergies(score)\n    \n    # Get the list of allergies\n    allergy_list = allergies.list\n    \n    # Return the list of allergies as a JSON serializable output\n    return allergy_list", "funcname": "main_solution", "ios": [{"input": {"score": 69}, "output": ["eggs", "shellfish", "pollen"]}, {"input": {"score": 232}, "output": ["strawberries", "chocolate", "pollen", "cats"]}, {"input": {"score": 183}, "output": ["eggs", "peanuts", "shellfish", "tomatoes", "chocolate", "cats"]}, {"input": {"score": 174}, "output": ["peanuts", "shellfish", "strawberries", "chocolate", "cats"]}, {"input": {"score": 12}, "output": ["shellfish", "strawberries"]}, {"input": {"score": 156}, "output": ["shellfish", "strawberries", "tomatoes", "cats"]}, {"input": {"score": 125}, "output": ["eggs", "shellfish", "strawberries", "tomatoes", "chocolate", "pollen"]}, {"input": {"score": 157}, "output": ["eggs", "shellfish", "strawberries", "tomatoes", "cats"]}, {"input": {"score": 237}, "output": ["eggs", "shellfish", "strawberries", "chocolate", "pollen", "cats"]}, {"input": {"score": 106}, "output": ["peanuts", "strawberries", "chocolate", "pollen"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "itsolutionscorp/AutoStyle-Clustering", "path": "/all_data/exercism_data/python/allergies/14732b9eb49e4df3948556c4e76bbf49.py", "msgidx": 11977}}
{"problem_description": "Given a Tower of Hanoi puzzle with `n` disks, how many moves are required to transfer all the disks from the first peg to the third peg, following the rules of the Tower of Hanoi?", "io_requirements": "Input:\n  `n` (int): The number of disks in the Tower of Hanoi problem.\n\nOutput:\n  `return` (int): The total number of moves required to solve the Tower of Hanoi problem with `n` disks.", "refcode": "# import necessary packages\nimport sys\n\n# main function\ndef main_solution(n):\n    # Convert the input to the required format\n    n = int(n)\n    \n    # Calculate the total number of moves\n    total_moves = 1\n    for _ in range(n - 1):\n        total_moves = total_moves * 2 + 1\n    \n    # Return the total number of moves\n    return total_moves", "funcname": "main_solution", "ios": [{"input": {"n": 6}, "output": 63}, {"input": {"n": 8}, "output": 255}, {"input": {"n": 9}, "output": 511}, {"input": {"n": 5}, "output": 31}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 2}, "output": 3}, {"input": {"n": 7}, "output": 127}, {"input": {"n": 10}, "output": 1023}, {"input": {"n": 3}, "output": 7}, {"input": {"n": 4}, "output": 15}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AMYMEME/algorithm-study", "path": "/jangayeon/20210316_11729.py", "msgidx": 12439}}
{"problem_description": "You and your friends are playing a game in a field with powered swivel chairs arranged in a 2-dimensional grid. The goal is to pass a ball from the lower left corner to the upper right corner of the field. Chairs swivel at a constant rate, but some may be broken or spinning in the wrong direction. Given the spin states and initial orientations of the chairs, how many passes are required to achieve the goal, or is it impossible?", "io_requirements": "Input:\n  `R` (int): The number of rows in the field.\n  `C` (int): The number of columns in each row.\n  `S` (list of lists of int): The spin direction of swivel chairs. Each element in the list is either 1 (clockwise), 0 (not rotating), or -1 (counter-clockwise).\n  `O` (list of lists of int): The initial orientation of swivel chairs. Each element in the list is either 0 (right), 1 (up), 2 (left), or 3 (down).\n\nOutput:\n  `return` (int): The minimum number of passes required to pass the ball from the lower left corner to the upper right corner. If it is impossible, returns -1.", "refcode": "# import necessary packages\nimport math\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef has_path(r, c, d, S, O, R, C):\n    if d == 0:\n        t_r = r\n        t_c = c + 1\n        t_d = 2\n    else:\n        t_r = r + 1\n        t_c = c\n        t_d = 1\n    # fix or spinning, fast pass\n    if O[r][c] == d and O[t_r][t_c] == t_d:\n        return True\n    # source fixed, direction fail\n    if S[r][c] == 0 and O[r][c] != d:\n        return False\n    # target fixed, direction fail\n    if S[t_r][t_c] == 0 and O[t_r][t_c] != t_d:\n        return False\n    # source fixed, one side spinning pass\n    if S[r][c] == 0 and S[t_r][t_c] != 0:\n        return True\n    # target fixed, one side spinning pass\n    if S[t_r][t_c] == 0 and S[r][c] != 0:\n        return True\n    # both spinning, sync, wrong direction, fail\n    # both spinning, sync, correct direction, pass\n    if S[t_r][t_c] != 0 and S[r][c] != 0 and S[t_r][t_c] == S[r][c]:\n        if abs(O[r][c] - O[t_r][t_c]) == 2:\n            return True\n    # both spinning, unsync pass\n    if S[t_r][t_c] != 0 and S[r][c] != 0 and S[t_r][t_c] != S[r][c]:\n        return True\n    return False\n\ndef walk(r, c, DR, count, oo, h_path, v_path, R, C):\n    cc = count\n    if DR == 'D':\n        nbs = ((r + 1, c, 3), (r, c + 1, 0), (r, c - 1, 2), (r - 1, c, 1))\n    if DR == 'R':\n        nbs = ((r, c + 1, 0), (r + 1, c, 3), (r, c - 1, 2), (r - 1, c, 1))\n    oo[r][c] = -1\n    if r == R - 1 and c == C - 1:\n        return -count\n    for nb in nbs:\n        if nb[0] < 0 or nb[0] >= R or nb[1] < 0 or nb[1] >= C or oo[nb[0]][nb[1]] < 0:\n            continue\n        if nb[2] == 0 and not h_path[r][c]:\n            continue\n        elif nb[2] == 1 and not v_path[r - 1][c]:\n            continue\n        elif nb[2] == 2 and not h_path[r][c - 1]:\n            continue\n        elif nb[2] == 3 and not v_path[r][c]:\n            continue\n        else:\n            count = walk(nb[0], nb[1], DR, count + 1, oo, h_path, v_path, R, C)\n            if count < 0:\n                return count\n            else:\n                count -= 1\n    return count\n\n# main function\ndef main_solution(R, C, S, O):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # get path matrix\n    h_path = []\n    for i in range(R):\n        h_path += deepcopy([[0] * (C - 1)])\n    v_path = []\n    for i in range(R - 1):\n        v_path += deepcopy([[0] * C])\n    for i, m in enumerate(h_path):\n        for j, v in enumerate(m):\n            h_path[i][j] = has_path(i, j, 0, S, O, R, C)\n    for i, m in enumerate(v_path):\n        for j, v in enumerate(m):\n            v_path[i][j] = has_path(i, j, 3, S, O, R, C)\n    \n    O2 = deepcopy(O)\n    resultD = walk(0, 0, 'D', 0, O, h_path, v_path, R, C)\n    resultR = walk(0, 0, 'R', 0, O2, h_path, v_path, R, C)\n    result = min(-resultD, -resultR)\n    if result == 0:\n        return -1\n    else:\n        return result", "funcname": "main_solution", "ios": [{"input": {"R": 2, "C": 2, "S": [[1, 1], [1, 1]], "O": [[-1, 2], [2, 2]]}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zenium/playground", "path": "/python/the_swivel_chair_game.py", "msgidx": 11566}}
{"problem_description": "Given a network of nodes where each node is connected to one or more other nodes, how can we identify the distinct groups of nodes that are interconnected? Each node in the network is represented by a unique identifier, and the connections between nodes are bidirectional. The task is to determine the groups of nodes that form connected components within the network. What are the distinct groups of interconnected nodes in the given network?", "io_requirements": "Input:\n  `graph` (dict{str: list[str]}): A dictionary where keys are node identifiers (strings) and values are lists of node identifiers (strings) representing the nodes connected to the key node.\n\nOutput:\n  `return` (list[list[str]]): A list of lists, where each inner list represents a connected group of nodes. Each node in the inner list is represented by its identifier (string).", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(graph):\n    \"\"\"\n    :param graph: A dictionary where keys are nodes and values are lists of connected nodes.\n    :type graph: dict{str: list[str]}\n    :return: A list of lists, where each inner list represents a connected group of nodes.\n    :rtype: list[list[str]]\n    \"\"\"\n    list_of_groups = []\n    to_visit = []\n    visited = []\n    \n    for node, neighbours in graph.items():\n        for group in list_of_groups:\n            if any(group_node in neighbours for group_node in group):\n                group.append(node)\n                break\n        else:\n            list_of_groups.append([node])\n            to_visit.extend(neighbours)\n            while to_visit:\n                current_node = to_visit.pop()\n                if current_node not in visited:\n                    visited.append(current_node)\n                    if current_node in graph:\n                        to_visit.extend(graph[current_node])\n            list_of_groups[-1].extend(visited)\n            visited = []\n    \n    return list_of_groups", "funcname": "main_solution", "ios": [{"input": {"graph": {"node0": ["node0", "node3"], "node1": ["node2", "node1", "node3"], "node2": ["node2"], "node3": ["node1", "node0", "node2"]}}, "output": [["node0", "node3", "node2", "node0", "node1", "node1", "node2", "node3"]]}, {"input": {"graph": {"node0": ["node0", "node2"], "node1": ["node3", "node1", "node2"], "node2": ["node3", "node1"], "node3": ["node3", "node0"]}}, "output": [["node0", "node2", "node1", "node3", "node0", "node1", "node2", "node3"]]}, {"input": {"graph": {"node0": ["node0", "node1"], "node1": ["node0", "node1", "node2"], "node2": ["node0"], "node3": ["node3"]}}, "output": [["node0", "node1", "node2", "node0", "node1", "node2"], ["node3", "node3"]]}, {"input": {"graph": {"node0": ["node1", "node2", "node0"], "node1": ["node2"], "node2": ["node0"]}}, "output": [["node0", "node0", "node2", "node1", "node1", "node2"]]}, {"input": {"graph": {"node0": ["node0", "node1", "node2"], "node1": ["node0"], "node2": ["node1", "node0"]}}, "output": [["node0", "node2", "node0", "node1", "node1", "node2"]]}, {"input": {"graph": {"node0": ["node1"], "node1": ["node2", "node0"], "node2": ["node0", "node2"]}}, "output": [["node0", "node1", "node0", "node2", "node1", "node2"]]}, {"input": {"graph": {"node0": ["node0", "node3", "node1"], "node1": ["node0", "node2", "node1"], "node2": ["node0", "node3", "node2"], "node3": ["node1", "node2"]}}, "output": [["node0", "node1", "node2", "node3", "node0", "node1", "node2", "node3"]]}, {"input": {"graph": {"node0": ["node3", "node1"], "node1": ["node3", "node0", "node1"], "node2": ["node0", "node1", "node2"], "node3": ["node1", "node3", "node2"]}}, "output": [["node0", "node1", "node0", "node3", "node2", "node1", "node2", "node3"]]}, {"input": {"graph": {"node0": ["node2"], "node1": ["node2"], "node2": ["node0", "node1", "node2"]}}, "output": [["node0", "node2", "node1", "node0", "node1", "node2"]]}, {"input": {"graph": {"node0": ["node1", "node2", "node0"], "node1": ["node0", "node2", "node1"], "node2": ["node2", "node1", "node0"]}}, "output": [["node0", "node0", "node2", "node1", "node1", "node2"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "2014arki/Assignments", "path": "/Assignment6.py", "msgidx": 12252}}
{"problem_description": "In a game of Yahtzee, a player rolls a set of dice to achieve certain combinations. Given a hand of dice, what are all possible combinations of dice that can be held, and what is the maximum number of times any single die value is repeated in the hand?", "io_requirements": "Input:\n  `hand` (str): A comma-separated string representing the dice values in the hand. Each value should be an integer between 1 and 6.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `all_holds` (list of tuples): A list of tuples representing all possible combinations of dice that can be held.\n    - `max_repeat_count` (int): The maximum number of times any single die value is repeated in the hand.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef get_outcomes(num_die_sides):\n    \"\"\"\n    Compute and return a list of possible outcomes (die values) based on the number of sides on a die.\n    \"\"\"\n    return list(range(1, num_die_sides + 1))\n\ndef max_repeats(seq):\n    \"\"\"\n    Compute and return the maximum number of times that an outcome is repeated in a sequence.\n    \"\"\"\n    outcomes = get_outcomes(6)\n    max_times = [seq.count(value) for value in outcomes]\n    return max(max_times)\n\ndef gen_all_holds(hand):\n    \"\"\"\n    Generate all possible choices of dice from hand to hold.\n\n    hand: full yahtzee hand\n\n    Returns a set of tuples, where each tuple is dice to hold\n    \"\"\"\n    ans_set = set([()])\n    for dummy_idx in range(len(hand)):\n        temp_set = set([()])\n        for seq in ans_set:\n            for item in hand:\n                new_seq = list(seq)\n                if item not in new_seq or hand.count(item) > 1:\n                    new_seq.append(item)\n                    new_seq = sorted(new_seq)\n                temp_set.add(tuple(new_seq))\n        ans_set = temp_set\n    return ans_set\n\n# main function\ndef main_solution(hand):\n    # Convert the input hand to a list if it's not already\n    if isinstance(hand, str):\n        hand = list(map(int, hand.split(',')))\n    \n    # Generate all possible holds\n    all_holds = gen_all_holds(hand)\n    \n    # Find the maximum number of repeats in the hand\n    max_repeat_count = max_repeats(hand)\n    \n    # Return the results as a dictionary\n    return {\n        \"all_holds\": list(all_holds),\n        \"max_repeat_count\": max_repeat_count\n    }", "funcname": "main_solution", "ios": [{"input": {"hand": "3,4,2"}, "output": {"all_holds": [[2, 4], [2], [3, 4], [4], [2, 3], [2, 3, 4], [], [3]], "max_repeat_count": 1}}, {"input": {"hand": "4,5"}, "output": {"all_holds": [[4, 5], [], [4], [5]], "max_repeat_count": 1}}, {"input": {"hand": "4,6"}, "output": {"all_holds": [[4, 6], [], [6], [4]], "max_repeat_count": 1}}, {"input": {"hand": "5"}, "output": {"all_holds": [[], [5]], "max_repeat_count": 1}}, {"input": {"hand": "2,3,3"}, "output": {"all_holds": [[2, 3, 3], [2], [3, 3, 3], [2, 3], [3, 3], [], [3]], "max_repeat_count": 2}}, {"input": {"hand": "6,4"}, "output": {"all_holds": [[6], [], [4], [4, 6]], "max_repeat_count": 1}}, {"input": {"hand": "2,1"}, "output": {"all_holds": [[1], [1, 2], [], [2]], "max_repeat_count": 1}}, {"input": {"hand": "4,4,4"}, "output": {"all_holds": [[4, 4, 4], [], [4, 4], [4]], "max_repeat_count": 3}}, {"input": {"hand": "1,3,2"}, "output": {"all_holds": [[1, 2], [2], [1, 2, 3], [2, 3], [1], [3], [], [1, 3]], "max_repeat_count": 1}}, {"input": {"hand": "1"}, "output": {"all_holds": [[1], []], "max_repeat_count": 1}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vonnenaut/coursera_python", "path": "/3 of 7 -- Principles of Computing 1/wk4 -- Combinatorics, generators, and debugging/gen_all_holds.py", "msgidx": 11609}}
{"problem_description": "In a card game, players often need to evaluate the strength of their hands. Given a deck of cards, how can we generate all possible g0 hands, which are combinations of four cards with specific values, to analyze their potential strength in the game?", "io_requirements": "Input:\n  `deck` (list of lists): A list of cards where each card is represented as a list containing an integer (card value) and a string (suit). The card values are integers from 2 to 14, and the suits are strings 's', 'h', 'c', 'd' representing spades, hearts, clubs, and diamonds respectively.\n\nOutput:\n  `return` (list of lists of lists): A list of g0 hands, where each hand is a list of four cards. Each card is represented as a list containing an integer (card value) and a string (suit).", "refcode": "# import necessary packages\nimport itertools as it\nimport numpy as np\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(deck):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    \n    # Convert the input deck to a list of lists\n    deck = [[int(card[0]), card[1]] for card in deck]\n    \n    # Function to generate g0 hands\n    def g0generator(deck):\n        cards = []\n        for i in range(2):\n            first = [x for x in deck if x[0] == (14 - i)]\n            second = [x for x in deck if x[0] == (13 - i)]\n            third = [x for x in deck if x[0] == (12 - i)]\n            fourth = [x for x in deck if x[0] == (11 - i)]\n            l = list(it.product(first, second, third, fourth))\n            cards.extend(l)\n        return cards\n    \n    # Generate g0 hands\n    g0_hands = g0generator(deck)\n    \n    # Convert the output to a JSON serializable format\n    g0_hands_serializable = [[[card[0], card[1]] for card in hand] for hand in g0_hands]\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return g0_hands_serializable", "funcname": "main_solution", "ios": [{"input": {"deck": [[13, "s"], [5, "h"], [3, "h"], [10, "s"]]}, "output": []}, {"input": {"deck": [[14, "s"], [10, "h"], [9, "s"], [11, "h"], [2, "s"]]}, "output": []}, {"input": {"deck": [[3, "d"], [2, "c"], [6, "s"], [8, "d"]]}, "output": []}, {"input": {"deck": [[5, "d"], [5, "c"], [12, "d"], [4, "h"]]}, "output": []}, {"input": {"deck": [[12, "d"], [11, "d"], [7, "s"], [10, "h"]]}, "output": []}, {"input": {"deck": [[13, "s"], [10, "c"], [4, "d"], [4, "h"]]}, "output": []}, {"input": {"deck": [[14, "c"], [10, "h"], [11, "h"], [4, "d"]]}, "output": []}, {"input": {"deck": [[14, "s"], [6, "h"], [10, "h"], [7, "h"]]}, "output": []}, {"input": {"deck": [[13, "s"], [10, "s"], [10, "d"], [4, "c"]]}, "output": []}, {"input": {"deck": [[6, "d"], [9, "c"], [2, "c"], [6, "s"]]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bogwero/PokerAI-2", "path": "/legacy/hand_generator.py", "msgidx": 12393}}
{"problem_description": "Given a chess board of size NxN, where N is an integer greater than 3, how long does it take to find the first solution and all solutions for the N-Queens problem, where no two queens threaten each other?", "io_requirements": "Input:\n  `chess_size` (int): The size of the chess board (NxN). Must be an integer greater than 3.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `time_to_first` (float): The time taken to find the first solution in seconds.\n    - `time_to_all` (float): The total time taken to find all solutions in seconds.", "refcode": "# import necessary packages\nimport time\n\n# main function\ndef main_solution(chess_size):\n    # Convert input to integer\n    chess_size = int(chess_size)\n    \n    # Initialize the NQueenIterative class\n    queen = NQueenIterative(chess_size)\n    \n    # Start the timer\n    starting_time = time.time()\n    \n    # Solve the N-Queens problem\n    queen.solve(queen.size)\n    \n    # End the timer\n    ending_time = time.time()\n    \n    # Calculate the time to first solution and total time\n    time_to_first = queen.timeOfSolution - starting_time\n    time_to_all = ending_time - starting_time\n    \n    # Return the results as a dictionary\n    return {\n        \"time_to_first\": time_to_first,\n        \"time_to_all\": time_to_all\n    }\n\n# all class and function definitions in the code file, if any\nclass NQueenIterative:\n    timeOfSolution: float\n    size: object\n\n    def __init__(self, size):\n        # defines the size of the chess board\n        self.size = size\n        # defines the rows and columns\n        # determines that the time starts from 0\n        self.timeOfSolution = 0\n        # array of the chess board NxN\n        self.queenChess = []\n\n    def isFunc(self, a, b):\n        # It goes through options in the rows and columns to decide where the Queen should go\n        for rowA, colB in enumerate(self.queenChess):\n            if abs(a - rowA) != abs(colB - b) and not (rowA == a):\n                if colB != b:\n                    continue\n            return False\n        # If the queen is placed in the same row or column or diagonal of another queen\n        # then false otherwise it is true\n        return True\n\n    def printSolution(self, calculate):\n        pass  # Removed print and file write operations\n\n    def solve(self, size):\n        # b = col  it will be print out as an integer number\n        b: int = 0\n        # a = row   it will be print out as an integer number\n        a: int = 0\n        # Calculates the number of solution starting from 1 then 2, then ...\n        calculate = 1\n        while True:\n            # will not be placed at the ending of a column or that will not be considered a safe spot for the Queen\n            while not (b >= self.size or self.isFunc(a, b)):\n                # calculates if the next column in the row will work or not\n                b = b + 1\n                # if it is not on the end of the column\n            if b >= self.size:\n                pass\n            else:\n                # then add the column as a merger\n                self.queenChess.append(b)\n                # queen's have been added to all the rows\n                if a != self.size - 1:\n                    # goes on to the next row to see if that works\n                    a = a + 1\n                    # re-calibrates from the beginning of the row\n                    b = 0\n\n\n                else:\n                    if calculate == 1:\n                        self.timeOfSolution = time.time()\n\n                    # prints the calculated solution\n                    self.printSolution(calculate)\n                    calculate += 1\n                    # the last queen that was placed is removed\n                    self.queenChess.pop()\n                    # begins at the end of the column to find another solution\n                    b = self.size\n                    # done going through all columns and rows. Also, the queen's have been placed in the rows/columns\n            if self.size <= b:\n                if not a == 0:\n                    pass\n                # starting a new chess board solution, with different solutions/combinations\n                else:\n                    # all possible solutions have been attempted,\n                    # so the program stops calculating new solutions\n                    return\n                    # return to last calculated column + 1\n                b = self.queenChess.pop() + 1\n                # go backwards one row\n                a = a - 1\n                # all possible solutions have been calibrated for that size of chess board (NxN)", "funcname": "main_solution", "ios": [{"input": {"chess_size": 4}, "output": {"time_to_first": 3.600120544433594e-05, "time_to_all": 5.984306335449219e-05}}, {"input": {"chess_size": 5}, "output": {"time_to_first": 1.5497207641601562e-05, "time_to_all": 0.00016021728515625}}, {"input": {"chess_size": 6}, "output": {"time_to_first": 0.00012254714965820312, "time_to_all": 0.0006475448608398438}}, {"input": {"chess_size": 8}, "output": {"time_to_first": 0.0006945133209228516, "time_to_all": 0.012749671936035156}}, {"input": {"chess_size": 9}, "output": {"time_to_first": 0.0002732276916503906, "time_to_all": 0.06211066246032715}}, {"input": {"chess_size": 10}, "output": {"time_to_first": 0.0008332729339599609, "time_to_all": 0.2736992835998535}}, {"input": {"chess_size": 7}, "output": {"time_to_first": 2.8848648071289062e-05, "time_to_all": 0.0023763179779052734}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bajajris/N-queen-Problem", "path": "/N-Queen Iterative.py", "msgidx": 11781}}
{"problem_description": "Given a graph of characters where each node is connected to other nodes, and a target word, determine if it is possible to form the target word by traversing the graph such that all nodes are visited at least once. The traversal cannot skip any node. What is the result of this traversal for a given graph and target word?", "io_requirements": "Input:\n  `graph_structure` (str): A JSON string representing the graph structure. The keys are the node values, and the values are lists of node values that the key node is connected to.\n  `target_word` (str): A string representing the target word to be formed by traversing the graph.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the target word can be formed by traversing the graph using all nodes at least once.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, value, nodes):\n        self.value = value\n        self.nodes = nodes\n\ndef dfs(node, word, index, nodes_list, total_nodes):\n    if index == len(word):\n        return len(nodes_list) == total_nodes\n\n    if node.value == word[index]:\n        if node not in nodes_list:\n            nodes_list.add(node)\n\n    for n in node.nodes:\n        if dfs(n, word, index + 1, nodes_list, total_nodes):\n            return True\n\n    return False\n\n# main function\ndef main_solution(graph_structure, target_word):\n    # Convert JSON serializable inputs to original input variables\n    nodes_dict = json.loads(graph_structure)\n    nodes = {}\n    for key, value in nodes_dict.items():\n        nodes[key] = Node(key, [])\n    for key, value in nodes_dict.items():\n        for node in value:\n            nodes[key].nodes.append(nodes[node])\n\n    # Perform the main logic\n    total_nodes = len(nodes)\n    nodes_list = set()\n    result = dfs(nodes[target_word[0]], target_word, 0, nodes_list, total_nodes)\n\n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"graph_structure": "{\"a\": [\"a\"], \"b\": [\"a\"], \"c\": [\"c\"]}", "target_word": "bca"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"a\", \"c\"], \"b\": [\"b\"], \"c\": [\"c\"]}", "target_word": "ca"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"a\"], \"b\": [\"c\"], \"c\": [\"a\"]}", "target_word": "ca"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"a\", \"c\"], \"b\": [\"c\"], \"c\": [\"a\", \"c\"]}", "target_word": "cba"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"a\", \"d\", \"b\"], \"b\": [\"a\"], \"c\": [\"d\", \"c\"], \"d\": [\"a\", \"c\", \"d\"]}", "target_word": "ca"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"d\"], \"b\": [\"c\", \"d\", \"b\"], \"c\": [\"e\", \"a\"], \"d\": [\"c\", \"a\", \"b\", \"e\"], \"e\": [\"e\"]}", "target_word": "ce"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"e\"], \"b\": [\"a\", \"e\", \"b\"], \"c\": [\"e\", \"a\"], \"d\": [\"c\", \"e\", \"a\"], \"e\": [\"d\", \"c\"]}", "target_word": "edbca"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"b\", \"c\"], \"b\": [\"a\", \"c\"], \"c\": [\"c\", \"b\"]}", "target_word": "acb"}, "output": true}, {"input": {"graph_structure": "{\"a\": [\"c\", \"b\"], \"b\": [\"b\", \"a\"], \"c\": [\"c\", \"b\"]}", "target_word": "ab"}, "output": false}, {"input": {"graph_structure": "{\"a\": [\"d\"], \"b\": [\"c\", \"d\", \"b\", \"e\"], \"c\": [\"e\", \"a\", \"d\"], \"d\": [\"e\", \"b\"], \"e\": [\"c\", \"e\"]}", "target_word": "eab"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tikalestari/haberdashery", "path": "/Trees/WordGraph.py", "msgidx": 11843}}
{"problem_description": "In a small village, there is a family tree that needs to be validated. The relationships between family members are provided in a list where each entry represents a father-son relationship. Given the list of relationships, can you determine if the relationships form a valid family tree?", "io_requirements": "Input:\n  `tree` (list of lists): A list of lists where each inner list contains exactly two strings representing a father-son relationship. For example, `[[\"Logan\", \"Mike\"], [\"Logan\", \"Jack\"]]`.\n\nOutput:\n  `return` (str): A JSON-encoded string representing a boolean value (`true` or `false`) indicating whether the given relationships form a valid family tree.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef is_family(tree):\n    fathers = [i[0] for i in tree]\n    sons = [i[1] for i in tree]\n    if len(sons) > len(set(sons)):\n        return False\n    if len(set(fathers) - set(sons)) != 1:\n        return False\n    family = {i[1]: i[0] for i in tree}\n    for key, value in family.items():\n        if key == value:\n            return False\n        if value in family.keys():\n            if family[value] == key:\n                return False\n    return True\n\n# main function\ndef main_solution(tree):\n    # Convert the input list of lists to a list of tuples\n    tree = [tuple(pair) for pair in tree]\n    \n    # Call the is_family function\n    result = is_family(tree)\n    \n    # Return the result as a JSON serializable output\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"tree": [["PsXzg", "gboUh"]]}, "output": "true"}, {"input": {"tree": [["bEFLT", "JKKFE"], ["snLTu", "sQYJn"]]}, "output": "false"}, {"input": {"tree": [["fKWUI", "PSaYI"]]}, "output": "true"}, {"input": {"tree": [["BcUyd", "ZKGMN"], ["cYCcA", "QBJyc"], ["QESmT", "YYwnW"]]}, "output": "false"}, {"input": {"tree": [["CCGWr", "hQVoR"], ["LAQXY", "fKyGg"], ["ftODV", "ebUsW"]]}, "output": "false"}, {"input": {"tree": [["uxSUj", "iQjqF"], ["OvEbQ", "oHUrz"]]}, "output": "false"}, {"input": {"tree": [["QYPHd", "eGqFx"], ["iQIOV", "oSbkV"]]}, "output": "false"}, {"input": {"tree": [["lBLnR", "bjkQS"], ["shJqn", "ZvCJz"]]}, "output": "false"}, {"input": {"tree": [["sxnBP", "WyZjK"], ["nSlcy", "lFPSI"]]}, "output": "false"}, {"input": {"tree": [["hFEaK", "IRdda"], ["HbgXo", "OShPg"]]}, "output": "false"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "YxiangJ/Python", "path": "/Checkiolearn/Scientific Expedition/wrong_family.py", "msgidx": 12519}}
{"problem_description": "In a game of marbles, players take turns placing marbles in a circle. Each turn, a player either places a marble in the circle or, if the marble number is a multiple of 23, scores points. Given the number of players and the value of the last marble, what is the highest score achieved by any player?", "io_requirements": "Input:\n  `n_players` (int): The number of players participating in the game.\n  `last_marble` (int): The value of the last marble in the game.\n\nOutput:\n  `return` (int): The highest score achieved by any player in the game.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(n_players, last_marble):\n    # Convert inputs to appropriate types if necessary\n    n_players = int(n_players)\n    last_marble = int(last_marble)\n\n    # game container\n    circle = deque([0])\n    # initialise score tracker\n    scores = [0 for _ in range(n_players)]\n\n    # iterate through the marbles available\n    for i in range(1, last_marble * 100 + 1):\n        player = i % n_players\n\n        if i % 23 != 0:\n            circle.rotate(-1)\n            circle.append(i)\n        else:\n            circle.rotate(7)\n            # update player score\n            scores[player] += (i + circle.pop())\n            circle.rotate(-1)\n\n    # return the highest score, which is JSON serializable\n    return max(scores)", "funcname": "main_solution", "ios": [{"input": {"n_players": 88, "last_marble": 980}, "output": 3266336}, {"input": {"n_players": 75, "last_marble": 919}, "output": 3288584}, {"input": {"n_players": 74, "last_marble": 291}, "output": 377100}, {"input": {"n_players": 21, "last_marble": 705}, "output": 6809544}, {"input": {"n_players": 3, "last_marble": 409}, "output": 15907421}, {"input": {"n_players": 72, "last_marble": 805}, "output": 2631978}, {"input": {"n_players": 24, "last_marble": 814}, "output": 7946534}, {"input": {"n_players": 84, "last_marble": 201}, "output": 155568}, {"input": {"n_players": 3, "last_marble": 29}, "output": 81862}, {"input": {"n_players": 17, "last_marble": 737}, "output": 9175267}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MatejBabis/AdventOfCode2k18", "path": "/day9/part2.py", "msgidx": 12262}}
{"problem_description": "Given a positive integer `n`, a prime ring is a circular arrangement of the numbers from 1 to `n` such that the sum of each pair of adjacent numbers is a prime number. What are the possible configurations of the prime ring for the given `n`?", "io_requirements": "Input:\n  `n` (int): An integer representing the size of the prime ring. The value should be greater than 1.\n\nOutput:\n  `return` (list of lists of int): A list of lists where each sublist represents a valid prime ring configuration. Each sublist contains integers from 1 to `n` arranged in such a way that the sum of each pair of adjacent numbers is a prime number.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef primenumbers(n):\n    n = int(n)\n    if n < 2:\n        return []\n    elif n == 2:\n        return [2]\n\n    ps = [2]; k = 3\n    while k <= n:\n        sqrtk = math.sqrt(k)\n        for p in ps:\n            if p > sqrtk:\n                ps.append(k)\n                break\n\n            if not k % p:\n                break\n        k += 2\n\n    return ps\n\ndef ifront(i, l):\n    r = list(l)\n    r.insert(0, i)\n    return r\n\ndef prime_list(s, e, l, primes):\n    if len(l) == 0:\n        return []\n    elif len(l) == 1:\n        if s + l[0] in primes and e + l[0] in primes:\n            return [l]\n        else:\n            return []\n\n    ll = []\n    for i in l:\n        llt = []\n        if s + i in primes:\n            lt = list(l)\n            lt.remove(i)\n            llt = prime_list(i, e, lt, primes)\n            llt = [ifront(i, a) for a in llt]\n        ll.extend(llt)\n    return ll\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = int(n)\n    primes = primenumbers(2 * n)  # generate prime numbers\n\n    ll = prime_list(1, 1, list(range(2, n + 1)), primes)\n    ll = [ifront(1, l) for l in ll]\n\n    # Convert the result to a JSON serializable format\n    result = [list(map(int, sublist)) for sublist in ll]\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": []}, {"input": {"n": 9}, "output": []}, {"input": {"n": 5}, "output": []}, {"input": {"n": 8}, "output": [[1, 2, 3, 8, 5, 6, 7, 4], [1, 2, 5, 8, 3, 4, 7, 6], [1, 4, 7, 6, 5, 8, 3, 2], [1, 6, 7, 4, 3, 8, 5, 2]]}, {"input": {"n": 2}, "output": [[1, 2]]}, {"input": {"n": 7}, "output": []}, {"input": {"n": 4}, "output": [[1, 2, 3, 4], [1, 4, 3, 2]]}, {"input": {"n": 6}, "output": [[1, 4, 3, 2, 5, 6], [1, 6, 5, 2, 3, 4]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jinsook/eclipseworkspace", "path": "/YunsPython/prime_ring_s.py", "msgidx": 12401}}
{"problem_description": "In a game of blackjack, a player and a dealer are each dealt two cards from a shuffled deck. The player can choose to \"hit\" (draw another card) or \"stand\" (keep their current hand) based on their hand's value. The dealer must hit until their hand's value is at least 17. The goal is to get as close to 21 as possible without going over. Given the initial hands of the player and the dealer, and the number of decks used in the game, what is the final outcome of the game for the player?", "io_requirements": "Input:\n  `num_decks` (int): The number of decks used in the game.\n  `player_hand` (list): The initial hand of the player, containing strings representing cards.\n  `dealer_hand` (list): The initial hand of the dealer, containing strings representing cards.\n\nOutput:\n  `return` (dict): A dictionary containing the final values of the player's and dealer's hands and the result of the game.\n    - `player_value` (int): The final value of the player's hand.\n    - `dealer_value` (int): The final value of the dealer's hand.\n    - `result` (int): The outcome of the game (1: win, -1: lose, 0: tie).", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef draw_cards(deck, n):\n    '''\n    Draws n cards from deck. \n    \n    Output:\n        hand: the n cards that were draw.\n        deck: what remains of the deck after the draw.\n    '''\n    hand = deck[:n]\n    deck = deck[n:]\n    return hand, deck\n\ndef hand_sum(hand):\n    '''\n    Computes the value of an blackjack hand.\n    If the hand has an ace it will return the highes value of the hand.\n    \n    Parameters\n    ----------\n    hand : list\n        A blackjack hand.\n\n    Returns\n    -------\n    total : int\n        The value of hand in a blackjack game.\n\n    '''\n    total = 0\n    total_ace = 0\n    for card in hand:\n        if card == \"A\":\n            total_ace += 1\n        elif card.isnumeric():\n            total += int(card)\n        else:\n            total += 10\n    total += total_ace\n    if total_ace > 0:\n        if total + 10 <= 21:\n            total += 10        \n    return total\n\ndef dealer(dealer_hand):\n    '''\n    This mimics the dealer behaviour in a blackjack game.\n\n    Parameters\n    ----------\n    dealer_hand : list\n        The cards that the dealer has.\n\n    Returns\n    -------\n    bool\n        If the dealer Hits or Stops the game.\n\n    '''\n    dealer_value = hand_sum(dealer_hand)\n    \n    while (dealer_value < 17):\n        return True\n    return False\n\n# main function\ndef main_solution(num_decks, player_hand, dealer_hand):\n    '''\n    Simulates a blackjack game and determines the outcome for the player.\n\n    Parameters\n    ----------\n    num_decks : int\n        The number of decks used in the game.\n    player_hand : list\n        The initial hand of the player.\n    dealer_hand : list\n        The initial hand of the dealer.\n\n    Returns\n    -------\n    dict\n        A dictionary with the result of the game.\n        Keys:\n            'player_value': int, the final value of the player's hand.\n            'dealer_value': int, the final value of the dealer's hand.\n            'result': int, the outcome of the game (1: win, -1: lose, 0: tie).\n    '''\n    cards = ['A','2','3','4','5','6','7','8','9','10','J','Q','K']\n    deck = np.array(cards * 4 * num_decks)\n    np.random.shuffle(deck)\n    \n    known_cards = np.append(player_hand, dealer_hand[0])\n    \n    player_value = hand_sum(player_hand)\n    dealer_value = hand_sum(dealer_hand)\n    \n    # Player turn (simplified to always hit if below 17)\n    while player_value < 17:\n        card, deck = draw_cards(deck, 1)\n        player_hand = np.append(player_hand, card)\n        player_value = hand_sum(player_hand)\n        if player_value > 21:\n            return {'player_value': player_value, 'dealer_value': dealer_value, 'result': -1}\n        known_cards = np.append(known_cards, card)\n    \n    # Dealer turn\n    while dealer(dealer_hand):\n        card, deck = draw_cards(deck, 1)\n        dealer_hand = np.append(dealer_hand, card)\n        dealer_value = hand_sum(dealer_hand)\n        if dealer_value > 21:\n            return {'player_value': player_value, 'dealer_value': dealer_value, 'result': 1}\n    \n    player_value = hand_sum(player_hand)\n    dealer_value = hand_sum(dealer_hand)\n    \n    if player_value > dealer_value:\n        return {'player_value': player_value, 'dealer_value': dealer_value, 'result': 1}\n    elif player_value == dealer_value:\n        return {'player_value': player_value, 'dealer_value': dealer_value, 'result': 0}\n    else:\n        return {'player_value': player_value, 'dealer_value': dealer_value, 'result': -1}", "funcname": "main_solution", "ios": [{"input": {"num_decks": 9, "player_hand": ["10", "4"], "dealer_hand": ["K", "4"]}, "output": {"player_value": 17, "dealer_value": 23, "result": 1}}, {"input": {"num_decks": 1, "player_hand": ["Q", "9"], "dealer_hand": ["4", "Q"]}, "output": {"player_value": 19, "dealer_value": 18, "result": 1}}, {"input": {"num_decks": 9, "player_hand": ["9", "6"], "dealer_hand": ["8", "9"]}, "output": {"player_value": 25, "dealer_value": 17, "result": -1}}, {"input": {"num_decks": 9, "player_hand": ["A", "2"], "dealer_hand": ["6", "A"]}, "output": {"player_value": 19, "dealer_value": 17, "result": 1}}, {"input": {"num_decks": 1, "player_hand": ["J", "3"], "dealer_hand": ["3", "6"]}, "output": {"player_value": 22, "dealer_value": 9, "result": -1}}, {"input": {"num_decks": 3, "player_hand": ["5", "5"], "dealer_hand": ["5", "J"]}, "output": {"player_value": 20, "dealer_value": 18, "result": 1}}, {"input": {"num_decks": 9, "player_hand": ["Q", "A"], "dealer_hand": ["7", "J"]}, "output": {"player_value": 21, "dealer_value": 17, "result": 1}}, {"input": {"num_decks": 8, "player_hand": ["8", "A"], "dealer_hand": ["5", "7"]}, "output": {"player_value": 19, "dealer_value": 19, "result": 0}}, {"input": {"num_decks": 6, "player_hand": ["A", "6"], "dealer_hand": ["A", "7"]}, "output": {"player_value": 17, "dealer_value": 18, "result": -1}}, {"input": {"num_decks": 6, "player_hand": ["K", "9"], "dealer_hand": ["3", "Q"]}, "output": {"player_value": 19, "dealer_value": 17, "result": 1}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hmosousa/blackjack", "path": "/blackjack.py", "msgidx": 11395}}
{"problem_description": "In an ancestral tree where each individual is represented by a letter from 'A' to 'I', and each individual has a property pointing to their youngest ancestor, what is the name of the youngest common ancestor for two given descendants?", "io_requirements": "Input:\n  `top_ancestor_name` (str): The name of the top ancestor in the ancestral tree.\n  `descendant_one_name` (str): The name of the first descendant in the ancestral tree.\n  `descendant_two_name` (str): The name of the second descendant in the ancestral tree.\n\nOutput:\n  `return` (str): The name of the youngest common ancestor of the two descendants.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass AncestralTree:\n    def __init__(self, name):\n        self.name = name\n        self.ancestor = None\n\n    def addsAnAncestor(self, descendants):\n        for descendant in descendants:\n            descendant.ancestor = self\n\ndef getYoungestCommonAncestor(topAncestor, descendant_one, descendant_two):\n    depth_one = get_descendent_depth(descendant_one)\n    depth_two = get_descendent_depth(descendant_two)\n    if depth_one > depth_two:\n        return backtrack_ancestral(descendant_one, descendant_two, depth_one - depth_two)\n    else:\n        return backtrack_ancestral(descendant_two, descendant_one, depth_two - depth_one)\n\ndef get_descendent_depth(node):\n    depth = 0\n    while node:\n        node = node.ancestor\n        depth += 1\n    return depth\n\ndef backtrack_ancestral(one, two, depth_diff):\n    for i in range(depth_diff):\n        one = one.ancestor\n    while one != two:\n        one = one.ancestor\n        two = two.ancestor\n    return one\n\n# main function\ndef main_solution(top_ancestor_name, descendant_one_name, descendant_two_name):\n    # Convert JSON serializable inputs to original input variables\n    ancestralTrees = {}\n    LETTERS = list('ABCDEFGHI')\n    for letter in LETTERS:\n        ancestralTrees[letter] = AncestralTree(letter)\n\n    ancestralTrees['A'].addsAnAncestor([\n        ancestralTrees['B'],\n        ancestralTrees['C']\n    ])\n    ancestralTrees['B'].addsAnAncestor([\n        ancestralTrees['D'],\n        ancestralTrees['E'],\n    ])\n    ancestralTrees['C'].addsAnAncestor([\n        ancestralTrees['F'],\n        ancestralTrees['G'],\n    ])\n    ancestralTrees['D'].addsAnAncestor([\n        ancestralTrees['H'],\n        ancestralTrees['I'],\n    ])\n\n    topAncestor = ancestralTrees[top_ancestor_name]\n    descendant_one = ancestralTrees[descendant_one_name]\n    descendant_two = ancestralTrees[descendant_two_name]\n\n    # Get the youngest common ancestor\n    common_ancestor = getYoungestCommonAncestor(topAncestor, descendant_one, descendant_two)\n\n    # Convert the result to JSON serializable output\n    return common_ancestor.name", "funcname": "main_solution", "ios": [{"input": {"top_ancestor_name": "F", "descendant_one_name": "D", "descendant_two_name": "E"}, "output": "B"}, {"input": {"top_ancestor_name": "H", "descendant_one_name": "E", "descendant_two_name": "D"}, "output": "B"}, {"input": {"top_ancestor_name": "I", "descendant_one_name": "E", "descendant_two_name": "B"}, "output": "B"}, {"input": {"top_ancestor_name": "E", "descendant_one_name": "A", "descendant_two_name": "G"}, "output": "A"}, {"input": {"top_ancestor_name": "A", "descendant_one_name": "A", "descendant_two_name": "D"}, "output": "A"}, {"input": {"top_ancestor_name": "D", "descendant_one_name": "D", "descendant_two_name": "G"}, "output": "A"}, {"input": {"top_ancestor_name": "E", "descendant_one_name": "I", "descendant_two_name": "E"}, "output": "B"}, {"input": {"top_ancestor_name": "F", "descendant_one_name": "F", "descendant_two_name": "G"}, "output": "C"}, {"input": {"top_ancestor_name": "D", "descendant_one_name": "I", "descendant_two_name": "H"}, "output": "D"}, {"input": {"top_ancestor_name": "C", "descendant_one_name": "B", "descendant_two_name": "H"}, "output": "B"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BarthJr/tech-code-interview", "path": "/youngest_common_ancestor_v2.py", "msgidx": 12429}}
{"problem_description": "In a game of Tic-Tac-Toe, given a specific board configuration and the current player's turn, determine if 'x' has a winning strategy. The board is represented by a string of 9 characters, where each character can be '.', 'x', or 'o'. The current player's turn is indicated by a single character, either 'x' or 'o'. What is the result indicating whether 'x' can win?", "io_requirements": "Input:\n  `board_state` (str): A string representing the current state of the Tic-Tac-Toe board. The string should be exactly 9 characters long, with each character being one of '.', 'x', or 'o'. The board is indexed as follows:\n  ```\n  6 7 8\n  3 4 5\n  0 1 2\n  ```\n  `current_player` (str): A string representing the current player's turn. The string should be exactly 1 character long, either 'x' or 'o'.\n\nOutput:\n  `return` (dict): A dictionary with a single key `can_win` (bool), indicating whether 'x' can win the game given the current board state and player's turn.", "refcode": "# import necessary packages\nimport numpy as np\nimport copy\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\nPTS = '.xo'\nEMPTY, BLACK, WHITE = 0, 1, 2\nECH, BCH, WCH = PTS[EMPTY], PTS[BLACK], PTS[WHITE]\n\ndef x_wins(s):\n  return (s[0]=='x') and (s[1]=='x') and (s[2]=='x') or \\\n         (s[3]=='x') and (s[4]=='x') and (s[5]=='x') or \\\n         (s[6]=='x') and (s[7]=='x') and (s[8]=='x') or \\\n         (s[0]=='x') and (s[3]=='x') and (s[6]=='x') or \\\n         (s[1]=='x') and (s[4]=='x') and (s[7]=='x') or \\\n         (s[2]=='x') and (s[5]=='x') and (s[8]=='x') or \\\n         (s[0]=='x') and (s[4]=='x') and (s[8]=='x') or \\\n         (s[2]=='x') and (s[4]=='x') and (s[6]=='x') \n\ndef x_can_win(s, ptm):\n  if x_wins(s):\n    return True\n  blanks = []\n  for j in range(9):\n    if s[j]==ECH: blanks.append(j)\n  if len(blanks)==0:\n    return False\n  if ptm == BCH:\n    for k in blanks:\n      t = change_str(s, k, BCH)\n      if x_can_win(t, WCH):\n        return True\n    return False\n  # ptm == WCH\n  for k in blanks:\n    t = change_str(s, k, WCH)\n    if not x_can_win(t, BCH):\n      return False\n  return True\n\ndef oppCH(ch): \n  if ch== BCH: return WCH\n  elif ch== WCH: return BCH\n  else: assert(False)\n\ndef change_str(s, where, what):\n  return s[:where] + what + s[where+1:]\n\n# main function\ndef main_solution(board_state, current_player):\n  # Convert JSON serializable input to original input variables\n  board_state = board_state.replace(' ', '')  # Ensure no spaces in the board state string\n  current_player = current_player.replace(' ', '')  # Ensure no spaces in the current player string\n\n  # Check if 'x' can win given the current board state and player's turn\n  can_win = x_can_win(board_state, current_player)\n\n  # Return the result as a JSON serializable output\n  return {\"can_win\": can_win}", "funcname": "main_solution", "ios": [{"input": {"board_state": "xo.oo..xx", "current_player": "o"}, "output": {"can_win": false}}, {"input": {"board_state": "xx.ooxx..", "current_player": "o"}, "output": {"can_win": false}}, {"input": {"board_state": "o.o.xoxxx", "current_player": "x"}, "output": {"can_win": true}}, {"input": {"board_state": "xxo.oooo.", "current_player": "o"}, "output": {"can_win": false}}, {"input": {"board_state": "oxxoo..o.", "current_player": "x"}, "output": {"can_win": false}}, {"input": {"board_state": "xxxx.xo.o", "current_player": "x"}, "output": {"can_win": true}}, {"input": {"board_state": "..o.xxx.x", "current_player": "x"}, "output": {"can_win": true}}, {"input": {"board_state": "xooxox.x.", "current_player": "x"}, "output": {"can_win": true}}, {"input": {"board_state": "o..x.o...", "current_player": "o"}, "output": {"can_win": false}}, {"input": {"board_state": "o..xoxxoo", "current_player": "x"}, "output": {"can_win": false}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BedirT/games-puzzles-algorithms", "path": "/simple/ttt/ttt_mod.py", "msgidx": 12228}}
{"problem_description": "Given a set of six 4-digit numbers, each representing a different type of figurate number (triangle, square, pentagonal, hexagonal, heptagonal, and octagonal), find the sum of the numbers in the only ordered set that forms a cyclic sequence where the last two digits of each number are the first two digits of the next number (including the last number with the first). The problem requires that the starting number's first two digits are provided. What is the sum of the numbers in this cyclic set?", "io_requirements": "Input:\n  `start_number` (str): A string representing the first two digits of the starting octagonal number. The string should be exactly two characters long and consist of digits (e.g., \"12\", \"34\").\n\nOutput:\n  `return` (int or None): An integer representing the sum of the six cyclic 4-digit numbers if a valid set is found. If no valid set is found, it returns `None`.", "refcode": "# import necessary packages\nimport time\nfrom itertools import combinations, permutations\n\n# all class and function definitions in the code file, if any\ndef is_triangle_number(num):\n    return ((-1 + (1 + 8*num) ** 0.5)/2).is_integer()\n\ndef is_square_number(num):\n    return (num ** 0.5).is_integer()\n\ndef is_pentagonal_number(num):\n    return ((1 + (1 + 24*num) ** 0.5)/6).is_integer()\n\ndef is_hexagonal_number(num):\n    return ((1 + (1 + 8*num) ** 0.5)/4).is_integer()\n\ndef is_heptagonal_number(num):\n    return ((3 + (9 + 40*num) ** 0.5)/10).is_integer()\n\ndef is_octagonal_number(num):\n    return ((1 + (1 + 3*num) ** 0.5)/3).is_integer()\n\ndef start_with_designated_digits(num, first_two_digits):\n    return str(num)[:2] == first_two_digits\n\n# main function\ndef main_solution(start_number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    octagonal_numbers = [num for num in range(1000, 10000) if is_octagonal_number(num)]\n    heptagonal_numbers = [num for num in range(1000, 10000) if is_heptagonal_number(num)]\n    hexagonal_numbers = [num for num in range(1000, 10000) if is_hexagonal_number(num)]\n    pentagonal_numbers = [num for num in range(1000, 10000) if is_pentagonal_number(num)]\n    square_numbers = [num for num in range(1000, 10000) if is_square_number(num)]\n    triangle_numbers = [num for num in range(1000, 10000) if is_triangle_number(num)]\n    figurate_numbers_dict = {\n        (index+3): figurate_numbers for index, figurate_numbers in enumerate([triangle_numbers, square_numbers, pentagonal_numbers, hexagonal_numbers, heptagonal_numbers])\n    }\n    figurate_numbers_first_two_digits = {\n        key: set([str(num)[:2] for num in value]) for key, value in figurate_numbers_dict.items()\n    }\n\n    answer_dict = {}\n    current_last_two_digit = None\n    answer_flag = False\n    found_flag = False\n    \n    for octagonal_number in octagonal_numbers:\n        if str(octagonal_number)[:2] != start_number:\n            continue\n        for order in permutations([3, 4, 5, 6, 7]):\n            answer_dict = {8: octagonal_number}\n            current_last_two_digit = str(octagonal_number)[2:]\n            for index, figurate_number in enumerate(order):\n                if current_last_two_digit not in figurate_numbers_first_two_digits[figurate_number]:\n                    break\n                else:\n                    found_flag = False\n                    for number in [num for num in figurate_numbers_dict[figurate_number] if start_with_designated_digits(num, current_last_two_digit)]:\n                        if index == 4:\n                            if start_with_designated_digits(number, current_last_two_digit) and start_with_designated_digits(octagonal_number, str(number)[2:]):\n                                answer_dict[figurate_number] = number\n                                answer_flag = True\n                                break\n                        else:\n                            if str(number)[2:] in figurate_numbers_first_two_digits[order[index+1]]:\n                                answer_dict[figurate_number] = number\n                                current_last_two_digit = str(number)[2:]\n                                found_flag = True\n                                break\n                    if found_flag == False:\n                        break\n                if answer_flag == True:\n                    break\n            if answer_flag == True:\n                break\n        if answer_flag == True:\n            break\n\n    if answer_flag:\n        return sum(answer_dict.values())\n    else:\n        return None", "funcname": "main_solution", "ios": [{"input": {"start_number": "12"}, "output": 28684}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Kazzle619/Project_Euler", "path": "/project_euler_61.py", "msgidx": 10977}}
{"problem_description": "Imagine you are conducting an experiment to determine the highest floor of a building from which an egg can be dropped without breaking. You have a certain number of eggs available for this experiment. Given the number of eggs and the number of floors in the building, what is the minimum number of drops required in the worst case scenario to determine the highest floor?", "io_requirements": "Input:\n  `number_egg` (int): The number of eggs available for the experiment.\n  `number_floors` (int): The number of floors in the building.\n\nOutput:\n  `return` (dict): A dictionary containing the key `min_drops` with the value being the minimum number of drops required in the worst case to determine the highest floor from which an egg can be dropped without breaking.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(number_egg, number_floors):\n    # Convert input variables if necessary\n    number_egg = int(number_egg)\n    number_floors = int(number_floors)\n    \n    # Function to calculate the minimum number of drops needed in the worst case\n    def eggs(number_egg, number_floors):\n        if (number_egg == 1 or number_egg == 0):\n            return number_floors if number_egg == 1 else 0\n        \n        optimal = [[0 for _ in range(number_floors + 1)] for _ in range(number_egg + 1)]\n        \n        for i in range(1, number_egg + 1):\n            optimal[i][1] = 1\n            optimal[i][0] = 0\n \n        for j in range(1, number_floors + 1):\n            optimal[1][j] = j\n \n        for i in range(2, number_egg + 1):\n            for j in range(2, number_floors + 1):\n                optimal[i][j] = 10000\n                for x in range(1, j + 1):\n                    res = 1 + max(optimal[i-1][x-1], optimal[i][j-x])\n                    if res < optimal[i][j]:\n                        optimal[i][j] = res\n \n        return optimal[number_egg][number_floors]\n    \n    # Calculate the result\n    result = eggs(number_egg, number_floors)\n    \n    # Convert the result to a JSON serializable output\n    return {\"min_drops\": result}", "funcname": "main_solution", "ios": [{"input": {"number_egg": 6, "number_floors": 830}, "output": {"min_drops": 10}}, {"input": {"number_egg": 8, "number_floors": 616}, "output": {"min_drops": 10}}, {"input": {"number_egg": 5, "number_floors": 978}, "output": {"min_drops": 11}}, {"input": {"number_egg": 1, "number_floors": 604}, "output": {"min_drops": 604}}, {"input": {"number_egg": 0, "number_floors": 885}, "output": {"min_drops": 0}}, {"input": {"number_egg": 5, "number_floors": 436}, "output": {"min_drops": 10}}, {"input": {"number_egg": 4, "number_floors": 512}, "output": {"min_drops": 11}}, {"input": {"number_egg": 3, "number_floors": 124}, "output": {"min_drops": 9}}, {"input": {"number_egg": 9, "number_floors": 459}, "output": {"min_drops": 9}}, {"input": {"number_egg": 8, "number_floors": 856}, "output": {"min_drops": 10}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "alinsson/metrobi", "path": "/5_eggs.py", "msgidx": 12098}}
{"problem_description": "You have two jugs: a large jug with a capacity of `A` gallons and a small jug with a capacity of `B` gallons. Neither of the jugs have markings on them. There is a pump that can be used to fill the jugs with water. How can you get exactly `C` gallons of water in the large jug? Suppose `B <= C <= A` and they are integers. What will be the final volumes of both jugs after attempting to achieve the desired amount of water in the large jug?", "io_requirements": "Input:\n  `A` (int): The size of the large jug in gallons.\n  `B` (int): The size of the small jug in gallons.\n  `C` (int): The desired amount of water in the large jug in gallons.\n\nOutput:\n  `return` (dict): A dictionary containing the final volumes of the large and small jugs.\n    - `large_jar_volume` (int or None): The final volume of the large jug. If the desired volume cannot be achieved, it will be `None`.\n    - `small_jar_volume` (int or None): The final volume of the small jug. If the desired volume cannot be achieved, it will be `None`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Jar:\n    def __init__(self, size, label):\n        self.size = size\n        self.volumn = 0\n        self.label = label\n\n    def fill(self):\n        self.volumn = self.size\n    \n    def pour(self):\n        self.volumn = 0\n\n    def trans(self, toJar):\n        if self.volumn + toJar.volumn >= toJar.size:\n            self.volumn -= (toJar.size - toJar.volumn) \n            toJar.volumn = toJar.size\n        else:\n            toJar.volumn += self.volumn\n            self.volumn = 0\n    \n    def display(self):\n        pass  # Removed display for simplicity\n\ndef jarRC(jarLarge, jarSmall, want):\n    gcd = math.gcd(jarLarge.size, jarSmall.size)\n    if want % gcd != 0:\n        return False\n\n    else:\n        if want == gcd:\n            jarLarge.fill()\n            jarLarge.trans(jarSmall)\n            jarSmall.pour()\n            return jarLarge, jarSmall\n        else:\n            jarLarge, jarSmall = jarRC(jarLarge, jarSmall, want - gcd)\n            jarLarge.trans(jarSmall)\n            jarLarge.fill()\n            jarLarge.trans(jarSmall)\n            jarSmall.pour()\n            return jarLarge, jarSmall\n\n# main function\ndef main_solution(A, B, C):\n    # Convert JSON serializable inputs to original input variables\n    jarLarge = Jar(A, \"large\")\n    jarSmall = Jar(B, \"small\")\n    \n    # Call the original function\n    result = jarRC(jarLarge, jarSmall, C)\n    \n    # Convert the output to JSON serializable format\n    if result:\n        jarLarge, jarSmall = result\n        return {\"large_jar_volume\": jarLarge.volumn, \"small_jar_volume\": jarSmall.volumn}\n    else:\n        return {\"large_jar_volume\": None, \"small_jar_volume\": None}", "funcname": "main_solution", "ios": [{"input": {"A": 2, "B": 1, "C": 1}, "output": {"large_jar_volume": 1, "small_jar_volume": 0}}, {"input": {"A": 4, "B": 4, "C": 4}, "output": {"large_jar_volume": 0, "small_jar_volume": 0}}, {"input": {"A": 9, "B": 3, "C": 5}, "output": {"large_jar_volume": null, "small_jar_volume": null}}, {"input": {"A": 2, "B": 2, "C": 2}, "output": {"large_jar_volume": 0, "small_jar_volume": 0}}, {"input": {"A": 9, "B": 8, "C": 9}, "output": {"large_jar_volume": 9, "small_jar_volume": 0}}, {"input": {"A": 10, "B": 4, "C": 9}, "output": {"large_jar_volume": null, "small_jar_volume": null}}, {"input": {"A": 3, "B": 2, "C": 2}, "output": {"large_jar_volume": 2, "small_jar_volume": 0}}, {"input": {"A": 5, "B": 5, "C": 5}, "output": {"large_jar_volume": 0, "small_jar_volume": 0}}, {"input": {"A": 10, "B": 1, "C": 10}, "output": {"large_jar_volume": 10, "small_jar_volume": 0}}, {"input": {"A": 10, "B": 5, "C": 6}, "output": {"large_jar_volume": null, "small_jar_volume": null}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "weiweiECNU/pythonDataStructure", "path": "/recursion/nonscale_kettle.py", "msgidx": 12259}}
{"problem_description": "Given a range of integers `a` and specific lower bounds for `b` depending on whether `a` is a 1-digit or 2-digit number, what is the sum of all unique products `a * b` such that the concatenated string of `a`, `b`, and the product contains each digit from 1 to 9 exactly once?", "io_requirements": "Input:\n  `a_start` (int): The starting value for the range of `a`.\n  `a_end` (int): The ending value for the range of `a`.\n  `b_low_1digit` (int): The lower bound for `b` when `a` is a 1-digit number.\n  `b_low_2digit` (int): The lower bound for `b` when `a` is a 2-digit number.\n\nOutput:\n  `return` (int): The sum of all unique products that satisfy the pandigital condition.", "refcode": "# import necessary packages\nfrom time import time\n\n# all class and function definitions in the code file, if any\ndef check_pandigital(a, b, prod):\n    temp = str(a) + str(b) + str(prod)\n    digits = set([int(x) for x in temp])\n    if 0 in digits:\n        return False\n    if len(digits) == 9:\n        return True\n    return False\n\n# main function\ndef main_solution(a_start, a_end, b_low_1digit, b_low_2digit):\n    prod_sum = set()\n    for a in range(a_start, a_end + 1):\n        if a < 10:\n            b_low = b_low_1digit\n        else:\n            b_low = b_low_2digit\n\n        for b in range(b_low, 10000 // a):\n            prod = a * b\n            if check_pandigital(a, b, prod):\n                prod_sum.add(prod)\n    return sum(prod_sum)", "funcname": "main_solution", "ios": [{"input": {"a_start": 2, "a_end": 63, "b_low_1digit": 1235, "b_low_2digit": 127}, "output": 45228}, {"input": {"a_start": 8, "a_end": 17, "b_low_1digit": 1234, "b_low_2digit": 123}, "output": 5796}, {"input": {"a_start": 6, "a_end": 66, "b_low_1digit": 1234, "b_low_2digit": 124}, "output": 30424}, {"input": {"a_start": 2, "a_end": 23, "b_low_1digit": 1234, "b_low_2digit": 127}, "output": 25946}, {"input": {"a_start": 4, "a_end": 60, "b_low_1digit": 1235, "b_low_2digit": 128}, "output": 45228}, {"input": {"a_start": 7, "a_end": 81, "b_low_1digit": 1234, "b_low_2digit": 129}, "output": 30424}, {"input": {"a_start": 2, "a_end": 15, "b_low_1digit": 1237, "b_low_2digit": 123}, "output": 20600}, {"input": {"a_start": 2, "a_end": 12, "b_low_1digit": 1235, "b_low_2digit": 127}, "output": 20600}, {"input": {"a_start": 8, "a_end": 81, "b_low_1digit": 1234, "b_low_2digit": 126}, "output": 30424}, {"input": {"a_start": 4, "a_end": 93, "b_low_1digit": 1234, "b_low_2digit": 126}, "output": 45228}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "akshatk16/EulerProject", "path": "/Problem032.py", "msgidx": 12596}}
{"problem_description": "Given the classic n-queens puzzle, where you need to place `n` queens on an `n x n` chessboard such that no two queens can attack each other, what are the distinct configurations of the queens' placements for a randomly chosen board size `n`?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be an integer between 1 and 9 inclusive.\n\nOutput:\n  `return` (List[List[str]]): A list of all distinct solutions to the n-queens puzzle. Each solution is represented as a list of strings, where each string represents a row on the chessboard. 'Q' indicates a queen and '.' indicates an empty space.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def DFS(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p - q not in xy_dif and p + q not in xy_sum: \n                    DFS(queens + [q], xy_dif + [p - q], xy_sum + [p + q])  \n        result = []\n        DFS([], [], [])\n        return [[\".\" * i + \"Q\" + \".\" * (n - i - 1) for i in sol] for sol in result]\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": []}, {"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}, {"input": {"n": 1}, "output": [["Q"]]}, {"input": {"n": 2}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chyidl/leetcode", "path": "/0051-n-queens/n-queens.py", "msgidx": 12321}}
{"problem_description": "In a logic puzzle, five people (Hamming, Knuth, Minsky, Simon, and Wilkes) arrive on different days of the week (Monday to Friday) and have specific roles or buy specific items. Given the constraints of their arrivals and roles/items, what is the order in which they arrive?", "io_requirements": "Input:\n  `days_mapping` (dict): A dictionary mapping days of the week to their respective indices (0-4). The keys are strings representing the days ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday') and the values are integers (0-4).\n\nOutput:\n  `return` (list): A list of strings representing the names of the people in the order they arrive. The names are 'Hamming', 'Knuth', 'Minsky', 'Simon', and 'Wilkes'.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(days_mapping):\n    \"\"\"\n    Solves the logic puzzle and returns the names of the people in the order they arrive.\n    \n    Args:\n    days_mapping (dict): A dictionary mapping days of the week to their respective indices (0-4).\n    \n    Returns:\n    list: A list of names in the order they arrive.\n    \"\"\"\n    # Convert days_mapping to a list of days\n    days = [days_mapping[day] for day in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']]\n    \n    # Generate all possible orderings of the days\n    orderings = list(itertools.permutations(days))\n    \n    # Iterate through all possible orderings of the days\n    for Hamming, Knuth, Minsky, Simon, Wilkes in orderings:\n        # Check if Knuth arrived the day after Simon\n        if Knuth == Simon + 1:\n            # Iterate through all possible orderings of the items bought\n            for droid, laptop, iphone, tablet, _ in orderings:\n                # Check the conditions related to the items bought\n                if laptop == days_mapping['Wednesday'] and tablet != days_mapping['Friday'] and (iphone == days_mapping['Tuesday'] or tablet == days_mapping['Tuesday']):\n                    # Iterate through all possible orderings of the professions\n                    for writer, manager, designer, programmer, _ in orderings:\n                        # Check the conditions related to the professions\n                        if Wilkes != programmer and (Wilkes == programmer or Wilkes == droid) and (Hamming == programmer or Hamming == droid) and Minsky != writer and Knuth != manager and tablet != manager and Knuth == manager + 1 and Simon == manager and designer != days_mapping['Thursday'] and designer != droid and (Wilkes == days_mapping['Monday'] or Wilkes == writer) and (laptop == days_mapping['Monday'] or laptop == writer):\n                            # Map the days to the names\n                            result = {Hamming: \"Hamming\", Knuth: \"Knuth\", Minsky: \"Minsky\", Simon: \"Simon\", Wilkes: \"Wilkes\"}\n                            # Return the names in the order they arrive\n                            return [result[day] for day in days]\n    return None", "funcname": "main_solution", "ios": [{"input": {"days_mapping": {"Thursday": 0, "Friday": 1, "Wednesday": 2, "Tuesday": 3, "Monday": 4}}, "output": ["Wilkes", "Minsky", "Knuth", "Hamming", "Simon"]}, {"input": {"days_mapping": {"Thursday": 0, "Friday": 1, "Wednesday": 2, "Monday": 3, "Tuesday": 4}}, "output": ["Wilkes", "Minsky", "Knuth", "Hamming", "Simon"]}, {"input": {"days_mapping": {"Thursday": 0, "Friday": 1, "Tuesday": 2, "Wednesday": 3, "Monday": 4}}, "output": ["Wilkes", "Simon", "Knuth", "Hamming", "Minsky"]}, {"input": {"days_mapping": {"Monday": 0, "Friday": 1, "Thursday": 2, "Wednesday": 3, "Tuesday": 4}}, "output": ["Wilkes", "Hamming", "Knuth", "Simon", "Minsky"]}, {"input": {"days_mapping": {"Thursday": 0, "Wednesday": 1, "Tuesday": 2, "Monday": 3, "Friday": 4}}, "output": ["Wilkes", "Hamming", "Knuth", "Simon", "Minsky"]}, {"input": {"days_mapping": {"Thursday": 0, "Wednesday": 1, "Friday": 2, "Tuesday": 3, "Monday": 4}}, "output": ["Wilkes", "Hamming", "Knuth", "Simon", "Minsky"]}, {"input": {"days_mapping": {"Monday": 0, "Friday": 1, "Wednesday": 2, "Thursday": 3, "Tuesday": 4}}, "output": ["Wilkes", "Minsky", "Knuth", "Hamming", "Simon"]}, {"input": {"days_mapping": {"Friday": 0, "Monday": 1, "Thursday": 2, "Tuesday": 3, "Wednesday": 4}}, "output": ["Wilkes", "Simon", "Knuth", "Hamming", "Minsky"]}, {"input": {"days_mapping": {"Tuesday": 0, "Wednesday": 1, "Thursday": 2, "Monday": 3, "Friday": 4}}, "output": ["Wilkes", "Simon", "Knuth", "Hamming", "Minsky"]}, {"input": {"days_mapping": {"Friday": 0, "Thursday": 1, "Monday": 2, "Tuesday": 3, "Wednesday": 4}}, "output": ["Wilkes", "Simon", "Knuth", "Hamming", "Minsky"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "frrp/Design-of-computer-programs_Final", "path": "/logic_puzzle.py", "msgidx": 12377}}
{"problem_description": "Given a binary tree, determine whether it is a balanced tree. A balanced tree is defined as a tree in which the heights of the two subtrees of any node never differ by more than one. What is the result of checking if the given binary tree structure is balanced?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each node is represented as a dictionary with keys:\n    - `val` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as another dictionary or None if there is no right child.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is balanced. `True` if the tree is balanced, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef get_height(node):\n    if not node:\n        return 0\n    return max(get_height(node.left), get_height(node.right)) + 1\n\ndef is_balance(node):\n    if not node:\n        return True\n    dis = abs(get_height(node.left) - get_height(node.right))\n    if dis > 1:\n        return False\n    else:\n        return is_balance(node.left) and is_balance(node.right)\n\n# main function\ndef main_solution(tree_structure):\n    # Convert JSON serializable input to TreeNode objects\n    def build_tree(data):\n        if not data:\n            return None\n        root = TreeNode(data['val'])\n        root.left = build_tree(data['left'])\n        root.right = build_tree(data['right'])\n        return root\n    \n    # Build the tree from the input structure\n    root = build_tree(tree_structure)\n    \n    # Check if the tree is balanced\n    balanced = is_balance(root)\n    \n    # Return the result as a JSON serializable output\n    return balanced", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 80, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 89, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 35, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 73, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 78, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 65, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 12, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 9, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 3, "left": null, "right": null}}, "output": true}, {"input": {"tree_structure": {"val": 8, "left": null, "right": null}}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "initiald0824/leetcode-warm-python", "path": "/CC150/\u68c0\u67e5\u4e8c\u53c9\u6811\u662f\u5426\u5e73\u8861.py", "msgidx": 12618}}
{"problem_description": "Given a starting value, what is the smallest number greater than or equal to this value that is a palindrome when represented in decimal, binary, and octal formats?", "io_requirements": "Input:\n  `start_value` (int): The starting value for the search of the smallest number that is a palindrome in decimal, binary, and octal representations. It should be an odd number greater than or equal to 11.\n\nOutput:\n  `return` (int): The smallest number greater than or equal to `start_value` that is a palindrome in decimal, binary, and octal representations.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef reverseString(string):\n    reversedString = ''.join(list(reversed(str(string))))\n    return reversedString\n\n# main function\ndef main_solution(start_value):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    i = start_value\n    while True:\n        if (str(i) == reverseString(i) and str(bin(i)[2:]) == reverseString(bin(i)[2:]) and str(oct(i)[2:]) == reverseString(oct(i)[2:])):\n            # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n            return i\n        i += 2", "funcname": "main_solution", "ios": [{"input": {"start_value": 19}, "output": 585}, {"input": {"start_value": 23}, "output": 585}, {"input": {"start_value": 25}, "output": 585}, {"input": {"start_value": 15}, "output": 585}, {"input": {"start_value": 27}, "output": 585}, {"input": {"start_value": 13}, "output": 585}, {"input": {"start_value": 21}, "output": 585}, {"input": {"start_value": 17}, "output": 585}, {"input": {"start_value": 11}, "output": 585}, {"input": {"start_value": 29}, "output": 585}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sazanami5/MathPuzzle", "path": "/question1/question1.py", "msgidx": 12849}}
{"problem_description": "Given a 2x3 sliding puzzle board, where each tile is numbered from 0 to 5, and 0 represents the empty space, how many moves are required to solve the puzzle by moving the tiles into the configuration [[1, 2, 3], [4, 5, 0]]? If it is impossible to solve the puzzle, what should be returned?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2x3 grid representing the puzzle board. Each element is an integer between 0 and 5, where 0 represents the empty space.\n\nOutput:\n  `return` (int): The minimum number of moves required to solve the puzzle. If the puzzle cannot be solved, it returns -1.", "refcode": "# import necessary packages\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def __init__(self):\n        self.directions = ((1, 0), (-1, 0), (0, 1), (0, -1))\n        \n    def _on_board(self, row, col):\n        return row >= 0 and row < 2 and col >= 0 and col < 3\n    \n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        for i in range(2):\n            for j in range(3):\n                if board[i][j] == 0:\n                    row = i\n                    col = j\n                    break\n        \n        visited = set()\n        t_b = tuple([tuple(r) for r in board])\n        visited.add(t_b)\n        queue = deque([(row, col, board, 0)])\n        \n        while len(queue) > 0:\n            row, col, board, move = queue.popleft()\n            if board == [[1,2,3],[4,5,0]]:\n                return move\n            \n            for d in self.directions:\n                new_row = row + d[0]\n                new_col = col + d[1]\n                \n                if self._on_board(new_row, new_col):\n                    \n                    board[row][col], board[new_row][new_col] = \\\n                    board[new_row][new_col], board[row][col]\n                    \n                    t_n_b = tuple([tuple(r) for r in board])\n                    \n                    if t_n_b not in visited:\n                        visited.add(t_n_b)\n                        queue.append((new_row, new_col, deepcopy(board), move + 1))\n                        \n                    board[row][col], board[new_row][new_col] = \\\n                    board[new_row][new_col], board[row][col]\n                        \n        return -1\n\n# main function\ndef main_solution(board: List[List[int]]) -> int:\n    # Convert input to JSON serializable format\n    solution = Solution()\n    result = solution.slidingPuzzle(board)\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 4, 2], [0, 5, 3]]}, "output": -1}, {"input": {"board": [[2, 0, 3], [4, 5, 1]]}, "output": 12}, {"input": {"board": [[1, 3, 0], [4, 5, 2]]}, "output": -1}, {"input": {"board": [[4, 1, 5], [3, 2, 0]]}, "output": 10}, {"input": {"board": [[2, 5, 1], [0, 3, 4]]}, "output": 18}, {"input": {"board": [[1, 2, 4], [5, 3, 0]]}, "output": 12}, {"input": {"board": [[3, 1, 5], [2, 0, 4]]}, "output": 11}, {"input": {"board": [[1, 2, 3], [0, 5, 4]]}, "output": -1}, {"input": {"board": [[3, 5, 1], [2, 4, 0]]}, "output": -1}, {"input": {"board": [[2, 5, 0], [4, 1, 3]]}, "output": 15}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MartinMa28/Algorithms_review", "path": "/BFS/773_sliding_puzzle.py", "msgidx": 12566}}
{"problem_description": "Given a number, a circular prime is defined as a prime number where all rotations of its digits are also prime numbers. For example, 197 is a circular prime because 197, 971, and 719 are all prime numbers. How many circular primes are there below a certain limit?", "io_requirements": "Input:\n  `limit` (int): The upper limit (exclusive) up to which to search for circular primes.\n\nOutput:\n  `return` (int): The number of circular primes found below the given limit.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef isprime(num: int) -> bool:\n    for i in range(2, int(np.sqrt(num))+1):\n        if num % i == 0:\n            return False\n    return True\n\ndef rotate(num: int) -> set:\n    rot = {num}\n    length = len(str(num))\n    k = 0\n    while k < length:\n        tmp = list(str(num))\n        dig = tmp[0]\n        tmp[:] = tmp[1:]\n        tmp.append(dig)\n        num = ''.join(tmp)\n        rot.add(int(num))\n        k = k + 1\n    return rot\n\n# main function\ndef main_solution(limit: int) -> int:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    tot = 0\n    c_primes = [2]\n    flag = False\n    for i in range(3, limit, 2):\n        if isprime(i):\n            flag = True\n            tmp = set()\n            cps = rotate(i)\n            for x in cps:\n                if isprime(x):\n                    tmp.add(x)\n                else:\n                    flag = False\n                    break\n        if flag:\n            c_primes.extend(list(tmp))\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(set(c_primes))", "funcname": "main_solution", "ios": [{"input": {"limit": 692267}, "output": 55}, {"input": {"limit": 468382}, "output": 55}, {"input": {"limit": 445850}, "output": 55}, {"input": {"limit": 272296}, "output": 55}, {"input": {"limit": 736649}, "output": 55}, {"input": {"limit": 223969}, "output": 55}, {"input": {"limit": 113378}, "output": 43}, {"input": {"limit": 327893}, "output": 55}, {"input": {"limit": 446349}, "output": 55}, {"input": {"limit": 15862}, "output": 38}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AnuragAnalog/project_euler", "path": "/Python/euler035.py", "msgidx": 12376}}
{"problem_description": "Given a target string, a population size, and a mutation rate, how many generations does it take for a genetic algorithm to evolve a population that matches or closely approximates the target string? What is the maximum fitness score achieved during this process, and what is the closest string to the target that was achieved?", "io_requirements": "Input:\n  `target` (str): The target string that the genetic algorithm aims to evolve towards.\n  `populationsize` (int): The size of the population in each generation.\n  `rounds` (int): The number of evolution rounds to run.\n  `mutation_rate` (float): The mutation rate for the genetic algorithm.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `target_acquired` (bool): Indicates whether the target string was acquired.\n    - `generation` (int): The generation number at which the evolution stopped.\n    - `max_fitness` (float): The maximum fitness score achieved during the evolution process.\n    - `closest_target` (str): The closest string to the target that was achieved during the evolution process.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef generate_random_dna(N, target):\n    \"\"\"\n    Function to randomly generate DNA elements\n    DNA elements will be randomly generated from the ASCII characters that are present in the target string\n\n    :param N: number of DNA elements to generate\n    :type N: int\n    :param target: target string to match\n    :type target: str\n    :return: DNA string randomly generated\n    :rtype: str\n    \"\"\"\n    dna_elements = []\n    for i in range(0, len(target)):\n        # ord takes the ASCII number of each character in the target string\n        elem = ord(target[i])\n        dna_elements.append(elem)\n    # randomly generated ASCII characters\n    dna_nums = list(np.random.choice(dna_elements, N))\n    dna = \"\"\n    for elem in dna_nums:\n        # chr converts the ASCII character back into a str\n        dna = dna + chr(int(elem))\n    return dna\n\nclass Evolution(object):\n    \"\"\"\n    Class for Evoloving a population to reach the target string\n\n    Attributes:\n        target  target string you wish to evolve to\n        populationsize  size of population of each generation, default is 100\n        population      population of each generation, will change with evolution\n        fitness         fitness scores of the population\n        mating_pool     mating pool to generate new members of population\n        generation      number to represent the generation you are on\n        target_acquired boolean field, if true then the target was required\n        max_fitness     current maximum fitness score of population\n        target_population   the member of the population that is equal to the target string once evolution is completed\n        closest_target  the current member of hte population that is closest to the target\n    \"\"\"\n    def __init__(self, target, populationsize=100):\n        \"\"\"\n\n        :param target: target string\n        :type target: str\n        :param populationsize: size of initial population and subsequent new generations population, default is 100\n        :type populationsize: int\n        \"\"\"\n        self.target = target\n        self.populationsize = populationsize\n        self.population = []\n        self.fitness = []\n        self.mating_pool = []\n        self.generation = 1\n        self.target_acquired = False\n        self.max_fitness = None\n        self.target_population = None\n        self.closest_target = None\n        # initialize population\n        self.generate_initial_population()\n        # initialize fitness scores\n        self.generate_fitness()\n        # initialize matingpool\n        self.create_mating_pool()\n        # check initial progress\n        self.check_progress()\n\n    def generate_initial_population(self):\n        \"\"\"\n        Function to generate a population sized denoted as size\n        population is of N generated random DNA elements\n        N is the length of the target\n        \"\"\"\n        self.population = []\n        N = len(self.target)\n        for x in range(0, self.populationsize):\n            dna = generate_random_dna(N, self.target)\n            self.population.append(dna)\n\n    def generate_fitness(self):\n        \"\"\"\n        Function to generate the fitness score of each population member\n        fitness score is determined by the number of correctly placed characters in the string\n        \"\"\"\n        self.fitness = []\n        for member in self.population:\n            score = 0\n            for i in range(0, len(self.target)):\n                if member[i] == self.target[i]:\n                    score = score + 1\n            self.fitness.append(score / len(self.target))\n\n    def create_mating_pool(self):\n        \"\"\"\n        Function to generate the mating pool\n        the matingpool will be generated from members of the population\n        a member will be added to the matingpool as determined by their fitness score %\n        for example: if a member has .5 fitness score, it will be added 50 times to the mating pool\n        \"\"\"\n        self.mating_pool = []\n        for i, member in enumerate(self.population):\n            score = self.fitness[i]\n            n = int(np.rint(score * 100))\n            for j in range(0, n):\n                self.mating_pool.append(member)\n\n    def reproduction(self):\n        \"\"\"\n            Function to pick two parents from the mating pool and combine them for the new generation\n            2 parents are picked randomly\n            The two parents will make 2 babies.\n            The first will be the \"best\" parts from parentA and the rest from parentB\n            the second will be the \"best\" parts from parentB and the rest from parentA\n            \"\"\"\n\n        self.population = []\n        for x in range(0, int(self.populationsize/2)):\n            parentA = np.random.choice(self.mating_pool)\n            other_parents = [member for member in self.mating_pool if member != parentA]\n            parentB = np.random.choice(other_parents)\n            babyA = \"\"\n            babyB = \"\"\n            for i in range(0, len(self.target)):\n                if parentA[i] == self.target[i]:\n                    babyA = babyA + parentA[i]\n                else:\n                    babyA = babyA + parentB[i]\n                if parentB[i] == self.target[i]:\n                    babyB = babyB + parentB[i]\n                else:\n                    babyB = babyB + parentA[i]\n            self.population.append(babyA)\n            self.population.append(babyB)\n\n    def mutation(self, mutation_rate=0.01):\n        \"\"\"\n        Function to mutate childs DNA\n        This will allow more diversity in the new generation\n        mutation rate is set at 0.01, but can be changed when calling evolution.evolution_rounds\n        if mutating then the dna character will be randomly exchanged for one that is within the ASCII codes of the\n        target str\n\n        :param mutation_rate: rate to mutate\n        :type mutation_rate: float\n        \"\"\"\n        new_population = []\n        for member in self.population:\n            dna_out = \"\"\n            for i in range(0, len(member)):\n                mutation = np.random.choice(['mutate', 'no_mutate'], p=[mutation_rate, 1 - mutation_rate])\n                if mutation == 'mutate':\n                    dna_out = dna_out + generate_random_dna(1, self.target)\n                else:\n                    dna_out = dna_out + member[i]\n            new_population.append(dna_out)\n        self.population = new_population\n\n    def check_progress(self):\n        \"\"\"\n        Function to check progress of evolution\n        can check max_fitness to check the highest fitness score\n        closet_target will be the member of the population that has the highest score\n\n        \"\"\"\n        self.max_fitness = max(self.fitness)\n        index = self.fitness.index(self.max_fitness)\n        self.closest_target = self.population[index]\n        if self.max_fitness == 1.0:\n            self.target_acquired = True\n            self.target_population = self.closest_target\n\n    def new_generation(self, mutation_rate=0.01):\n        \"\"\"\n        Function to create a new generation\n\n        \"\"\"\n        self.reproduction()\n        self.mutation(mutation_rate)\n        self.generate_fitness()\n        self.check_progress()\n        self.create_mating_pool()\n        self.generation = self.generation + 1\n\n    def evolution_rounds(self, rounds, mutation_rate=0.01):\n        \"\"\"\n        Function to generate rounds of evolution\n        main driver of the genetic algorithm class\n        evolution_rounds will stop when the target is acquired\n\n        :param rounds: rounds of evolution\n        :type rounds: int\n        :param mutation_rate: rate for mutation\n        :type mutation_rate: float\n\n        \"\"\"\n        for i in range(0, rounds):\n            self.new_generation(mutation_rate)\n            if self.target_acquired:\n                break\n\n# main function\ndef main_solution(target, populationsize, rounds, mutation_rate):\n    \"\"\"\n    Main function to run the genetic algorithm and return the result.\n\n    :param target: The target string to evolve towards.\n    :type target: str\n    :param populationsize: The size of the population in each generation.\n    :type populationsize: int\n    :param rounds: The number of evolution rounds to run.\n    :type rounds: int\n    :param mutation_rate: The mutation rate for the genetic algorithm.\n    :type mutation_rate: float\n    :return: A dictionary containing the result of the evolution process.\n    :rtype: dict\n    \"\"\"\n    evolution = Evolution(target, populationsize)\n    evolution.evolution_rounds(rounds, mutation_rate)\n    \n    result = {\n        \"target_acquired\": evolution.target_acquired,\n        \"generation\": evolution.generation,\n        \"max_fitness\": evolution.max_fitness,\n        \"closest_target\": evolution.closest_target\n    }\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"target": "cmzuygvfm", "populationsize": 162, "rounds": 172, "mutation_rate": 0.029928484843753517}, "output": {"target_acquired": true, "generation": 4, "max_fitness": 1.0, "closest_target": "cmzuygvfm"}}, {"input": {"target": "stqdvmanj", "populationsize": 67, "rounds": 205, "mutation_rate": 0.07529471256636379}, "output": {"target_acquired": true, "generation": 4, "max_fitness": 1.0, "closest_target": "stqdvmanj"}}, {"input": {"target": "blewry", "populationsize": 143, "rounds": 143, "mutation_rate": 0.012839766511388176}, "output": {"target_acquired": true, "generation": 3, "max_fitness": 1.0, "closest_target": "blewry"}}, {"input": {"target": "oyrcoxa", "populationsize": 199, "rounds": 232, "mutation_rate": 0.038621947649537816}, "output": {"target_acquired": true, "generation": 3, "max_fitness": 1.0, "closest_target": "oyrcoxa"}}, {"input": {"target": "ozfspk", "populationsize": 86, "rounds": 212, "mutation_rate": 0.027950551535709856}, "output": {"target_acquired": true, "generation": 3, "max_fitness": 1.0, "closest_target": "ozfspk"}}, {"input": {"target": "odwvhjxl", "populationsize": 153, "rounds": 147, "mutation_rate": 0.04173025472408184}, "output": {"target_acquired": true, "generation": 4, "max_fitness": 1.0, "closest_target": "odwvhjxl"}}, {"input": {"target": "hmjdrjax", "populationsize": 83, "rounds": 371, "mutation_rate": 0.038121064528090755}, "output": {"target_acquired": true, "generation": 3, "max_fitness": 1.0, "closest_target": "hmjdrjax"}}, {"input": {"target": "ikanpt", "populationsize": 166, "rounds": 207, "mutation_rate": 0.0607017732312853}, "output": {"target_acquired": true, "generation": 2, "max_fitness": 1.0, "closest_target": "ikanpt"}}, {"input": {"target": "wnlhm", "populationsize": 175, "rounds": 357, "mutation_rate": 0.04278690724670562}, "output": {"target_acquired": true, "generation": 2, "max_fitness": 1.0, "closest_target": "wnlhm"}}, {"input": {"target": "chjpg", "populationsize": 191, "rounds": 237, "mutation_rate": 0.014150645815477446}, "output": {"target_acquired": true, "generation": 2, "max_fitness": 1.0, "closest_target": "chjpg"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "maggieelkin/George", "path": "/George.py", "msgidx": 11329}}
{"problem_description": "Given a valid parentheses sequence `seq`, how can you split it into two non-overlapping valid parentheses strings `A` and `B` such that the maximum depth of nested parentheses in both `A` and `B` is minimized? Provide the assignment of each character in `seq` to either `A` or `B` in the form of a list where 0 represents assignment to `A` and 1 represents assignment to `B`.", "io_requirements": "Input:\n  `seq` (str): A string consisting of only '(' and ')', representing a valid parentheses sequence.\n\nOutput:\n  `return` (list of int): A list of integers where each integer is either 0 or 1. Each integer represents the assignment of the corresponding character in `seq` to either A (0) or B (1), such that the maximum depth of nested parentheses in both A and B is minimized.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(seq: str):\n    # Convert the input string to a list of integers representing the assignment of each bracket to A or B\n    ans = []\n    d = 0\n    for c in seq:\n        if c == '(':\n            d += 1\n            ans.append(d % 2)\n        if c == ')':\n            ans.append(d % 2)\n            d -= 1\n    # Return the list of assignments\n    return ans", "funcname": "main_solution", "ios": [{"input": {"seq": "(())()(())"}, "output": [1, 0, 0, 1, 1, 1, 1, 0, 0, 1]}, {"input": {"seq": "()()()((()"}, "output": [1, 1, 1, 1, 1, 1, 1, 0, 1, 1]}, {"input": {"seq": "(()((())()"}, "output": [1, 0, 0, 0, 1, 0, 0, 1, 1, 1]}, {"input": {"seq": "(((())))()"}, "output": [1, 0, 1, 0, 0, 1, 0, 1, 1, 1]}, {"input": {"seq": "(((((((((("}, "output": [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]}, {"input": {"seq": "()(())((()"}, "output": [1, 1, 1, 0, 0, 1, 1, 0, 1, 1]}, {"input": {"seq": "()()()()(("}, "output": [1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}, {"input": {"seq": "(())()(()("}, "output": [1, 0, 0, 1, 1, 1, 1, 0, 0, 0]}, {"input": {"seq": "()(()(()(("}, "output": [1, 1, 1, 0, 0, 0, 1, 1, 1, 0]}, {"input": {"seq": "(()((()))("}, "output": [1, 0, 0, 0, 1, 0, 0, 1, 0, 0]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Dawyer/Code", "path": "/problems/LeetCode/LeetCode1111. \u6709\u6548\u62ec\u53f7\u7684\u5d4c\u5957\u6df1\u5ea6.py", "msgidx": 12336}}
{"problem_description": "Given a string of digits and spaces, where the digits represent potential date components, how many unique valid dates can be formed from the string, and what is the earliest valid date among them? The valid dates must be in the format DDMMYYYY, where the year is at least 2000.", "io_requirements": "Input:\n  `input_string` (str): A string of digits and spaces representing a potential date. The string should be 8 characters long without spaces, or 10 characters long with spaces.\n\nOutput:\n  `return` (str): A string formatted as \"count DD MM YYYY\", where:\n    - `count` (int): The number of unique valid dates that can be formed from the input string.\n    - `DD` (str): The day of the earliest valid date in two-digit format.\n    - `MM` (str): The month of the earliest valid date in two-digit format.\n    - `YYYY` (str): The year of the earliest valid date in four-digit format.\n  If no valid date can be formed, the function returns `0`.", "refcode": "# import necessary packages\nfrom itertools import permutations\nfrom datetime import datetime\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    s = list(input_string.replace(' ', ''))\n    count = 0\n    mindate = None\n    dates = set()\n    \n    # Iterate over all permutations of the input string\n    for l in permutations(s):\n        dd = int(''.join(l[:2]))\n        mm = int(''.join(l[2:4]))\n        yyyy = int(''.join(l[4:]))\n\n        # Skip years less than 2000\n        if yyyy < 2000:\n            continue\n\n        try:\n            # Try to create a datetime object\n            d = datetime(yyyy, mm, dd)\n        except ValueError:\n            # Skip invalid dates\n            continue\n\n        # Check if the date is unique\n        if d not in dates:\n            count += 1\n            dates.add(d)\n\n        # Update the minimum date\n        if mindate is None or mindate > d:\n            mindate = d\n\n    # If no valid date was found, return 0\n    if mindate is None:\n        return 0\n    else:\n        # Format the minimum date and return the count and date\n        dd = str(mindate.day).zfill(2)\n        mm = str(mindate.month).zfill(2)\n        return f\"{count} {dd} {mm} {mindate.year}\"", "funcname": "main_solution", "ios": [{"input": {"input_string": "57 49 12 21"}, "output": "336 29 11 2457"}, {"input": {"input_string": "81444342"}, "output": 0}, {"input": {"input_string": "77642129"}, "output": "60 29 12 4677"}, {"input": {"input_string": "29211821"}, "output": "152 29 12 2118"}, {"input": {"input_string": "38655906"}, "output": 0}, {"input": {"input_string": "92490449"}, "output": "20 29 09 4449"}, {"input": {"input_string": "18824453"}, "output": 0}, {"input": {"input_string": "08 57 70 23"}, "output": "648 08 07 2357"}, {"input": {"input_string": "69 88 53 39"}, "output": 0}, {"input": {"input_string": "72 23 04 92"}, "output": "342 29 07 2234"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Jyotirm0y/kattis", "path": "/dreamer.py", "msgidx": 12260}}
{"problem_description": "In a game of Minesweeper, you are given a board with hidden mines and empty squares. You need to determine the state of the board after a specific click on an unrevealed square. What will be the resulting board configuration after the click, considering the rules of Minesweeper?", "io_requirements": "Input:\n  `board` (List[List[str]]): A 2D list representing the game board where each element is one of the following characters:\n    - 'M' represents an unrevealed mine.\n    - 'E' represents an unrevealed empty square.\n    - 'B' represents a revealed blank square with no adjacent mines.\n    - Digits ('1' to '8') represent the number of adjacent mines to a revealed square.\n    - 'X' represents a revealed mine.\n  `click` (List[int]): A list containing two integers representing the row and column indices of the next click position.\n\nOutput:\n  `return` (List[List[str]]): A 2D list representing the updated game board after processing the click according to the game rules.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\ndef updateBoard(board: List[List[str]], click: List[int]) -> List[List[str]]:\n    M = len(board)\n    N = len(board[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    def adjacent_mines(i, j):\n        mines = 0\n        for x, y in directions:\n            if 0 <= i + x < M and 0 <= j + y < N and board[i + x][j + y] == \"M\":\n                mines += 1\n        return mines\n    \n    def dfs(i, j):\n        mines = adjacent_mines(i, j)\n        if mines:\n            board[i][j] = str(mines)\n            return board\n        \n        board[i][j] = \"B\"\n        \n        for x, y in directions:\n            if 0 <= i + x < M and 0 <= j + y < N and board[i + x][j + y] == \"E\":\n                dfs(i + x, j + y)\n        return board\n    \n    if board[click[0]][click[1]] == \"M\":\n        board[click[0]][click[1]] = \"X\"\n        return board\n    \n    if board[click[0]][click[1]] == \"E\":\n        return dfs(click[0], click[1])\n\n# main function\ndef main_solution(board: List[List[str]], click: List[int]) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable\n    # return, the returned value must be json serializable\n    return updateBoard(board, click)", "funcname": "main_solution", "ios": [{"input": {"board": [["B", "B", "B", "B"], ["1", "1", "B", "B"], ["M", "2", "1", "B"], ["E", "M", "1", "B"]], "click": [1, 2]}, "output": [["B", "B", "B", "B"], ["1", "1", "B", "B"], ["M", "2", "1", "B"], ["E", "M", "1", "B"]]}, {"input": {"board": [["B", "1", "M", "M", "E"], ["B", "2", "E", "E", "M"], ["B", "1", "M", "E", "E"]], "click": [0, 0]}, "output": [["B", "1", "M", "M", "E"], ["B", "2", "E", "E", "M"], ["B", "1", "M", "E", "E"]]}, {"input": {"board": [["E", "M", "E", "E"], ["M", "E", "E", "E"], ["2", "E", "E", "E"], ["M", "E", "E", "M"]], "click": [2, 0]}, "output": [["E", "M", "E", "E"], ["M", "E", "E", "E"], ["2", "E", "E", "E"], ["M", "E", "E", "M"]]}, {"input": {"board": [["E", "E", "E", "E", "E", "E"], ["E", "E", "E", "2", "M", "E"], ["E", "M", "E", "M", "E", "M"]], "click": [1, 3]}, "output": [["E", "E", "E", "E", "E", "E"], ["E", "E", "E", "2", "M", "E"], ["E", "M", "E", "M", "E", "M"]]}, {"input": {"board": [["E", "E", "M", "M"], ["E", "E", "E", "E"], ["E", "E", "1", "E"], ["E", "E", "M", "E"]], "click": [2, 2]}, "output": [["E", "E", "M", "M"], ["E", "E", "E", "E"], ["E", "E", "1", "E"], ["E", "E", "M", "E"]]}, {"input": {"board": [["B", "B", "B"], ["B", "B", "B"], ["1", "1", "B"], ["M", "1", "B"]], "click": [1, 1]}, "output": [["B", "B", "B"], ["B", "B", "B"], ["1", "1", "B"], ["M", "1", "B"]]}, {"input": {"board": [["E", "E", "E", "E", "E"], ["M", "4", "M", "E", "E"], ["E", "M", "M", "E", "E"]], "click": [1, 1]}, "output": [["E", "E", "E", "E", "E"], ["M", "4", "M", "E", "E"], ["E", "M", "M", "E", "E"]]}, {"input": {"board": [["E", "E", "M"], ["E", "2", "M"], ["E", "E", "E"]], "click": [1, 1]}, "output": [["E", "E", "M"], ["E", "2", "M"], ["E", "E", "E"]]}, {"input": {"board": [["E", "2", "E"], ["M", "M", "E"], ["M", "E", "E"]], "click": [0, 1]}, "output": [["E", "2", "E"], ["M", "M", "E"], ["M", "E", "E"]]}, {"input": {"board": [["E", "M", "2"], ["E", "E", "M"], ["M", "E", "E"]], "click": [0, 2]}, "output": [["E", "M", "2"], ["E", "E", "M"], ["M", "E", "E"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "erjan/coding_exercises", "path": "/minesweeper.py", "msgidx": 12175}}
{"problem_description": "Given a set of test cases, each containing a number of cubes with specified side lengths, determine if it is possible to stack these cubes in a vertical pile such that each cube is either smaller than or equal to the cube directly below it. You can only pick cubes from either the leftmost or the rightmost end of the row. For each test case, what is the result indicating whether it is possible to stack the cubes in the required manner?", "io_requirements": "Input:\n  `test_cases` (list of dictionaries): Each dictionary represents a test case with the following keys:\n    - `n` (int): The number of cubes in the test case.\n    - `side_lengths` (list of int): The side lengths of the cubes in the test case.\n\nOutput:\n  `return` (list of str): A list of strings where each string is either \"Yes\" or \"No\", indicating whether it is possible to stack the cubes for each test case.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(test_cases):\n    results = []\n    for case in test_cases:\n        n, side_lengths = case['n'], deque(case['side_lengths'])\n        result = \"Yes\"\n        if max(side_lengths) not in (side_lengths[0], side_lengths[-1]):\n            result = \"No\"\n        results.append(result)\n    return results", "funcname": "main_solution", "ios": [{"input": {"test_cases": [{"n": 4, "side_lengths": [20, 93, 93, 92]}]}, "output": ["No"]}, {"input": {"test_cases": [{"n": 8, "side_lengths": [67, 98, 25, 59, 82, 8, 79, 56]}]}, "output": ["No"]}, {"input": {"test_cases": [{"n": 8, "side_lengths": [64, 11, 3, 72, 89, 1, 3, 39]}]}, "output": ["No"]}, {"input": {"test_cases": [{"n": 1, "side_lengths": [87]}]}, "output": ["Yes"]}, {"input": {"test_cases": [{"n": 1, "side_lengths": [27]}]}, "output": ["Yes"]}, {"input": {"test_cases": [{"n": 2, "side_lengths": [54, 43]}]}, "output": ["Yes"]}, {"input": {"test_cases": [{"n": 7, "side_lengths": [5, 45, 29, 59, 16, 49, 23]}]}, "output": ["No"]}, {"input": {"test_cases": [{"n": 5, "side_lengths": [87, 25, 97, 52, 14]}]}, "output": ["No"]}, {"input": {"test_cases": [{"n": 2, "side_lengths": [8, 100]}]}, "output": ["Yes"]}, {"input": {"test_cases": [{"n": 3, "side_lengths": [77, 99, 69]}]}, "output": ["No"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "NikolayVaklinov10/Python_Challenges", "path": "/Collections/Piling_Up!.py", "msgidx": 12634}}
{"problem_description": "Given a plaintext string without spaces, how can you encrypt it using a recursive algorithm that separates the characters into two groups based on their positions (even and odd)?", "io_requirements": "Input:\n  `plaintext` (str): A string representing the plaintext to be encrypted. The string should not contain any spaces.\n\nOutput:\n  `return` (str): A string representing the encrypted ciphertext.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef beaver_code(plaintext, left, right):\n    if len(plaintext) == 1 or len(plaintext) == 2:\n        return plaintext\n    else:\n        for i in range(len(plaintext)):\n            if i % 2 == 0:\n                left += plaintext[i]\n            else:\n                right += plaintext[i]\n    return beaver_code(left, \"\", \"\") + beaver_code(right, \"\", \"\")\n\n# main function\ndef main_solution(plaintext):\n    # Convert the input plaintext to a string without spaces\n    plaintext = plaintext.replace(\" \", \"\")\n    \n    # Initialize left and right strings\n    left = \"\"\n    right = \"\"\n    \n    # Call the beaver_code function to get the ciphertext\n    ciphertext = beaver_code(plaintext, left, right)\n    \n    # Return the ciphertext as the output\n    return ciphertext", "funcname": "main_solution", "ios": [{"input": {"plaintext": "aNBVk1eu"}, "output": "akBeN1Vu"}, {"input": {"plaintext": "8p1bt"}, "output": "8t1pb"}, {"input": {"plaintext": "AuKmup"}, "output": "AuKupm"}, {"input": {"plaintext": "cvpsri"}, "output": "crpvis"}, {"input": {"plaintext": "ojrW2LIBu"}, "output": "ou2rIjLWB"}, {"input": {"plaintext": "y2wmuCqP"}, "output": "yuwq2CmP"}, {"input": {"plaintext": "4B3BV"}, "output": "4V3BB"}, {"input": {"plaintext": "PwBS3Nk9"}, "output": "P3BkwNS9"}, {"input": {"plaintext": "jMCR4"}, "output": "j4CMR"}, {"input": {"plaintext": "exUcJR7"}, "output": "eJU7xRc"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yarenska/kraker", "path": "/beaver.py", "msgidx": 12859}}
{"problem_description": "In the game of Conway's Game of Life, given an initial state of a game board, what will be the state of the board after one iteration of the game rules? The rules are as follows:\n1. Any live cell with fewer than two live neighbors dies (underpopulation).\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies (overpopulation).\n4. Any dead cell with exactly three live neighbors becomes a live cell (reproduction).\n\nThe initial state of the board is represented by a 2D list where each element is either `0` (dead cell) or `1` (live cell). What will be the next state of the board after applying these rules?", "io_requirements": "Input:\n  `board` (List[List[int]]): A 2D list representing the initial state of the game board. Each element in the list is either `0` (dead cell) or `1` (live cell).\n\nOutput:\n  `return` (List[List[int]]): A 2D list representing the next state of the game board after applying the rules of Conway's Game of Life. Each element in the list is either `0` (dead cell) or `1` (live cell).", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                live_neighbors = self.getLiveNeighbors(i, j, board)\n                if board[i][j] == 1 or board[i][j] == -1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        board[i][j] = -1\n                else:\n                    if live_neighbors == 3:\n                        board[i][j] = 2\n                        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == -1:\n                    board[i][j] = 0\n                elif board[i][j] == 2:\n                    board[i][j] = 1\n                    \n    def getLiveNeighbors(self, i, j, board):\n        directions = [(1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1)]\n        live_neighbors = 0\n        for r, c in directions:\n            row = i + r\n            col = j + c\n            if row >= 0 and row < len(board) and col >= 0 and col < len(board[0]):\n                if board[row][col] == 1 or board[row][col] == -1:\n                    live_neighbors += 1\n        return live_neighbors\n\n# main function\ndef main_solution(board: List[List[int]]) -> List[List[int]]:\n    # Convert the input board to a list of lists of integers\n    solution = Solution()\n    solution.gameOfLife(board)\n    return board", "funcname": "main_solution", "ios": [{"input": {"board": [[0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 0]]}, "output": [[0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 0]]}, {"input": {"board": [[0, 0, 1, 0, 0], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]}, "output": [[0, 0, 1, 0, 0], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]}, {"input": {"board": [[0, 1, 0, 0], [1, 0, 0, 1], [1, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0], [1, 1, 0, 1]]}, "output": [[0, 1, 0, 0], [1, 0, 0, 1], [1, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0], [1, 1, 0, 1]]}, {"input": {"board": [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 0]]}, "output": [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 0]]}, {"input": {"board": [[0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0]]}, "output": [[0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0]]}, {"input": {"board": [[1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0]]}, "output": [[1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0]]}, {"input": {"board": [[0, 0, 0], [0, 0, 0], [0, 0, 0]]}, "output": [[0, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": {"board": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 1], [0, 1, 1, 0, 0]]}, "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 1], [0, 1, 1, 0, 0]]}, {"input": {"board": [[0, 0, 1, 0], [1, 1, 0, 0], [0, 0, 0, 0]]}, "output": [[0, 0, 1, 0], [1, 1, 0, 0], [0, 0, 0, 0]]}, {"input": {"board": [[0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0]]}, "output": [[0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "HarshaVardhan-Kaki/Array-2", "path": "/game_of_life.py", "msgidx": 12581}}
{"problem_description": "A frog wants to cross a river with `n` stones in it. Each stone has a number written on it, indicating the exact number of stones the frog can jump forward or backward from that stone. The frog can start from the near bank and jump to the first stone, and from the last stone (or any other stone with a large enough number) to the far bank. What is the minimum number of jumps required for the frog to cross the river, or is it impossible to cross?", "io_requirements": "Input:\n  `n` (int): The number of stones in the river.\n  `stones` (list of int): A list of integers where each integer represents the number of stones the frog can jump from that stone.\n\nOutput:\n  `return` (int or str): The minimum number of jumps required for the frog to cross the river. If it's not possible, returns the string `\"no chance :-(\"`.", "refcode": "# import necessary packages\nfrom collections import deque, defaultdict\n\n# main function\ndef main_solution(n, stones):\n    # Convert stones list to a JSON serializable format\n    stones = list(stones)\n    \n    # Initialize variables\n    voisins = dict()\n    for i, jump in enumerate(stones):\n        v = []\n        if i - jump >= 0:\n            v.append(i - jump)\n        v.append(min(n, i + jump))\n        voisins[i] = v\n    \n    unvisited = defaultdict(lambda: True)\n    queue = deque()\n    distance = defaultdict(int)\n    distance[0] = 1\n    queue.appendleft(0)\n    unvisited[0] = False\n    \n    # BFS algorithm to find the minimum number of jumps\n    while len(queue) > 0:\n        newstone = queue.pop()\n        if newstone == n:\n            return distance[newstone]\n        for voisin in voisins[newstone]:\n            if unvisited[voisin]:\n                distance[voisin] = distance[newstone] + 1\n                unvisited[voisin] = False\n                queue.appendleft(voisin)\n    \n    return \"no chance :-(\"", "funcname": "main_solution", "ios": [{"input": {"n": 10, "stones": [1, 5, 1, 3, 2, 0, 5, 3, 8, 5]}, "output": 4}, {"input": {"n": 3, "stones": [1, 1, 2]}, "output": 4}, {"input": {"n": 4, "stones": [2, 4, 1, 2]}, "output": 4}, {"input": {"n": 9, "stones": [9, 6, 5, 1, 1, 8, 6, 1, 0]}, "output": 2}, {"input": {"n": 5, "stones": [4, 5, 1, 4, 0]}, "output": "no chance :-("}, {"input": {"n": 5, "stones": [3, 2, 4, 2, 1]}, "output": 3}, {"input": {"n": 2, "stones": [0, 2]}, "output": "no chance :-("}, {"input": {"n": 2, "stones": [1, 0]}, "output": "no chance :-("}, {"input": {"n": 5, "stones": [4, 4, 2, 0, 2]}, "output": 3}, {"input": {"n": 3, "stones": [1, 1, 3]}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/Fz92j7nQEkoRXhRE7_10.py", "msgidx": 12542}}
{"problem_description": "Given a binary tree, how would you represent the inverted structure of the tree in a format where each level of the tree is a sub-array, and each sub-array contains the values of the nodes at that level? The inversion should swap every left node in the tree for its corresponding right node.", "io_requirements": "Input:\n  `tree_structure` (list of integers and None): A list representing the binary tree structure. Each integer represents a node value, and `None` represents a missing node. The list is constructed in a level-order traversal manner.\n\nOutput:\n  `return` (list of lists of integers): A list where each sub-list represents a level in the inverted binary tree. Each integer in the sub-list represents the value of a node at that level.", "refcode": "# import necessary packages\nimport collections\n\n# all class and function definitions in the code file, if any\nclass Tree:\n    def __init__(self, value):\n        self.val = value\n        self.left = None\n        self.right = None\n\n    # Returns tree in an array, each level is a sub array\n    def __repr__(self):\n        if not self:\n            return []\n        result = []\n        queue = collections.deque([self])\n        while queue:\n            level_size = len(queue)\n            current_level = []\n            for _ in range(level_size):\n                node = queue.popleft()\n                if node:\n                    current_level.append(node.val)\n                    queue.append(node.left)\n                    queue.append(node.right)\n            if current_level:\n                result.append(current_level)\n        return result\n\n# O(n) time | O(n) space\ndef invertBinaryTree(tree):\n    if not tree:\n        return None\n    tree.left, tree.right = tree.right, tree.left\n    invertBinaryTree(tree.left)\n    invertBinaryTree(tree.right)\n    return tree\n\n# main function\ndef main_solution(tree_structure):\n  # Convert the JSON serializable input to the original input variables\n  def build_tree(structure):\n      if not structure:\n          return None\n      root = Tree(structure[0])\n      queue = collections.deque([root])\n      index = 1\n      while queue and index < len(structure):\n          node = queue.popleft()\n          if structure[index] is not None:\n              node.left = Tree(structure[index])\n              queue.append(node.left)\n          index += 1\n          if index < len(structure) and structure[index] is not None:\n              node.right = Tree(structure[index])\n              queue.append(node.right)\n          index += 1\n      return root\n\n  tree = build_tree(tree_structure)\n  inverted_tree = invertBinaryTree(tree)\n  # Convert the output to JSON serializable format\n  return inverted_tree.__repr__()", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [63, 92, 88]}, "output": [[63], [88, 92]]}, {"input": {"tree_structure": [null, 1, 29, 17, 83, 98, 52]}, "output": [[null], [29, 1], [52, 98, 83, 17]]}, {"input": {"tree_structure": [null, null, 38, 34, 22, 79, 90]}, "output": [[null], [38], [22, 34], [90, 79]]}, {"input": {"tree_structure": [null, 55, 83]}, "output": [[null], [83, 55]]}, {"input": {"tree_structure": [40]}, "output": [[40]]}, {"input": {"tree_structure": [null, 7, 61, null, 49, null, 82]}, "output": [[null], [61, 7], [82, 49]]}, {"input": {"tree_structure": [null]}, "output": [[null]]}, {"input": {"tree_structure": [null, 95, 79, 70, 19, null, null]}, "output": [[null], [79, 95], [19, 70]]}, {"input": {"tree_structure": [null, 6, 65]}, "output": [[null], [65, 6]]}, {"input": {"tree_structure": [88, 43, 25, 2, 7, 24, null]}, "output": [[88], [25, 43], [24, 7, 2]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "alexisdavalos/DailyBytes", "path": "/BinaryTreeInversion/InvertBinaryTree.py", "msgidx": 12295}}
{"problem_description": "In the context of the Nim Game, where players take turns removing objects from distinct heaps, the nim sum is a crucial concept. Given a list of heaps represented by their sizes, what is the nim sum of these heaps?", "io_requirements": "Input:\n  `numbers` (list of strings): A list of strings where each string represents a non-negative integer.\n\nOutput:\n  `return` (int): The nim sum of the list of integers.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef nim_sum(array):\n    max_len, base_2 = len(bin(max(array))) - 2, [bin(i)[2:] for i in array]\n    result = '0' * max_len\n\n    for i in range(len(base_2)):\n        if len(base_2[i]) < max_len:\n            base_2[i] = ('0' * (max_len - len(base_2[i]))) + base_2[i]\n        for j in range(max_len):\n            result = result[:j] + str((int(result[j]) + int(base_2[i][j])) % 2) + result[j + 1:]\n    return int('0b' + result, 2)\n\n# main function\ndef main_solution(numbers):\n    # Convert the input list of strings to integers\n    numbers = [int(num) for num in numbers]\n    \n    # Calculate the nim sum\n    result = nim_sum(numbers)\n    \n    # Return the result as an integer\n    return result", "funcname": "main_solution", "ios": [{"input": {"numbers": ["82", "78", "21", "85", "15"]}, "output": 83}, {"input": {"numbers": ["88", "7", "3", "17", "34"]}, "output": 111}, {"input": {"numbers": ["94", "51", "4", "72", "26"]}, "output": 59}, {"input": {"numbers": ["69", "9", "30", "27", "46"]}, "output": 103}, {"input": {"numbers": ["65", "98", "27", "25", "46"]}, "output": 15}, {"input": {"numbers": ["56", "18", "25", "63", "8"]}, "output": 4}, {"input": {"numbers": ["89", "70", "25", "67", "26"]}, "output": 95}, {"input": {"numbers": ["82", "68", "58", "66", "58"]}, "output": 84}, {"input": {"numbers": ["95", "45", "44", "85", "98"]}, "output": 105}, {"input": {"numbers": ["65", "75", "24", "6", "54"]}, "output": 34}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bigWaitForItOh/Classic-Problems", "path": "/nim_sum/python/nim_sum.py", "msgidx": 13029}}
{"problem_description": "In a hallway, there are `n` doors initially closed. A person walks through the hallway and performs a series of operations on the doors: the first time, they open every door; the second time, they close every second door; the third time, they toggle every third door, and so on. After `n` passes, how many doors remain open?", "io_requirements": "Input:\n  `n` (int): The total number of doors, where `n` is a positive integer.\n\nOutput:\n  `return` (int): The number of doors that remain open after the series of operations.", "refcode": "import math\n\ndef main_solution(n):\n    \"\"\"\n    Calculates the number of doors that remain open after a series of operations.\n    \n    Args:\n    n (int): The total number of doors.\n    \n    Returns:\n    int: The number of doors that remain open.\n    \"\"\"\n    return int(math.sqrt(n - 1))", "funcname": "main_solution", "ios": [{"input": {"n": 42}, "output": 6}, {"input": {"n": 212}, "output": 14}, {"input": {"n": 908}, "output": 30}, {"input": {"n": 782}, "output": 27}, {"input": {"n": 658}, "output": 25}, {"input": {"n": 281}, "output": 16}, {"input": {"n": 226}, "output": 15}, {"input": {"n": 548}, "output": 23}, {"input": {"n": 673}, "output": 25}, {"input": {"n": 158}, "output": 12}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "roachsinai/Coding_Interviews", "path": "/CtCI-6th-Edition-Python/Chapter6/9_lockers.py", "msgidx": 12922}}
{"problem_description": "A frog can jump either 1 step, 2 steps, or any number of steps up to n steps at a time. Given the number of steps `n`, how many distinct ways can the frog reach the top of the steps?", "io_requirements": "Input:\n  `number` (int): The number of steps the frog needs to jump. It should be a positive integer.\n\nOutput:\n  `return` (int): The total number of ways the frog can jump to the given number of steps.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def jumpfloorii(self, number):\n        if number < 2:\n            return number\n        else:\n            val = 2\n            for _ in range(3, number+1):\n                val = 2*val\n        return val\n\n# main function\ndef main_solution(number):\n    # Convert JSON serializable input to the original input variable\n    number = int(number)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the jumpfloorii method\n    result = solution.jumpfloorii(number)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"number": 2}, "output": 2}, {"input": {"number": 6}, "output": 32}, {"input": {"number": 5}, "output": 16}, {"input": {"number": 10}, "output": 512}, {"input": {"number": 9}, "output": 256}, {"input": {"number": 1}, "output": 1}, {"input": {"number": 3}, "output": 4}, {"input": {"number": 7}, "output": 64}, {"input": {"number": 4}, "output": 8}, {"input": {"number": 8}, "output": 128}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "xxNB/sword-offer", "path": "/code/3.21_1.py", "msgidx": 12451}}
{"problem_description": "Given a number of pairs of parentheses, how can we generate all possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate. Must be a non-negative integer.\n\nOutput:\n  `return` (list of str): A list of strings, where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef _gen_paren(parens, opened, closed):\n    if opened == 0:\n        return [parens + (')' * closed)]\n    elif opened == closed:\n        return _gen_paren(parens + '(', opened - 1, closed)\n    elif closed > opened:\n        return _gen_paren(parens + '(', opened - 1, closed) + _gen_paren(parens + ')', opened, closed - 1)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    if n == 0:\n        return []\n    else:\n        return _gen_paren('', n, n)", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 0}, "output": []}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "btjd/coding-exercises", "path": "/recursion_backtracking/generate_parenthesis.py", "msgidx": 12359}}
{"problem_description": "Given a range of numbers up to one million, which prime number within this range can be expressed as the sum of the most consecutive prime numbers? What is the length of this sequence of consecutive primes?", "io_requirements": "Input:\n- `block` (int): The size of the block for generating primes. This should be a positive integer.\n- `limit` (int): The upper limit for the prime number to be checked. This should be a positive integer.\n\nOutput:\n- `return` (dict): A dictionary containing the following keys:\n  - `prime` (int): The prime number that can be written as the sum of the most consecutive primes below the given limit.\n  - `length` (int): The number of consecutive primes that sum up to the prime number.", "refcode": "# import necessary packages\nimport logging\nimport sys\nimport time\n\n# all class and function definitions in the code file, if any\ndef prime_sieve(extend, primes=[]):\n    nums = [True] * extend\n    if not primes:\n        offset = 2\n    else:\n        offset = primes[-1] + 1\n        for p in primes:\n            start = (offset - 1) // p + 1\n            end = (offset + extend - 1) // p + 1\n            for n in range(start, end):\n                nums[n * p - offset] = False\n    for i in range(extend):\n        if nums[i]:\n            primes.append(i + offset)\n            for n in range(2, 1 + extend // (i + offset)):\n                nums[(i + offset) * n - offset] = False\n    return primes\n\ndef is_prime_sum(num, primes, sum_min):\n    i = 0\n    while True:\n        prime_sum = primes[i:i + sum_min]\n        if sum(prime_sum) > num:\n            return False\n        j = i + sum_min\n        while True:\n            prime_sum.append(primes[j])\n            if sum(prime_sum) > num:\n                break\n            elif sum(prime_sum) == num:\n                return prime_sum\n            j += 1\n        i += 1\n\n# main function\ndef main_solution(block, limit):\n    primes = prime_sieve(block)\n    i = 0\n    max_i = 0\n    max_prime_set = 0\n    while True:\n        i += 1\n        if i >= len(primes):\n            primes = prime_sieve(block, primes)\n        if primes[i] > limit:\n            break\n        prime_set = is_prime_sum(primes[i], primes, max_prime_set)\n        if prime_set and max_prime_set < len(prime_set):\n            max_prime_set = len(prime_set)\n            max_i = i\n    return {\"prime\": primes[max_i], \"length\": max_prime_set}", "funcname": "main_solution", "ios": [{"input": {"block": 46764, "limit": 781393}, "output": {"prime": 768373, "length": 484}}, {"input": {"block": 83640, "limit": 632772}, "output": {"prime": 624209, "length": 439}}, {"input": {"block": 30062, "limit": 568314}, "output": {"prime": 552751, "length": 415}}, {"input": {"block": 46978, "limit": 195154}, "output": {"prime": 182107, "length": 249}}, {"input": {"block": 54166, "limit": 481591}, "output": {"prime": 478001, "length": 387}}, {"input": {"block": 84775, "limit": 157280}, "output": {"prime": 148817, "length": 225}}, {"input": {"block": 45984, "limit": 462833}, "output": {"prime": 448867, "length": 377}}, {"input": {"block": 44098, "limit": 881481}, "output": {"prime": 868151, "length": 512}}, {"input": {"block": 95801, "limit": 300758}, "output": {"prime": 287137, "length": 308}}, {"input": {"block": 67260, "limit": 883534}, "output": {"prime": 868151, "length": 512}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ThomasZumsteg/project-euler", "path": "/problem_0050.py", "msgidx": 12468}}
{"problem_description": "Imagine you are at a fast-food restaurant that sells Chicken McNuggets in packages of different sizes. You are curious to know the largest number of McNuggets that cannot be bought exactly using the available package sizes. Given the sizes of the packages, what is the largest number of McNuggets that cannot be purchased exactly?", "io_requirements": "Input:\n  `packages` (tuple): A tuple of three integers representing the sizes of the packages of McNuggets. The integers should be positive and distinct.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"largest_number_unbuyable\"` whose value is an integer representing the largest number of McNuggets that cannot be bought in exact quantity using the given package sizes.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(packages):\n    # Convert the input tuple to a list for easier manipulation\n    packages = list(packages)\n    \n    # Initialize variables\n    bestSoFar = 0\n    combinations = 1\n    lastFound = packages[0]\n    \n    # Iterate over possible values of n\n    for n in range(packages[0] + 1, 60):\n        found = False\n        # Check all combinations of a, b, c\n        for a, b, c in itertools.product(range(n), repeat=3):\n            if (a * packages[0] + b * packages[1] + c * packages[2]) == n:\n                found = True\n                break\n        \n        # Update bestSoFar based on whether n can be expressed as a combination\n        if found:\n            if lastFound == (n - 1):\n                combinations += 1\n                lastFound = n\n            else:\n                combinations = 1\n                lastFound = n\n        else:\n            bestSoFar = n\n            combinations = 0\n    \n    # Return the result as a dictionary\n    return {\"largest_number_unbuyable\": bestSoFar}", "funcname": "main_solution", "ios": [{"input": {"packages": [7, 3, 6]}, "output": {"largest_number_unbuyable": 11}}, {"input": {"packages": [2, 3, 7]}, "output": {"largest_number_unbuyable": 0}}, {"input": {"packages": [2, 5, 6]}, "output": {"largest_number_unbuyable": 3}}, {"input": {"packages": [7, 2, 8]}, "output": {"largest_number_unbuyable": 0}}, {"input": {"packages": [3, 9, 8]}, "output": {"largest_number_unbuyable": 13}}, {"input": {"packages": [1, 3, 8]}, "output": {"largest_number_unbuyable": 2}}, {"input": {"packages": [9, 10, 2]}, "output": {"largest_number_unbuyable": 0}}, {"input": {"packages": [9, 2, 4]}, "output": {"largest_number_unbuyable": 0}}, {"input": {"packages": [5, 6, 3]}, "output": {"largest_number_unbuyable": 7}}, {"input": {"packages": [1, 4, 7]}, "output": {"largest_number_unbuyable": 3}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bandidotkom/basics_python", "path": "/mit_intro/ps2b.py", "msgidx": 12088}}
{"problem_description": "Given a set of network configuration lines, each containing sections of IP addresses and hypernet sequences enclosed in square brackets, determine how many of these lines support TLS (Transport Layer Security) by having an ABBA pattern outside the brackets but not inside, and how many support SSL by having an ABA pattern outside the brackets and a corresponding BAB pattern inside the brackets. What are the counts of such lines for both TLS and SSL support?", "io_requirements": "Input:\n  `input_lines` (list of strings): A list of strings where each string represents a line of input. Each line may contain sections enclosed in square brackets `[]`.\n\nOutput:\n  `return` (dictionary): A dictionary with two keys:\n    - `\"abba_count\"` (int): The number of lines that contain an ABBA pattern outside square brackets but not inside square brackets.\n    - `\"ssl_count\"` (int): The number of lines that support SSL (Super Secret Listening) by having an ABA pattern outside square brackets and a corresponding BAB pattern inside square brackets.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\nabba = lambda s: any([s[i]==s[i+3] and s[i+1]==s[i+2] and s[i]!=s[i+1] for i in range(len(s)-3)])\n\ndef ssl(s, h):\n    aba = [x[i+1:i+3]+x[i+1] for x in s for i in range(len(x)-2) if x[i]==x[i+2]]\n    return any([x in y for x in aba for y in h])\n\n# main function\ndef main_solution(input_lines):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  n, m = 0, 0\n  for line in input_lines:\n    a = re.split(r'\\[|\\]', line)\n    s, h = a[0::2], a[1::2]\n    n += (any(map(abba, s)) and not any(map(abba, h)))\n    m += ssl(s, h)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return {\"abba_count\": n, \"ssl_count\": m}", "funcname": "main_solution", "ios": [{"input": {"input_lines": ["AMyy[pmew]xxZaHLKz", "tsGCGewtp[Q[Jd]Fs]pOAw", "AbUY[ywMI]GyYM[UQ]Hwi", "UjlhhE[[Rl]eZbR]w[XHm]m", "UZySRm[jJyGiW]rO[HZ]Uu", "SN[p[[osmJ]K]ko]vT"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["YCpVcB[UhXyc]FMxq[bpO]sr", "mOm[prl][sJR]C", "thR[RovT]vb[[JG]]", "PBvnW[EAce]SwQSBk", "TYlDDBaWnJa[wZ]", "U[RmEcdJF]cyK"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["S[oxqPujMzPIC[[aS]]]", "v[KEwf]d[Uqj]c", "SAy[XVS[au]l]n", "jMhtImgM[lYTpOAUI]m", "Am[fvHu[TEK[]PISRicz]]", "gtWeIEcGnb[km[[sr]]JS]Z", "AtXdUPQHW[wIu]yvX", "W[tW]VXlIlUHfsZFLQ[sS]"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["QwLp[YBGFyuTLV]aqwH", "RkXF[vKUJPWBFO[Cm[tA]]o]M", "BU[nT[FD]NnadhhguPjB]q", "AxmJyR[gXpF[SQ]F]otwm", "Uzovg[XxzPcFoNP[Ei]]", "MOHdt[SNU[GAOsE]uzKb]"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["EwSjPZ[[fFxligh]Z]Q", "IOILw[skj[zjmxth]]", "NRcu[HEEUV]pjkhQ", "eK[u[v[ycjxcb]YbBMV]HlTC]", "ftk[nMicf[MY]fHID]SYnp[ES]", "eQsEXGTlpz[[CJ]EGm[pnv]]", "FgnWtjxYq[Ayy]", "UFCySFem[KF]"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["NxCcvQYwv[waKY[s]XK]", "TmaQMXH[Kfz]BzxR[Xbm[i]]", "uB[gs[YQ[GX]u]SH]YfABpPwNN", "LyDpxxbuZK[Up]DWp", "W[Hu[qTMxY[HM]nC]]", "XwItsRF[WfH]"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["MTNeWhr[imS]KvmOcHbw", "M[wiEBt]GhJh[NCtF]", "oLDlE[kDhw]KRHt", "F[bz[KqU[Bf]Urs]hQ]", "ipb[HnwlHuTBb]y", "C[aIfYLUedQYX]", "twhad[hnYNmb]Dhmw", "JxFOePod[ysnWCF[jzw[]]wY]"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["CgxNJ[oiKF[us]HMe]", "QqS[Mj[LpxKl]JBAOkN[]ym]Pi", "e[hPqkza]pe[gFa]N", "s[XN[]oukZ]WFPlaGD", "uZnuuzD[drW]", "Jhs[qp]K[Q[GB]vCsa]", "Cb[VKRkeSpt[PbRc[]]xH]B", "ILGcM[mBe]pbgCc"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["iz[NcND][PvjCKqfW]nO", "CqNEKuzLv[jKKcEZLk]M", "TxQMrEAFe[[jU]k]H", "VIlUrNLOrysBq[YpLn]", "ersXHvCZXzP[gc]"]}, "output": {"abba_count": 0, "ssl_count": 0}}, {"input": {"input_lines": ["j[[iY]xil[]nwdz]JAVlRRfwTu", "pFJwLIUUJagVzss[pM]", "fhdB[eXpgR]v[hy]fhA", "WxJFj[r[CYE]z[EGB]Mx]", "vuGHcmd[pVGVxZv]Dsqf", "tG[n[[lozVrHaT]]d]", "OMvV[DrPu[EyAh][]c]", "mWTY[[t[PG]Tw]XP]"]}, "output": {"abba_count": 0, "ssl_count": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sebastianst/aoc2016", "path": "/7/solution.py", "msgidx": 12517}}
{"problem_description": "In a social network, each person can be connected to multiple other people. Given a CSV file where each row represents a list of names, with the first name being the head and the subsequent names being connected to it, what is the maximum number of cycles that can be formed in this network?", "io_requirements": "Input:\n  `csv_data` (str): A string containing CSV data where each row represents a list of names. The first name in each row is the head, and the subsequent names are connected to it in a graph.\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"max_cycles\"` whose value is an integer representing the maximum number of cycles found in the graph. If there is an error in the input data, the dictionary will contain a key `\"error\"` with a corresponding error message.", "refcode": "# import necessary packages\nimport csv\nfrom io import StringIO\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Graph: \n    def __init__(self, V):\n        self.V = V \n        self.visited = {}\n        self.graph = {}\n        self.result = 0\n        self.count = 1\n        \n    def add(self, csv_data):\n        d = set()\n        csv_reader = csv.reader(StringIO(csv_data), delimiter=',')\n        for row in csv_reader:\n            if row[0] in d:\n                return 0\n            else:\n                d.add(row[0])\n            head = Node(row[0])\n            n = head\n            for name in row[1:]:\n                if name[0] == ' ':\n                    name = name[1:]\n                node = Node(name)\n                n.next = node\n                n = n.next\n            self.graph[head.value] = head.next\n    \n    def DFS(self, v):  \n        self.count += 1\n        self.visited[v] = True\n        if v in self.graph:\n            val = self.graph[v]\n            while val is not None:\n                if not self.visited[val.value]:\n                    self.DFS(val.value)\n                val = val.next\n        return 0\n    \n    def countCycles(self):  \n        for name in self.V:  \n            self.count = 0\n            self.visited = dict.fromkeys(self.V, False)\n            self.visited[name] = True\n            self.DFS(name)  \n            self.result = max(self.result, self.count)\n        return self.result\n\n# main function\ndef main_solution(csv_data):\n    # Convert the input CSV data to a set of unique names\n    V = set()\n    csv_reader = csv.reader(StringIO(csv_data), delimiter=',')\n    for row in csv_reader:\n        for name in row:\n            if name[0] == ' ':\n                name = name[1:]\n            V.add(name)\n    \n    # Create the graph and count the cycles\n    g = Graph(V)\n    if g.add(csv_data) == 0:\n        return {\"error\": \"Error: please check the file\"}\n    \n    result = g.countCycles()\n    return {\"max_cycles\": result}", "funcname": "main_solution", "ios": [{"input": {"csv_data": "Alice,Uma,Trent,Walter\nJudy,Dave,Heidi\nSybil,Judy\nMallory,Peggy\nDave,Quentin,Ivan\nDave,Carol,Olivia"}, "output": {"error": "Error: please check the file"}}, {"input": {"csv_data": "Eve,Frank,Trent,Peggy\nIvan,Dave,Uma\nOlivia,Victor,Mallory\nOlivia,Heidi,Rupert,Ivan,Walter"}, "output": {"error": "Error: please check the file"}}, {"input": {"csv_data": "Ivan,Grace,Rupert,Quentin\nAlice,Trent,Sybil,Quentin\nWalter,Sybil,Uma,Olivia\nNiaj,Judy,Grace,Dave"}, "output": {"max_cycles": 4}}, {"input": {"csv_data": "Trent,Mallory,Judy\nHeidi,Peggy,Sybil,Grace\nGrace,Victor,Sybil,Trent,Heidi"}, "output": {"max_cycles": 8}}, {"input": {"csv_data": "Sybil,Bob\nCarol,Victor\nTrent,Grace,Dave\nBob,Mallory,Uma,Ivan,Niaj"}, "output": {"max_cycles": 6}}, {"input": {"csv_data": "Victor,Peggy,Frank,Eve,Sybil\nOlivia,Carol,Quentin\nIvan,Olivia,Mallory,Judy,Grace"}, "output": {"max_cycles": 7}}, {"input": {"csv_data": "Peggy,Sybil,Mallory\nSybil,Victor,Alice,Niaj\nMallory,Carol,Quentin"}, "output": {"max_cycles": 8}}, {"input": {"csv_data": "Sybil,Carol\nFrank,Carol,Olivia\nQuentin,Walter,Uma,Carol,Sybil\nIvan,Alice,Olivia,Eve"}, "output": {"max_cycles": 5}}, {"input": {"csv_data": "Eve,Sybil,Carol\nUma,Heidi,Olivia\nPeggy,Uma"}, "output": {"max_cycles": 4}}, {"input": {"csv_data": "Victor,Rupert\nCarol,Frank,Walter\nBob,Sybil,Trent\nQuentin,Rupert"}, "output": {"max_cycles": 3}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Parth7/Academic-Expert-finding-Sytem", "path": "/backup.py", "msgidx": 12671}}
{"problem_description": "Given a network of interconnected nodes, where each connection between nodes is represented by an edge, determine if there exists at least one node whose removal would increase the number of connected components in the network. What is the result of this analysis for the given set of edges?", "io_requirements": "Input:\n  `edges` (list of tuples): A list of tuples representing the edges of the graph. Each tuple contains two integers representing the nodes connected by the edge.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the graph has at least one articulation point (`True`) or not (`False`).", "refcode": "# import necessary packages\nimport networkx as nx\n\n# all class and function definitions in the code file, if any\ndef create_graph(edges):\n    G = nx.Graph()\n    for edge in edges:\n        G.add_edge(edge[0], edge[1])\n    return G\n\ndef DFS(G):\n    connexes = 0\n    startVisited(G)\n    for i in G.nodes():\n        if G.nodes[i]['visited'] == False:\n            connexes += 1\n            explore(i, G)\n    return connexes\n            \ndef explore(v, G):\n    G.nodes[v]['visited'] = True\n    for u in G.neighbors(v):\n        if not G.nodes[u]['visited']:\n            explore(u, G)\n        \ndef startVisited(G):\n    for i in G.nodes():\n        G.nodes[i]['visited'] = False\n        \ndef articulacio(G):\n    inicial = DFS(G)\n    for i in list(G.nodes()):\n        G.remove_node(i)\n        final = DFS(G)\n        if final > inicial:\n            return True\n        G.add_node(i)\n        for neighbor in list(G.neighbors(i)):\n            G.add_edge(i, neighbor)\n    return False\n\n# main function\ndef main_solution(edges):\n    # Convert JSON serializable input to original input variables\n    G = create_graph(edges)\n    \n    # Core solution logic\n    result = articulacio(G)\n    \n    # Convert result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"edges": [[7, 4], [6, 10], [3, 4]]}, "output": true}, {"input": {"edges": [[4, 10], [10, 2], [5, 6], [6, 5], [4, 8], [10, 5]]}, "output": true}, {"input": {"edges": [[10, 4], [5, 1], [5, 9]]}, "output": true}, {"input": {"edges": [[6, 4], [4, 1], [7, 1]]}, "output": true}, {"input": {"edges": [[4, 6], [9, 1], [2, 1], [9, 6], [3, 9]]}, "output": true}, {"input": {"edges": [[6, 10], [4, 9], [2, 5], [2, 7], [9, 2], [8, 4], [7, 4]]}, "output": true}, {"input": {"edges": [[3, 5], [1, 1], [8, 10], [4, 8]]}, "output": true}, {"input": {"edges": [[4, 6], [4, 7], [6, 2], [4, 1], [1, 3]]}, "output": true}, {"input": {"edges": [[3, 1], [7, 5], [6, 1], [2, 8]]}, "output": true}, {"input": {"edges": [[7, 8], [2, 7], [10, 7], [7, 10]]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Agfont/Advanced-Algorithms", "path": "/Support/Ayuda - Aina/1-dfs_compConex.py", "msgidx": 12685}}
{"problem_description": "Given a maze generated by a specific rule based on a \"favourite number\", you are tasked with finding the shortest path from the starting position (1, 1) to a specified destination within the maze. The maze is constructed such that each cell is either open or a wall, determined by the binary representation of a calculated value involving the coordinates and the favourite number. What is the minimum number of steps required to reach the destination, considering that the path should not exceed 50 steps?", "io_requirements": "Input:\n  `favourite_number` (int): A positive integer used to determine the structure of the maze.\n  `destination_pos` (list of int): A list containing two integers representing the x and y coordinates of the destination position in the maze.\n\nOutput:\n  `return` (int): The minimum number of steps required to reach the destination position from the starting position (1, 1), or `math.inf` if the destination is unreachable within 50 steps.", "refcode": "import math\n\n# Returns the valid neighbours, that are not out of bounds, to a current position\ndef get_neighbours(position):\n    old_x = position[0]\n    old_y = position[1]\n    neighbours = []\n    delta_movements = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for delta_movement in delta_movements:\n        d_x = delta_movement[0]\n        d_y = delta_movement[1]\n        new_x = old_x + d_x\n        new_y = old_y + d_y\n        # A long as both are positive then it is a valid position\n        if new_x > -1 and new_y > -1:\n            neighbours.append((new_x, new_y))\n\n    return neighbours\n\n# Returns True if specified position is not a wall\ndef is_open_pos(position, favourite_number):\n    x = position[0]\n    y = position[1]\n\n    wall_sum = x*x + 3*x + 2*x*y + y + y*y + favourite_number\n    binary_sum = str(bin(wall_sum))\n    # Count the number of 1's\n    one_count = 0\n    for bit in binary_sum:\n        if bit == '1':\n            one_count += 1\n    # Check if number of 1's is even\n    if one_count % 2 == 0:\n        return True\n    else:\n        return False\n\n# Returns true if a position is visited\ndef is_visited(position, visited: dict):\n    return visited.get(position, False)\n\n# Shortest path through the maze, from (0, 0) to a specified position\ndef shortest_path(current_pos, destination_pos, visited: dict, steps, favourite_number):\n    if steps > 50:\n        return math.inf\n\n    # if current position is destination, return steps\n    elif current_pos == destination_pos:\n        return steps\n\n    # Otherwise keep searching\n\n    # Add current position to visited\n    visited[current_pos] = True\n\n    neighbours = get_neighbours(current_pos)\n    next_steps = []\n\n    # Move in every direction\n    for neighbour in neighbours:\n        if is_open_pos(neighbour, favourite_number) and not is_visited(neighbour, visited):\n            next_steps.append(shortest_path(neighbour, destination_pos, visited.copy(), steps + 1, favourite_number))\n    # If you moved to a dead end, return infinity\n    if not next_steps:\n        return math.inf\n    # Return the minimum steps from moving in any direction\n    else:\n        return min(next_steps)\n\n# main function\ndef main_solution(favourite_number, destination_pos):\n    # Convert JSON serializable input to original input variables\n    destination_pos = tuple(destination_pos)\n\n    # Calculate the shortest path\n    steps = shortest_path((1, 1), destination_pos, {}, 0, favourite_number)\n\n    # Convert the output to JSON serializable\n    return steps", "funcname": "main_solution", "ios": [{"input": {"favourite_number": 382, "destination_pos": [49, 8]}, "output": Infinity}, {"input": {"favourite_number": 806, "destination_pos": [48, 37]}, "output": Infinity}, {"input": {"favourite_number": 98, "destination_pos": [29, 2]}, "output": Infinity}, {"input": {"favourite_number": 4, "destination_pos": [14, 40]}, "output": Infinity}, {"input": {"favourite_number": 281, "destination_pos": [12, 17]}, "output": Infinity}, {"input": {"favourite_number": 454, "destination_pos": [43, 1]}, "output": Infinity}, {"input": {"favourite_number": 399, "destination_pos": [7, 26]}, "output": 35}, {"input": {"favourite_number": 314, "destination_pos": [44, 21]}, "output": Infinity}, {"input": {"favourite_number": 690, "destination_pos": [22, 50]}, "output": Infinity}, {"input": {"favourite_number": 379, "destination_pos": [49, 43]}, "output": Infinity}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Erasimos/AoC_2016", "path": "/Day_13/Day_13.py", "msgidx": 12384}}
{"problem_description": "Alice is trying to determine the number of houses on her street based on her house number. She knows that the total number of houses `S` and her house number `N` are related by the formula `2*N**2 = S(S+1)`. Given a range of possible house numbers `low` to `high`, and a choice of search algorithm (`fast` or `slow`), what are the possible pairs of `(N, S)` that satisfy this relationship?", "io_requirements": "Input:\n- `low` (int): The lower bound for Alice's house number for the search.\n- `high` (int): The upper bound for Alice's house number for the search.\n- `alg` (str): The search algorithm to use, either 'fast' or 'slow'.\n- `showoddeven` (bool): A flag to show the odd and even parts in the fast search algorithm.\n\nOutput:\n- `return` (list of tuples): A list of tuples where each tuple contains two integers `(N, S)`. `N` is Alice's house number and `S` is the total number of houses on the street.", "refcode": "# import necessary packages\nimport math\nimport gmpy2\n\n# main function\ndef main_solution(low, high, alg, showoddeven):\n    # Convert JSON serializable inputs to original input variables\n    args = {\n        'low': low,\n        'high': high,\n        'alg': alg,\n        'showoddeven': showoddeven\n    }\n\n    class SearchBase:\n        def __init__(self, args):\n            self.args = args\n\n        def printFind(self, N, S, extraStr=''):\n            pass  # Remove print statements\n\n    class SlowSearch(SearchBase):\n        def search(self):\n            results = []\n            for N in range(self.args['low'], self.args['high']):\n                prod = 1 + 8 * N * N\n                if not gmpy2.is_square(prod):\n                    continue\n                root = math.isqrt(prod)\n                S = (root - 1) // 2\n                results.append((N, S))\n            return results\n\n    class FastSearch(SearchBase):\n        def search(self):\n            results = []\n            lolim = max(math.isqrt(self.args['low']), 3)\n            if lolim % 2 == 0:\n                lolim += 1\n            hilim = math.isqrt(2 * self.args['high'])\n\n            for oddnum in range(lolim, hilim, 2):\n                oddsq = oddnum * oddnum\n                for fix in [1, -1]:\n                    evensqdoub = oddsq + fix\n                    evensq = evensqdoub // 2\n                    if not gmpy2.is_square(evensq):\n                        continue\n                    evennum = math.isqrt(evensq)\n                    root = oddnum * evennum\n                    N = root\n                    if N > self.args['high']:\n                        return results\n                    S = min(oddsq, evensqdoub)\n                    results.append((N, S))\n                    break\n            return results\n\n    searcher = FastSearch(args) if args['alg'] == 'fast' else SlowSearch(args)\n    results = searcher.search()\n\n    # Convert results to JSON serializable output\n    return results", "funcname": "main_solution", "ios": [{"input": {"low": 387, "high": 5840488, "alg": "fast", "showoddeven": true}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449]]}, {"input": {"low": 915, "high": 4907399, "alg": "slow", "showoddeven": true}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449]]}, {"input": {"low": 236, "high": 3310857, "alg": "slow", "showoddeven": true}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449]]}, {"input": {"low": 796, "high": 6631448, "alg": "fast", "showoddeven": false}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449]]}, {"input": {"low": 611, "high": 7083093, "alg": "fast", "showoddeven": true}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449]]}, {"input": {"low": 493, "high": 9131592, "alg": "fast", "showoddeven": true}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449], [7997214, 11309768]]}, {"input": {"low": 980, "high": 2464527, "alg": "slow", "showoddeven": true}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449]]}, {"input": {"low": 357, "high": 577599, "alg": "slow", "showoddeven": false}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928]]}, {"input": {"low": 586, "high": 511496, "alg": "fast", "showoddeven": true}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928]]}, {"input": {"low": 766, "high": 1842533, "alg": "fast", "showoddeven": false}, "output": [[1189, 1681], [6930, 9800], [40391, 57121], [235416, 332928], [1372105, 1940449]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "criptik/puzcorner", "path": "/housenums.py", "msgidx": 12880}}
{"problem_description": "In a game of Tic Tac Toe, given a specific board state, what is the optimal next move for the current player?", "io_requirements": "Input:\n  `board_state` (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each element can be 'X', 'O', or None.\n\nOutput:\n  `return` (tuple): A tuple representing the optimal move (i, j) where i is the row index and j is the column index.", "refcode": "# import necessary packages\nimport math\nimport copy\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\nrows = 3\ncols = 3\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    xcount = sum(row.count(X) for row in board)\n    ocount = sum(row.count(O) for row in board)\n    return O if xcount > ocount else X\n\n# Function to get all possible actions\ndef actions(board):\n    return [(i, j) for i in range(rows) for j in range(cols) if board[i][j] == EMPTY]\n\n# Function to get the result of an action\ndef result(board, action):\n    if action not in actions(board):\n        raise ValueError('Invalid Action')\n    board_copy = copy.deepcopy(board)\n    board_copy[action[0]][action[1]] = player(board)\n    return board_copy\n\n# Function to determine the winner\ndef winner(board):\n    for i in range(rows):\n        if all(board[i][j] == X for j in range(cols)):\n            return X\n        if all(board[i][j] == O for j in range(cols)):\n            return O\n    for j in range(cols):\n        if all(board[i][j] == X for i in range(rows)):\n            return X\n        if all(board[i][j] == O for i in range(rows)):\n            return O\n    if all(board[i][i] == X for i in range(rows)) or all(board[i][rows - 1 - i] == X for i in range(rows)):\n        return X\n    if all(board[i][i] == O for i in range(rows)) or all(board[i][rows - 1 - i] == O for i in range(rows)):\n        return O\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or not any(EMPTY in row for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    return 1 if winner(board) == X else -1 if winner(board) == O else 0\n\n# Function to get the optimal action using minimax\ndef minimax(board):\n    if terminal(board):\n        return None\n    if player(board) == X:\n        return max_value(board)[1]\n    else:\n        return min_value(board)[1]\n\ndef max_value(board):\n    if terminal(board):\n        return utility(board), None\n    v = -math.inf\n    best_action = None\n    for action in actions(board):\n        min_val = min_value(result(board, action))[0]\n        if min_val > v:\n            v = min_val\n            best_action = action\n    return v, best_action\n\ndef min_value(board):\n    if terminal(board):\n        return utility(board), None\n    v = math.inf\n    best_action = None\n    for action in actions(board):\n        max_val = max_value(result(board, action))[0]\n        if max_val < v:\n            v = max_val\n            best_action = action\n    return v, best_action\n\n# main function\ndef main_solution(board_state):\n    \"\"\"\n    Determines the optimal next move for the current player on the given board state.\n    \n    Args:\n    board_state (list of lists): A 3x3 matrix representing the Tic Tac Toe board. Each element can be 'X', 'O', or None.\n    \n    Returns:\n    tuple: A tuple representing the optimal move (i, j) where i is the row index and j is the column index.\n    \"\"\"\n    return minimax(board_state)", "funcname": "main_solution", "ios": [{"input": {"board_state": [[null, null, null], [null, null, null], [null, null, null]]}, "output": [0, 0]}, {"input": {"board_state": [[null, null, "X"], [null, null, null], [null, null, null]]}, "output": [1, 1]}, {"input": {"board_state": [[null, null, null], [null, null, "O"], [null, "X", "X"]]}, "output": [0, 0]}, {"input": {"board_state": [[null, null, null], [null, null, null], [null, "X", null]]}, "output": [0, 1]}, {"input": {"board_state": [[null, "O", "X"], ["O", null, null], ["X", null, null]]}, "output": [1, 1]}, {"input": {"board_state": [["O", "X", "O"], ["X", null, "O"], ["X", null, "X"]]}, "output": [2, 1]}, {"input": {"board_state": [["O", "X", null], ["O", "X", null], [null, "O", "X"]]}, "output": [2, 0]}, {"input": {"board_state": [[null, null, null], ["O", null, null], ["X", "X", null]]}, "output": [0, 0]}, {"input": {"board_state": [["X", null, null], [null, null, null], [null, null, null]]}, "output": [1, 1]}, {"input": {"board_state": [["X", "O", null], [null, null, null], [null, "X", null]]}, "output": [2, 0]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jenny456/python-ai", "path": "/tictactoe/tictactoe.py", "msgidx": 12212}}
{"problem_description": "Given a hierarchical structure of a company represented as a binary tree, where each node represents a manager and the value of the node represents the manager's tenure in the company, what is the tenure of the manager whose team has the highest average tenure?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the binary tree structure. Each node is represented as a dictionary with keys `'val'` (int), `'left'` (dict or None), and `'right'` (dict or None).\n\nOutput:\n  `return` (int): The value of the node with the highest average team tenure in the tree.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def __init__(self):\n        self.maxExperience = -float('inf')\n        self.nodeWithMaxExperience =  -float('inf')\n\n    def findMostExperiencedTeam(self, tree):\n        def fmetUtil(tree):\n            if tree is None:\n                return [0, 0]\n\n            if tree.left is None and tree.right is None:\n                return [tree.val, 1]\n\n            leftSum, leftCount = fmetUtil(tree.left)\n            rightSum, rightCount = fmetUtil(tree.right)\n\n            currExp = (leftSum + rightSum + tree.val) / (leftCount + rightCount + 1)\n\n            if currExp > self.maxExperience:\n                self.maxExperience = currExp\n                self.nodeWithMaxExperience = tree.val\n\n            return [leftSum + rightSum + tree.val, leftCount + rightCount + 1]\n\n        fmetUtil(tree)\n        return self.nodeWithMaxExperience\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        root = TreeNode(data['val'])\n        root.left = build_tree(data['left'])\n        root.right = build_tree(data['right'])\n        return root\n\n    tree = build_tree(tree_structure)\n    solution = Solution()\n    result = solution.findMostExperiencedTeam(tree)\n    \n    # Convert the result to a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 14, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 15, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 17, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 7, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 11, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 2, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 9, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 12, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 16, "left": null, "right": null}}, "output": -Infinity}, {"input": {"tree_structure": {"val": 8, "left": null, "right": null}}, "output": -Infinity}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "deepika087/CompetitiveProgramming", "path": "/GeneralPractice/Amazon 2020| Oldest team.py", "msgidx": 11847}}
{"problem_description": "In a chessboard of size `n x n`, how many ways can `n` queens be placed such that no two queens threaten each other? Additionally, given a list of distances `D`, how many ways can a set of points be reconstructed such that the distances between all pairs of points match the given list? What are the total number of solutions for both problems?", "io_requirements": "Input:\n  `n` (int): The number of queens for the N-Queens problem.\n  `D` (list of int): A list of distances for the Turnpike Reconstruction problem.\n\nOutput:\n  `return` (dict): A dictionary containing the results of both problems.\n    - `queen_solution` (int): The number of solutions for the N-Queens problem.\n    - `turnpike_solution` (int): The number of solutions for the Turnpike Reconstruction problem.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Queen:\n    def __init__(self, n):\n        self.x = x = [-1 for i in range(n)]\n        self.S = S = {i for i in range(n)}\n        self.result = self.Queen(n, S, x)\n\n    def check(self, x, j, arranged_queen_num):\n        for i in range(arranged_queen_num - 1):\n            tmp = (x[i] - j) / (i - arranged_queen_num + 1)\n            if tmp == 1 or tmp == -1:\n                return False\n        return True\n\n    def Queen(self, n, S, x):\n        if len(S) == 0:\n            return 1\n        else:\n            result = 0\n            for col in S:\n                x[n - len(S)] = col\n                S.remove(col)\n                if self.check(x, col, n - len(S)):\n                    result += self.Queen(n, S, x)\n                S.add(col)\n                x[n - len(S)] = -1\n            return result\n\nclass TurnpikeReconstruction:\n    def __init__(self, D):\n        N = (1 + math.sqrt(1 + 8 * len(D))) / 2\n        N = int(N)\n        x = [-1 for i in range(N)]\n        x[0] = 0\n        self.solution = self.reconstruction(D, x, 1, N - 1)\n\n    def check_and_delete_upper_bound(self, D, x, l, u):\n        tmp = []\n        for i in x[0:l]:\n            d = x[u] - i\n            if d not in D:\n                for elem in tmp:\n                    D.append(elem)\n                return False\n            else:\n                tmp.append(d)\n                D.remove(d)\n        for i in x[u + 1:]:\n            d = i - x[u]\n            if d not in D:\n                for elem in tmp:\n                    D.append(elem)\n                return False\n            else:\n                tmp.append(d)\n                D.remove(d)\n        return True\n\n    def check_and_delete_lower_bound(self, D, x, l, u):\n        tmp = []\n        for i in x[0:l]:\n            d = x[l] - i\n            if d not in D:\n                for elem in tmp:\n                    D.append(elem)\n                return False\n            else:\n                tmp.append(d)\n                D.remove(d)\n        for i in x[u + 1:]:\n            d = i - x[l]\n            if d not in D:\n                for elem in tmp:\n                    D.append(elem)\n                return False\n            else:\n                tmp.append(d)\n                D.remove(d)\n        return True\n\n    def reconstruction(self, D, x, l, u):\n        if l > u:\n            return 1\n        else:\n            solution = 0\n            x[u] = max(D)\n            if self.check_and_delete_upper_bound(D, x, l, u):\n                solution += self.reconstruction(D, x, l, u - 1)\n                for i in x[0:l]:\n                    d = x[u] - i\n                    D.append(d)\n                for i in x[u + 1:]:\n                    d = i - x[u]\n                    D.append(d)\n            x[u] = -1\n\n            x[l] = x[len(x) - 1] - max(D)\n            if self.check_and_delete_lower_bound(D, x, l, u):\n                solution += self.reconstruction(D, x, l + 1, u)\n                for i in x[0:l]:\n                    d = x[l] - i\n                    D.append(d)\n                for i in x[u + 1:]:\n                    d = i - x[l]\n                    D.append(d)\n            x[l] = -1\n            return solution\n\n# main function\ndef main_solution(n, D):\n    # Convert input variables if necessary\n    n = int(n)\n    D = list(D)\n\n    # Solve the N-Queens problem\n    queen_solution = Queen(n).result\n\n    # Solve the Turnpike Reconstruction problem\n    turnpike_solution = TurnpikeReconstruction(D).solution\n\n    # Return the results as a dictionary\n    return {\n        \"queen_solution\": queen_solution,\n        \"turnpike_solution\": turnpike_solution\n    }", "funcname": "main_solution", "ios": [{"input": {"n": 4, "D": [1, 3, 1, 2, 1, 2]}, "output": {"queen_solution": 12, "turnpike_solution": 2}}, {"input": {"n": 4, "D": [1, 3, 1, 1, 2, 2]}, "output": {"queen_solution": 12, "turnpike_solution": 2}}, {"input": {"n": 6, "D": [1, 1, 2, 3, 2, 2, 1, 1, 5, 1, 4, 3, 2, 3, 4]}, "output": {"queen_solution": 26, "turnpike_solution": 4}}, {"input": {"n": 4, "D": [2, 1, 3, 1, 2, 1]}, "output": {"queen_solution": 12, "turnpike_solution": 2}}, {"input": {"n": 5, "D": [2, 1, 3, 1, 2, 1, 4, 2, 3, 1]}, "output": {"queen_solution": 45, "turnpike_solution": 4}}, {"input": {"n": 6, "D": [5, 2, 2, 1, 4, 2, 1, 3, 2, 1, 3, 1, 4, 3, 1]}, "output": {"queen_solution": 26, "turnpike_solution": 4}}, {"input": {"n": 6, "D": [3, 2, 3, 2, 4, 1, 4, 1, 5, 2, 1, 2, 1, 3, 1]}, "output": {"queen_solution": 26, "turnpike_solution": 4}}, {"input": {"n": 6, "D": [1, 2, 1, 1, 3, 4, 2, 2, 4, 5, 3, 2, 3, 1, 1]}, "output": {"queen_solution": 26, "turnpike_solution": 4}}, {"input": {"n": 6, "D": [3, 2, 4, 3, 5, 2, 1, 1, 2, 2, 3, 1, 1, 4, 1]}, "output": {"queen_solution": 26, "turnpike_solution": 4}}, {"input": {"n": 4, "D": [1, 1, 2, 2, 1, 3]}, "output": {"queen_solution": 12, "turnpike_solution": 2}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ZheWang711/DataStructures_in_Python", "path": "/back_trace.py", "msgidx": 12128}}
{"problem_description": "A security system uses a keypad with digits arranged in a specific pattern. When a user enters a PIN, the system records the observed digits but cannot distinguish between the actual digit and its adjacent digits due to a fault in the recording mechanism. Given the observed PIN, what are all the possible PINs that could have been entered by the user, considering the adjacency of the digits on the keypad?", "io_requirements": "Input:\n  `observed` (str): A string representing the observed PIN. Each character in the string corresponds to a digit on a keypad.\n\nOutput:\n  `return` (list of str): A list of strings representing all possible PINs that could be formed from the observed PIN, considering adjacent digits on the keypad.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(observed):\n  # observed (str): A string representing the observed PIN.\n  \n  keypad = {\n    '1': ['1', '2', '4'],\n    '2': ['1', '2', '3', '5'],\n    '3': ['2', '3', '6'],\n    '4': ['1', '4', '5', '7'],\n    '5': ['2', '4', '5', '6', '8'],\n    '6': ['3', '5', '6', '9'],\n    '7': ['4', '7', '8'],\n    '8': ['0', '5', '7', '8', '9'],\n    '9': ['6', '8', '9'],\n    '0': ['0', '8']\n  }\n  \n  code = [keypad[digit] for digit in observed]\n  code = list(itertools.product(*code))\n  code = [''.join(e) for e in code]\n  \n  # return, the returned value must be json serializable (list of strings)\n  return code", "funcname": "main_solution", "ios": [{"input": {"observed": "72"}, "output": ["41", "42", "43", "45", "71", "72", "73", "75", "81", "82", "83", "85"]}, {"input": {"observed": "6"}, "output": ["3", "5", "6", "9"]}, {"input": {"observed": "0"}, "output": ["0", "8"]}, {"input": {"observed": "7"}, "output": ["4", "7", "8"]}, {"input": {"observed": "80"}, "output": ["00", "08", "50", "58", "70", "78", "80", "88", "90", "98"]}, {"input": {"observed": "1"}, "output": ["1", "2", "4"]}, {"input": {"observed": "05"}, "output": ["02", "04", "05", "06", "08", "82", "84", "85", "86", "88"]}, {"input": {"observed": "49"}, "output": ["16", "18", "19", "46", "48", "49", "56", "58", "59", "76", "78", "79"]}, {"input": {"observed": "5"}, "output": ["2", "4", "5", "6", "8"]}, {"input": {"observed": "17"}, "output": ["14", "17", "18", "24", "27", "28", "44", "47", "48"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "KoryHunter37/code-mastery", "path": "/python/codewars/the-observed-pin/solution.py", "msgidx": 12886}}
{"problem_description": "Given a positive integer that encodes a set S, where each bit in the binary representation of the integer corresponds to a specific element in the set, determine the positive integer that encodes the set of running sums of the members of S when those are listed in increasing order. What is the derived encoded set?", "io_requirements": "Input:\n  `encoded_set` (int): A positive integer that encodes a set S as described in the problem statement.\n\nOutput:\n  `return` (int): A positive integer that encodes the set of running sums of the members of S when those are listed in increasing order.", "refcode": "# import necessary packages\nfrom itertools import accumulate\n\n# all class and function definitions in the code file, if any\ndef encode_list(encoded_set):\n    bin_str = bin(encoded_set)[2:]\n    str_length = len(bin_str)\n    res_lis = []\n    for i in range(str_length):\n        if i % 2 == 0 and bin_str[-(i + 1)] == '1':\n            c = i // 2\n            res_lis.append(c)\n        elif bin_str[-(i + 1)] == '1':\n            c = -i // 2\n            res_lis.append(c)\n    res_lis.sort()\n    return res_lis\n\ndef code_derived_set(encoded_set):\n    encoded_running_sum = 0\n    lis = encode_list(encoded_set)\n    tem_sum = 0\n    tem_lis = []\n    for i in range(len(lis)):\n        tem_sum += lis[i]\n        if tem_sum not in tem_lis:\n            tem_lis.append(tem_sum)\n        else:\n            continue\n        if tem_sum < 0:\n            encoded_running_sum += 2 ** (- tem_sum * 2 - 1)\n        else:\n            encoded_running_sum += 2 ** (tem_sum * 2)\n    return encoded_running_sum\n\n# main function\ndef main_solution(encoded_set):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    encoded_set = int(encoded_set)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return code_derived_set(encoded_set)", "funcname": "main_solution", "ios": [{"input": {"encoded_set": 212105}, "output": 38324588035309568}, {"input": {"encoded_set": 446735}, "output": 696321720328}, {"input": {"encoded_set": 808612}, "output": 11135240114208}, {"input": {"encoded_set": 399088}, "output": 2373105877760}, {"input": {"encoded_set": 856735}, "output": 11133126181632}, {"input": {"encoded_set": 367292}, "output": 47886067988201480}, {"input": {"encoded_set": 466763}, "output": 44532924285504}, {"input": {"encoded_set": 999697}, "output": 146067163152}, {"input": {"encoded_set": 27881}, "output": 9492045504512}, {"input": {"encoded_set": 389002}, "output": 46839830870105423873}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhendeliu/unsw-2019-t1", "path": "/unsw-it-9021/python-code/quiz5/quiz_5.py", "msgidx": 12421}}
{"problem_description": "In a large maze, a robot is programmed to move according to a specific pattern described by a string. The robot can move north ('N'), east ('E'), south ('S'), or west ('W'), and the pattern can include parentheses for grouping and pipes for alternation. Given the movement pattern, how many steps are required to reach the furthest room from the starting point, and how many rooms are more than 1000 steps away from the starting point?", "io_requirements": "Input:\n  `regex` (str): A string representing the movement pattern of a robot. The string can contain characters 'N', 'E', 'S', 'W' for north, east, south, and west respectively, and parentheses '(', ')' and pipe '|' for grouping and alternation.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `furthest_room` (int): The maximum number of steps required to reach any room from the starting point.\n    - `rooms_more_than_1000_steps` (int): The number of rooms that are more than 1000 steps away from the starting point.", "refcode": "# import necessary packages\nfrom collections import defaultdict\nimport typing\n\n# all class and function definitions in the code file, if any\ndef extract_data(regex: str) -> typing.Dict[typing.Tuple[int, int], int]:\n    letter_to_move = {\n        'N': (0, -1),\n        'E': (1, 0),\n        'S': (0, 1),\n        'W': (-1, 0)\n    }\n\n    positions = []\n    x, y = 5000, 5000\n    came_from = defaultdict(set)\n    prev_x, prev_y = x, y\n    distances = defaultdict(int)\n    for c in regex[1:-1]:\n        if c == \"(\":\n            positions.append((x, y))\n        elif c == \")\":\n            x, y = positions.pop()\n        elif c == \"|\":\n            x, y = positions[-1]\n        else:\n            dx, dy = letter_to_move[c]\n            x += dx\n            y += dy\n            came_from[(x, y)].add((prev_x, prev_y))\n            if distances[(x, y)] != 0:\n                distances[(x, y)] = min(distances[(x, y)], distances[(prev_x, prev_y)] + 1)\n            else:\n                distances[(x, y)] = distances[(prev_x, prev_y)] + 1\n\n        prev_x, prev_y = x, y\n\n    return distances\n\ndef furthest_room(distances: typing.Dict[typing.Tuple[int, int], int]) -> int:\n    return max(distances.values())\n\ndef furthest_room_more_than_10000(distances: typing.Dict[typing.Tuple[int, int], int]) -> int:\n    return len(list(filter(lambda x: distances[x] >= 1000, distances)))\n\n# main function\ndef main_solution(regex: str) -> typing.Dict[str, int]:\n    # Convert input to JSON serializable format\n    distances = extract_data(regex)\n    \n    # Calculate the furthest room and the number of rooms more than 1000 steps away\n    furthest = furthest_room(distances)\n    more_than_10000 = furthest_room_more_than_10000(distances)\n    \n    # Return the results in a JSON serializable format\n    return {\n        \"furthest_room\": furthest,\n        \"rooms_more_than_1000_steps\": more_than_10000\n    }", "funcname": "main_solution", "ios": [{"input": {"regex": "^W(S|N|N)N(N|W)WWS(W|S|N)S(E)S(N|S|N)N(W|S)WW$"}, "output": {"furthest_room": 8, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^NNE(W)SW(E|E)N(W|E|W)S(N)SW(W)E(E|W)$"}, "output": {"furthest_room": 4, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^NEN(E)E(W|S)WW(W|S)W(W|W)WS(S|N|N)E(W|N)E(W|S)E(W|S|W)S(W)W(N|N)E(W|W)EN(S|W)$"}, "output": {"furthest_room": 8, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^N(E)E(E|N|N)EESW(E)SN(E|W|N)NN(S)N(W)EN(E|S|W)$"}, "output": {"furthest_room": 8, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^E(W)N(S)W(E|S)W(N)S(N|S|N)NNN(N)WSSE$"}, "output": {"furthest_room": 9, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^W(S|N|N)SWEN(N|E|W)SNEE(W|N|W)WWWS(E)SWEN(N|E|S)SW$"}, "output": {"furthest_room": 5, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^S(N|W|W)WN(N|W|E)SEW(E|N)N(W)N(W)EW(S)$"}, "output": {"furthest_room": 5, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^WSN(E|W)SN(E)S(W|N|N)E(W|W|N)WW(E)W(W)S(W)S(N|E)N(W|E|E)NSE(E|N|S)SW(E)E(E|S|E)$"}, "output": {"furthest_room": 8, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^SEW(W|E|S)S(W|W)NEWNNEEN(N)W(E|W)S$"}, "output": {"furthest_room": 8, "rooms_more_than_1000_steps": 0}}, {"input": {"regex": "^S(S|S)S(N|N|S)SN(N|N|W)SEEWSWW(S|E|E)EEWN(E|N|E)E(S)$"}, "output": {"furthest_room": 8, "rooms_more_than_1000_steps": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "artrey/adventofcode2018", "path": "/day20/main.py", "msgidx": 12712}}
{"problem_description": "Given a string consisting of English letters, how can we generate all possible unique permutations of the string, considering that the string may contain duplicate characters?", "io_requirements": "Input:\n  `S` (str): A string containing only English letters. The length of the string is between 1 and 9.\n\nOutput:\n  `return` (list[str]): A list of strings, where each string is a unique permutation of the input string `S`.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(S):\n    \"\"\"\n    Generate all unique permutations of a given string with duplicate characters.\n\n    Args:\n    S (str): The input string containing only English letters.\n\n    Returns:\n    list[str]: A list of all unique permutations of the input string.\n    \"\"\"\n    # Generate all permutations of the string\n    permutations = set(itertools.permutations(S))\n    # Convert each permutation tuple to a string\n    unique_permutations = [\"\".join(p) for p in permutations]\n    return unique_permutations", "funcname": "main_solution", "ios": [{"input": {"S": "AE"}, "output": ["EA", "AE"]}, {"input": {"S": "GrP"}, "output": ["PGr", "rGP", "rPG", "PrG", "GrP", "GPr"]}, {"input": {"S": "g"}, "output": ["g"]}, {"input": {"S": "NE"}, "output": ["NE", "EN"]}, {"input": {"S": "fIS"}, "output": ["IfS", "SfI", "fIS", "ISf", "fSI", "SIf"]}, {"input": {"S": "i"}, "output": ["i"]}, {"input": {"S": "fmU"}, "output": ["fUm", "fmU", "mUf", "Umf", "Ufm", "mfU"]}, {"input": {"S": "W"}, "output": ["W"]}, {"input": {"S": "ogF"}, "output": ["goF", "Fog", "gFo", "oFg", "ogF", "Fgo"]}, {"input": {"S": "uiz"}, "output": ["iuz", "uzi", "uiz", "zui", "izu", "ziu"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "SimmonsChen/LeetCode", "path": "/\u56de\u6eaf/\u9762\u8bd5\u9898 08.08. \u6709\u91cd\u590d\u5b57\u7b26\u4e32\u7684\u6392\u5217\u7ec4\u5408.py", "msgidx": 12848}}
{"problem_description": "Given the preorder and inorder traversal sequences of a binary tree, can you reconstruct the structure of the binary tree and provide its serialized representation? The preorder and inorder traversal sequences are provided as JSON serialized lists of integers.", "io_requirements": "Input:\n  `preorder` (str): A JSON serialized list of integers representing the preorder traversal of a binary tree.\n  `inorder` (str): A JSON serialized list of integers representing the inorder traversal of the same binary tree.\nOutput:\n  `return` (str): A JSON serialized list representing the serialized binary tree. Each element in the list is either an integer (node value) or `null` (indicating a missing node).", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Function to serialize a tree into a list\ndef serialize_tree(root):\n    if not root:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node:\n            result.append(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            result.append(None)\n    # Remove trailing None values\n    while result and result[-1] is None:\n        result.pop()\n    return result\n\n# Function to build a tree from preorder and inorder traversals\nclass Solution:\n    def buildTree(self, preorder, inorder):\n        if len(preorder) == 0:\n            return None\n        # Get the root from the preorder list\n        root_val = preorder[0]\n        root = TreeNode(root_val)\n\n        # Find the index of the root in the inorder list\n        index = inorder.index(root_val)\n\n        # Split the inorder list into left and right subtrees\n        inorder_left = inorder[:index]\n        inorder_right = inorder[index+1:]\n\n        # Split the preorder list into left and right subtrees\n        preorder_left = preorder[1:1+len(inorder_left)]\n        preorder_right = preorder[1+len(inorder_left):]\n\n        # Recursively build the left and right subtrees\n        root.left = self.buildTree(preorder_left, inorder_left)\n        root.right = self.buildTree(preorder_right, inorder_right)\n\n        return root\n\n# main function\ndef main_solution(preorder, inorder):\n    # Convert input lists to JSON serializable format\n    preorder = json.loads(preorder)\n    inorder = json.loads(inorder)\n\n    # Build the tree\n    solution = Solution()\n    root = solution.buildTree(preorder, inorder)\n\n    # Serialize the tree into a list\n    serialized_tree = serialize_tree(root)\n\n    # Return the serialized tree\n    return json.dumps(serialized_tree)", "funcname": "main_solution", "ios": [{"input": {"preorder": "[24]", "inorder": "[24]"}, "output": "[24]"}, {"input": {"preorder": "[76, 1, 75, 92, 6, 64, 21]", "inorder": "[75, 1, 92, 76, 64, 6, 21]"}, "output": "[76, 1, 6, 75, 92, 64, 21]"}, {"input": {"preorder": "[18, 70, 48]", "inorder": "[70, 18, 48]"}, "output": "[18, 70, 48]"}, {"input": {"preorder": "[35, 59, 87, 4, 90, 100, 85, 3, 38, 67, 36, 77, 20, 1, 82]", "inorder": "[4, 87, 90, 59, 85, 100, 3, 35, 36, 67, 77, 38, 1, 20, 82]"}, "output": "[35, 59, 38, 87, 100, 67, 20, 4, 90, 85, 3, 36, 77, 1, 82]"}, {"input": {"preorder": "[88, 53, 31, 57, 21, 99, 14, 37, 15, 33, 62, 56, 20, 79, 65]", "inorder": "[57, 31, 21, 53, 14, 99, 37, 88, 62, 33, 56, 15, 79, 20, 65]"}, "output": "[88, 53, 15, 31, 99, 33, 20, 57, 21, 14, 37, 62, 56, 79, 65]"}, {"input": {"preorder": "[23]", "inorder": "[23]"}, "output": "[23]"}, {"input": {"preorder": "[87, 69, 41]", "inorder": "[69, 87, 41]"}, "output": "[87, 69, 41]"}, {"input": {"preorder": "[51, 69, 6]", "inorder": "[69, 51, 6]"}, "output": "[51, 69, 6]"}, {"input": {"preorder": "[2]", "inorder": "[2]"}, "output": "[2]"}, {"input": {"preorder": "[23, 44, 29]", "inorder": "[44, 23, 29]"}, "output": "[23, 44, 29]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Linkney/LeetCode", "path": "/SwordOffer/O07.py", "msgidx": 12283}}
{"problem_description": "Given a string composed of lowercase alphabetic characters, what are all the possible unique arrangements of the characters in the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should be composed of characters without spaces or special characters.\n\nOutput:\n  `return` (list of str): A list of all possible permutations of the input string. Each permutation is represented as a string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef swap(str_list, i, j):\n    tem = str_list[i]\n    str_list[i] = str_list[j]\n    str_list[j] = tem\n\ndef permutation(str_list, start):\n    if str_list is None or start < 0:\n        return False\n    if start == len(str_list) - 1:\n        return [''.join(str_list)]\n    else:\n        permutations = []\n        i = start\n        while i < len(str_list):\n            swap(str_list, start, i)\n            permutations.extend(permutation(str_list, start + 1))\n            swap(str_list, start, i)\n            i += 1\n        return permutations\n\n# main function\ndef main_solution(input_string):\n  # Convert the input string to a list for manipulation\n  str_list = list(input_string)\n  \n  # Get all permutations of the input string\n  permutations = permutation(str_list, 0)\n  \n  # Return the permutations as a list of strings\n  return permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "vwd"}, "output": ["vwd", "vdw", "wvd", "wdv", "dwv", "dvw"]}, {"input": {"input_string": "ybh"}, "output": ["ybh", "yhb", "byh", "bhy", "hby", "hyb"]}, {"input": {"input_string": "zqc"}, "output": ["zqc", "zcq", "qzc", "qcz", "cqz", "czq"]}, {"input": {"input_string": "iko"}, "output": ["iko", "iok", "kio", "koi", "oki", "oik"]}, {"input": {"input_string": "dqc"}, "output": ["dqc", "dcq", "qdc", "qcd", "cqd", "cdq"]}, {"input": {"input_string": "hhk"}, "output": ["hhk", "hkh", "hhk", "hkh", "khh", "khh"]}, {"input": {"input_string": "alf"}, "output": ["alf", "afl", "laf", "lfa", "fla", "fal"]}, {"input": {"input_string": "ift"}, "output": ["ift", "itf", "fit", "fti", "tfi", "tif"]}, {"input": {"input_string": "jvr"}, "output": ["jvr", "jrv", "vjr", "vrj", "rvj", "rjv"]}, {"input": {"input_string": "rrt"}, "output": ["rrt", "rtr", "rrt", "rtr", "trr", "trr"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "liubaokai/pythonlianxi", "path": "/lianxi/class.py", "msgidx": 12833}}
{"problem_description": "Given an N x N matrix filled with values representing different types of cells (source, destination, blank, and blank wall), determine if there is a path from the source to the destination that only traverses through blank cells. The matrix contains exactly one source and one destination. What is the result of the path traversal?", "io_requirements": "Input:\n  `matrix` (list of lists of integers): A 2D list representing the N x N matrix. Each element in the matrix can be 0, 1, 2, or 3. \n  - `1` represents the source.\n  - `2` represents the destination.\n  - `3` represents a blank cell.\n  - `0` represents a blank wall.\n\nOutput:\n  `return` (boolean): `True` if there is a path from the source to the destination, traversing through blank cells only. `False` otherwise.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# all class and function definitions in the code file, if any\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def BFS(self, s, d):\n        if s == d:\n            return True\n\n        visited = [False] * (self.n * self.n + 1)\n\n        q = []\n        q.append(s)\n\n        visited[s] = True\n\n        while q:\n            u = q.pop(0)\n\n            for i in self.graph[u]:\n                if i == d:\n                    return True\n                if visited[i] == False:\n                    q.append(i)\n                    visited[i] = True\n\n        return False\n\ndef isSafe(i, j, mat):\n    return i >= 0 and i < len(mat) and j >= 0 and j < len(mat[0])\n\n# main function\ndef main_solution(matrix):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    s, d = None, None\n    N = len(matrix)\n    g = Graph(N)\n\n    k = 1\n\n    for i in range(N):\n        for j in range(N):\n            if matrix[i][j] != 0:\n                if isSafe(i, j + 1, matrix):\n                    g.add_edge(k, k + 1)\n                if isSafe(i, j - 1, matrix):\n                    g.add_edge(k, k - 1)\n                if isSafe(i - 1, j, matrix):\n                    g.add_edge(k, k - N)\n                if isSafe(i + 1, j, matrix):\n                    g.add_edge(k, k + N)\n\n            if matrix[i][j] == 1:\n                s = k\n            if matrix[i][j] == 2:\n                d = k\n            k += 1\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return g.BFS(s, d)", "funcname": "main_solution", "ios": [{"input": {"matrix": [[3, 0, 3], [0, 1, 0], [0, 2, 3]]}, "output": true}, {"input": {"matrix": [[0, 2, 1, 0], [0, 3, 0, 1], [2, 3, 3, 0], [2, 0, 1, 1]]}, "output": true}, {"input": {"matrix": [[0, 1, 1, 2], [0, 3, 2, 3], [2, 0, 0, 1], [1, 1, 3, 2]]}, "output": true}, {"input": {"matrix": [[3, 2, 1], [2, 2, 0], [2, 2, 0]]}, "output": true}, {"input": {"matrix": [[2, 1, 2, 2], [1, 0, 2, 1], [1, 1, 1, 0], [2, 0, 2, 0]]}, "output": true}, {"input": {"matrix": [[3, 0, 1], [2, 2, 1], [0, 3, 3]]}, "output": true}, {"input": {"matrix": [[1, 1, 0, 1], [2, 2, 1, 2], [2, 3, 2, 0], [1, 3, 1, 3]]}, "output": true}, {"input": {"matrix": [[1, 0, 3, 0], [3, 3, 0, 1], [1, 0, 3, 0], [0, 0, 2, 0]]}, "output": false}, {"input": {"matrix": [[3, 1, 0], [1, 1, 0], [2, 1, 0]]}, "output": true}, {"input": {"matrix": [[0, 0, 0, 3], [1, 0, 0, 3], [1, 0, 0, 1], [0, 2, 3, 0]]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Rahul7656/Coding", "path": "/GeeksforGeeks/Graph/17.FindWhetherPathExistsBwTwoCellsMatrix.py", "msgidx": 12780}}
{"problem_description": "Given a rectangular board with some cells marked as 'X' and others as 'O', determine the final state of the board after all 'O's that are not connected to the border are replaced with 'X'. What will be the final configuration of the board?", "io_requirements": "Input:\n  `board` (List[List[str]]): A 2D list representing the board where each element is either 'X' or 'O'. The board is rectangular, with all rows having the same length.\n\nOutput:\n  `return` (List[List[str]]): A 2D list representing the modified board where all 'O's that are not connected to the border are replaced with 'X'.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass UnionFind:\n    def __init__(self, n):\n        self.uf = [-1] * (n + 1)\n        self.sets_count = n\n\n    def find(self, p):\n        if self.uf[p] < 0:\n            return p\n        self.uf[p] = self.find(self.uf[p])\n        return self.uf[p]\n\n    def union(self, p, q):\n        p_root = self.find(p)\n        q_root = self.find(q)\n        if p_root == q_root:\n            return\n        if self.uf[p_root] > self.uf[q_root]:\n            self.uf[q_root] += self.uf[p_root]\n            self.uf[p_root] = q_root\n        else:\n            self.uf[p_root] += self.uf[q_root]\n            self.uf[q_root] = p_root\n        self.sets_count -= 1\n\n    def is_connected(self, p, q):\n        return self.find(p) == self.find(q)\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        if not board or not board[0]:\n            return\n        m, n = len(board), len(board[0])\n        uf = UnionFind(m * n)\n        dummy = m * n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    ind = i * n + j\n                    if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                        uf.union(ind, dummy)\n                    if i != m - 1 and j != n - 1:\n                        if board[i][j + 1] == 'O':\n                            uf.union(ind, ind + 1)\n                        if board[i + 1][j] == 'O':\n                            uf.union(ind, ind + n)\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and not uf.is_connected(i * n + j, dummy):\n                    board[i][j] = 'X'\n\n# main function\ndef main_solution(board: List[List[str]]) -> List[List[str]]:\n    # Convert input to JSON serializable format\n    solution = Solution()\n    solution.solve(board)\n    # Convert output to JSON serializable format\n    return board", "funcname": "main_solution", "ios": [{"input": {"board": [["X", "X", "O"], ["O", "X", "X"], ["X", "O", "X"], ["O", "O", "X"], ["O", "X", "O"]]}, "output": [["X", "X", "O"], ["O", "X", "X"], ["X", "O", "X"], ["O", "O", "X"], ["O", "X", "O"]]}, {"input": {"board": [["O", "X", "O", "X"], ["X", "X", "O", "X"], ["O", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "X", "X", "X"]]}, "output": [["O", "X", "O", "X"], ["X", "X", "O", "X"], ["O", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "X", "X", "X"], ["X", "X", "X", "X"]]}, {"input": {"board": [["X", "X", "O", "X", "X"], ["X", "X", "X", "X", "X"], ["O", "X", "X", "X", "O"], ["X", "X", "X", "O", "O"]]}, "output": [["X", "X", "O", "X", "X"], ["X", "X", "X", "X", "X"], ["O", "X", "X", "X", "O"], ["X", "X", "X", "O", "O"]]}, {"input": {"board": [["O", "X", "X"], ["O", "X", "X"], ["X", "X", "O"], ["X", "X", "O"], ["X", "X", "X"], ["X", "X", "X"]]}, "output": [["O", "X", "X"], ["O", "X", "X"], ["X", "X", "O"], ["X", "X", "O"], ["X", "X", "X"], ["X", "X", "X"]]}, {"input": {"board": [["X", "O", "O"], ["O", "X", "X"], ["O", "X", "X"], ["O", "X", "X"]]}, "output": [["X", "O", "O"], ["O", "X", "X"], ["O", "X", "X"], ["O", "X", "X"]]}, {"input": {"board": [["O", "X", "X", "O", "O", "O"], ["X", "X", "O", "O", "X", "X"], ["X", "X", "X", "O", "X", "O"], ["X", "O", "X", "X", "X", "O"]]}, "output": [["O", "X", "X", "O", "O", "O"], ["X", "X", "O", "O", "X", "X"], ["X", "X", "X", "O", "X", "O"], ["X", "O", "X", "X", "X", "O"]]}, {"input": {"board": [["X", "X", "X"], ["X", "X", "X"], ["O", "X", "X"], ["O", "X", "O"]]}, "output": [["X", "X", "X"], ["X", "X", "X"], ["O", "X", "X"], ["O", "X", "O"]]}, {"input": {"board": [["O", "X", "X"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "O"], ["X", "X", "O"]]}, "output": [["O", "X", "X"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "O"], ["X", "X", "O"]]}, {"input": {"board": [["O", "X", "O", "X", "X", "X"], ["O", "O", "X", "X", "X", "X"], ["X", "X", "O", "X", "X", "X"]]}, "output": [["O", "X", "O", "X", "X", "X"], ["O", "O", "X", "X", "X", "X"], ["X", "X", "O", "X", "X", "X"]]}, {"input": {"board": [["O", "O", "O"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "X"]]}, "output": [["O", "O", "O"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "X"], ["X", "X", "X"]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hrz123/algorithm010", "path": "/Week07/130. \u88ab\u56f4\u7ed5\u7684\u533a\u57df.py", "msgidx": 12493}}
{"problem_description": "Given a 2D rectangular height map of a continent, where each cell represents the height of the terrain, determine the grid points where water can flow to both the Pacific and Atlantic oceans. The Pacific Ocean touches the left and top edges of the map, while the Atlantic Ocean touches the right and bottom edges. Water can only flow from a cell to another cell with an equal or lower height. What are the coordinates of the grid points where water can flow to both oceans?", "io_requirements": "Input:\n  `height_map` (list of lists of integers): A 2D rectangular array representing the height map of a continent. Each element in the array is a positive integer indicating the height of the corresponding grid point.\n\nOutput:\n  `return` (list of tuples): A list of coordinates (each coordinate is a tuple of two integers) representing the grid points where water can flow to both the Pacific and Atlantic oceans. Each tuple contains two integers, the first representing the column index and the second representing the row index.", "refcode": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\nNEIGHBOURS = (\n    (-1, 0),\n    (1, 0),\n    (0, -1),\n    (0, 1)\n)\n\ndef get_neighbours(pos, flow):\n    h, w = len(flow), len(flow[0])\n    valid_neigh = []\n    for i, j in NEIGHBOURS:\n        next_pos = pos[0] + i, pos[1] + j\n        if 0 <= next_pos[0] < h and 0 <= next_pos[1] < w and flow[next_pos[0]][next_pos[1]] == 0:\n            valid_neigh.append((i, j))\n    return valid_neigh\n\ndef calc_flow(pos, map2d, flow):\n    flow[pos[0]][pos[1]] = 1\n    cur_val = map2d[pos[0]][pos[1]]\n    for neigh in get_neighbours(pos, flow):\n        next_pos = pos[0] + neigh[0], pos[1] + neigh[1]\n        if cur_val >= map2d[next_pos[0]][next_pos[1]]:\n            calc_flow(next_pos, map2d, flow)\n\n# main function\ndef main_solution(height_map):\n    h, w = len(height_map), len(height_map[0])\n    \n    pacific_flow = [[0 for _ in range(w)] for _ in range(h)]\n    atlantic_flow = copy.deepcopy(pacific_flow)\n    \n    for i in range(w):\n        calc_flow((0, i), height_map, pacific_flow)\n    for i in range(1, h):\n        calc_flow((i, 0), height_map, pacific_flow)\n    \n    for i in range(w):\n        calc_flow((h-1, i), height_map, atlantic_flow)\n    for i in range(h-1):\n        calc_flow((i, w-1), height_map, atlantic_flow)\n    \n    divide_points = []\n    for i in range(w):\n        for j in range(h):\n            if pacific_flow[j][i] == 1 and atlantic_flow[j][i] == 1:\n                divide_points.append((i, j))\n    \n    return divide_points", "funcname": "main_solution", "ios": [{"input": {"height_map": [[9, 9, 1, 9, 3], [4, 1, 5, 3, 9], [2, 9, 6, 4, 4]]}, "output": [[0, 2], [1, 1], [2, 0], [3, 1], [4, 0]]}, {"input": {"height_map": [[2, 8, 9, 6], [9, 8, 6, 4], [3, 7, 4, 10]]}, "output": [[0, 2], [1, 2], [2, 2], [3, 0], [3, 1]]}, {"input": {"height_map": [[8, 5, 7], [10, 10, 8], [3, 10, 5]]}, "output": [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]}, {"input": {"height_map": [[9, 4, 10, 8, 2], [6, 4, 9, 3, 6], [6, 5, 7, 2, 3]]}, "output": [[0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 2], [3, 1], [3, 2], [4, 0]]}, {"input": {"height_map": [[1, 7, 3, 9], [7, 4, 8, 8], [7, 2, 5, 9]]}, "output": [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2], [3, 0], [3, 1]]}, {"input": {"height_map": [[2, 10, 4, 5], [6, 3, 4, 1], [8, 2, 5, 6]]}, "output": [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 0], [2, 1], [3, 0], [3, 1]]}, {"input": {"height_map": [[6, 7, 9], [2, 7, 6], [8, 7, 10], [7, 5, 7]]}, "output": [[0, 0], [0, 1], [0, 3], [1, 0], [1, 1], [1, 2], [1, 3], [2, 0], [2, 1]]}, {"input": {"height_map": [[5, 8, 6, 10, 6, 1], [10, 6, 6, 3, 3, 7], [8, 2, 3, 2, 3, 10]]}, "output": [[0, 2], [1, 2], [2, 2], [3, 1], [3, 2], [4, 1], [4, 2], [5, 0]]}, {"input": {"height_map": [[6, 3, 3], [4, 10, 3], [4, 3, 5], [8, 6, 9]]}, "output": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 2], [1, 3], [2, 0], [2, 1]]}, {"input": {"height_map": [[5, 7, 8], [5, 8, 4], [9, 3, 10]]}, "output": [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "amitibo/programming_exercises", "path": "/set2/Q3.py", "msgidx": 12904}}
{"problem_description": "In a two-dimensional Tic-Tac-Toe game, two players take turns marking spaces in a 3x3 grid. Player 1 uses 'X' and Player 2 uses 'O'. The game ends when one player has three of their marks in a row (horizontally, vertically, or diagonally), or when all nine squares are filled without a winner, resulting in a draw. Given a sequence of moves made by the players, what is the outcome of the game?", "io_requirements": "Input:\n  `moves` (list of integers): A list of integers representing the sequence of moves made by the players. Each integer corresponds to a position on the 3x3 Tic-Tac-Toe board (1 to 9).\n\nOutput:\n  `return` (string): A string indicating the result of the game. Possible values are:\n  - \"Player 1 wins!\": If Player 1 wins the game.\n  - \"Player 2 wins!\": If Player 2 wins the game.\n  - \"Draw\": If the game ends in a draw.\n  - \"Incomplete game\": If the game is not finished based on the provided moves.", "refcode": "# import necessary packages\nimport numpy as np\nfrom itertools import combinations\n\n# all class and function definitions in the code file, if any\nclass tickTackToe():\n    '''Class for the Tick-Tack-Toe game.'''\n\n    # the board definitions for the coordinates and positions\n    board = {\n        \"TOP_LEFT\": [1, (80,80)],\n        \"TOP_MID\": [2, (280,80)],\n        \"TOP_RIGHT\": [3, (480,80)],\n        \n        \"MID_LEFT\": [4, (80,280)],\n        \"CENTER\": [5, (280,280)],\n        \"MID_RIGHT\": [6, (480,280)],\n\n        \"BOT_LEFT\": [7, (80, 480)],\n        \"BOT_MID\": [8, (280,480)],\n        \"BOT_RIGHT\": [9, (480,480)],\n    }\n\n    # the win scenarios\n    win = [\n        [1,2,3],\n        [4,5,6],\n        [7,8,9],\n        [1,4,7],\n        [2,5,8],\n        [3,6,9],\n        [1,5,9],\n        [3,5,7]\n    ]\n\n    def __init__(self, tickTackToeBoard=board, winMoves=win):\n        '''Initialize Tick Tack Toe.'''\n        self.board = tickTackToeBoard\n        self.win = np.array(winMoves)\n        self.player1 = []\n        self.player2 = []\n\n    def checkPlayerMove(self, moves, player):\n        '''Test if the player has won by checking all the combinations of their moves.'''\n        moves = list(combinations(moves, 3))\n        for move in moves:\n            if (self.win == move).all(1).any():\n                return f\"{player} wins!\"\n        return None\n\n    def checkGame(self):\n        '''Check if someone wins or if it's a draw.'''\n        if len(self.player1) >= 3:\n            result = self.checkPlayerMove(self.player1, \"Player 1\")\n            if result:\n                return result\n        if len(self.player2) >= 3:\n            result = self.checkPlayerMove(self.player2, \"Player 2\")\n            if result:\n                return result\n        if len(self.player1) + len(self.player2) == 9:\n            return \"Draw\"\n        return None\n\n    def doMove(self, move):\n        '''Performs the move for a player.'''\n        if move in self.player1 or move in self.player2:\n            return \"Invalid move\"\n        if len(self.player1) <= len(self.player2):\n            self.player1.append(move)\n        else:\n            self.player2.append(move)\n        return self.checkGame()\n\n# main function\ndef main_solution(moves):\n    '''Simulates a Tic-Tac-Toe game based on a sequence of moves.'''\n    game = tickTackToe()\n    for move in moves:\n        result = game.doMove(move)\n        if result:\n            return result\n    return \"Incomplete game\"", "funcname": "main_solution", "ios": [{"input": {"moves": [5, 1, 3, 2, 7, 6, 9, 8, 4]}, "output": "Draw"}, {"input": {"moves": [2, 1, 8, 7, 3]}, "output": "Incomplete game"}, {"input": {"moves": [2, 7, 9, 6]}, "output": "Incomplete game"}, {"input": {"moves": [6, 7, 9, 1, 3, 8, 4, 2]}, "output": "Incomplete game"}, {"input": {"moves": [5, 9, 2, 7, 6, 8]}, "output": "Incomplete game"}, {"input": {"moves": [9, 1, 4, 5, 6, 2, 8]}, "output": "Incomplete game"}, {"input": {"moves": [5, 1, 4, 6, 3, 8]}, "output": "Incomplete game"}, {"input": {"moves": [7, 8, 2, 4, 6]}, "output": "Incomplete game"}, {"input": {"moves": [4, 3, 9, 5, 7, 6, 8, 2, 1]}, "output": "Draw"}, {"input": {"moves": [6, 3, 1, 9, 4]}, "output": "Incomplete game"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "m0tela01/Data-Science-Python-Labs", "path": "/hw2/TickTackToe.py", "msgidx": 12547}}
{"problem_description": "Given a positive integer, what are all the prime numbers that are less than or equal to this integer?", "io_requirements": "Input:\n  `number` (int): A positive integer representing the upper limit to find all prime numbers under.\n\nOutput:\n  `return` (list of int): A list of prime numbers that are less than or equal to the input `number`.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(number):\n    # Convert the input to an integer if it's not already\n    number = int(number)\n    \n    # Function to find all prime numbers under the given number\n    def find_prime_list_under_number(number):\n        prime_list = []\n        for n in range(2, number + 1):\n            for i in prime_list:\n                if n % i == 0 and i * i <= n:\n                    break\n            else:\n                prime_list.append(n)\n        return prime_list\n    \n    # Get the list of prime numbers\n    prime_numbers = find_prime_list_under_number(number)\n    \n    # Return the list of prime numbers as a JSON serializable output\n    return prime_numbers", "funcname": "main_solution", "ios": [{"input": {"number": 24}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23]}, {"input": {"number": 44}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]}, {"input": {"number": 19}, "output": [2, 3, 5, 7, 11, 13, 17, 19]}, {"input": {"number": 70}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]}, {"input": {"number": 67}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]}, {"input": {"number": 10}, "output": [2, 3, 5, 7]}, {"input": {"number": 68}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]}, {"input": {"number": 65}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]}, {"input": {"number": 14}, "output": [2, 3, 5, 7, 11, 13]}, {"input": {"number": 41}, "output": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "swcide/algorithm", "path": "/homework/01_homework_\uc18c\uc218.py", "msgidx": 13394}}
{"problem_description": "In the game of chess, the N-Queens puzzle involves placing N queens on an N\u00d7N chessboard such that no two queens threaten each other. Given a board size, what is the arrangement of queens that satisfies this condition?", "io_requirements": "Input:\n  `size` (int): The size of the board, which represents the number of queens and the dimensions of the board (size x size).\n\nOutput:\n  `return` (list of int): A list representing the positions of the queens on the board such that no two queens threaten each other. Each element in the list corresponds to the column position of the queen in each row. If no solution exists, the function returns `None`.", "refcode": "# import necessary packages\nimport itertools as it\n\n# all class and function definitions in the code file, if any\ndef is_solution(perm):\n    for (i1, i2) in it.combinations(range(len(perm)), 2):\n        if abs(i1 - i2) == abs(perm[i1] - perm[i2]):\n            return False\n    return True\n\n# main function\ndef main_solution(size):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    for perm in it.permutations(range(size)):\n        if is_solution(perm):\n            # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n            return list(perm)\n    return None", "funcname": "main_solution", "ios": [{"input": {"size": 6}, "output": [1, 3, 5, 0, 2, 4]}, {"input": {"size": 4}, "output": [1, 3, 0, 2]}, {"input": {"size": 5}, "output": [0, 2, 4, 1, 3]}, {"input": {"size": 8}, "output": [0, 4, 7, 5, 2, 6, 1, 3]}, {"input": {"size": 7}, "output": [0, 2, 4, 6, 1, 3, 5]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "comherron/CourseraDiscreteMath", "path": "/ChessCode/bruteForce.py", "msgidx": 12907}}
{"problem_description": "Given a string of unique characters, what are all the possible ways to arrange these characters?", "io_requirements": "Input:\n  `input_str` (str): A string of unique characters with no duplicates.\n\nOutput:\n  `return` (list of str): A list of all possible permutations of the input string, where each permutation is a string.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef permutationStr(chars):\n    result = []\n\n    def permutation(chars, begin):\n        if begin == len(chars):\n            result.append(\"\".join(chars))\n            return\n        for j in range(begin, len(chars)):\n            chars[begin], chars[j] = chars[j], chars[begin]\n            permutation(chars, begin + 1)\n            chars[begin], chars[j] = chars[j], chars[begin]\n\n    permutation(chars, 0)\n    return result\n\n# main function\ndef main_solution(input_str):\n    # Convert the input string to a list of characters\n    chars = list(input_str)\n    \n    # Get the permutations of the characters\n    permutations = permutationStr(chars)\n    \n    # Convert the list of permutations to a JSON serializable format\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"input_str": "XJY"}, "output": ["XJY", "XYJ", "JXY", "JYX", "YJX", "YXJ"]}, {"input": {"input_str": "MKQ"}, "output": ["MKQ", "MQK", "KMQ", "KQM", "QKM", "QMK"]}, {"input": {"input_str": "QMA"}, "output": ["QMA", "QAM", "MQA", "MAQ", "AMQ", "AQM"]}, {"input": {"input_str": "pJA"}, "output": ["pJA", "pAJ", "JpA", "JAp", "AJp", "ApJ"]}, {"input": {"input_str": "BuH"}, "output": ["BuH", "BHu", "uBH", "uHB", "HuB", "HBu"]}, {"input": {"input_str": "udO"}, "output": ["udO", "uOd", "duO", "dOu", "Odu", "Oud"]}, {"input": {"input_str": "WRp"}, "output": ["WRp", "WpR", "RWp", "RpW", "pRW", "pWR"]}, {"input": {"input_str": "KPW"}, "output": ["KPW", "KWP", "PKW", "PWK", "WPK", "WKP"]}, {"input": {"input_str": "Jop"}, "output": ["Jop", "Jpo", "oJp", "opJ", "poJ", "pJo"]}, {"input": {"input_str": "dSx"}, "output": ["dSx", "dxS", "Sdx", "Sxd", "xSd", "xdS"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "xiao-xiaoming/DataStructure-BeautyOfAlgorithm", "path": "/06.recursion/permutation_str.py", "msgidx": 12721}}
{"problem_description": "Given a string consisting of letters, what are all the possible unique arrangements of the characters in the string?", "io_requirements": "Input:\n  `input_string` (str): A string for which all permutations need to be generated. The string should not contain any special characters or spaces.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a unique permutation of the input string.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(input_string):\n    # Convert the input string to a list of characters\n    char_list = list(input_string)\n    \n    # Generate all permutations of the list of characters\n    permutations = [''.join(p) for p in itertools.permutations(char_list)]\n    \n    # Return the list of permutations\n    return permutations", "funcname": "main_solution", "ios": [{"input": {"input_string": "OPU"}, "output": ["OPU", "OUP", "POU", "PUO", "UOP", "UPO"]}, {"input": {"input_string": "zpu"}, "output": ["zpu", "zup", "pzu", "puz", "uzp", "upz"]}, {"input": {"input_string": "uCr"}, "output": ["uCr", "urC", "Cur", "Cru", "ruC", "rCu"]}, {"input": {"input_string": "cmN"}, "output": ["cmN", "cNm", "mcN", "mNc", "Ncm", "Nmc"]}, {"input": {"input_string": "KdB"}, "output": ["KdB", "KBd", "dKB", "dBK", "BKd", "BdK"]}, {"input": {"input_string": "UvX"}, "output": ["UvX", "UXv", "vUX", "vXU", "XUv", "XvU"]}, {"input": {"input_string": "rLL"}, "output": ["rLL", "rLL", "LrL", "LLr", "LrL", "LLr"]}, {"input": {"input_string": "Gpe"}, "output": ["Gpe", "Gep", "pGe", "peG", "eGp", "epG"]}, {"input": {"input_string": "NOF"}, "output": ["NOF", "NFO", "ONF", "OFN", "FNO", "FON"]}, {"input": {"input_string": "xBw"}, "output": ["xBw", "xwB", "Bxw", "Bwx", "wxB", "wBx"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shukad333/leet-python", "path": "/recursion/WordsPermute.py", "msgidx": 13457}}
{"problem_description": "Given a number of nodes `n`, how many unique binary search trees can be constructed using these nodes, and what are their structures?", "io_requirements": "Input:\n  `n` (int): The number of nodes in the binary tree. It should be a positive integer.\n\nOutput:\n  `return` (str): A JSON string representing a list of dictionaries. Each dictionary represents a binary tree structure where each node is represented by its value (`val`), and its left (`left`) and right (`right`) children. If a node does not have a child, the corresponding key will have a value of `None`.", "refcode": "# import necessary packages\nimport json\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def generateTrees(self, n: int):\n        if not n: return []\n        nodes = {}\n        def recursive(start, end):\n            if (start, end) in nodes:\n                return nodes[(start, end)]\n            if start > end: return [None]\n            if start == end: return [TreeNode(start)]\n            else:\n                ret = []\n                for i in range(start, end+1):\n                    left = recursive(start, i - 1)\n                    right = recursive(i+1, end)\n                    for leftNode in left:\n                        for rightNode in right:\n                            root = TreeNode(i)\n                            root.left = leftNode\n                            root.right = rightNode\n                            ret.append(root)\n                nodes[(start, end)] = ret\n            return ret\n\n        return recursive(1, n)\n\n# main function\ndef main_solution(n: int):\n    # Convert the input to the required format\n    n = int(n)\n    \n    # Invoke the function that requires non-json serializable inputs\n    solve = Solution()\n    trees = solve.generateTrees(n)\n    \n    # Convert the output to JSON serializable format\n    def tree_to_dict(node):\n        if node is None:\n            return None\n        return {\n            \"val\": node.val,\n            \"left\": tree_to_dict(node.left),\n            \"right\": tree_to_dict(node.right)\n        }\n    \n    result = [tree_to_dict(tree) for tree in trees]\n    \n    # Return the JSON serializable output\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": "[{\"val\": 1, \"left\": null, \"right\": null}]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "xukangjune/Leetcode", "path": "/solved/95. \u4e0d\u540c\u7684\u4e8c\u53c9\u641c\u7d22\u6811 II.py", "msgidx": 12373}}
{"problem_description": "Given two nxn binary matrices A1 and A2, determine whether they are isomorphic. If they are, find out how many different permutation matrices P can be used to satisfy the isomorphism condition. What is the result of this determination?", "io_requirements": "Input:\n  `size` (int): The size of the nxn matrices A1 and A2.\n  `A1` (list of lists of int): The first matrix represented as a list of lists of integers.\n  `A2` (list of lists of int): The second matrix represented as a list of lists of integers.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `isomorphic` (bool): Indicates whether A1 and A2 are isomorphic.\n    - `count` (int): The number of matrices P that satisfy the isomorphism condition.", "refcode": "# import necessary packages\nimport numpy as np\nfrom itertools import permutations\n\n# main function\ndef main_solution(size, A1, A2):\n    # Convert input lists to numpy arrays\n    A1 = np.array(A1)\n    A2 = np.array(A2)\n    \n    # Generate all permutations of the indices\n    arr = list(range(size))\n    perms = list(permutations(arr))\n    \n    found = False\n    count = 0\n    \n    for a in perms:\n        P = np.zeros((size, size))\n        for i in range(len(a)):\n            P[i][a[i]] = 1\n        \n        if int((np.dot(P, A1) == np.dot(A2, P)).mean()) == 1:\n            found = True\n            count += 1\n    \n    # Return the result as a dictionary\n    return {\"isomorphic\": found, \"count\": count}", "funcname": "main_solution", "ios": [{"input": {"size": 2, "A1": [[0, 1], [0, 1]], "A2": [[1, 1], [0, 0]]}, "output": {"isomorphic": false, "count": 0}}, {"input": {"size": 2, "A1": [[1, 0], [0, 0]], "A2": [[1, 0], [0, 0]]}, "output": {"isomorphic": true, "count": 1}}, {"input": {"size": 2, "A1": [[1, 0], [0, 0]], "A2": [[0, 0], [1, 1]]}, "output": {"isomorphic": false, "count": 0}}, {"input": {"size": 2, "A1": [[0, 0], [0, 1]], "A2": [[1, 1], [1, 0]]}, "output": {"isomorphic": false, "count": 0}}, {"input": {"size": 2, "A1": [[0, 1], [0, 1]], "A2": [[0, 1], [0, 1]]}, "output": {"isomorphic": true, "count": 1}}, {"input": {"size": 2, "A1": [[1, 1], [1, 1]], "A2": [[1, 0], [0, 1]]}, "output": {"isomorphic": false, "count": 0}}, {"input": {"size": 2, "A1": [[0, 1], [0, 0]], "A2": [[0, 1], [0, 0]]}, "output": {"isomorphic": true, "count": 1}}, {"input": {"size": 2, "A1": [[1, 1], [1, 1]], "A2": [[1, 1], [0, 0]]}, "output": {"isomorphic": false, "count": 0}}, {"input": {"size": 2, "A1": [[1, 0], [1, 1]], "A2": [[1, 0], [0, 1]]}, "output": {"isomorphic": false, "count": 0}}, {"input": {"size": 2, "A1": [[0, 0], [0, 1]], "A2": [[0, 0], [1, 0]]}, "output": {"isomorphic": false, "count": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ro1406/Graph-Theory", "path": "/Find Permutation Matrix To Show Isomorphism.py", "msgidx": 13214}}
{"problem_description": "Given a position in a spiral sequence, what are the Manhattan distance from this position to the center of the spiral and the first value in the stress test sequence that is greater than this position?", "io_requirements": "Input:\n  `item` (int): A positive integer representing the position in a spiral sequence.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `manhattan_distance` (int): The Manhattan distance from the given position to the center of the spiral.\n    - `stress_test_value` (int): The first value in the stress test sequence that is greater than the given position.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef iter_coords():\n    yield (0, 0)\n    incr = 0\n    x = 1\n    y = 0\n    while True:\n        incr += 2\n        top = y + incr - 1\n        bot = y - 1\n        left = x - incr\n        right = x\n        yield (x, y)\n        while y < top:\n            y += 1\n            yield (x, y)\n        while x > left:\n            x -= 1\n            yield (x, y)\n        while y > bot:\n            y -= 1\n            yield (x, y)\n        while x < right:\n            x += 1\n            yield (x, y)\n        x += 1\n\ndef manhattan_distance(item):\n    ex, ey = next(itertools.islice(iter_coords(), item-1, item))\n    return abs(ex) + abs(ey)\n\ndef iter_stress_test():\n    data = {}\n    iter = iter_coords()\n\n    data[next(iter)] = 1\n    yield 1\n\n    for item in iter:\n        x, y = item\n        val = data.get((x - 1, y - 1), 0)\n        val += data.get((x - 1, y), 0)\n        val += data.get((x - 1, y + 1), 0)\n        val += data.get((x, y - 1), 0)\n        val += data.get((x, y + 1), 0)\n        val += data.get((x + 1, y - 1), 0)\n        val += data.get((x + 1, y), 0)\n        val += data.get((x + 1, y + 1), 0)\n\n        data[item] = val\n        yield val\n\ndef stress_test(item):\n    return next(x for x in iter_stress_test() if x > item)\n\n# main function\ndef main_solution(item):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    distance = manhattan_distance(item)\n    stress = stress_test(item)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"manhattan_distance\": distance, \"stress_test_value\": stress}", "funcname": "main_solution", "ios": [{"input": {"item": 13663}, "output": {"manhattan_distance": 90, "stress_test_value": 14267}}, {"input": {"item": 557443}, "output": {"manhattan_distance": 566, "stress_test_value": 752688}}, {"input": {"item": 416874}, "output": {"manhattan_distance": 443, "stress_test_value": 752688}}, {"input": {"item": 510002}, "output": {"manhattan_distance": 509, "stress_test_value": 752688}}, {"input": {"item": 172912}, "output": {"manhattan_distance": 271, "stress_test_value": 266330}}, {"input": {"item": 485686}, "output": {"manhattan_distance": 573, "stress_test_value": 752688}}, {"input": {"item": 871733}, "output": {"manhattan_distance": 624, "stress_test_value": 875851}}, {"input": {"item": 173503}, "output": {"manhattan_distance": 386, "stress_test_value": 266330}}, {"input": {"item": 299216}, "output": {"manhattan_distance": 541, "stress_test_value": 312453}}, {"input": {"item": 297435}, "output": {"manhattan_distance": 410, "stress_test_value": 312453}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "amscotti/adventofcode_2017", "path": "/day_3_spiral_memory.py", "msgidx": 13031}}
{"problem_description": "In a binary tree of height `h`, each node is indexed in a level-order traversal manner. Given a list of node indices `qs`, determine the parent node index for each node in the list. If a node is the root, its parent should be indicated as `-1`. What are the parent node indices for the given list of node indices `qs` in a binary tree of height `h`?", "io_requirements": "Input:\n  `h` (int): The height of the binary tree.\n  `qs` (list of int): A list of node indices for which the parent node needs to be found.\n\nOutput:\n  `return` (list of int): A list of parent node indices corresponding to the input node indices. If a node is the root, its parent is `-1`.", "refcode": "import math\n\ndef nearest_power_of_2(n):\n    return 2 ** math.floor(math.log(n, 2))\n\ndef level_base(q):\n    while True:\n        p = nearest_power_of_2(q)\n        if (q == 2 * p - 1):\n            return int(q)\n        q -= p - 1\n\ndef sibling(q):\n    base = level_base(q)\n    below = q - base\n    above = q + base\n    return above if base == level_base(above) else below\n\ndef parent(h, q):\n    isroot = q == 2 ** h - 1\n    return -1 if isroot else 1 + max(q, sibling(q))\n\ndef main_solution(h, qs):\n    return [parent(h, q) for q in qs]", "funcname": "main_solution", "ios": [{"input": {"h": 3, "qs": [1, 5, 3, 6, 2, 4]}, "output": [3, 6, 7, 7, 3, 6]}, {"input": {"h": 3, "qs": [6, 4, 3, 7]}, "output": [7, 6, 7, -1]}, {"input": {"h": 3, "qs": [3, 6]}, "output": [7, 7]}, {"input": {"h": 2, "qs": [3, 1, 2]}, "output": [-1, 3, 3]}, {"input": {"h": 5, "qs": [15, 30, 19, 1, 22, 25, 24, 20, 8, 9, 28, 6, 29, 2]}, "output": [31, 31, 21, 3, 30, 29, 25, 21, 10, 10, 29, 7, 30, 3]}, {"input": {"h": 4, "qs": [5, 14, 15, 6, 8, 3]}, "output": [6, 15, -1, 7, 10, 7]}, {"input": {"h": 2, "qs": [3]}, "output": [-1]}, {"input": {"h": 5, "qs": [8, 25, 3, 24, 21, 4]}, "output": [10, 29, 7, 25, 22, 6]}, {"input": {"h": 3, "qs": [2, 7, 5, 3, 4, 6, 1]}, "output": [3, -1, 6, 7, 6, 7, 3]}, {"input": {"h": 4, "qs": [11, 14, 7, 3, 4, 12, 6, 15, 1, 2, 8]}, "output": [13, 15, 15, 7, 6, 13, 7, -1, 3, 3, 10]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BrendanCannell/foobar", "path": "/ion-flux-relabeling/solution.py", "msgidx": 13066}}
{"problem_description": "Given a social network represented as a graph, where nodes represent individuals and edges represent friendships, determine whether the network can be divided into two groups such that no two friends are in the same group. What is the result of this division?", "io_requirements": "Input:\n  `nodes` (list of int): List of node identifiers.\n  `edges` (list of tuples): List of edge tuples where each tuple represents an edge between two nodes.\n\nOutput:\n  `return` (bool): True if the graph is bipartite, False otherwise.", "refcode": "# import necessary packages\nfrom collections import deque\nimport networkx as nx\n\n# all class and function definitions in the code file, if any\nclass bipartite(object):    \n    def uncolored(self, node):\n        \"\"\"\n        Determine if this node is colored\n        uncolored--return True\n        colored----return False\n        \"\"\"\n        if node not in self.colorings['black'] and node not in self.colorings['white']:\n            return True\n        else:\n            return False\n\n    def changeColor(self, node):\n        \"\"\"\n        Change the color of node\n        if it is black, change to white\n        if it is white, change to black\n        \"\"\"\n        if node in self.colorings['black']:\n            return 'white'\n        elif node in self.colorings['white']:\n            return 'black'\n            \n    def canColor(self, node, color):\n        \"\"\"\n        Determine if this node can be colored with given color\n        can be colored with color--True\n        else-----------------------False\n        \"\"\"\n        neighbors = self.G[node].keys() # get all neighbors of the node\n        return all([neighbor not in self.colorings[color] for neighbor in neighbors])\n\n    def isBipartite(self, G):\n        \"\"\"\n        If graph G is bipartite--True\n        If G is not bipartite----False\n        \"\"\"\n        self.G = G \n        self.colorings = {'black': set(), 'white': set()}\n        start = list(G.nodes())[0] # the first node as initial node to start\n        self.colorings['black'].add(start) # Once got the node, color black\n        q = deque([start])\n        while q:\n            n = q.pop()\n            next_color = self.changeColor(n)\n            # get the neighbors who are not colored\n            uncolored_neighbors = []\n            for neighbor in G[n].keys():\n                if self.uncolored(neighbor):\n                    uncolored_neighbors.append(neighbor)\n\n            for neighbor in uncolored_neighbors:\n                # if this neighbor can be colored with given node,\n                # just color it and add this neighbor to q\n                if self.canColor(neighbor, next_color):\n                    self.colorings[next_color].add(neighbor)\n                    q.append(neighbor)\n                # if can not be colored, then this graph is non-bipartite\n                else:\n                    return False\n        # if not false, then G is bipartite\n        return True\n\n# main function\ndef main_solution(nodes, edges):\n    \"\"\"\n    Determine if a given graph is bipartite.\n    \n    Parameters:\n    nodes (list of int): List of node identifiers.\n    edges (list of tuples): List of edge tuples where each tuple represents an edge between two nodes.\n    \n    Returns:\n    bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    G = nx.Graph()\n    G.add_nodes_from(nodes)\n    G.add_edges_from(edges)\n    return bipartite().isBipartite(G)", "funcname": "main_solution", "ios": [{"input": {"nodes": [1, 2, 3, 4], "edges": [[1, 2], [1, 4], [2, 4], [3, 4]]}, "output": false}, {"input": {"nodes": [1, 2, 3], "edges": [[1, 3], [2, 3]]}, "output": true}, {"input": {"nodes": [1, 2, 3, 4], "edges": [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]}, "output": false}, {"input": {"nodes": [1, 2], "edges": []}, "output": true}, {"input": {"nodes": [1, 2], "edges": [[1, 2]]}, "output": true}, {"input": {"nodes": [1, 2, 3, 4], "edges": [[1, 2]]}, "output": true}, {"input": {"nodes": [1, 2, 3, 4], "edges": [[1, 3], [2, 4]]}, "output": true}, {"input": {"nodes": [1, 2, 3], "edges": [[2, 3]]}, "output": true}, {"input": {"nodes": [1, 2, 3, 4], "edges": [[1, 3], [1, 4], [2, 4]]}, "output": true}, {"input": {"nodes": [1, 2, 3, 4, 5], "edges": [[1, 5], [2, 5], [3, 5]]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "minlu1021/graph-theory-course", "path": "/PS1/bipartite.py", "msgidx": 12771}}
{"problem_description": "Given a graph with `N` nodes and `M` edges, where each edge connects two nodes, determine whether the graph contains an odd cycle. An odd cycle is a cycle in the graph where the number of edges is odd. What is the boolean result indicating the presence of an odd cycle in the graph?", "io_requirements": "Input:\n  `N` (int): The number of nodes in the graph.\n  `M` (int): The number of edges in the graph.\n  `edges` (str): A JSON serialized list of tuples, where each tuple represents an edge between two nodes.\n\nOutput:\n  `return` (str): A JSON serialized boolean value indicating whether the graph contains an odd cycle.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef has_odd_cycle(N, M, edges):\n    # Placeholder implementation for the sake of example\n    # In a real scenario, this function would contain the logic to determine if the graph has an odd cycle\n    ans = False\n    return ans\n\n# main function\ndef main_solution(N, M, edges):\n    # Convert JSON serializable inputs to the original input variables\n    edges = json.loads(edges)\n    \n    # Call the original function with the converted inputs\n    result = has_odd_cycle(N, M, edges)\n    \n    # Convert the result to a JSON serializable output\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"N": 5, "M": 3, "edges": "[[5, 3], [4, 5], [2, 3]]"}, "output": "false"}, {"input": {"N": 3, "M": 2, "edges": "[[3, 1], [2, 3]]"}, "output": "false"}, {"input": {"N": 8, "M": 12, "edges": "[[6, 5], [4, 3], [3, 7], [6, 8], [1, 8], [4, 2], [1, 4], [7, 2], [4, 8], [3, 2], [8, 5], [5, 2]]"}, "output": "false"}, {"input": {"N": 3, "M": 3, "edges": "[[3, 1], [3, 2], [1, 2]]"}, "output": "false"}, {"input": {"N": 6, "M": 4, "edges": "[[5, 6], [6, 4], [1, 4], [1, 5]]"}, "output": "false"}, {"input": {"N": 2, "M": 1, "edges": "[[2, 1]]"}, "output": "false"}, {"input": {"N": 6, "M": 8, "edges": "[[3, 4], [5, 4], [5, 1], [4, 2], [5, 6], [3, 6], [3, 2], [2, 5]]"}, "output": "false"}, {"input": {"N": 3, "M": 1, "edges": "[[1, 3]]"}, "output": "false"}, {"input": {"N": 6, "M": 5, "edges": "[[3, 1], [4, 2], [2, 6], [3, 2], [6, 3]]"}, "output": "false"}, {"input": {"N": 4, "M": 3, "edges": "[[3, 1], [3, 2], [1, 4]]"}, "output": "false"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kq-li/stuy", "path": "/pclassic/2017s/stubs/Bugs.py", "msgidx": 13260}}
{"problem_description": "Given a chess board with `m` rows and `n` columns, how many distinct ways can you place `m` queens on the board such that no two queens threaten each other? If only the first solution is needed, what would be the configuration of the board?", "io_requirements": "Input:\n  `m` (int): Number of rows in the chess board.\n  `n` (int): Number of columns in the chess board.\n  `first_solution` (bool): If `True`, the function will return only the first solution found. If `False`, it will return all possible solutions.\n\nOutput:\n  `return` (list of lists): A list of solutions, where each solution is represented as a list of lists (2D array) representing the chess board configuration. Each cell in the 2D array is either `0` (no queen) or `1` (queen).", "refcode": "# import necessary packages\nimport numpy as np\nfrom copy import deepcopy\n\n# all class and function definitions in the code file, if any\ndef is_possible(board, pos):\n    '''\n    Function checks if queen can be placed on position pos.\n    INPUTS: board - numpy.array object representing chess board.\n                    - Value 1 in array means there is queen on position.\n                    - Value 0 in array means there is no queen.\n            pos - Tested position in tuple form.\n                    - E.g. (3, 4) means 3rd row and 4th column. Numbering starts from 0.\n\n    OUTPUT: Returns True if it is safe to place queen on position. If not then returns False.\n    '''\n    m, n = board.shape\n    r, c = pos\n    # Check in column\n    for i in range(m):\n        if board[i][c] == 1:\n            return False\n    # Check in row\n    for i in range(n):\n        if board[r][i] == 1:\n            return False\n    # Check in diagonals\n    # Getting upper left starting point\n    r_0 = r\n    c_0 = c\n    while (r_0 != 0) and (c_0 != 0):\n        r_0 -= 1\n        c_0 -= 1\n    # Checking to right and down\n    while (r_0 != m) and (c_0 != n):\n        if board[r_0][c_0] == 1:\n            return False\n        r_0 += 1\n        c_0 += 1\n\n    # Getting upper right starting point\n    r_0 = r\n    c_0 = c\n    while (r_0 != 0) and (c_0 != n-1):\n        r_0 -= 1\n        c_0 += 1\n    # Checking to left and down\n    while (r_0 != m) and (c_0 != -1):\n        if board[r_0][c_0] == 1:\n            return False\n        r_0 += 1\n        c_0 -= 1\n\n    return True\n\nCOUNTER = 0\ndef solve(m, n, board, start_row, list_of_solutions, first_solution=False):\n    '''\n    Function solves M x N Queen Puzzle.\n    INPUTS: - m - Number of chess board rows.\n            - n - Number of chess board columns.\n            - board - numpy.array object with dimension M x N.\n                    - Represents chess board.\n                    - Element with value 0 means there is no queen.\n                    - Element with value 1 means there is queen.\n            - start_row - Used during recursion.\n                        - If is function run for the first time set to 0.\n            - list_of_solutions - list containing all founded solutions.\n            - first_solution    - If True then script will find ONLY ONE solution.\n                                - Otherwise all solutions will be found.\n    OUTPUT: - list_of_solutions - In this passed in user finds solution(s).\n                                - Every solution is deepcopied to the list of numpy.array objects.\n    '''\n    global COUNTER\n    if COUNTER >= 1 and first_solution:\n        return\n\n    if start_row >= m:\n        COUNTER += 1\n        list_of_solutions.append(deepcopy(board))\n        return\n\n    for col in range(n):\n        if is_possible(board, (start_row, col)):\n            board[start_row][col] = 1\n            solve(m, n, board, start_row+1, list_of_solutions, first_solution)\n            board[start_row][col] = 0\n\n# main function\ndef main_solution(m, n, first_solution=False):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    board = np.zeros((m, n), dtype='int8')\n    solutions = []\n    solve(m, n, board, 0, solutions, first_solution)\n    \n    # Convert solutions to JSON serializable format\n    serializable_solutions = []\n    for solution in solutions:\n        serializable_solutions.append(solution.tolist())\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return serializable_solutions", "funcname": "main_solution", "ios": [{"input": {"m": 4, "n": 5, "first_solution": true}, "output": [[[1, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 1, 0, 0, 0]]]}, {"input": {"m": 4, "n": 3, "first_solution": false}, "output": []}, {"input": {"m": 8, "n": 8, "first_solution": true}, "output": []}, {"input": {"m": 6, "n": 4, "first_solution": true}, "output": []}, {"input": {"m": 8, "n": 6, "first_solution": false}, "output": []}, {"input": {"m": 2, "n": 4, "first_solution": true}, "output": []}, {"input": {"m": 6, "n": 7, "first_solution": true}, "output": []}, {"input": {"m": 2, "n": 6, "first_solution": true}, "output": []}, {"input": {"m": 6, "n": 3, "first_solution": true}, "output": []}, {"input": {"m": 8, "n": 3, "first_solution": true}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RudolfHlavacek/M-N-Queen-Puzzle", "path": "/m_n_queen_puzzle.py", "msgidx": 12724}}
{"problem_description": "Given a set of min terms and don't care terms, what are the essential and non-essential prime implicants in the context of Boolean algebra simplification?", "io_requirements": "Input:\n  `min_terms` (list of integers): List of min terms entered by the user.\n  `dont_care_terms` (list of integers): List of don't care terms entered by the user.\n\nOutput:\n  `return` (dictionary): A dictionary containing two keys:\n    - `essential_prime_implicants` (list of tuples): List of tuples where each tuple contains the data and underscore value of essential prime implicants.\n    - `non_essential_prime_implicants` (list of tuples): List of tuples where each tuple contains the data and underscore value of non-essential prime implicants.", "refcode": "# import necessary packages\nimport itertools\nimport copy\n\n# all class and function definitions in the code file, if any\nclass AMinTerm:\n    def __init__(self, ip):\n        self.data = ip\n        self.listB = []\n\nclass MinTerms:\n    def __init__(self):\n        self.minTerms = []\n        self.bitCount = 0\n        self.inputCount = 0\n        self.totalCount = 0\n\n    def set_globals(self):\n        maximum = copy.copy(max(self.minTerms, key=lambda x: x.data))\n        if maximum.data == 0:\n            self.bitCount = 1\n        else:\n            while maximum.data > 0:\n                maximum.data >>= 1\n                self.bitCount += 1\n        self.totalCount = len(self.minTerms)\n\nclass ClassA:\n    def __init__(self, ip):\n        self.data = ip\n        self.prime_implicants = True\n        self.one_count = bin(ip).count('1')\n        self.underscore = 0\n\nclass ClassB:\n    def __init__(self, data, us):\n        self.data = data\n        self.underscore = us\n\n    def __eq__(self, other):\n        return self.data == other.data and self.underscore == other.underscore\n\n# main function\ndef main_solution(min_terms, dont_care_terms):\n    # Convert JSON serializable inputs to original input variables\n    mts = MinTerms()\n    for term in min_terms:\n        mts.minTerms.append(AMinTerm(term))\n    for term in dont_care_terms:\n        mts.minTerms.append(AMinTerm(term))\n    mts.inputCount = len(min_terms)\n    mts.set_globals()\n\n    # Core logic\n    listB = TableA(mts)\n    listDisplay, count = TableB(listB, mts)\n\n    # Convert output to JSON serializable format\n    essential_prime_implicants = []\n    non_essential_prime_implicants = []\n    for x in listDisplay[:count]:\n        essential_prime_implicants.append((x.data, x.underscore))\n    for x in listDisplay[count:]:\n        non_essential_prime_implicants.append((x.data, x.underscore))\n\n    return {\n        \"essential_prime_implicants\": essential_prime_implicants,\n        \"non_essential_prime_implicants\": non_essential_prime_implicants\n    }\n\ndef TableA(input):\n    listA = []\n    listB = []\n    for x in input.minTerms:\n        a = ClassA(x.data)\n        listA.append(a)\n    inputList = listA\n    inputList.sort(key=lambda x: x.data)\n    while True:\n        holdList = []\n        holdCount = 0\n        tempTupleList = itertools.combinations(inputList, 2)\n        tempFilterTupleList = filter(lambda x: ((x[0].underscore == x[1].underscore) and\n                                               ( (x[1].one_count - x[0].one_count) == 1)\n                                     and (bin(x[1].data - x[0].data).count('1') == 1)), tempTupleList)\n        for hTemp in tempFilterTupleList:\n            hTemp[0].prime_implicants = False\n            hTemp[1].prime_implicants = False\n            tempA = ClassA(hTemp[0].data)\n            tempA.underscore = hTemp[1].data - hTemp[0].data + hTemp[1].underscore\n            holdList.append(tempA)\n            holdCount += 1\n        for x in inputList:\n            if x.prime_implicants:\n                tempB = ClassB(x.data, x.underscore)\n                if tempB not in listB:\n                    listB.append(tempB)\n        if holdCount == 0:\n            break\n        inputList = [x for x in holdList]\n    return listB\n\ndef TableB(listB, input):\n    listDisplay = []\n    bAndMinTermsTuple = itertools.product(listB, input.minTerms[:input.inputCount])\n    for b, m in bAndMinTermsTuple:\n        if b.data == (b.data & m.data):\n            if m.data == ((b.data | b.underscore) & m.data):\n                m.listB.append(b)\n    for m in input.minTerms:\n        if len(m.listB) == 1:\n            if m.listB[0] not in listDisplay:\n                listDisplay.append(m.listB[0])\n            if m.listB[0] in listB:\n                listB.remove(m.listB[0])\n    count = len(listDisplay)\n    displayAndMinTermsTuple = itertools.product(listDisplay, input.minTerms)\n    for d, m in displayAndMinTermsTuple:\n        if d in m.listB:\n            m.listB = []\n    bAndMinTermsTuple = itertools.product(listB, input.minTerms)\n    for b, m in bAndMinTermsTuple:\n        if b in m.listB:\n            if b not in listDisplay:\n                listDisplay.append(b)\n            if b in listB:\n                listB.remove(b)\n            m.listB = []\n    return listDisplay, count", "funcname": "main_solution", "ios": [{"input": {"min_terms": [103, 96], "dont_care_terms": [134, 79, 216, 136, 77]}, "output": {"essential_prime_implicants": [[103, 0], [96, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [160, 171], "dont_care_terms": []}, "output": {"essential_prime_implicants": [[160, 0], [171, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [223, 98], "dont_care_terms": [216, 153, 144]}, "output": {"essential_prime_implicants": [[223, 0], [98, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [199, 233], "dont_care_terms": [19, 103]}, "output": {"essential_prime_implicants": [[199, 0], [233, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [26, 9, 238, 126], "dont_care_terms": [131]}, "output": {"essential_prime_implicants": [[26, 0], [9, 0], [238, 0], [126, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [27, 44, 198], "dont_care_terms": [178, 41, 122, 236]}, "output": {"essential_prime_implicants": [[27, 0], [44, 0], [198, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [239, 65, 138, 50, 173], "dont_care_terms": [118, 215]}, "output": {"essential_prime_implicants": [[239, 0], [65, 0], [138, 0], [50, 0], [173, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [37, 64], "dont_care_terms": [79]}, "output": {"essential_prime_implicants": [[37, 0], [64, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [236, 71, 254, 126, 132], "dont_care_terms": [85, 118, 181]}, "output": {"essential_prime_implicants": [[236, 0], [71, 0], [126, 128], [132, 0]], "non_essential_prime_implicants": []}}, {"input": {"min_terms": [69, 214, 203, 207], "dont_care_terms": [250, 128, 228, 41, 124]}, "output": {"essential_prime_implicants": [[69, 0], [214, 0], [203, 4]], "non_essential_prime_implicants": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mpanchmatia/TabulationMethod", "path": "/Tabulatoin.py", "msgidx": 12820}}
{"problem_description": "Given a 2D grid where each cell can contain different values, and a specific value that represents an island, how many distinct islands are there in the grid, and what are the coordinates of the cells that belong to these islands?", "io_requirements": "Input:\n  `grid` (list of lists of integers): A 2D grid where each element represents a cell in the grid. The values can be any integer, but only the cells with the value equal to `cluster_num` will be considered as part of an island.\n  `cluster_num` (integer): The value in the grid that represents a cell belonging to an island. Cells with this value will be considered as part of an island, while others will be ignored.\n\nOutput:\n  `return` (dictionary): A dictionary containing the following keys:\n    - `numberOfIslands` (integer): The number of distinct islands found in the grid.\n    - `islandCoordinates` (list of tuples): A list of tuples where each tuple represents the coordinates (row, column) of cells that belong to the islands.", "refcode": "# import necessary packages\nimport numpy as np\n\n# Class to represent Disjoint Set Data structure\nclass DisjointUnionSets: \n    def __init__(self, n):\n        self.rank = [0] * n \n        self.parent = [0] * n \n        self.n = n \n        self.makeSet() \n\n    def makeSet(self): \n        for i in range(self.n): \n            self.parent[i] = i \n\n    def find(self, x): \n        if (self.parent[x] != x): \n            return self.find(self.parent[x]) \n        return x \n\n    def Union(self, x, y): \n        xRoot = self.find(x) \n        yRoot = self.find(y) \n        if xRoot == yRoot: \n            return\n        if self.rank[xRoot] < self.rank[yRoot]: \n            self.parent[xRoot] = yRoot\n        elif self.rank[yRoot] < self.rank[xRoot]: \n            self.parent[yRoot] = xRoot \n        else: \n            self.parent[yRoot] = xRoot \n            self.rank[xRoot] = self.rank[xRoot] + 1\n\n# Function to count islands in a 2D grid\ndef countIslands(a, cluser_num): \n    n = len(a) \n    m = len(a[0]) \n    if cluser_num != 0:\n        for j in range(0, n): \n            for k in range(0, m):\n                if a[j][k] != cluser_num:\n                    a[j][k] = 0\n                else :\n                    a[j][k] = 1\n    else:\n        for j in range(0, n): \n            for k in range(0, m):\n                if a[j][k] == cluser_num:\n                    a[j][k] = 1\n                else:\n                    a[j][k] = 0\n    dus = DisjointUnionSets(n * m) \n\n    for j in range(0, n): \n        for k in range(0, m): \n            if a[j][k] == 0: \n                continue\n            if j + 1 < n and a[j + 1][k] == 1: \n                dus.Union(j * (m) + k, (j + 1) * (m) + k) \n            if j - 1 >= 0 and a[j - 1][k] == 1: \n                dus.Union(j * (m) + k, (j - 1) * (m) + k) \n            if k + 1 < m and a[j][k + 1] == 1: \n                dus.Union(j * (m) + k, (j) * (m) + k + 1) \n            if k - 1 >= 0 and a[j][k - 1] == 1: \n                dus.Union(j * (m) + k, (j) * (m) + k - 1) \n            if (j + 1 < n and k + 1 < m and a[j + 1][k + 1] == 1): \n                dus.Union(j * (m) + k, (j + 1) * (m) + k + 1) \n            if (j + 1 < n and k - 1 >= 0 and a[j + 1][k - 1] == 1): \n                dus.Union(j * m + k, (j + 1) * (m) + k - 1) \n            if (j - 1 >= 0 and k + 1 < m and a[j - 1][k + 1] == 1): \n                dus.Union(j * m + k, (j - 1) * m + k + 1) \n            if (j - 1 >= 0 and k - 1 >= 0 and a[j - 1][k - 1] == 1): \n                dus.Union(j * m + k, (j - 1) * m + k - 1) \n\n    c = [0] * (n * m) \n    numberOfIslands = 0\n    lis = []\n    for j in range(n): \n        for k in range(m): \n            if a[j][k] == 1: \n                lis.append((j, k))\n                x = dus.find(j * m + k) \n                if c[x] == 0: \n                    numberOfIslands += 1\n                    c[x] += 1\n                else: \n                    c[x] += 1\n\n    return {\"numberOfIslands\": numberOfIslands, \"islandCoordinates\": lis}\n\n# main function\ndef main_solution(grid, cluster_num):\n    # Convert input grid to a list of lists if it's a numpy array\n    if isinstance(grid, np.ndarray):\n        grid = grid.tolist()\n    \n    # Call the countIslands function\n    result = countIslands(grid, cluster_num)\n    \n    # Return the result as a dictionary\n    return result", "funcname": "main_solution", "ios": [{"input": {"grid": [[1, 0, 1, 0, 0], [0, 0, 1, 0, 1], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]], "cluster_num": 0}, "output": {"numberOfIslands": 4, "islandCoordinates": [[0, 0], [0, 2], [1, 2], [1, 4], [2, 0], [2, 1], [4, 0]]}}, {"input": {"grid": [[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]], "cluster_num": 3}, "output": {"numberOfIslands": 3, "islandCoordinates": [[1, 1], [2, 4], [4, 0]]}}, {"input": {"grid": [[0, 0, 0, 0, 0], [1, 0, 1, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 1, 0, 0]], "cluster_num": 1}, "output": {"numberOfIslands": 4, "islandCoordinates": [[1, 0], [1, 2], [1, 3], [1, 4], [3, 4], [4, 2]]}}, {"input": {"grid": [[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0]], "cluster_num": 1}, "output": {"numberOfIslands": 2, "islandCoordinates": [[1, 2], [2, 0], [2, 1], [3, 4]]}}, {"input": {"grid": [[1, 1, 0, 0, 1], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]], "cluster_num": 2}, "output": {"numberOfIslands": 3, "islandCoordinates": [[0, 0], [0, 1], [0, 4], [1, 0], [3, 2]]}}, {"input": {"grid": [[1, 0, 0, 0, 1], [0, 1, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 1]], "cluster_num": 3}, "output": {"numberOfIslands": 4, "islandCoordinates": [[0, 0], [0, 4], [1, 1], [2, 0], [4, 2], [4, 4]]}}, {"input": {"grid": [[0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 1, 0]], "cluster_num": 0}, "output": {"numberOfIslands": 1, "islandCoordinates": [[0, 3], [1, 4], [2, 2], [2, 4], [3, 3], [4, 3]]}}, {"input": {"grid": [[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 0, 0]], "cluster_num": 2}, "output": {"numberOfIslands": 2, "islandCoordinates": [[1, 1], [3, 0], [3, 2], [4, 1]]}}, {"input": {"grid": [[0, 0, 1, 0, 0], [0, 0, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 0]], "cluster_num": 3}, "output": {"numberOfIslands": 3, "islandCoordinates": [[0, 2], [1, 2], [1, 3], [2, 2], [4, 0], [4, 1], [4, 3]]}}, {"input": {"grid": [[0, 0, 0, 0, 1], [1, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0]], "cluster_num": 2}, "output": {"numberOfIslands": 3, "islandCoordinates": [[0, 4], [1, 0], [1, 3], [4, 3]]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "huhulaoxian/group-photo", "path": "/src/Learning/disjoint_Set.py", "msgidx": 12679}}
{"problem_description": "Given the coordinates of two cells on a standard 8x8 chessboard, determine the minimum number of moves a knight needs to reach from the starting cell to the ending cell. The knight can move in an \"L\" shape: two squares in one direction and then one square perpendicular, or one square in one direction and then two squares perpendicular. If it is possible to reach the ending cell within 2 moves, return the number of moves required. If it is not possible, return -1. What is the number of moves required for the knight to move from the starting cell to the ending cell?", "io_requirements": "Input:\n  `start_x` (int): The x-coordinate of the starting position on the chessboard (1-8).\n  `start_y` (int): The y-coordinate of the starting position on the chessboard (1-8).\n  `end_x` (int): The x-coordinate of the ending position on the chessboard (1-8).\n  `end_y` (int): The y-coordinate of the ending position on the chessboard (1-8).\n\nOutput:\n  `return` (int): The number of moves required for the knight to reach the ending position from the starting position, or -1 if it's not possible within 2 moves.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_pos(x1, y1, x2, y2, t, count):\n    \"\"\"Recursive function to check if a knight can move from (x1, y1) to (x2, y2) in t moves.\"\"\"\n    if t < 0:\n        return False\n    if not (0 <= x1 < 8 and 0 <= y1 < 8):\n        return False\n    if (x1, y1) == (x2, y2):\n        return count\n    t -= 1\n    count += 1\n    return (is_pos(x1 - 1, y1 - 2, x2, y2, t, count) or\n            is_pos(x1 + 1, y1 - 2, x2, y2, t, count) or\n            is_pos(x1 + 2, y1 - 1, x2, y2, t, count) or\n            is_pos(x1 + 2, y1 + 1, x2, y2, t, count) or\n            is_pos(x1 + 1, y1 + 2, x2, y2, t, count) or\n            is_pos(x1 - 1, y1 + 2, x2, y2, t, count) or\n            is_pos(x1 - 2, y1 + 1, x2, y2, t, count) or\n            is_pos(x1 - 2, y1 - 1, x2, y2, t, count))\n\n# main function\ndef main_solution(start_x, start_y, end_x, end_y):\n    \"\"\"\n    Determines if a knight can move from the starting position (start_x, start_y) to the ending position (end_x, end_y)\n    on a chessboard in no more than 2 moves. Returns the number of moves required or -1 if it's not possible.\n    \"\"\"\n    # Convert input coordinates to zero-based indices\n    start_x -= 1\n    start_y -= 1\n    end_x -= 1\n    end_y -= 1\n    \n    # Call the recursive function to check the possibility and count the moves\n    result = is_pos(start_x, start_y, end_x, end_y, 2, 0)\n    \n    # Return the result, converting False to -1\n    return -1 if result is False else result", "funcname": "main_solution", "ios": [{"input": {"start_x": 3, "start_y": 4, "end_x": 7, "end_y": 2}, "output": 2}, {"input": {"start_x": 3, "start_y": 4, "end_x": 1, "end_y": 7}, "output": -1}, {"input": {"start_x": 7, "start_y": 8, "end_x": 1, "end_y": 4}, "output": -1}, {"input": {"start_x": 4, "start_y": 7, "end_x": 1, "end_y": 3}, "output": -1}, {"input": {"start_x": 5, "start_y": 6, "end_x": 6, "end_y": 1}, "output": -1}, {"input": {"start_x": 1, "start_y": 4, "end_x": 1, "end_y": 8}, "output": 2}, {"input": {"start_x": 4, "start_y": 5, "end_x": 1, "end_y": 7}, "output": -1}, {"input": {"start_x": 7, "start_y": 1, "end_x": 7, "end_y": 1}, "output": 0}, {"input": {"start_x": 2, "start_y": 6, "end_x": 3, "end_y": 7}, "output": 2}, {"input": {"start_x": 4, "start_y": 2, "end_x": 7, "end_y": 7}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dmitryzykovArtis/education", "path": "/25.py", "msgidx": 12946}}
{"problem_description": "In a game where two players take turns to pick one or two coins from a line until no coins are left, the player who picks the last coin wins. Given a certain number of coins in the line, what is the outcome for the first player? Will the first player win or lose?", "io_requirements": "Input:\n  `n` (int): The number of coins in the line.\n\nOutput:\n  `return` (str): A string indicating the result of the game. It can be either \"win\" if the first player wins or \"lose\" if the first player loses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def coinsInALine(self, n):\n        s = {}\n        s[1] = True\n        s[2] = True\n        for i in range(3, n+1):\n            s[i] = (not s[i-1]) or (not s[i-2])\n        return s[n]\n\n# main function\ndef main_solution(n):\n    # n is the number of coins in the line\n    solution = Solution()\n    result = solution.coinsInALine(n)\n    # Convert the boolean result to a string for JSON serialization\n    return \"win\" if result else \"lose\"", "funcname": "main_solution", "ios": [{"input": {"n": 64}, "output": "win"}, {"input": {"n": 32}, "output": "win"}, {"input": {"n": 86}, "output": "win"}, {"input": {"n": 92}, "output": "win"}, {"input": {"n": 45}, "output": "lose"}, {"input": {"n": 48}, "output": "lose"}, {"input": {"n": 2}, "output": "win"}, {"input": {"n": 41}, "output": "win"}, {"input": {"n": 51}, "output": "lose"}, {"input": {"n": 61}, "output": "win"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lonelyarcher/leetcode.python3", "path": "/dp_game_CoinsInALine.py", "msgidx": 12537}}
{"problem_description": "Given a range of numbers up to a certain limit, what is the sum of all numbers that are palindromic in both base 10 and base 2?", "io_requirements": "Input:\n  `limit` (int): The upper limit for the range of numbers to check for palindromic properties in both base 10 and base 2. Must be a positive integer.\n\nOutput:\n  `return` (int): The sum of all numbers less than the given `limit` that are palindromic in both base 10 and base 2.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(limit):\n    result = 0\n    for i in range(1, limit, 2):\n        if not i % 10: continue\n        base10 = str(i)\n        base2 = format(i, 'b')\n        if base10 == base10[::-1] and base2 == base2[::-1]:\n            result += i\n    return result", "funcname": "main_solution", "ios": [{"input": {"limit": 560487}, "output": 286602}, {"input": {"limit": 678801}, "output": 872187}, {"input": {"limit": 839289}, "output": 872187}, {"input": {"limit": 191949}, "output": 286602}, {"input": {"limit": 230717}, "output": 286602}, {"input": {"limit": 400307}, "output": 286602}, {"input": {"limit": 913038}, "output": 872187}, {"input": {"limit": 658607}, "output": 872187}, {"input": {"limit": 586748}, "output": 872187}, {"input": {"limit": 887455}, "output": 872187}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wapor/euler", "path": "/36_double_base_palindromes.py", "msgidx": 13486}}
{"problem_description": "Given a pattern string consisting of only 'a' and 'b', and a value string consisting of only lowercase letters, determine if the value string can be matched to the pattern string. The pattern string describes a sequence of 'a' and 'b' where each 'a' and 'b' can represent a substring in the value string. However, 'a' and 'b' cannot represent the same substring. What is the result of matching the value string against the pattern string?", "io_requirements": "Input:\n  `pattern` (str): A string consisting of only 'a' and 'b' that describes the pattern.\n  `value` (str): A string consisting of only lowercase letters that needs to be matched against the pattern.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the `value` string matches the `pattern` string.", "refcode": "# import necessary packages\nimport collections\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def patternMatching(self, pattern: str, value: str) -> bool:\n        counter = collections.Counter(pattern)\n        chrA, chrB = 'a', 'b'\n        if counter[chrA] < counter[chrB]:\n            chrA, chrB = chrB, chrA\n        if counter[chrA] == 0:\n            return value == ''\n        for i in range(len(value) // counter[chrA] + 1):\n            al = i\n            bl = (len(value) - al * counter[chrA]) // counter[chrB] if counter[chrB] > 0 else 0\n            a, b, index = None, None, 0\n            for j in range(len(pattern)):\n                if pattern[j] == chrA:\n                    if a is None:\n                        a = value[index:index + al]\n                    else:\n                        temp = value[index:index + al]\n                        if a != temp:\n                            break\n                    index += al\n                else:\n                    if b is None:\n                        b = value[index: index + bl]\n                    else:\n                        temp = value[index: index + bl]\n                        if b != temp:\n                            break\n                    index += bl\n                if a is not None and b is not None and a == b:\n                    break\n            if index == len(value) and a != b:\n                return True\n\n        return False\n\n# main function\ndef main_solution(pattern: str, value: str) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.patternMatching(pattern, value)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"pattern": "bb", "value": "i"}, "output": false}, {"input": {"pattern": "a", "value": "dycwomib"}, "output": true}, {"input": {"pattern": "aa", "value": ""}, "output": true}, {"input": {"pattern": "", "value": "mrxtss"}, "output": false}, {"input": {"pattern": "bbabbaaba", "value": "ilhc"}, "output": false}, {"input": {"pattern": "", "value": "gyz"}, "output": false}, {"input": {"pattern": "aa", "value": "yunmvc"}, "output": false}, {"input": {"pattern": "a", "value": "n"}, "output": true}, {"input": {"pattern": "aaababb", "value": "grfo"}, "output": false}, {"input": {"pattern": "aabbbbba", "value": "prnyr"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vzpd/myBrushRecord", "path": "/exercise/\u6bcf\u65e5\u4e00\u9898_\u6a21\u62df\u5339\u914d.py", "msgidx": 12636}}
{"problem_description": "Given a list of integers, how can we identify the prime numbers and filter out the integers that do not have exactly `k` proper divisors, where `k` is a non-negative integer? Specifically, what are the prime numbers in the list and what is the resulting list after filtering based on the number of proper divisors?", "io_requirements": "Input:\n  `ls` (list of integers): A list of integers for which we need to find prime numbers and filter based on the number of proper divisors.\n  `k` (integer): An integer representing the number of proper divisors that an integer in `ls` must have to be retained in the list.\n\nOutput:\n  `return` (dictionary): A dictionary containing two keys:\n    - `prime_numbers` (list of integers): A list of integers that are prime numbers from the input list `ls`.\n    - `filtered_ls` (list of integers): The modified list `ls` after removing integers that do not have exactly `k` proper divisors.", "refcode": "# import necessary packages\nfrom math import sqrt\n\n# all class and function definitions in the code file, if any\ndef pre(ls):\n    diviList = []\n    for n in ls:\n        for m in range(2, int(sqrt(n)) + 1):\n            if n % m == 0:\n                diviList = diviList + [n]*2                   \n    return diviList\n\ndef divisori(ls):    \n    for p in set(pre(ls)):\n        if sqrt(p).is_integer():\n            pre(ls).remove(p)\n    return pre(ls)  \n           \ndef togli1(ls,k):\n    coppieList = [[n,divisori(ls).count(n)] for n in set(divisori(ls))]\n    q = [a for a in coppieList if a[1] == k ]\n    return q\n\ndef togli2(ls,k):\n    nuovaLista = []\n    for unico in togli1(ls,k):\n        nuovaLista = nuovaLista + [unico[0]]\n    return nuovaLista\n\ndef primi(ls):\n    primiList = []\n    for n in ls:\n       if all(n % m != 0 for m in range(2, int(sqrt(n) + 1))):\n           primiList.append(n)\n    return primiList\n\n# main function\ndef main_solution(ls, k):\n    # Convert input to appropriate types if necessary\n    ls = list(ls)\n    k = int(k)\n    \n    # Call the original modi function\n    prime_numbers = modi(ls, k)\n    \n    # Convert output to JSON serializable format\n    prime_numbers = list(prime_numbers)\n    filtered_ls = list(ls)\n    \n    return {\"prime_numbers\": prime_numbers, \"filtered_ls\": filtered_ls}\n\ndef modi(ls,k):\n    finList = []\n    [[finList.append(i)] for i in list(primi(ls))]\n    ls[:] = sorted((set(ls) & set(togli2(ls,k))), key = ls.index)\n    \n    return finList", "funcname": "main_solution", "ios": [{"input": {"ls": [276, 355, 214, 261, 163, 4, 484, 356, 341, 312], "k": 5}, "output": {"prime_numbers": [163], "filtered_ls": []}}, {"input": {"ls": [870, 98, 613, 404, 898, 379, 914, 568, 454, 738], "k": 0}, "output": {"prime_numbers": [613, 379], "filtered_ls": []}}, {"input": {"ls": [67, 172, 172, 347, 515, 807, 392, 89, 608, 979], "k": 5}, "output": {"prime_numbers": [67, 347, 89], "filtered_ls": []}}, {"input": {"ls": [392, 22, 848, 815, 49, 275, 126, 641, 324, 722], "k": 8}, "output": {"prime_numbers": [641], "filtered_ls": [848]}}, {"input": {"ls": [655, 287, 15, 343, 652, 592, 490, 2, 550, 74], "k": 7}, "output": {"prime_numbers": [2], "filtered_ls": []}}, {"input": {"ls": [266, 307, 283, 464, 298, 92, 335, 891, 643, 636], "k": 3}, "output": {"prime_numbers": [307, 283, 643], "filtered_ls": []}}, {"input": {"ls": [447, 158, 335, 285, 805, 700, 67, 664, 401, 717], "k": 9}, "output": {"prime_numbers": [67, 401], "filtered_ls": []}}, {"input": {"ls": [966, 865, 889, 879, 419, 324, 861, 344, 53, 49], "k": 1}, "output": {"prime_numbers": [419, 53], "filtered_ls": []}}, {"input": {"ls": [176, 708, 232, 823, 197, 880, 82, 947, 323, 637], "k": 9}, "output": {"prime_numbers": [823, 197, 947], "filtered_ls": []}}, {"input": {"ls": [132, 676, 34, 72, 599, 90, 594, 70, 362, 925], "k": 0}, "output": {"prime_numbers": [599], "filtered_ls": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Fondamenti18/fondamenti-di-programmazione", "path": "/students/1762439/homework01/program01.py", "msgidx": 13065}}
{"problem_description": "Given a chessboard of size NxN, where N is a positive integer, how can we place N queens on the board such that no two queens threaten each other? Each queen must be placed in a unique row and column, and no two queens can be on the same diagonal. What is the configuration of the board that satisfies these conditions?", "io_requirements": "Input:\n  `dimension` (int): The size of the NxN chessboard. It should be a positive integer.\n\nOutput:\n  `return` (list of lists): A 2D list representing the chessboard with queens placed in valid positions. Each sublist represents a row in the chessboard. If no solution is found, it returns the string \"No solution found\".", "refcode": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\ndef isBoardValid(board, row, column):\n    dimension = len(board)\n    for i in range(column):\n        if board[row][i] == 1:\n            return False\n    for i, j in zip(range(row), range(column)):\n        if board[i][j] == 1:\n            return False\n    \n    for i, j in zip(range(row + 1, dimension), range(column - 1, -1, -1)):\n        if board[i][j] == 1:\n            return False          \n    return True \n\ndef NQueen(board, column):\n    if len(board) == column:\n        return board\n    else:\n        for row in range(len(board)):\n            board[row][column] = 1\n            if isBoardValid(board, row, column) == True:\n                result = NQueen(board, column + 1)\n                if result:\n                    return result\n            board[row][column] = 0\n    return None\n\n# main function\ndef main_solution(dimension):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  board = [[0]*dimension for _ in range(dimension)]\n  result = NQueen(board, 0)\n  if result:\n      return result\n  else:\n      return \"No solution found\"", "funcname": "main_solution", "ios": [{"input": {"dimension": 7}, "output": [[0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1]]}, {"input": {"dimension": 5}, "output": [[0, 0, 0, 0, 1], [1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0]]}, {"input": {"dimension": 4}, "output": [[0, 0, 1, 0], [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1]]}, {"input": {"dimension": 6}, "output": [[0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "aindrila2412/Algorithms", "path": "/Specific_Algorithms/NQueenProblem.py", "msgidx": 12998}}
{"problem_description": "Given a 2D binary matrix where each cell contains either 0 or 1, and a list of group sizes, how many groups of each specified size exist in the matrix? A group is defined as a set of cells containing 1 that are adjacent to each other (either horizontally or vertically).", "io_requirements": "Input:\n  `matrix` (list of lists of integers): A 2D array of integers where each element is either 0 or 1. The size of the matrix is n x n.\n  `group_sizes` (list of integers): An array of integers where each integer represents a group size for which the number of groups in the matrix should be found.\n\nOutput:\n  `return` (list of integers): An array of integers where each element at index k denotes the number of groups of size `group_sizes[k]` present in the matrix.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# main function\ndef main_solution(matrix, group_sizes):\n    M, N = len(matrix), len(matrix[0])\n    cnt = defaultdict(int)\n    visited = [[False] * N for _ in range(M)]\n\n    def dfs(r, c):\n        visited[r][c] = True\n        ret = 1\n        for i, j in zip((r, r, r-1, r+1), (c-1, c+1, c, c)):\n            if not (i < 0 or i == M or j < 0 or j == N or matrix[i][j] == 0 or visited[i][j]):\n                ret += dfs(i, j)\n        return ret\n\n    for r in range(M):\n        for c in range(N):\n            if matrix[r][c] == 1 and not visited[r][c]:\n                group_size = dfs(r, c)\n                cnt[group_size] += 1\n    \n    return [cnt[tk] for tk in group_sizes]", "funcname": "main_solution", "ios": [{"input": {"matrix": [[1, 1, 1], [1, 0, 1], [1, 0, 0]], "group_sizes": [7, 4]}, "output": [0, 0]}, {"input": {"matrix": [[0, 0], [0, 1]], "group_sizes": [4]}, "output": [0]}, {"input": {"matrix": [[1, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 0], [1, 0, 1, 1]], "group_sizes": [4, 15, 7, 4]}, "output": [0, 0, 1, 0]}, {"input": {"matrix": [[0, 0], [1, 1]], "group_sizes": [4, 1]}, "output": [0, 0]}, {"input": {"matrix": [[0, 0, 1, 0], [1, 0, 0, 1], [0, 0, 0, 0], [1, 0, 0, 1]], "group_sizes": [11, 10]}, "output": [0, 0]}, {"input": {"matrix": [[1, 1, 0, 1], [1, 0, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1]], "group_sizes": [6]}, "output": [0]}, {"input": {"matrix": [[1, 1, 1, 0], [1, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 0]], "group_sizes": [16, 7, 1]}, "output": [0, 0, 0]}, {"input": {"matrix": [[1]], "group_sizes": [1]}, "output": [1]}, {"input": {"matrix": [[0]], "group_sizes": [1]}, "output": [0]}, {"input": {"matrix": [[0, 0], [0, 0]], "group_sizes": [4, 1]}, "output": [0, 0]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "snowdj/cs_course", "path": "/Algorithms/challenges/hr_counting_groups.py", "msgidx": 13276}}
{"problem_description": "Given a matrix of characters and a word, determine if there is a path in the matrix that forms the given word. The path can start from any cell in the matrix and can move left, right, up, or down. Each cell in the matrix can be used only once in the path. What is the result of whether the word can be formed in the matrix?", "io_requirements": "Input:\n  `board` (List[List[str]]): A 2D list of strings representing the matrix. Each element in the list is a string of length 1.\n  `word` (str): A string representing the word to be searched in the matrix.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the word exists in the matrix.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        m, n = len(board), len(board[0])\n        if m == 0: return False\n\n        marked = [[False for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if self.search_word(board, word, 0, i, j, marked, m, n):\n                    return True\n        return False\n\n    directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n\n    def search_word(self, board, word, index, x, y, marked, m, n):\n        if index == len(word) - 1:  # word\u53ea\u6709\u4e00\u4e2a\n            return board[x][y] == word[index]\n        if board[x][y] == word[index]:  # \u5173\u952e\u70b9\uff01\u4eceword\u7684\u7b2c\u4e00\u4e2a\u5f00\u59cb\u627e\uff01\n            marked[x][y] = True\n            for direction in self.directions:\n                new_x = x + direction[0]\n                new_y = y + direction[1]\n                if 0 <= new_x < m and 0 <= new_y < n and not marked[new_x][new_y] and \\\n                        self.search_word(board, word, index + 1, new_x, new_y, marked, m, n):\n                    return True\n            marked[x][y] = False\n\n        return False\n\n# main function\ndef main_solution(board: List[List[str]], word: str) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.exist(board, word)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"board": [["g", "x", "j"]], "word": "bpd"}, "output": false}, {"input": {"board": [["o"]], "word": "vaxf"}, "output": false}, {"input": {"board": [["u", "u", "c"], ["a", "n", "w"]], "word": "hazop"}, "output": false}, {"input": {"board": [["i", "c", "w", "g"]], "word": "nluc"}, "output": false}, {"input": {"board": [["e"]], "word": "qh"}, "output": false}, {"input": {"board": [["q", "v", "c"]], "word": "pw"}, "output": false}, {"input": {"board": [["p"], ["q"]], "word": "rqt"}, "output": false}, {"input": {"board": [["e", "m", "n", "b"]], "word": "f"}, "output": false}, {"input": {"board": [["k", "f", "r", "f"], ["s", "m", "i", "c"]], "word": "y"}, "output": false}, {"input": {"board": [["g"], ["d"], ["v"]], "word": "q"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Stevenzzz1996/MLLCV", "path": "/Leetcode/\u52a8\u6001\u89c4\u5212/\u9762\u8bd5\u989812. \u77e9\u9635\u4e2d\u7684\u8def\u5f84.py", "msgidx": 12893}}
{"problem_description": "Given two wires laid out on a grid, each following a specific path defined by a series of movements, determine the Manhattan distance from the origin to the closest point where the two wires intersect. The paths of the wires are described by strings where each movement is denoted by a direction (Right, Left, Up, Down) followed by a distance. What is the minimum Manhattan distance to an intersection point?", "io_requirements": "Input:\n- `wire1` (str): A string representing the path of the first wire. Each movement is separated by a comma, and each movement is denoted by a direction (R, L, U, D) followed by a number indicating the distance.\n- `wire2` (str): A string representing the path of the second wire. The format is the same as `wire1`.\n\nOutput:\n- `return` (int): The Manhattan distance from the origin (0, 0) to the closest intersection point of the two wires. If no intersection exists, it returns `float('inf')`.", "refcode": "import math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Section:\n    def __init__(self, point1, point2):\n        self.point1 = point1\n        self.point2 = point2\n\ndef get_list_of_all_points(wire):\n    list_of_points = wire.split(',')\n    list_of_each_points = list()\n    x = 0\n    y = 0\n    for i in list_of_points:\n        if i.startswith(\"R\"):\n            x += int(i[1:])\n        elif i.startswith(\"L\"):\n            x -= int(i[1:])\n        elif i.startswith(\"U\"):\n            y += int(i[1:])\n        elif i.startswith(\"D\"):\n            y -= int(i[1:])\n        list_of_each_points.append(Point(x, y))\n    return list_of_each_points\n\ndef calculate_dist_between_points(c1, c2):\n    return abs(c1.x - c2.x) + abs(c1.y - c2.y)\n\ndef direction(a, b, c):\n    val = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)\n    if val == 0:\n        return 0\n    elif val < 0:\n        return 2\n    return 1\n\ndef on_line(l1, p):\n    return (p.x <= max(l1.point1.x, l1.point2.x) and p.x >= min(l1.point1.x, l1.point2.x) and\n            p.y <= max(l1.point1.y, l1.point2.y) and p.y >= min(l1.point1.y, l1.point2.y))\n\ndef is_intersect(l1, l2):\n    dir1 = direction(l1.point1, l1.point2, l2.point1)\n    dir2 = direction(l1.point1, l1.point2, l2.point2)\n    dir3 = direction(l2.point1, l2.point2, l1.point1)\n    dir4 = direction(l2.point1, l2.point2, l1.point2)\n\n    if dir1 != dir2 and dir3 != dir4:\n        return True\n    if dir1 == 0 and on_line(l1, l2.point1):\n        return True\n    if dir2 == 0 and on_line(l1, l2.point2):\n        return True\n    if dir3 == 0 and on_line(l2, l1.point1):\n        return True\n    if dir4 == 0 and on_line(l2, l1.point2):\n        return True\n    return False\n\ndef create_sections_list(list_of_points):\n    list_of_sections = list()\n    for i in range(len(list_of_points) - 1):\n        list_of_sections.append(Section(list_of_points[i], list_of_points[i + 1]))\n    return list_of_sections\n\ndef get_list_of_intersect_points(sections1, sections2):\n    list_of_intersect_points = list()\n    for i in range(len(sections1)):\n        for j in range(len(sections2)):\n            if is_intersect(sections1[i], sections2[j]):\n                x_intersect = max(min(sections1[i].point1.x, sections1[i].point2.x), min(sections2[j].point1.x, sections2[j].point2.x))\n                y_intersect = max(min(sections1[i].point1.y, sections1[i].point2.y), min(sections2[j].point1.y, sections2[j].point2.y))\n                list_of_intersect_points.append(Point(x_intersect, y_intersect))\n    return list_of_intersect_points\n\ndef get_min_distance(sections1, sections2):\n    list_of_intersect_points = get_list_of_intersect_points(sections1, sections2)\n    list_of_distances = [calculate_dist_between_points(Point(0, 0), p) for p in list_of_intersect_points]\n    return min(list_of_distances) if list_of_distances else float('inf')\n\ndef main_solution(wire1, wire2):\n    points1 = get_list_of_all_points(wire1)\n    points2 = get_list_of_all_points(wire2)\n    sections1 = create_sections_list(points1)\n    sections2 = create_sections_list(points2)\n    min_distance = get_min_distance(sections1, sections2)\n    return min_distance", "funcname": "main_solution", "ios": [{"input": {"wire1": "R1,L6,U6,L8,R1,R4,D4,U1,D2,D7", "wire2": "D3,R1,U5,D8,D10,D9,R4,L3,R3,R9"}, "output": 1}, {"input": {"wire1": "D4,U2,D1,U1,U8,R1,R4,D6,L5,U9", "wire2": "D8,R9,U10,U7,U1,U10,R7,D1,U2,U3"}, "output": Infinity}, {"input": {"wire1": "U6,L5,R5,L5,R2,U3,D1,U1,U10,R4", "wire2": "R5,R3,U1,L8,D10,L9,D10,D6,L2,R9"}, "output": Infinity}, {"input": {"wire1": "D2,U4,D5,L8,L2,L4,D1,R8,R7,R8", "wire2": "R7,U10,L3,D1,L8,L6,D10,R4,R9,L9"}, "output": 1}, {"input": {"wire1": "U8,U4,D9,L9,U4,D4,D10,R1,D4,L6", "wire2": "D2,R1,U10,L6,U2,U6,R2,R7,D8,D3"}, "output": 8}, {"input": {"wire1": "U1,D7,R5,D5,D2,U6,U8,U7,R2,D4", "wire2": "R1,R2,U1,D7,L7,U8,R7,U10,D2,L4"}, "output": 6}, {"input": {"wire1": "R6,L6,U3,U3,L3,U8,U5,R7,D3,U1", "wire2": "L4,R5,R7,L5,L2,L2,L8,D8,R10,D3"}, "output": 0}, {"input": {"wire1": "U4,U9,R5,U1,L8,R1,R8,D1,L6,U2", "wire2": "U2,R6,R9,U1,D2,U5,L2,D7,L5,D8"}, "output": Infinity}, {"input": {"wire1": "U8,R4,D6,R1,R9,R6,U10,U9,U7,R2", "wire2": "L2,R1,R10,U8,L7,U4,D10,L4,L7,D3"}, "output": 10}, {"input": {"wire1": "R6,R9,U9,R10,L7,R2,L8,U10,R1,D5", "wire2": "R5,L8,D3,U4,L1,D10,R5,D6,L5,U2"}, "output": Infinity}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Zokero/AdventCalendar", "path": "/03.12.2019 (done)/day3.py", "msgidx": 12488}}
{"problem_description": "Given a number `N`, what is the largest pandigital prime number that is less than or equal to `N`? If no such number exists, return `-1`.", "io_requirements": "Input:\n  `N` (int): An integer representing the upper limit to find the largest pandigital prime number less than or equal to this number.\n\nOutput:\n  `return` (int): The largest pandigital prime number less than or equal to `N`, or `-1` if no such number exists.", "refcode": "# import necessary packages\nimport math\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef isPrime(num):\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef allpan():\n    allpan = []\n    for digits in range(4, 8):\n        arr = range(1, digits + 1)\n        for perm in list(itertools.permutations(arr)):\n            if perm[-1] % 2 != 0:\n                num = int(''.join(str(i) for i in perm))\n                if isPrime(num):\n                    allpan.append(num)\n    return allpan\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    allpan_list = allpan()\n    if N <= 1423:\n        return -1\n    else:\n        arr = [i for i in allpan_list if i <= N]\n        return arr[-1]", "funcname": "main_solution", "ios": [{"input": {"N": 972045}, "output": 4231}, {"input": {"N": 846239}, "output": 4231}, {"input": {"N": 248180}, "output": 4231}, {"input": {"N": 639315}, "output": 4231}, {"input": {"N": 117289}, "output": 4231}, {"input": {"N": 650285}, "output": 4231}, {"input": {"N": 804152}, "output": 4231}, {"input": {"N": 215602}, "output": 4231}, {"input": {"N": 536321}, "output": 4231}, {"input": {"N": 170246}, "output": 4231}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ktakats/project-euler", "path": "/problems/problem41.py", "msgidx": 13146}}
{"problem_description": "In a game of chess, a knight moves in an L-shape pattern: two squares in one direction and then one square perpendicular, or one square in one direction and then two squares perpendicular. Given the starting and destination positions of a knight on an 8x8 chessboard, represented as integers where each position is calculated as `row * 8 + column`, what is the minimum number of moves required for the knight to reach the destination from the starting position?", "io_requirements": "Input:\n  `src` (int): The starting position of the knight on a standard 8x8 chessboard, represented as a single integer where the position is calculated as `row * 8 + column`.\n  `dest` (int): The destination position of the knight on a standard 8x8 chessboard, represented as a single integer where the position is calculated as `row * 8 + column`.\n\nOutput:\n  `return` (int): The minimum number of moves required for a knight to travel from the `src` position to the `dest` position on a standard 8x8 chessboard. If no path is found, it returns `-1`.", "refcode": "# import necessary packages\nfrom queue import PriorityQueue\n\n# all class and function definitions in the code file, if any\nmoves = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]\n\ndef convertPosition(pos):\n    return (pos // 8, pos % 8)\n\ndef convertCoordinate(coord):\n    (l, c) = coord\n    return l * 8 + c\n\ndef availableCoord(coord):\n    (l, c) = coord\n    return l >= 0 and l <= 7 and c >= 0 and c <= 7\n\n# main function\ndef main_solution(src, dest):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    src = int(src)\n    dest = int(dest)\n    \n    pq = PriorityQueue()\n    pq.put((0, convertPosition(src)))\n    visit = set()\n    goal = convertPosition(dest)\n    \n    while pq.qsize() > 0:\n        (dist, (l, c)) = pq.get()\n        if (l, c) in visit:\n            continue\n        visit.add((l, c))\n        if((l, c) == goal):\n            return dist\n        for (ml, mc) in moves:\n            if availableCoord((l + ml, c + mc)):\n                pq.put((dist + 1, (l + ml, c + mc)))\n    \n    return -1  # In case no path is found, though it should always find a path in a valid chessboard scenario", "funcname": "main_solution", "ios": [{"input": {"src": 60, "dest": 9}, "output": 3}, {"input": {"src": 22, "dest": 48}, "output": 4}, {"input": {"src": 39, "dest": 42}, "output": 4}, {"input": {"src": 42, "dest": 31}, "output": 3}, {"input": {"src": 41, "dest": 40}, "output": 3}, {"input": {"src": 35, "dest": 31}, "output": 3}, {"input": {"src": 39, "dest": 36}, "output": 3}, {"input": {"src": 14, "dest": 22}, "output": 3}, {"input": {"src": 10, "dest": 11}, "output": 3}, {"input": {"src": 44, "dest": 59}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wxnn08/RepLord", "path": "/foobar/dont-get-volunteered.py", "msgidx": 13413}}
{"problem_description": "In a space exploration mission, a team of astronomers is analyzing an asteroid field to determine the best location for a monitoring station. The field is represented as a grid where each cell can either contain an asteroid (`#`) or be empty (`.`). The team needs to identify the asteroid from which the maximum number of other asteroids can be seen without any obstruction. Given the map of the asteroid field, which asteroid should the team choose for the monitoring station, and how many other asteroids can be seen from this location?", "io_requirements": "Input:\n  `map_str` (str): A string representing the asteroid map. Each line is separated by a newline character (`\\n`), and asteroids are represented by the `#` character.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `best_asteroid` (dict): A dictionary with keys `x` and `y` representing the coordinates of the best asteroid.\n    - `best_count` (int): The number of other asteroids that the best asteroid has a clear line of sight to.", "refcode": "# import necessary packages\nimport math\nfrom numpy import add, subtract, divide, multiply\n\n# all class and function definitions in the code file, if any\nclass AsteroidMap:\n    def __init__(self, map_str):\n        self.asteroids = []\n\n        lines = map_str.split('\\n')\n        for y in range(len(lines)):\n            line = lines[y]\n            for x in range(len(line)):\n                if line[x] == '#':\n                    self.asteroids.append((x,y))\n\n        self.max_x = max(map(lambda point: point[0], self.asteroids))\n        self.max_y = max(map(lambda point: point[1], self.asteroids))\n\n    def count_visible(self, origin):\n        visible = self.asteroids.copy()\n\n        for target in self.asteroids:\n            if target == origin:\n                visible.remove(target)\n                continue\n\n            diff = subtract(target, origin)\n            step = divide(diff, math.gcd(*diff))\n\n            for i in range(1, 2**31):\n                hidden_point = tuple(add(target, multiply(step, i)))\n                if hidden_point in visible:\n                    visible.remove(hidden_point)\n\n                x, y = hidden_point\n                if x < 0 or y < 0 or x > self.max_x or y > self.max_y:\n                    break\n\n        return len(visible)\n\n    def find_best(self):\n        visible_counts = list(map(self.count_visible, self.asteroids))\n        best_count = max(visible_counts)\n        best_index = visible_counts.index(best_count)\n\n        return (self.asteroids[best_index], best_count)\n\n# main function\ndef main_solution(map_str):\n    # Convert the input string to a JSON serializable format\n    asteroid_map = AsteroidMap(map_str)\n    best_asteroid, best_count = asteroid_map.find_best()\n    \n    # Convert the output to a JSON serializable format\n    best_asteroid_json = {'x': best_asteroid[0], 'y': best_asteroid[1]}\n    return {'best_asteroid': best_asteroid_json, 'best_count': best_count}", "funcname": "main_solution", "ios": [{"input": {"map_str": "......#\n##...##\n.##..#.\n..#....\n##.....\n#......"}, "output": {"best_asteroid": {"x": 6, "y": 0}, "best_count": 11}}, {"input": {"map_str": "..#....#\n..#...##\n#...#.##\n.#....#.\n..###...\n#...###.\n.#....#."}, "output": {"best_asteroid": {"x": 2, "y": 0}, "best_count": 18}}, {"input": {"map_str": "..#...\n#.##..\n#####.\n#...##\n.##...\n.#...."}, "output": {"best_asteroid": {"x": 1, "y": 4}, "best_count": 14}}, {"input": {"map_str": "...#......\n.#.#....##\n..#...#...\n.#.##.....\n#........#\n##..#.....\n......#..#\n##.#..#.#."}, "output": {"best_asteroid": {"x": 9, "y": 4}, "best_count": 20}}, {"input": {"map_str": ".......\n..##...\n##...#.\n#..#.#.\n.......\n...#..#\n..##.##\n.#...##"}, "output": {"best_asteroid": {"x": 1, "y": 2}, "best_count": 15}}, {"input": {"map_str": "....#.\n##..#.\n......\n##...#\n#.....\n.#...."}, "output": {"best_asteroid": {"x": 1, "y": 3}, "best_count": 8}}, {"input": {"map_str": "#.....#..\n.##...#..\n##.#.#...\n...##.##.\n....#....\n##.#.....\n..#......\n...##...#\n...###..#\n##.....#."}, "output": {"best_asteroid": {"x": 5, "y": 2}, "best_count": 25}}, {"input": {"map_str": "...#.....\n....#.#..\n......#..\n#..##....\n.#.#..##.\n#.#.###.."}, "output": {"best_asteroid": {"x": 3, "y": 3}, "best_count": 15}}, {"input": {"map_str": ".........\n........#\n###...#..\n.####...#\n.##.###.#\n...#.....\n#.#.#....\n.#.#.#...\n#..####.."}, "output": {"best_asteroid": {"x": 3, "y": 7}, "best_count": 25}}, {"input": {"map_str": ".#..#..\n.#.##..\n.......\n#......\n#..#..#\n#.#..#.\n#......\n....#.."}, "output": {"best_asteroid": {"x": 1, "y": 0}, "best_count": 13}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DenizenB/advent-of-code", "path": "/2019/10a.py", "msgidx": 13045}}
{"problem_description": "Given a binary tree where each node contains an integer value, a unival tree is defined as a tree where all nodes under it have the same value. How many unival subtrees are there in the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (str): A JSON string representing the structure of the binary tree. Each node is represented as a dictionary with keys `\"val\"` (int), `\"left\"` (dict or None), and `\"right\"` (dict or None).\n\nOutput:\n  `return` (int): The number of unival subtrees in the given binary tree.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef helper(root, root_val):\n    if root is None:\n        return True\n    elif root.val == root_val:\n        return helper(root.left, root_val) and helper(root.right, root_val)\n    return False\n\ndef check_unival(root):\n    return helper(root, root.val)\n\ndef count_unival_subtrees(root):\n    if root is None:\n        return 0\n    left = count_unival_subtrees(root.left)\n    right = count_unival_subtrees(root.right)\n    return 1 + left + right if check_unival(root) else left + right\n\ndef bottom_up_helper(root, val):\n    if root is None:\n        return 0, True\n    left_count, l_nodes_match = bottom_up_helper(root.left, root.val)\n    right_count, r_nodes_match = bottom_up_helper(root.right, root.val)\n\n    if left_count == 0 and right_count == 0 and l_nodes_match is True and r_nodes_match is True:\n        if root.val == val:\n            return 1, True\n        else:\n            return 1, False\n    else:\n        if (l_nodes_match and r_nodes_match) is True and root.val == val:\n            return 1 + left_count + right_count, True\n        elif (l_nodes_match and r_nodes_match) is True and root.val != val:\n            return 1 + left_count + right_count, False\n        else:\n            return left_count + right_count, False\n\ndef count_unival_bottom_up(root):\n    count, _ = bottom_up_helper(root, root.val)\n    return count\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        return Node(data[\"val\"], build_tree(data[\"left\"]), build_tree(data[\"right\"]))\n\n    root = build_tree(json.loads(tree_structure))\n    \n    # Call the function to count unival subtrees\n    result = count_unival_bottom_up(root)\n    \n    # Return the result, which is JSON serializable\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": "{\"val\": 1, \"left\": null, \"right\": null}"}, "output": 1}, {"input": {"tree_structure": "{\"val\": 0, \"left\": null, \"right\": null}"}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "RafayAK/CodingPrep", "path": "/DailyCodingProblem/8_Google_Unival_trees.py", "msgidx": 13342}}
{"problem_description": "Given a set of numbers from 0 to 9, how many unique pairs of cubes can be formed such that each pair can display all the required squares (01, 04, 09, 16, 25, 36, 49, 64, 81) when the cubes are combined? Each cube is formed by selecting a certain number of choices from the set of numbers.", "io_requirements": "Input:\n  `nums` (list of integers): A list of integers from which combinations will be made.\n  `choices` (integer): The number of choices to make from the `nums` list.\n\nOutput:\n  `return` (integer): The number of unique pairs of cubes that can display all required squares.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef all_squares(cube1, cube2):\n    return (can_show(cube1, cube2, 0, 1) and \n            can_show(cube1, cube2, 0, 4) and \n            can_show(cube1, cube2, 0, 9) and\n            can_show(cube1, cube2, 1, 6) and \n            can_show(cube1, cube2, 2, 5) and\n            can_show(cube1, cube2, 3, 6) and\n            can_show(cube1, cube2, 4, 9) and\n            can_show(cube1, cube2, 6, 4) and\n            can_show(cube1, cube2, 8, 1))\n        \ndef can_show(cube1, cube2, digit1, digit2):\n    return ((cube_can_show(cube1, digit1) and\n             cube_can_show(cube2, digit2)) or\n            (cube_can_show(cube1, digit2) and\n             cube_can_show(cube2, digit1)))\n\ndef cube_can_show(cube, digit):\n    if (digit == 6) or (digit == 9):\n        return (6 in cube) or (9 in cube)\n    return (digit in cube)\n\n# main function\ndef main_solution(nums, choices):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    nums = list(nums)\n    cube_pairs = set()\n\n    for cube1 in (frozenset(c) for c in itertools.combinations(nums, choices)):\n        for cube2 in (frozenset(c) for c in itertools.combinations(nums, choices)):\n            if all_squares(cube1, cube2):\n                cube_pairs.add(frozenset([cube1, cube2]))\n\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return len(cube_pairs)", "funcname": "main_solution", "ios": [{"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 3}, "output": 0}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 4}, "output": 0}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 5}, "output": 122}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 8}, "output": 632}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 9}, "output": 48}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 7}, "output": 1876}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 2}, "output": 0}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 1}, "output": 0}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 6}, "output": 1217}, {"input": {"nums": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "choices": 10}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "plumdog/project_euler", "path": "/problem090/python/main.py", "msgidx": 13272}}
{"problem_description": "Given a range of numbers and a specific filter, how many prime numbers can be generated that meet the specified criteria within the given range? Specifically, you need to determine the prime numbers starting from `start_range` and ending at `end_range` (if not 0), and apply a filter that can either be 'none', 'end_with_1', or 'palindromic'. How many such prime numbers can be found?", "io_requirements": "Input:\n- `start_range` (int): The starting number for the prime number iterator.\n- `end_range` (int): The ending number for the prime number iterator. If 0, it iterates indefinitely.\n- `prime_count` (int): The number of prime numbers to generate.\n- `prime_filter` (str): The filter to apply to the prime numbers. Can be 'none', 'end_with_1', or 'palindromic'.\n\nOutput:\n- `return` (list): A list of prime numbers that meet the criteria.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\nclass Prime(object):\n    \"\"\" An iterator for prime numbers \"\"\"\n\n    def __init__(self, initial, final=0):\n        \"\"\" Initializer - accepts a number \"\"\"\n        self.current = initial\n        self.final = final\n        \n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        \"\"\" Return next item in iterator \"\"\"\n        return self._compute()\n\n    def _compute(self):\n        \"\"\" Compute the next prime number \"\"\"\n        num = self.current\n        \n        while True:\n            is_prime = True\n            \n            for x in range(2, int(pow(self.current, 0.5)+1)):\n                if self.current % x == 0:\n                    is_prime = False\n                    break\n\n            num = self.current\n            self.current += 1\n\n            if is_prime:\n                return num\n            \n            if self.final > 0 and self.current > self.final:\n                raise StopIteration\n\n# main function\ndef main_solution(start_range, end_range, prime_count, prime_filter):\n    \"\"\"\n    Generate a list of prime numbers based on the given criteria.\n\n    Parameters:\n    start_range (int): The starting number for the prime number iterator.\n    end_range (int): The ending number for the prime number iterator. If 0, it iterates indefinitely.\n    prime_count (int): The number of prime numbers to generate.\n    prime_filter (str): The filter to apply to the prime numbers. Can be 'none', 'end_with_1', or 'palindromic'.\n\n    Returns:\n    list: A list of prime numbers that meet the criteria.\n    \"\"\"\n    prime_iterator = Prime(start_range, end_range)\n    \n    if prime_filter == 'none':\n        prime_list = list(itertools.islice(prime_iterator, prime_count))\n    elif prime_filter == 'end_with_1':\n        prime_list = list(itertools.islice(itertools.filterfalse(lambda x: x % 10 != 1, prime_iterator), prime_count))\n    elif prime_filter == 'palindromic':\n        prime_list = list(itertools.islice(itertools.filterfalse(lambda x: str(x) != str(x)[-1::-1], prime_iterator), prime_count))\n    else:\n        raise ValueError(\"Invalid prime_filter value. Choose from 'none', 'end_with_1', or 'palindromic'.\")\n    \n    return prime_list", "funcname": "main_solution", "ios": [{"input": {"start_range": 38, "end_range": 59, "prime_count": 17, "prime_filter": "end_with_1"}, "output": [41]}, {"input": {"start_range": 21, "end_range": 0, "prime_count": 12, "prime_filter": "none"}, "output": [23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]}, {"input": {"start_range": 21, "end_range": 104, "prime_count": 10, "prime_filter": "end_with_1"}, "output": [31, 41, 61, 71, 101]}, {"input": {"start_range": 1, "end_range": 0, "prime_count": 9, "prime_filter": "end_with_1"}, "output": [1, 11, 31, 41, 61, 71, 101, 131, 151]}, {"input": {"start_range": 50, "end_range": 98, "prime_count": 16, "prime_filter": "none"}, "output": [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]}, {"input": {"start_range": 80, "end_range": 127, "prime_count": 1, "prime_filter": "end_with_1"}, "output": [101]}, {"input": {"start_range": 7, "end_range": 67, "prime_count": 7, "prime_filter": "palindromic"}, "output": [7, 11]}, {"input": {"start_range": 19, "end_range": 112, "prime_count": 16, "prime_filter": "palindromic"}, "output": [101]}, {"input": {"start_range": 51, "end_range": 106, "prime_count": 3, "prime_filter": "none"}, "output": [53, 59, 61]}, {"input": {"start_range": 96, "end_range": 166, "prime_count": 13, "prime_filter": "palindromic"}, "output": [101, 131, 151]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "PacktPublishing/Software-Architecture-with-Python", "path": "/Chapter07/iterator.py", "msgidx": 12967}}
{"problem_description": "In the classic Tower of Hanoi puzzle, there are three pegs and a number of disks of different sizes that can slide onto any peg. The puzzle starts with the disks neatly stacked in ascending order of size on one peg, the smallest at the top. The objective of the puzzle is to move the entire stack to another peg, obeying the following simple rules:\n1. Only one disk can be moved at a time.\n2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty peg.\n3. No disk may be placed on top of a smaller disk.\n\nGiven the number of disks `n` and the k-th move `k` in the sequence of moves to solve the Tower of Hanoi problem, which pegs are involved in the k-th move?", "io_requirements": "Input:\n  `n` (int): The number of disks in the Tower of Hanoi problem.\n  `k` (int): The k-th move in the sequence of moves to solve the Tower of Hanoi problem.\n\nOutput:\n  `return` (str): A string representing the k-th move in the format \"start target\", where `start` and `target` are the pegs involved in the move.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef hanoi_move(start, via, target, n, k):\n    if k == 2**(n - 1):\n        return f\"{start} {target}\"\n    elif k < 2**(n - 1):\n        return hanoi_move(start, target, via, n - 1, k)\n    else:\n        return hanoi_move(via, start, target, n - 1, k - 2**(n - 1))\n\n# main function\ndef main_solution(n, k):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = hanoi_move(1, 2, 3, n, k)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 4, "k": 12}, "output": "2 3"}, {"input": {"n": 7, "k": 70}, "output": "3 1"}, {"input": {"n": 3, "k": 5}, "output": "2 1"}, {"input": {"n": 4, "k": 15}, "output": "2 3"}, {"input": {"n": 1, "k": 1}, "output": "1 3"}, {"input": {"n": 8, "k": 106}, "output": "2 1"}, {"input": {"n": 2, "k": 1}, "output": "1 2"}, {"input": {"n": 10, "k": 243}, "output": "2 3"}, {"input": {"n": 7, "k": 33}, "output": "3 2"}, {"input": {"n": 6, "k": 34}, "output": "2 1"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "AprajitaChhawi/365DaysOfCode.MAY", "path": "/Day 19 tower of hanoi.py", "msgidx": 13488}}
{"problem_description": "Given a set of digits from '0' to '9', what is the sum of all 10-digit numbers that can be formed by permuting these digits, where each number satisfies the condition that the number formed by every three consecutive digits is divisible by a specific prime number (2, 3, 5, 7, 11, 13, 17)?", "io_requirements": "Input:\n  `digits` (str): A string of digits from '0' to '9' that will be permuted to find numbers fitting a specific pattern.\n\nOutput:\n  `return` (int): The sum of all numbers that fit the pattern described in the `fitsPattern` function.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef fitsPattern(perm):\n    divisors = [2, 3, 5, 7, 11, 13, 17]\n    for i in range(1, 8):\n        numString = ''.join([perm[i], perm[i+1], perm[i+2]])\n        number = int(numString)\n        divisor = divisors[i-1]\n        \n        if number % divisor != 0:\n            return False\n    return True\n\n# main function\ndef main_solution(digits):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    digits = list(digits)  # Convert the input string to a list of characters\n    \n    numSum = 0\n    for perm in list(itertools.permutations(digits)):\n        if fitsPattern(perm):\n            numSum += int(''.join(perm))\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return numSum", "funcname": "main_solution", "ios": [{"input": {"digits": "7183592046"}, "output": 16695334890}, {"input": {"digits": "8490732165"}, "output": 16695334890}, {"input": {"digits": "2695074318"}, "output": 16695334890}, {"input": {"digits": "9321746580"}, "output": 16695334890}, {"input": {"digits": "4930162875"}, "output": 16695334890}, {"input": {"digits": "1976203584"}, "output": 16695334890}, {"input": {"digits": "6853290417"}, "output": 16695334890}, {"input": {"digits": "3701984625"}, "output": 16695334890}, {"input": {"digits": "8547319602"}, "output": 16695334890}, {"input": {"digits": "1379608254"}, "output": 16695334890}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Akhunrah/Project-Euler", "path": "/Problem043.py", "msgidx": 13170}}
{"problem_description": "In a 10x10 grid maze, an agent starts at a given initial position and aims to reach a target position while avoiding randomly placed obstacles. The agent can move up, down, left, or right. If the agent reaches the target, it receives a high reward. If it hits an obstacle, it receives a negative reward and the episode ends. If the agent moves without reaching the target or hitting an obstacle, it receives a small negative reward. What is the final state of the agent, the reward it receives, and whether the episode is done after a series of random movements?", "io_requirements": "Input:\n  - `initial_position` (list of int): The starting position of the agent in the maze, represented as [x, y] coordinates.\n  - `target_position` (list of int): The target position in the maze, represented as [x, y] coordinates.\n  - `obstacles` (list of list of int): A list of obstacle positions in the maze, each represented as [x, y] coordinates.\n\nOutput:\n  - `result` (dict): A dictionary containing the final state of the agent, the reward, and whether the episode is done.\n    - `final_state` (list of int): The final position of the agent in the maze, represented as [x, y] coordinates.\n    - `reward` (int): The reward received by the agent.\n    - `done` (bool): Whether the episode is done (True if the agent reaches the target or hits an obstacle).", "refcode": "# import necessary packages\nimport numpy as np\n\n# Constants\nUNIT = 40   # pixels\nMAZE_H = 10  # grid height\nMAZE_W = 10  # grid width\n\n# main function\ndef main_solution(initial_position, target_position, obstacles):\n    \"\"\"\n    Simulates a simple maze environment where an agent navigates from an initial position to a target position, avoiding obstacles.\n    \n    Parameters:\n    - initial_position (list of int): The starting position of the agent in the maze, represented as [x, y] coordinates.\n    - target_position (list of int): The target position in the maze, represented as [x, y] coordinates.\n    - obstacles (list of list of int): A list of obstacle positions in the maze, each represented as [x, y] coordinates.\n    \n    Returns:\n    - result (dict): A dictionary containing the final state of the agent, the reward, and whether the episode is done.\n        - 'final_state' (list of int): The final position of the agent in the maze, represented as [x, y] coordinates.\n        - 'reward' (int): The reward received by the agent.\n        - 'done' (bool): Whether the episode is done (True if the agent reaches the target or hits an obstacle).\n    \"\"\"\n    # Convert initial_position and target_position to numpy arrays\n    initial_position = np.array(initial_position)\n    target_position = np.array(target_position)\n    \n    # Initialize the agent's state\n    state = initial_position\n    reward = 0\n    done = False\n    \n    # Define the possible actions\n    actions = ['u', 'd', 'l', 'r']\n    \n    # Simulate the agent's movement\n    while not done:\n        # Choose a random action\n        action = np.random.choice(actions)\n        \n        # Update the state based on the action\n        if action == 'u' and state[1] > 0:\n            state[1] -= UNIT\n        elif action == 'd' and state[1] < (MAZE_H - 1) * UNIT:\n            state[1] += UNIT\n        elif action == 'l' and state[0] > 0:\n            state[0] -= UNIT\n        elif action == 'r' and state[0] < (MAZE_W - 1) * UNIT:\n            state[0] += UNIT\n        \n        # Check if the agent has reached the target\n        if np.array_equal(state, target_position):\n            reward = 100\n            done = True\n        # Check if the agent has hit an obstacle\n        elif any(np.array_equal(state, obs) for obs in obstacles):\n            reward = -5\n            done = True\n        else:\n            reward -= 1\n    \n    # Return the result as a dictionary\n    return {\n        'final_state': state.tolist(),\n        'reward': reward,\n        'done': done\n    }", "funcname": "main_solution", "ios": [{"input": {"initial_position": [280, 40], "target_position": [320, 40], "obstacles": [[280, 200], [120, 160]]}, "output": {"final_state": [320, 40], "reward": 100, "done": true}}, {"input": {"initial_position": [320, 200], "target_position": [280, 120], "obstacles": [[280, 0], [280, 320]]}, "output": {"final_state": [280, 120], "reward": 100, "done": true}}, {"input": {"initial_position": [0, 320], "target_position": [360, 320], "obstacles": [[40, 200], [160, 240]]}, "output": {"final_state": [160, 240], "reward": -5, "done": true}}, {"input": {"initial_position": [200, 200], "target_position": [120, 160], "obstacles": [[0, 280], [120, 240]]}, "output": {"final_state": [120, 160], "reward": 100, "done": true}}, {"input": {"initial_position": [320, 80], "target_position": [200, 280], "obstacles": [[320, 200], [120, 240]]}, "output": {"final_state": [320, 200], "reward": -5, "done": true}}, {"input": {"initial_position": [0, 360], "target_position": [240, 80], "obstacles": [[120, 40]]}, "output": {"final_state": [120, 40], "reward": -5, "done": true}}, {"input": {"initial_position": [320, 40], "target_position": [320, 240], "obstacles": [[360, 120], [360, 240]]}, "output": {"final_state": [320, 240], "reward": 100, "done": true}}, {"input": {"initial_position": [200, 280], "target_position": [80, 160], "obstacles": [[160, 280]]}, "output": {"final_state": [160, 280], "reward": -5, "done": true}}, {"input": {"initial_position": [80, 200], "target_position": [240, 200], "obstacles": [[160, 80]]}, "output": {"final_state": [240, 200], "reward": 100, "done": true}}, {"input": {"initial_position": [120, 360], "target_position": [0, 40], "obstacles": [[40, 240], [360, 120]]}, "output": {"final_state": [360, 120], "reward": -5, "done": true}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yfchenShirley/compare_maze_3algorithms", "path": "/maze_env.py", "msgidx": 12924}}
{"problem_description": "Given a partially filled 3x3 mini sudoku board, can you determine if it is possible to complete the board according to the rules of sudoku? The board consists of cells that can contain the numbers 1, 2, or 3, and some cells may be empty (represented by 0). The rules of sudoku require that each row and each column must contain all the numbers 1, 2, and 3 exactly once. What is the completed board if it is solvable, or indicate if it is not possible to complete the board?", "io_requirements": "Input:\n  `board` (list of lists of integers): A 3x3 mini sudoku board represented as a list of lists. Each inner list represents a row in the board. The values in the board can be either 0 (empty cell) or integers 1, 2, or 3.\n\nOutput:\n  `return` (list of lists of integers or None): The solved 3x3 mini sudoku board if it is solvable, otherwise returns None. The board is represented as a list of lists, where each inner list represents a row in the board. The values in the board are integers 1, 2, or 3.", "refcode": "# import necessary packages\nfrom itertools import product\nfrom copy import copy\n\n# all class and function definitions in the code file, if any\ndef is_distinct(array):\n    \"\"\"\n    Auxiliary function to is_solved\n    Checks if all elements in an array are distinct\n    (ignores 0s though)\n    \"\"\"\n    used = []\n    for i in array:\n        if i == 0:\n            continue\n        if i in used:\n            return False\n        used.append(i)\n    return True\n\ndef is_valid(brd):\n    \"\"\"Check if a 3x3 mini sudoku is valid.\"\"\"\n    for i in range(3):\n        row = [brd[i][0], brd[i][1], brd[i][2]]\n        if not is_distinct(row):\n            return False\n        col = [brd[0][i], brd[1][i], brd[2][i]]\n        if not is_distinct(col):\n            return False\n    return True\n\ndef solve(brd, empties=9):\n    \"\"\"\n    Solve a mini sudoku\n    brd is the board\n    empty is the number of empty cells\n    \"\"\"\n    if empties == 0:\n        # base case\n        return is_valid(brd)\n    for row, col in product(range(3), repeat=2):\n        # run through every cell\n        cell = brd[row][col]\n        if cell != 0:\n            # if it's not empty jump\n            continue\n        brd2 = copy(brd)\n        for test in [1, 2, 3]:\n            brd2[row][col] = test\n            if is_valid(brd2) and solve(brd2, empties-1):\n                return True\n            # backtrack\n            brd2[row][col] = 0\n    return False\n\n# main function\ndef main_solution(board):\n    \"\"\"\n    Solves a 3x3 mini sudoku board and returns the solved board if solvable, otherwise returns None.\n    \"\"\"\n    # Convert the input board to a list of lists if it's not already\n    if not isinstance(board, list) or not all(isinstance(row, list) for row in board):\n        raise ValueError(\"Input board must be a list of lists.\")\n    \n    # Count the number of empty cells (cells with value 0)\n    empties = sum(1 for row in board for cell in row if cell == 0)\n    \n    # Solve the board\n    if solve(board, empties):\n        return board\n    else:\n        return None", "funcname": "main_solution", "ios": [{"input": {"board": [[1, 2, 3], [2, 3, 1], [3, 1, 2]]}, "output": [[1, 2, 3], [2, 3, 1], [3, 1, 2]]}, {"input": {"board": [[2, 1, 3], [1, 3, 2], [3, 2, 1]]}, "output": [[2, 1, 3], [1, 3, 2], [3, 2, 1]]}, {"input": {"board": [[2, 1, 3], [3, 2, 1], [1, 3, 2]]}, "output": [[2, 1, 3], [3, 2, 1], [1, 3, 2]]}, {"input": {"board": [[1, 2, 3], [3, 1, 2], [2, 3, 1]]}, "output": [[1, 2, 3], [3, 1, 2], [2, 3, 1]]}, {"input": {"board": [[1, 2, 3], [3, 1, 2], [2, 3, 1]]}, "output": [[1, 2, 3], [3, 1, 2], [2, 3, 1]]}, {"input": {"board": [[1, 2, 3], [3, 1, 2], [2, 3, 1]]}, "output": [[1, 2, 3], [3, 1, 2], [2, 3, 1]]}, {"input": {"board": [[3, 1, 2], [1, 2, 3], [2, 3, 1]]}, "output": [[3, 1, 2], [1, 2, 3], [2, 3, 1]]}, {"input": {"board": [[2, 1, 3], [3, 2, 1], [1, 3, 2]]}, "output": [[2, 1, 3], [3, 2, 1], [1, 3, 2]]}, {"input": {"board": [[1, 3, 2], [3, 2, 1], [2, 1, 3]]}, "output": [[1, 3, 2], [3, 2, 1], [2, 1, 3]]}, {"input": {"board": [[2, 3, 1], [3, 1, 2], [1, 2, 3]]}, "output": [[2, 3, 1], [3, 1, 2], [1, 2, 3]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "saisai/tutorial", "path": "/python/techiedelight_com/backtracking/minisudo.py", "msgidx": 12357}}
{"problem_description": "In an infinite two-dimensional grid, memory is stored in a spiral pattern starting from the central point \"1\". Given a specific location on this grid, how many steps are required to reach the central point \"1\" using Manhattan distance?", "io_requirements": "Input:\n  `location` (int): The location on the infinite two-dimensional grid, representing a number in the spiral memory.\n\nOutput:\n  `return` (int): The number of steps required to reach the central point \"1\" in Manhattan distance.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef spiralDepth(num):\n    \"\"\"Return the layer of a spiral that this number is in.\n\n    The last number in each layer is x ** 2 where x is an odd number (eg 9, 25, 49, 81).\"\"\"\n    depth = math.ceil(math.sqrt(num))\n    depth = depth if depth % 2 != 0 else depth + 1\n    return (depth - 1) // 2\n\ndef spiralQuadrant(num):\n    \"\"\"Return the quadrant of a spiral layer of a number.\"\"\"\n    depth = spiralDepth(num)\n    beginning = (2 * depth - 1) ** 2\n    end = (2 * (depth + 1) - 1) ** 2 - 1\n    return (num - beginning) // (depth * 2)\n\n# main function\ndef main_solution(location):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  depth = spiralDepth(location)\n  quadrant = spiralQuadrant(location)\n  steps = depth + abs(quadrant - 2)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return steps", "funcname": "main_solution", "ios": [{"input": {"location": 267897}, "output": 260}, {"input": {"location": 120442}, "output": 176}, {"input": {"location": 881196}, "output": 470}, {"input": {"location": 391734}, "output": 314}, {"input": {"location": 365271}, "output": 302}, {"input": {"location": 191586}, "output": 220}, {"input": {"location": 138326}, "output": 187}, {"input": {"location": 169652}, "output": 207}, {"input": {"location": 704987}, "output": 421}, {"input": {"location": 393198}, "output": 316}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "caitelatte/advent-of-code", "path": "/2017-python/d03-solution.py", "msgidx": 13472}}
{"problem_description": "In a Tic-Tac-Toe game, given the current state of the board, the current player's turn, and the current winner (if any), what will be the final state of the board after one more move, and who will be the winner?", "io_requirements": "Input:\n  `board` (list of lists of str): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be ' ', 'O', or 'X'.\n  `turn` (str): The current player's turn, either 'O' or 'X'.\n  `winner` (str or None): The current winner of the game, either 'O', 'X', or None if the game is still ongoing.\n\nOutput:\n  `return` (dict): A dictionary containing the final state of the board, the winner, and the final turn.\n    - `board` (list of lists of str): The final state of the 3x3 Tic-Tac-Toe board.\n    - `turn` (str): The final player's turn, either 'O' or 'X'.\n    - `winner` (str or None): The final winner of the game, either 'O', 'X', or None if the game is a draw.", "refcode": "# import necessary packages\nimport json\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass TicTacToe:\n    def __init__(self):\n        \"\"\"Initialize an empty board. The O's go first.\"\"\"\n        self.board = [[' ']*3 for _ in range(3)]\n        self.turn, self.winner = \"O\", None\n\n    def move(self, i, j):\n        \"\"\"Mark an O or X in the (i,j)th box and check for a winner.\"\"\"\n        if self.winner is not None:\n            raise ValueError(\"the game is over!\")\n        elif self.board[i][j] != ' ':\n            raise ValueError(\"space ({},{}) already taken\".format(i,j))\n        self.board[i][j] = self.turn\n\n        # Determine if the game is over.\n        b = self.board\n        if any(sum(s == self.turn for s in r)==3 for r in b):\n            self.winner = self.turn     # 3 in a row.\n        elif any(sum(r[i] == self.turn for r in b)==3 for i in range(3)):\n            self.winner = self.turn     # 3 in a column.\n        elif b[0][0] == b[1][1] == b[2][2] == self.turn:\n            self.winner = self.turn     # 3 in a diagonal.\n        elif b[0][2] == b[1][1] == b[2][0] == self.turn:\n            self.winner = self.turn     # 3 in a diagonal.\n        else:\n            self.turn = \"O\" if self.turn == \"X\" else \"X\"\n\n    def empty_spaces(self):\n        \"\"\"Return the list of coordinates for the empty boxes.\"\"\"\n        return [(i,j) for i in range(3) for j in range(3) if self.board[i][j] == ' ']\n\n    def __str__(self):\n        return \"\\n---------\\n\".join(\" | \".join(r) for r in self.board)\n\nclass TicTacToeEncoder(json.JSONEncoder):\n    \"\"\"A custom JSON Encoder for TicTacToe objects.\"\"\"\n    def default(self, obj):\n        if not isinstance(obj, TicTacToe):\n            raise TypeError(\"Expected a TicTacToe data type for encoding\")\n        return {\"dtype\": \"TicTacToe\", \"data\": [obj.board, obj.turn, obj.winner]}\n\ndef tic_tac_toe_decoder(obj):\n    \"\"\"A custom JSON decoder for TicTacToe objects.\"\"\"\n    if \"dtype\" in obj:\n        if obj[\"dtype\"] != \"TicTacToe\" or \"data\" not in obj:\n            raise ValueError(\"Expected TicTacToe message from TicTacToeEncoder\")\n        game = TicTacToe()\n        game.board = obj[\"data\"][0]\n        game.turn = obj[\"data\"][1]\n        game.winner = obj[\"data\"][2]\n        return game\n    raise ValueError(\"Expected TicTacToe message from TicTacToeEncoder\")\n\n# main function\ndef main_solution(board, turn, winner):\n    \"\"\"\n    Simulate a Tic-Tac-Toe game and determine the winner based on the current state of the board.\n    \n    Parameters:\n    board (list of lists of str): A 3x3 grid representing the Tic-Tac-Toe board. Each cell can be ' ', 'O', or 'X'.\n    turn (str): The current player's turn, either 'O' or 'X'.\n    winner (str or None): The current winner of the game, either 'O', 'X', or None if the game is still ongoing.\n    \n    Returns:\n    dict: A dictionary containing the final state of the board, the winner, and the final turn.\n    \"\"\"\n    game = TicTacToe()\n    game.board = board\n    game.turn = turn\n    game.winner = winner\n    \n    # Simulate a random move if the game is not over\n    if game.winner is None and game.empty_spaces():\n        i, j = game.empty_spaces()[np.random.randint(0, len(game.empty_spaces()))]\n        game.move(i, j)\n    \n    # Convert the game state to a JSON serializable format\n    return {\n        \"board\": game.board,\n        \"turn\": game.turn,\n        \"winner\": game.winner\n    }", "funcname": "main_solution", "ios": [{"input": {"board": [["O", " ", " "], ["O", " ", "X"], ["O", "X", " "]], "turn": "O", "winner": null}, "output": {"board": [["O", " ", " "], ["O", " ", "X"], ["O", "X", " "]], "turn": "O", "winner": "O"}}, {"input": {"board": [[" ", " ", "O"], ["X", "X", "O"], [" ", " ", " "]], "turn": "X", "winner": null}, "output": {"board": [[" ", " ", "O"], ["X", "X", "O"], [" ", " ", " "]], "turn": "O", "winner": null}}, {"input": {"board": [[" ", " ", " "], [" ", "X", " "], [" ", " ", " "]], "turn": "O", "winner": "X"}, "output": {"board": [[" ", " ", " "], [" ", "X", " "], [" ", " ", " "]], "turn": "O", "winner": "X"}}, {"input": {"board": [["X", " ", " "], ["O", " ", " "], [" ", " ", "X"]], "turn": "X", "winner": null}, "output": {"board": [["X", " ", " "], ["O", " ", " "], [" ", " ", "X"]], "turn": "O", "winner": null}}, {"input": {"board": [["X", " ", " "], [" ", "O", "X"], [" ", "X", "O"]], "turn": "X", "winner": null}, "output": {"board": [["X", " ", " "], [" ", "O", "X"], [" ", "X", "O"]], "turn": "O", "winner": null}}, {"input": {"board": [[" ", "X", "O"], [" ", "X", "O"], ["O", "X", " "]], "turn": "O", "winner": null}, "output": {"board": [[" ", "X", "O"], [" ", "X", "O"], ["O", "X", " "]], "turn": "X", "winner": null}}, {"input": {"board": [["X", "X", "O"], ["X", " ", "O"], ["X", "O", " "]], "turn": "X", "winner": null}, "output": {"board": [["X", "X", "O"], ["X", " ", "O"], ["X", "O", " "]], "turn": "X", "winner": "X"}}, {"input": {"board": [[" ", " ", "X"], ["O", " ", "X"], ["X", " ", "O"]], "turn": "X", "winner": null}, "output": {"board": [[" ", " ", "X"], ["O", " ", "X"], ["X", " ", "O"]], "turn": "O", "winner": null}}, {"input": {"board": [[" ", " ", "O"], [" ", "X", "O"], ["X", "O", "X"]], "turn": "O", "winner": null}, "output": {"board": [[" ", " ", "O"], [" ", "X", "O"], ["X", "O", "X"]], "turn": "X", "winner": null}}, {"input": {"board": [[" ", "X", "X"], ["O", "X", " "], ["O", "X", "O"]], "turn": "X", "winner": null}, "output": {"board": [[" ", "X", "X"], ["O", "X", " "], ["O", "X", "O"]], "turn": "X", "winner": "X"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kameronlightheart14/projects", "path": "/DataCollection/WebTechnologies/web_technologies.py", "msgidx": 13166}}
{"problem_description": "Given a mini-chess board with varying dimensions, how many legal positions can be formed where both kings are on the board and not both are in check?", "io_requirements": "Input:\n  `board_size` (list of int): A list containing two integers representing the dimensions of the board. The first integer represents the number of rows, and the second integer represents the number of columns.\n\nOutput:\n  `return` (int): The number of legal positions on the given board size where both kings are on the board and not both are in check.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef is_valid_position(board, kings_positions):\n    \"\"\"Check if the current board configuration is valid.\"\"\"\n    for king_pos in kings_positions:\n        if king_pos not in board:\n            return False\n    return True\n\ndef count_legal_positions(board_size):\n    \"\"\"Count the number of legal positions on a given board size.\"\"\"\n    board = set(itertools.product(range(board_size[0]), range(board_size[1])))\n    kings_positions = list(itertools.combinations(board, 2))\n    legal_positions = 0\n\n    for king1, king2 in kings_positions:\n        if is_valid_position(board, [king1, king2]):\n            legal_positions += 1\n\n    return legal_positions\n\n# main function\ndef main_solution(board_size):\n    # Convert the input to a tuple if it's not already\n    if isinstance(board_size, list):\n        board_size = tuple(board_size)\n    \n    # Call the function to count legal positions\n    result = count_legal_positions(board_size)\n    \n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"board_size": [4, 5]}, "output": 190}, {"input": {"board_size": [4, 3]}, "output": 66}, {"input": {"board_size": [3, 4]}, "output": 66}, {"input": {"board_size": [4, 4]}, "output": 120}, {"input": {"board_size": [5, 5]}, "output": 300}, {"input": {"board_size": [5, 3]}, "output": 105}, {"input": {"board_size": [3, 3]}, "output": 36}, {"input": {"board_size": [5, 4]}, "output": 190}, {"input": {"board_size": [3, 5]}, "output": 105}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DayGitH/Python-Challenges", "path": "/DailyProgrammer/DP20170908C.py", "msgidx": 13710}}
{"problem_description": "Given a set of digit positions and corresponding values, what is the family of 8 prime numbers that can be formed by replacing the specified positions with the given values?", "io_requirements": "Input:\n  `digit_positions` (list of str): A list of characters representing the positions to replace in the number format (e.g., ['b', 'b', 'b', 'a', 'c']).\n  `digit_values` (dict): A dictionary mapping the positions to their respective values (e.g., {'a': 1, 'b': 2, 'c': 3}).\n\nOutput:\n  `return` (list of str): A list of 8 prime numbers that form the family. If no such family is found, an empty list is returned.", "refcode": "# import necessary packages\nimport itertools\nimport math\n\n# Function to check if a number is prime\ndef is_prime(n):\n    if n == 2:\n        return True\n    elif n < 2:\n        return False\n    elif n > 2:\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n# main function\ndef main_solution(digit_positions, digit_values):\n    \"\"\"\n    Finds a family of 8 prime numbers by replacing specific digit positions with given values.\n\n    Args:\n    digit_positions (list of str): Positions to replace in the number format (e.g., ['b', 'b', 'b', 'a', 'c']).\n    digit_values (dict): Values to replace the positions with (e.g., {'a': 1, 'b': 2, 'c': 3}).\n\n    Returns:\n    list of str: A list of 8 prime numbers that form the family.\n    \"\"\"\n    cases = sorted(list(set(list(itertools.permutations(digit_positions)))), key=lambda x: x[0])\n    result = []\n    numbs = []\n    temp = []\n\n    for case in cases:\n        for a in range(0, 10):\n            for c in range(0, 10):\n                for e in [1, 3, 7, 9]:\n                    for b in range(0, 10):\n                        for i in case:\n                            if i == 'a':\n                                temp.append(str(a))\n                            elif i == 'b':\n                                temp.append(str(b))\n                            else:\n                                temp.append(str(c))\n                        numb = ''.join(temp) + str(e)\n                        if not numb.startswith('0') and is_prime(int(numb)):\n                            numbs.append(numb)\n                        temp.clear()\n                    if len(numbs) == 8:\n                        return numbs\n                    numbs.clear()\n    return []", "funcname": "main_solution", "ios": [{"input": {"digit_positions": ["b", "b", "c", "a", "b"], "digit_values": {"a": 1, "b": 2, "c": 6}}, "output": ["121313", "222323", "323333", "424343", "525353", "626363", "828383", "929393"]}, {"input": {"digit_positions": ["c", "b", "a", "a", "a"], "digit_values": {"a": 9, "b": 5, "c": 9}}, "output": []}, {"input": {"digit_positions": ["c", "b", "b", "a", "c"], "digit_values": {"a": 9, "b": 7, "c": 2}}, "output": []}, {"input": {"digit_positions": ["c", "b", "b", "a", "c"], "digit_values": {"a": 1, "b": 0, "c": 4}}, "output": []}, {"input": {"digit_positions": ["a", "b", "a", "a", "c"], "digit_values": {"a": 3, "b": 7, "c": 5}}, "output": []}, {"input": {"digit_positions": ["b", "a", "a", "c", "b"], "digit_values": {"a": 1, "b": 4, "c": 0}}, "output": []}, {"input": {"digit_positions": ["b", "a", "c", "b", "a"], "digit_values": {"a": 8, "b": 1, "c": 5}}, "output": []}, {"input": {"digit_positions": ["a", "a", "b", "b", "a"], "digit_values": {"a": 7, "b": 5, "c": 3}}, "output": []}, {"input": {"digit_positions": ["b", "a", "c", "b", "b"], "digit_values": {"a": 7, "b": 3, "c": 0}}, "output": ["121313", "222323", "323333", "424343", "525353", "626363", "828383", "929393"]}, {"input": {"digit_positions": ["a", "a", "c", "c", "c"], "digit_values": {"a": 3, "b": 6, "c": 5}}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Noahz110/Project_Euler", "path": "/pe51.py", "msgidx": 13552}}
{"problem_description": "Given a boolean expression represented as a string, how can we visualize the expression in a tree-like format where the structure of the tree reflects the logical hierarchy of the expression? The tree should also flatten contiguous recursive calls to AND and OR when doing so does not change the logic of the function. What is the resulting tree-like representation of the given boolean expression `treeStr`?", "io_requirements": "Input:\n  `treeStr` (str): A string representing a boolean expression tree using the format \"AND(a,b)\" or \"OR(foo,bar)\". The string can contain nested expressions and multiple characters for leaf nodes.\n\nOutput:\n  `return` (str): A string representing the tree-like representation of the input boolean expression. Each line of the string represents a level in the tree, with appropriate indentation to show the hierarchy.", "refcode": "# import necessary packages\nimport re\n\n# all class and function definitions in the code file, if any\ndef printTok(tok, opStk, childStk):\n    # compute prefix\n    prefix = ''\n    i = 0\n    while(i < len(opStk)):\n        previousOp = opStk[i]\n        showBar = False\n        if(childStk[i] == 'L'):\n            showBar = True\n        i += 1\n        while(i < len(opStk) and opStk[i] == previousOp):\n            if(childStk[i] == 'L'):\n                showBar = True\n            i += 1\n        if(showBar or i == len(opStk)):\n            prefix += \" |\"\n        else:\n            prefix += \"  \"\n        \n    if(prefix):\n        prefix = prefix[:-1] + \"+-\"\n    return prefix + tok\n\ndef printTree(treeStr):\n    tokens = re.split('([(),])', treeStr)\n    opStk = []\n    childStk = []\n    result = []\n    \n    for tok in tokens:\n        if(tok == 'AND' or tok == 'OR'):\n            if(not opStk or opStk[-1] != tok):\n                result.append(printTok(tok, opStk, childStk))\n            opStk.append(tok)\n        elif(tok == ')'):\n            opStk.pop()\n            childStk.pop()\n        elif(tok == '('):\n            childStk.append('L')\n        elif(tok == ','):\n            childStk.pop()\n            childStk.append('R')\n        elif(tok):\n            result.append(printTok(tok, opStk, childStk))\n    \n    return '\\n'.join(result)\n\n# main function\ndef main_solution(treeStr):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return printTree(treeStr)", "funcname": "main_solution", "ios": [{"input": {"treeStr": "AND(aqigw,k)"}, "output": "AND\n +-aqigw\n +-k"}, {"input": {"treeStr": "AND(mra,qeg)"}, "output": "AND\n +-mra\n +-qeg"}, {"input": {"treeStr": "OR(OR(AND(ky,xqrw),AND(ahyjd,xqrw)),AND(AND(hxdxj,yg),AND(yg,yg)))"}, "output": "OR\n +-AND\n | +-ky\n | +-xqrw\n +-AND\n | +-ahyjd\n | +-xqrw\n +-AND\n   +-hxdxj\n   +-yg\n   +-yg\n   +-yg"}, {"input": {"treeStr": "OR(AND(rcsq,rcsq),AND(rcsq,jbca))"}, "output": "OR\n +-AND\n | +-rcsq\n | +-rcsq\n +-AND\n   +-rcsq\n   +-jbca"}, {"input": {"treeStr": "OR(OR(AND(k,udll),OR(dnuo,zutty)),OR(AND(k,zutty),AND(zutty,dnuo)))"}, "output": "OR\n +-AND\n | +-k\n | +-udll\n +-dnuo\n +-zutty\n +-AND\n | +-k\n | +-zutty\n +-AND\n   +-zutty\n   +-dnuo"}, {"input": {"treeStr": "AND(pn,t)"}, "output": "AND\n +-pn\n +-t"}, {"input": {"treeStr": "OR(AND(wihl,ekri),AND(kx,wys))"}, "output": "OR\n +-AND\n | +-wihl\n | +-ekri\n +-AND\n   +-kx\n   +-wys"}, {"input": {"treeStr": "AND(tnn,tnn)"}, "output": "AND\n +-tnn\n +-tnn"}, {"input": {"treeStr": "AND(ogbf,ooups)"}, "output": "AND\n +-ogbf\n +-ooups"}, {"input": {"treeStr": "AND(ozh,ozh)"}, "output": "AND\n +-ozh\n +-ozh"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jastination/software-engineering-excercise-repository", "path": "/seer_python/jason/PrintTree2.py", "msgidx": 13382}}
{"problem_description": "Given a spiral matrix where numbers are filled in a counterclockwise spiral pattern starting from the center, what is the sum of the numbers on the diagonals of the matrix for a given odd-sized square matrix?", "io_requirements": "Input:\n  `size` (int): The size of the square matrix. Must be an odd number between 1 and 1001.\n\nOutput:\n  `return` (int): The sum of the numbers on the diagonals of the spiral matrix.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(size):\n    # Ensure size is odd and within a reasonable range\n    if size % 2 == 0:\n        raise ValueError(\"Size must be an odd number.\")\n    if size < 1 or size > 1001:\n        raise ValueError(\"Size must be between 1 and 1001.\")\n\n    # Initialize the matrix\n    n = np.zeros((size, size))\n\n    count = 1\n    spirals = size // 2 + 1\n    spiralCount = 1\n    x = size // 2\n    y = size // 2\n    n[x, y] = count\n\n    while spiralCount < spirals:\n        # go right once always\n        y += 1\n        count += 1\n        n[x, y] = count\n\n        # go down (2 * spiralCount) - 1 times\n        for i in range(0, (2 * spiralCount) - 1):\n            x += 1\n            count += 1\n            n[x, y] = count\n\n        # go left 2 * spiralCount times\n        for i in range(0, (2 * spiralCount)):\n            y -= 1\n            count += 1\n            n[x, y] = count\n\n        # go up 2 * spiralCount times\n        for i in range(0, (2 * spiralCount)):\n            x -= 1\n            count += 1\n            n[x, y] = count\n\n        # go right 2 * spiralCount times\n        for i in range(0, (2 * spiralCount)):\n            y += 1\n            count += 1\n            n[x, y] = count\n\n        spiralCount += 1\n\n    # Calculate the sum of the diagonals\n    sum_diagonals = 0\n    for i in range(0, size):\n        sum_diagonals += n[i][i]\n        sum_diagonals += n[i][size - 1 - i]\n\n    # Subtract one because the center is counted twice\n    sum_diagonals -= 1\n\n    return sum_diagonals", "funcname": "main_solution", "ios": [{"input": {"size": 1}, "output": 1.0}, {"input": {"size": 505}, "output": 85986601.0}, {"input": {"size": 855}, "output": 417050901.0}, {"input": {"size": 417}, "output": 48428641.0}, {"input": {"size": 1001}, "output": 669171001.0}, {"input": {"size": 383}, "output": 37528445.0}, {"input": {"size": 987}, "output": 641491601.0}, {"input": {"size": 261}, "output": 11887461.0}, {"input": {"size": 851}, "output": 411226601.0}, {"input": {"size": 921}, "output": 521245321.0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jnash67/eulerpython", "path": "/euler28.py", "msgidx": 13265}}
{"problem_description": "Given a positive integer, what is the sequence of numbers generated by the Collatz conjecture starting from that integer?", "io_requirements": "Input:\n  `start_value` (int): The starting integer for the Collatz sequence. Must be a positive integer.\n\nOutput:\n  `return` (str): A string representing the Collatz sequence, where each number in the sequence is separated by a comma.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef collatz_step(n):\n    \"\"\"Returns the result of the Collatz function.\n\n    The Collatz function C : N -> N is used in `collatz` to generate collatz\n    sequences. Raises an error if n < 1.\n\n    Parameters\n    ----------\n    n : int\n        to be passed through the collatz map.\n\n    Returns\n    -------\n    C(n) : int\n           The result of C(n), the first iteration of the collatz sequence of n.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('Value not accepted, please enter a positive value')\n    elif type(n) != int:\n        raise TypeError('Type entered not accepted, please enter an integer')\n    elif n % 2 == 0:\n        return n // 2\n    elif n == 1:\n        return 1\n    else:\n        return 3 * n + 1\n\ndef collatz(n):\n    \"\"\"Returns the Collatz sequence beginning with `n`.\n\n    It is conjectured that Collatz sequences all end with `1`. Calls\n    `collatz_step` at each iteration.\n\n    Parameters\n    ----------\n    n : int\n        to be passed through the collatz_step\n\n    Returns\n    -------\n    sequence : list\n               The Collatz sequence for starting point n\n\n    \"\"\" \n    sequence = [n]\n    currentValue = n\n    # while the next value in sequence is not 1\n    # retrieve next collatz map iteration\n    # append to sequence array    \n    while (currentValue != 1):\n        nextValue = collatz_step(currentValue)\n        sequence.append(nextValue)\n        currentValue = nextValue\n    return sequence\n\n# main function\ndef main_solution(start_value):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # convert the input to the required format for the collatz function\n    start_value = int(start_value)\n    \n    # call the collatz function\n    sequence = collatz(start_value)\n    \n    # convert the output to a json serializable format\n    sequence_str = ','.join(map(str, sequence))\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return sequence_str", "funcname": "main_solution", "ios": [{"input": {"start_value": 808}, "output": "808,404,202,101,304,152,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 560}, "output": "560,280,140,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 90}, "output": "90,45,136,68,34,17,52,26,13,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 870}, "output": "870,435,1306,653,1960,980,490,245,736,368,184,92,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 397}, "output": "397,1192,596,298,149,448,224,112,56,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 15}, "output": "15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 89}, "output": "89,268,134,67,202,101,304,152,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 454}, "output": "454,227,682,341,1024,512,256,128,64,32,16,8,4,2,1"}, {"input": {"start_value": 22}, "output": "22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1"}, {"input": {"start_value": 753}, "output": "753,2260,1130,565,1696,848,424,212,106,53,160,80,40,20,10,5,16,8,4,2,1"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "bliang01/homework1-nishalad95", "path": "/homework1/exercise1.py", "msgidx": 13893}}
{"problem_description": "Given a chessboard of size `n x n` where each cell contains a letter, determine if it is possible to form the word \"ICPCASIASG\" by moving a knight (which moves in an L-shape) on the board starting from any cell containing the letter 'I'. The knight can only move to cells that help form the word in the correct order. What is the result indicating whether the word can be formed or not?", "io_requirements": "Input:\n  `n` (int): The size of the board (n x n).\n  `board_str` (str): A string representing the board, where each character corresponds to a cell on the board. The length of the string is `n * n`.\n\nOutput:\n  `return` (str): A string \"YES\" if the goal word \"ICPCASIASG\" can be formed on the board starting from any 'I', otherwise \"NO\".", "refcode": "# import necessary packages\nfrom collections import deque\n\n# Global variables\ngoal = 'ICPCASIASG'\ndirections = [(2, -1), (2, 1), (1, 2), (1, -2), (-1, 2), (-1, -2), (-2, 1), (-2, -1)]\n\n# Function to perform DFS\ndef dfs(word, r, c, board):\n    if len(goal) == len(word):\n        return True\n\n    for dr, dc in directions:\n        r1 = dr + r\n        c1 = dc + c\n\n        if r1 >= 0 and r1 < len(board) and c1 >= 0 and c1 < len(board):\n            if goal.startswith(word + board[r1][c1]):\n                if dfs(word + board[r1][c1], r1, c1, board):\n                    return True\n    return False\n\n# Main solution function\ndef main_solution(n, board_str):\n    # Convert board_str to a 2D list\n    board = [list(board_str[n*i:n*i+n]) for i in range(n)]\n\n    # Iterate over the board to find the starting point\n    for r0 in range(n):\n        for c0 in range(n):\n            if board[r0][c0] == 'I':\n                if dfs('I', r0, c0, board):\n                    return \"YES\"\n\n    return \"NO\"", "funcname": "main_solution", "ios": [{"input": {"n": 4, "board_str": "SJUMRYQRDCDJSESH"}, "output": "NO"}, {"input": {"n": 4, "board_str": "PCYEYIVMPLONXXPJ"}, "output": "NO"}, {"input": {"n": 4, "board_str": "GLOQRGOYNXULZQWR"}, "output": "NO"}, {"input": {"n": 3, "board_str": "GEYDBOXFU"}, "output": "NO"}, {"input": {"n": 4, "board_str": "YORQFFMZEXKVWBLI"}, "output": "NO"}, {"input": {"n": 5, "board_str": "LTDIEHTFFSYSVAFHYDKFKJYXU"}, "output": "NO"}, {"input": {"n": 5, "board_str": "JJAJSBILRVNDXSTEEVIKDCUZV"}, "output": "NO"}, {"input": {"n": 3, "board_str": "KMVSIXHMO"}, "output": "NO"}, {"input": {"n": 5, "board_str": "HBMPKWZYTHXYJWXNLWMRQBIOC"}, "output": "NO"}, {"input": {"n": 4, "board_str": "YOZPOSJTDDSGIJTR"}, "output": "NO"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "alexlwn123/kattis", "path": "/Python/knightsearch.py", "msgidx": 13505}}
{"problem_description": "In a game of Tic Tac Toe, given a specific board configuration, what is the optimal move for the current player to either win or prevent the opponent from winning? The board configuration is represented by a 3x3 grid where each cell can be either \"X\", \"O\", or empty (represented by None). The optimal move should be returned as a tuple indicating the row and column indices of the best possible move.", "io_requirements": "Input:\n  `board_state` (list of lists of strings/None): A 3x3 board representation where each cell can be \"X\", \"O\", or None (representing an empty cell).\n\nOutput:\n  `return` (dict): A dictionary with a single key \"optimal_action\" whose value is a tuple representing the optimal move (i, j) for the current player on the board.", "refcode": "# import necessary packages\nimport math\nimport copy\nimport numpy as np\n\n# Constants\nX = \"X\"\nO = \"O\"\nEMPTY = None\n\n# Function to initialize the board\ndef initial_state():\n    return [[EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY],\n            [EMPTY, EMPTY, EMPTY]]\n\n# Function to determine the next player\ndef player(board):\n    count = sum(row.count(EMPTY) for row in board)\n    return 'X' if count % 2 == 1 else 'O'\n\n# Function to get all possible actions\ndef actions(board):\n    if terminal(board):\n        return []\n    possible_actions = [(i, j) for i in range(3) for j in range(3) if board[i][j] == EMPTY]\n    return possible_actions\n\n# Function to get the result of an action\ndef result(board, action):\n    m_board = copy.deepcopy(board)\n    i, j = action\n    if m_board[i][j] is EMPTY:\n        m_board[i][j] = player(board)\n        return m_board\n    raise Exception(\"Invalid action\")\n\n# Function to determine the winner\ndef winner(board):\n    w_board = np.array(board)\n    for row in w_board:\n        if len(set(row)) == 1 and row[0] is not EMPTY:\n            return row[0]\n    for col in np.transpose(w_board):\n        if len(set(col)) == 1 and col[0] is not EMPTY:\n            return col[0]\n    if len(set(np.diagonal(w_board))) == 1 and np.diagonal(w_board)[0] is not EMPTY:\n        return np.diagonal(w_board)[0]\n    if len(set(np.fliplr(w_board).diagonal())) == 1 and np.fliplr(w_board).diagonal()[0] is not EMPTY:\n        return np.fliplr(w_board).diagonal()[0]\n    return None\n\n# Function to check if the game is over\ndef terminal(board):\n    return winner(board) is not None or not any(EMPTY in row for row in board)\n\n# Function to get the utility of the board\ndef utility(board):\n    win = winner(board)\n    if win == 'X':\n        return 1\n    elif win == 'O':\n        return -1\n    else:\n        return 0\n\n# Function to get the optimal action using minimax\ndef minimax(board):\n    if terminal(board):\n        return None\n    if player(board) == 'X':\n        return maxvalue(board)[1]\n    else:\n        return minvalue(board)[1]\n\n# Function to get the max value\ndef maxvalue(board):\n    if terminal(board):\n        return [utility(board), None]\n    v = -math.inf\n    best_action = None\n    for action in actions(board):\n        min_val = minvalue(result(board, action))[0]\n        if min_val > v:\n            v = min_val\n            best_action = action\n    return [v, best_action]\n\n# Function to get the min value\ndef minvalue(board):\n    if terminal(board):\n        return [utility(board), None]\n    v = math.inf\n    best_action = None\n    for action in actions(board):\n        max_val = maxvalue(result(board, action))[0]\n        if max_val < v:\n            v = max_val\n            best_action = action\n    return [v, best_action]\n\n# main function\ndef main_solution(board_state):\n    # Convert the input board_state to a list of lists\n    board = [list(row) for row in board_state]\n    \n    # Get the optimal action using minimax\n    optimal_action = minimax(board)\n    \n    # Return the optimal action as a tuple\n    return {\"optimal_action\": optimal_action}", "funcname": "main_solution", "ios": [{"input": {"board_state": [[null, "O", null], ["O", "X", null], ["X", null, null]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board_state": [[null, "X", "X"], [null, "O", "O"], ["O", null, "X"]]}, "output": {"optimal_action": [0, 0]}}, {"input": {"board_state": [["X", null, "O"], [null, "O", "O"], ["X", "X", "X"]]}, "output": {"optimal_action": null}}, {"input": {"board_state": [[null, "X", null], ["O", "X", "O"], ["O", "X", "X"]]}, "output": {"optimal_action": null}}, {"input": {"board_state": [["O", "X", null], ["X", "O", "X"], ["X", null, "O"]]}, "output": {"optimal_action": null}}, {"input": {"board_state": [["X", null, null], [null, "X", null], ["O", "O", "X"]]}, "output": {"optimal_action": null}}, {"input": {"board_state": [["X", null, "O"], ["X", "O", null], ["O", null, "X"]]}, "output": {"optimal_action": null}}, {"input": {"board_state": [["O", null, null], ["X", null, null], ["O", null, "X"]]}, "output": {"optimal_action": [1, 2]}}, {"input": {"board_state": [[null, "X", "O"], [null, "X", null], ["X", null, "O"]]}, "output": {"optimal_action": [1, 2]}}, {"input": {"board_state": [[null, "O", null], [null, null, null], ["X", null, null]]}, "output": {"optimal_action": [0, 0]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "acharaakshit/AI-mini-projects", "path": "/tictactoe/tictactoe.py", "msgidx": 13025}}
{"problem_description": "Given the digits 1 through 9, how many distinct sets can be formed where each set contains all the digits exactly once and all elements in the set are prime numbers?", "io_requirements": "Input:\n  `permutation_length` (int): The length of the permutation of digits. Default is 9, representing digits 1 through 9.\n\nOutput:\n  `return` (int): The number of distinct sets containing each of the digits one through nine exactly once, where all elements in the set are prime.", "refcode": "# import necessary packages\nimport itertools\nimport sympy\n\n# Function to check if a number is prime\ndef is_prime(n):\n    return sympy.isprime(n)\n\n# Function to generate all permutations of digits 1 through 9\ndef generate_permutations():\n    return itertools.permutations('123456789')\n\n# Function to split a permutation into all possible subsets\ndef split_permutation(perm):\n    splits = []\n    for i in range(1, len(perm)):\n        splits.append((perm[:i], perm[i:]))\n    return splits\n\n# Function to check if all elements in a set are prime\ndef all_primes(numbers):\n    return all(is_prime(int(num)) for num in numbers)\n\n# main function\ndef main_solution(permutation_length=9):\n    count = 0\n    for perm in generate_permutations():\n        perm = ''.join(perm)\n        for split in split_permutation(perm):\n            if all_primes(split):\n                count += 1\n    return count", "funcname": "main_solution", "ios": [{"input": {"permutation_length": 9}, "output": 66646}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rwieckowski/project-euler-python", "path": "/euler118.py", "msgidx": 13228}}
{"problem_description": "Given a binary search tree, how can you convert it into a sorted doubly linked list without creating any new nodes, but only by adjusting the pointers of the existing nodes? What is the sequence of node values in the resulting doubly linked list?", "io_requirements": "Input:\n  `tree_structure` (list): A list representing the structure of the binary search tree. Each element in the list is either a value (int) or a list representing the left and right children of the node. The list structure is as follows: `[value, left_child, right_child]`.\n\nOutput:\n  `return` (list): A list of integers representing the values of the nodes in the sorted doubly linked list, in ascending order.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def Convert(self, pRootOfTree):\n        def dfs(root):\n            if not root:\n                return None\n\n            dfs(root.left)\n\n            if not self.prev:\n                self.head = root  # \u8bb0\u5f55head\u7528\u4e8e\u8fd4\u56de\n            else:\n                self.prev.right = root\n                root.left = self.prev\n\n            self.prev = root\n\n            dfs(root.right)\n\n        if not pRootOfTree:\n            return pRootOfTree\n        self.prev = None\n        dfs(pRootOfTree)\n        return self.head\n\n# main function\ndef main_solution(tree_structure):\n    # Convert the JSON serializable input to the original input variables\n    def build_tree(data):\n        if not data:\n            return None\n        root = TreeNode(data[0])\n        root.left = build_tree(data[1])\n        root.right = build_tree(data[2])\n        return root\n\n    # Build the tree from the input structure\n    root = build_tree(tree_structure)\n\n    # Convert the tree to a sorted doubly linked list\n    solution = Solution()\n    head = solution.Convert(root)\n\n    # Convert the result to a JSON serializable output\n    result = []\n    while head:\n        result.append(head.val)\n        head = head.right\n\n    return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [59, [54, null, null], [15, null, null]]}, "output": [54, 59, 15]}, {"input": {"tree_structure": [54, [47, null, null], [6, null, null]]}, "output": [47, 54, 6]}, {"input": {"tree_structure": [51, [96, null, null], [49, null, null]]}, "output": [96, 51, 49]}, {"input": {"tree_structure": [46, [70, null, null], [68, null, null]]}, "output": [70, 46, 68]}, {"input": {"tree_structure": [63, null, null]}, "output": [63]}, {"input": {"tree_structure": [87, [10, null, null], [88, null, null]]}, "output": [10, 87, 88]}, {"input": {"tree_structure": [31, null, null]}, "output": [31]}, {"input": {"tree_structure": [60, [79, null, null], [60, null, null]]}, "output": [79, 60, 60]}, {"input": {"tree_structure": [13, null, null]}, "output": [13]}, {"input": {"tree_structure": [5, null, null]}, "output": [5]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "wentilin/algorithms-study", "path": "/python/jianzhi/\u4e8c\u53c9\u641c\u7d22\u6811\u4e0e\u53cc\u5411\u94fe\u8868.py", "msgidx": 13512}}
{"problem_description": "You and your friend are playing a game where you are given a binary string of length 20. You can flip two consecutive '1's to '0's. The player who cannot make a move loses the game. Given a binary string, what is the nimber value that determines if the first player can win the game if both play optimally?", "io_requirements": "Input:\n  `binary_string` (str): A string consisting of '0's and '1's, representing a binary number. The length of the string should be less than or equal to 20.\n\nOutput:\n  `return` (int): The nimber value of the given binary string. This value indicates whether the first player can win the game if both play optimally.", "refcode": "# import necessary packages\nfrom collections import defaultdict\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass NimGame:\n    def __init__(self, n):\n        self.length = n\n        self.dp = [-1] * (n + 1)\n\n    def findNimConsecutive(self, l):\n        if self.dp[l] >= 0:\n            return self.dp[l]\n        if l == 0 or l == 1:\n            self.dp[l] = 0\n            return 0\n        appeared = set()\n        for j in range(1, l):\n            appeared.add(self.findNimConsecutive(j - 1) ^ self.findNimConsecutive(l - j - 1))\n        res = 0\n        while res in appeared:\n            res += 1\n        self.dp[l] = res\n        return res\n\n    def nim_value(self, s):\n        res = 0\n        i = 0\n        while i < len(s):\n            if s[i] == '1':\n                start = i\n                while i < len(s) and s[i] == '1':\n                    i += 1\n                res = res ^ self.findNimConsecutive(i - start)\n            i += 1\n        return res\n\n# main function\ndef main_solution(binary_string):\n    \"\"\"\n    Calculate the nimber value of a given binary string.\n\n    :param binary_string: str, a binary string consisting of '0's and '1's.\n    :return: int, the nimber value of the given binary string.\n    \"\"\"\n    n = len(binary_string)\n    game = NimGame(n)\n    nimber_value = game.nim_value(binary_string)\n    return nimber_value", "funcname": "main_solution", "ios": [{"input": {"binary_string": "11110111111011101100"}, "output": 1}, {"input": {"binary_string": "01010111101010100110"}, "output": 3}, {"input": {"binary_string": "01011100101011110001"}, "output": 3}, {"input": {"binary_string": "01000101101000011110"}, "output": 3}, {"input": {"binary_string": "00011000001000011001"}, "output": 0}, {"input": {"binary_string": "00001111101011011011"}, "output": 1}, {"input": {"binary_string": "00001100100110001101"}, "output": 1}, {"input": {"binary_string": "10111000111101000111"}, "output": 2}, {"input": {"binary_string": "00010000010101101010"}, "output": 1}, {"input": {"binary_string": "00011000110100100110"}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "inxell/flip_game", "path": "/flip_game_1D.py", "msgidx": 13606}}
{"problem_description": "Given a tree structure with a specified depth, what is the optimal arrangement of nodes that minimizes the maximum difference between any two connected nodes, and what is the resulting totogram score?", "io_requirements": "Input:\n  `depth` (int): The depth of the tree, which determines the number of nodes and the structure of the tree.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `score` (int): The totogram score, which is the maximum difference between any two connected nodes in the tree.\n    - `arrangement` (list): A list representing the optimal arrangement of nodes in the tree.", "refcode": "# import necessary packages\nimport math\n\n# Main function\ndef main_solution(depth):\n    # Convert depth to integer\n    depth = int(depth)\n    \n    # Initialize lists\n    ListOpen = []\n    ListFinal = []\n    ScoreList = []\n    \n    # Calculate the number of elements based on depth\n    NumberElements = int(1 + 3 * (math.pow(2, (depth - 1)) - 1))\n    \n    # Populate ListOpen with elements from 1 to NumberElements\n    for i in range(1, NumberElements + 1):\n        ListOpen.append(i)\n    \n    # Start with the median element\n    ListFinal.append([ListOpen.pop((NumberElements // 2))])\n    \n    # Split ListOpen into 3 sublists\n    data = [ListOpen[x:x + len(ListOpen) // 3] for x in range(0, len(ListOpen), len(ListOpen) // 3)]\n    \n    # Process the first level\n    for i in range(len(data)):\n        SubtractedList = [abs(x - ListFinal[0][0]) for x in data[i]]\n        ScoreList.append([min(SubtractedList)])\n        fringe = data[i][SubtractedList.index(min(SubtractedList))]\n        ListOpen.remove(fringe)\n        ListFinal.append([fringe])\n    \n    # Process subsequent levels\n    k = 6\n    increment = 1\n    while True:\n        datanext = [ListOpen[x:x + len(ListOpen) // k] for x in range(0, len(ListOpen), len(ListOpen) // k)]\n        counter = 0\n        j = 0\n        while counter < len(datanext):\n            if counter % 2 == 0 and counter != 0:\n                j += 1\n            SubtractedList = [abs(x - ListFinal[increment][j]) for x in datanext[counter]]\n            ScoreList.append([min(SubtractedList)])\n            fringe = datanext[counter][SubtractedList.index(min(SubtractedList))]\n            ListOpen.remove(fringe)\n            ListFinal[increment].append(fringe)\n            counter += 1\n        \n        if len(ListOpen) % 12 == 0:\n            ListFinal.append(ListOpen)\n            Finalscore = max([item for sublist in ScoreList for item in sublist])\n            dataToto = [item for sublist in ListFinal for item in sublist]\n            return {'score': Finalscore, 'arrangement': dataToto}\n        \n        k *= 2\n        increment += 1", "funcname": "main_solution", "ios": [{"input": {"depth": 3}, "output": {"score": 8, "arrangement": [6, 3, 1, 2, 4, 7, 9, 10, 5, 8]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tripathysa/Applied_Machine_Learning_and_Artificial_Intelligence_Programs", "path": "/Implementation_of_Minmax_BranchBound_Algorithms_for_two_games/totogram.py", "msgidx": 12959}}
{"problem_description": "Suppose that three friends, Liz, Fi, and Sarah, are playing on a 10-foot long seesaw. They want to position themselves such that the seesaw balances and they can swing their arms freely. Given their weights and the requirement that they must be at least three feet apart, what are the possible positions on the seesaw where they can sit to achieve balance?", "io_requirements": "Input:\n  `weights` (list of int): A list of integers representing the weights of the people in stone.\n  `n` (int): The number of people.\n  `min_distance` (int): The minimum distance in feet that each pair of people must be apart.\n\nOutput:\n  `return` (list of list of int): A list of solutions, where each solution is a list of integers representing the positions of the people on the seesaw.", "refcode": "# import necessary packages\nfrom z3 import SolverFor, IntVector, Or, sat\n\n# Function to ensure that x and y are n feet apart\ndef apart(sol, x, y, n):\n    sol.add(Or(x >= y + n, y >= x + n))\n\n# main function\ndef main_solution(weights, n, min_distance):\n    # Initialize the solver\n    sol = SolverFor(\"QF_FD\")\n\n    # Create integer variables for the positions of the people\n    people = IntVector(\"people\", n)\n\n    # Constraint: The sum of weights times positions should be zero for balance\n    sol.add(sum(weights[i] * people[i] for i in range(n)) == 0)\n\n    # Constraint: Ensure that each pair of people is at least min_distance feet apart\n    for i in range(n):\n        for j in range(i + 1, n):\n            apart(sol, people[i], people[j], min_distance)\n\n    # Find all solutions\n    solutions = []\n    while sol.check() == sat:\n        mod = sol.model()\n        solution = [mod.eval(people[i]).as_long() for i in range(n)]\n        solutions.append(solution)\n        # Ensure the next solution is different\n        sol.add(Or(people[i] != solution[i] for i in range(n)))\n\n    # Return the list of solutions\n    return solutions", "funcname": "main_solution", "ios": [{"input": {"weights": [5, 5, 2], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [7, 6, 7], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [7, 6, 5], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [2, 4, 10], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [5, 5, 3], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [10, 8, 6], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [1, 3, 3], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [2, 2, 7], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [2, 4, 1], "n": 3, "min_distance": 3}, "output": []}, {"input": {"weights": [7, 6, 6], "n": 3, "min_distance": 3}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hakank/hakank", "path": "/z3/stuckey_seesaw.py", "msgidx": 13524}}
{"problem_description": "In the classic Tower of Hanoi puzzle, you have three rods and a number of disks of different sizes that can slide onto any rod. The puzzle starts with the disks neatly stacked in ascending order of size on one rod, the smallest at the top. The objective is to move the entire stack to another rod, obeying the following simple rules:\n1. Only one disk can be moved at a time.\n2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.\n3. No disk may be placed on top of a smaller disk.\n\nGiven the number of disks `N`, what is the total number of moves required to solve the Tower of Hanoi puzzle, and what is the sequence of these moves?", "io_requirements": "Input:\n  `N` (int): The number of disks to be moved in the Tower of Hanoi problem.\n\nOutput:\n  `return` (dict): A dictionary containing two keys:\n    - `count` (int): The total number of moves required to solve the Tower of Hanoi problem with `N` disks.\n    - `movements` (str): A string representing the sequence of moves required to solve the Tower of Hanoi problem with `N` disks. Each move is represented as \"start dest\" (e.g., \"1 3\"), and moves are separated by newline characters.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef hanoi_count(N):\n    if N == 1:\n        return 1\n    return 2 * hanoi_count(N-1) + 1\n\ndef hanoi_movement(N, start, dest):\n    if N == 1:\n        return f\"{start} {dest}\"\n    else:\n        return \"\\n\".join([\n            hanoi_movement(N-1, 1, 2),\n            hanoi_movement(1, 1, 3),\n            hanoi_movement(N-1, 2, 3)\n        ])\n\n# main function\ndef main_solution(N):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    count = hanoi_count(N)\n    movements = hanoi_movement(N, 1, 3)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"count\": count, \"movements\": movements}", "funcname": "main_solution", "ios": [{"input": {"N": 4}, "output": {"count": 15, "movements": "1 2\n1 3\n2 3\n1 3\n1 2\n1 3\n2 3\n1 3\n1 2\n1 3\n2 3\n1 3\n1 2\n1 3\n2 3"}}, {"input": {"N": 2}, "output": {"count": 3, "movements": "1 2\n1 3\n2 3"}}, {"input": {"N": 3}, "output": {"count": 7, "movements": "1 2\n1 3\n2 3\n1 3\n1 2\n1 3\n2 3"}}, {"input": {"N": 1}, "output": {"count": 1, "movements": "1 3"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EmjayAhn/DailyAlgorithm", "path": "/01_baekjoon/71_problem_11729.py", "msgidx": 14019}}
{"problem_description": "Given a series of towers where each tower has a specific height that determines the maximum number of towers you can travel from that position, determine if it is possible to reach the last tower. The height of each tower is represented by a list of integers. Each integer in the list indicates the maximum number of towers you can travel from that specific position. For example, if the height of the 0th tower is 3, you can travel to the 1st, 2nd, or 3rd towers from the 0th tower. Is it possible to cross the last tower given the heights of the towers?", "io_requirements": "Input:\n  `towers` (List[int]): A list of integers where each integer represents the maximum number of towers that can be traveled from that position.\n\nOutput:\n  `return` (bool): A boolean indicating whether it is possible to cross the last tower.", "refcode": "# import necessary packages\nimport copy\n\n# main function\ndef main_solution(towers):\n    \"\"\"\n    Determines if it is possible to cross the last tower given a list of tower heights.\n    \n    :param towers: List of integers where each integer represents the maximum number of towers that can be traveled from that position.\n    :return: Boolean indicating whether it is possible to cross the last tower.\n    \"\"\"\n    tower_copy = copy.deepcopy(towers)\n    # Start from the end of the tower list\n    for i in range(len(tower_copy) - 1, -1, -1):\n        current_height = tower_copy[i]\n        # verify how many steps we can give to the right side towers of the current position\n        extra_steps_available = current_height - 1\n        if extra_steps_available >= 1:\n            tower_copy[i] -= extra_steps_available\n            for pos in range(i + 1, len(tower_copy)):\n                # Give 1 additional height to each of the positions in the right side towers\n                tower_copy[pos] += 1\n                extra_steps_available -= 1\n                # If no more extra steps available, stop the pushing down and consider the next left most tower\n                if extra_steps_available <= 0:\n                    break\n    if 0 in tower_copy:\n        return False\n    else:\n        return True", "funcname": "main_solution", "ios": [{"input": {"towers": [2, 2, 1, 3, 5, 0, 1, 5, 4, 4]}, "output": true}, {"input": {"towers": [0, 1, 4, 1, 2, 5, 1, 1]}, "output": false}, {"input": {"towers": [1, 1, 2, 1, 3]}, "output": true}, {"input": {"towers": [0, 5, 2, 2, 1, 0]}, "output": false}, {"input": {"towers": [5, 5, 1, 4, 3]}, "output": true}, {"input": {"towers": [4, 3, 5, 0, 3, 2, 5, 2]}, "output": true}, {"input": {"towers": [4, 3, 4, 2, 4, 4, 4]}, "output": true}, {"input": {"towers": [5, 1, 2, 3, 0]}, "output": true}, {"input": {"towers": [5, 5, 0, 2, 2]}, "output": true}, {"input": {"towers": [4, 5, 0, 3, 3, 2, 4, 0, 5, 3]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mathewsjose90/Python-Learnings", "path": "/Examples/Practice/tower_hopping.py", "msgidx": 13774}}
{"problem_description": "Given a maze represented by a 2D grid where `0` indicates a free path and `1` indicates an obstacle, what is the path from the top-left corner to the bottom-right corner that avoids all obstacles? The path should be represented as a 2D grid where `1` indicates a part of the path and `0` indicates no path. If no path exists, return an empty list.", "io_requirements": "Input:\n  `C` (list of lists of integers): A 2D grid representing the maze. Each element in the grid is either `0` (indicating a free path) or `1` (indicating an obstacle). The grid must be square (i.e., the number of rows equals the number of columns).\n\nOutput:\n  `return` (list of lists of integers): A 2D grid representing the path from the top-left corner to the bottom-right corner. Each element in the grid is either `0` (indicating no path) or `1` (indicating a part of the path). If no path is found, the function returns an empty list.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef verificaCasilla(C, x, y): \n    if x >= 0 and x < len(C[0]) and y >= 0 and y < len(C) and C[y][x] == 0: \n        return True\n    return False\n\ndef encontrar_ruta_aux(C, x, y, solucion): \n    if x == len(C[0]) - 1 and y == len(C) - 1 and C[y][x] == 0: \n        solucion[y][x] = 1\n        return solucion\n          \n    if verificaCasilla(C, x, y) == True: \n        solucion[y][x] = 1\n          \n        posibleSol = encontrar_ruta_aux(C, x + 1, y, solucion)\n        if posibleSol != []:\n            return posibleSol\n            \n        posibleSol = encontrar_ruta_aux(C, x, y + 1, solucion)\n        if posibleSol != []:\n            return posibleSol\n          \n        solucion[y][x] = 0\n    \n    return []\n\n# main function\ndef main_solution(C):\n    # Convert input to the required format\n    C = np.array(C)\n    \n    # Initialize the solution path\n    recorridoSol = [ [ 0 for j in range(len(C[1])) ] for i in range(len(C)) ] \n    \n    # Find the path\n    path = encontrar_ruta_aux(C, 0, 0, recorridoSol)\n    \n    # Convert the path to a JSON serializable format\n    path = np.array(path).tolist()\n    \n    return path", "funcname": "main_solution", "ios": [{"input": {"C": [[0, 1, 1, 0], [0, 1, 0, 1], [0, 1, 1, 0], [1, 1, 1, 0]]}, "output": []}, {"input": {"C": [[0, 0, 0, 1], [0, 0, 1, 0], [1, 1, 1, 1], [0, 1, 0, 0]]}, "output": []}, {"input": {"C": [[0, 0, 0], [0, 0, 0], [0, 0, 0]]}, "output": [[1, 1, 1], [0, 0, 1], [0, 0, 1]]}, {"input": {"C": [[0, 1, 0], [1, 0, 0], [1, 0, 0]]}, "output": []}, {"input": {"C": [[0, 0, 1], [0, 0, 1], [0, 0, 0]]}, "output": [[1, 1, 0], [0, 1, 0], [0, 1, 1]]}, {"input": {"C": [[0, 1, 1, 0], [0, 1, 1, 1], [0, 0, 0, 1], [0, 0, 1, 0]]}, "output": []}, {"input": {"C": [[0, 1, 0, 1], [0, 1, 1, 1], [1, 0, 1, 1], [0, 1, 1, 0]]}, "output": []}, {"input": {"C": [[0, 0, 0], [0, 1, 1], [1, 1, 0]]}, "output": []}, {"input": {"C": [[0, 1, 0], [1, 0, 1], [0, 0, 0]]}, "output": []}, {"input": {"C": [[0, 0, 0, 1], [0, 0, 1, 1], [1, 1, 0, 0], [0, 0, 0, 0]]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "IC-3002/ic-3002-2020ii-tc7-Andres10976", "path": "/rutas.py", "msgidx": 13542}}
{"problem_description": "In a space monitoring mission, you are tasked with determining the optimal location for a monitoring station on an asteroid field. The field is represented as a grid where `#` indicates an asteroid and `.` indicates empty space. The goal is to find the location from which the maximum number of asteroids can be detected. Detection is blocked by other asteroids that lie exactly in line between the monitoring station and the target asteroid.\n\nGiven the asteroid map, what is the best location to place the monitoring station, and how many asteroids can be detected from this location?", "io_requirements": "Input:\n  `asteroid_map` (str): A string representing the asteroid map. Each line in the map is separated by a newline character (`\\n`). Asteroids are represented by the character `#`.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `best_location` (tuple): A tuple representing the coordinates (x, y) of the best location to place a monitoring station.\n    - `max_detected` (int): An integer representing the maximum number of asteroids that can be detected from the best location.", "refcode": "import math\n\ndef points_are_collinear(p, q, r):\n    px, py = p\n    qx, qy = q\n    rx, ry = r\n    term1 = (px - rx) * (qy - ry)\n    term2 = (qx - rx) * (py - ry)\n    return term1 - term2 == 0\n\ndef get_asteroids_in_rect(asteroids, source, target):\n    sx, sy = source\n    tx, ty = target\n    minx = min(sx, tx)\n    maxx = max(sx, tx)\n    miny = min(sy, ty)\n    maxy = max(sy, ty)\n    result = []\n    for asteroid in asteroids:\n        if asteroid == source or asteroid == target:\n            continue\n        x, y = asteroid\n        if minx <= x <= maxx and miny <= y <= maxy:\n            result.append(asteroid)\n    return result\n\ndef get_detected_counts(asteroids, source):\n    detected = set()\n    for target in asteroids:\n        if target == source:\n            continue\n        inbetweens = get_asteroids_in_rect(asteroids, source, target)\n        collinear_found = False\n        for inbetween in inbetweens:\n            if points_are_collinear(source, inbetween, target):\n                collinear_found = True\n                break\n        if not collinear_found:\n            detected.add(target)\n    return source, len(detected)\n\ndef find_asteroids(lines):\n    width = len(lines[0])\n    height = len(lines)\n    asteroids = []\n    for y in range(height):\n        for x in range(width):\n            if lines[y][x] == \"#\":\n                asteroids.append((x, y))\n    return asteroids\n\ndef main_solution(asteroid_map):\n    lines = asteroid_map.split(\"\\n\")\n    asteroids = find_asteroids(lines)\n    detected_counts = [get_detected_counts(asteroids, asteroid) for asteroid in asteroids]\n    sorted_detected_counts = sorted(detected_counts, key=lambda t: t[1], reverse=True)\n    best_location, max_detected = sorted_detected_counts[0]\n    return {\"best_location\": best_location, \"max_detected\": max_detected}", "funcname": "main_solution", "ios": [{"input": {"asteroid_map": ".....##.\n....##..\n.....#..\n#.#.....\n.##..##.\n........\n.#.#..#.\n.#..####"}, "output": {"best_location": [2, 3], "max_detected": 17}}, {"input": {"asteroid_map": "...#.\n#.#..\n...#.\n.#.#.\n#...."}, "output": {"best_location": [0, 1], "max_detected": 6}}, {"input": {"asteroid_map": "..#.#.#..\n.#.......\n#.#.##.#.\n.....#...\n#.#...##.\n##.#..###\n.........\n#.#......"}, "output": {"best_location": [1, 1], "max_detected": 20}}, {"input": {"asteroid_map": "##.#..\n.#...#\n.#.#..\n#....#\n##....\n....##\n#.....\n......"}, "output": {"best_location": [3, 2], "max_detected": 13}}, {"input": {"asteroid_map": ".#..#..\n#.#....\n.....#.\n.##.#.#\n#...#.#\n#......"}, "output": {"best_location": [5, 2], "max_detected": 12}}, {"input": {"asteroid_map": "#......#.#\n..#....#.#\n...##...#.\n...#.....#\n.##......#\n...#.....#\n....#...#.\n##.#...##."}, "output": {"best_location": [8, 6], "max_detected": 22}}, {"input": {"asteroid_map": "....#...\n.#..##..\n.#.##.##\n.##.....\n.###.#.#\n..#.....\n.#...#.#"}, "output": {"best_location": [2, 5], "max_detected": 18}}, {"input": {"asteroid_map": "#.#.#..#.\n#..#.##..\n.##..#...\n...#..##.\n.##...#..\n.#......#\n........#\n.........\n.#...#...\n........."}, "output": {"best_location": [6, 3], "max_detected": 21}}, {"input": {"asteroid_map": "...#.\n.#..#\n#..#.\n.....\n#.#.#\n.#...\n...#.\n.....\n#...."}, "output": {"best_location": [1, 1], "max_detected": 10}}, {"input": {"asteroid_map": "...#.#.\n.##.#..\n....#..\n..#...#\n..#....\n#......\n...#...\n...###.\n.##....\n......."}, "output": {"best_location": [4, 2], "max_detected": 15}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "taylorjg/classic_problems_python", "path": "/aoc/2019/Day10/main.py", "msgidx": 13236}}
{"problem_description": "Given a number, determine whether it is a two-sided prime. A two-sided prime is a prime number that remains prime when its digits are truncated from either side. For example, 3797 is a two-sided prime because 3797, 797, 97, and 7 are all prime numbers. What is the result of checking if the given number is a two-sided prime?", "io_requirements": "Input:\n  `number` (int): The number to be checked for being a two-sided prime.\n\nOutput:\n  `return` (bool): `True` if the number is a two-sided prime, `False` otherwise.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isprime(num):\n    no = int(num)\n    if no <= 1:\n        return False\n    elif (no == 2) or (no == 3):\n        return True\n    elif (no % 2 == 0) or (no % 3 == 0):\n        return False\n    else:\n        for i in range(2, math.floor(no / 2)):\n            if no % i == 0:\n                return False\n        return True\n\ndef truncateleft(num, num_length):\n    if num_length == 1:\n        return isprime(num)\n    i = num[1: num_length + 1]\n    return isprime(i) and truncateleft(i, len(i))\n\ndef truncateright(num, num_length):\n    if num_length == 1:\n        return isprime(num)\n    j = num[0: num_length - 1]\n    return isprime(j) and truncateright(j, len(j))\n\n# main function\ndef main_solution(number):\n    # Convert the input to string to ensure it's JSON serializable\n    num = str(number)\n    num_length = len(num)\n    if num_length == 1:\n        return isprime(num)\n    else:\n        return isprime(num) and truncateleft(num, num_length) and truncateright(num, num_length)", "funcname": "main_solution", "ios": [{"input": {"number": 65964}, "output": false}, {"input": {"number": 11757}, "output": false}, {"input": {"number": 86806}, "output": false}, {"input": {"number": 57513}, "output": false}, {"input": {"number": 41157}, "output": false}, {"input": {"number": 47765}, "output": false}, {"input": {"number": 94691}, "output": false}, {"input": {"number": 60930}, "output": false}, {"input": {"number": 68502}, "output": false}, {"input": {"number": 33113}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ShashankUniyal/twosidedprime", "path": "/Utility.py", "msgidx": 13403}}
{"problem_description": "Given a number represented as a string, determine whether it appears the same when rotated 180 degrees. What is the result of checking if the number `number` is strobogrammatic?", "io_requirements": "Input:\n  `number` (str): A string representing the number to be checked for being strobogrammatic.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input number is strobogrammatic (True) or not (False).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef is_strobogrammatic(num):\n    \"\"\"\n    Determines if a given number is strobogrammatic.\n    \n    Args:\n    num (str): The number to check, represented as a string.\n    \n    Returns:\n    bool: True if the number is strobogrammatic, False otherwise.\n    \"\"\"\n    strobogrammatic_pairs = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    \n    while left <= right:\n        if num[left] not in strobogrammatic_pairs or num[right] not in strobogrammatic_pairs:\n            return False\n        if strobogrammatic_pairs[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# main function\ndef main_solution(number):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = is_strobogrammatic(number)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"number": "198060801"}, "output": false}, {"input": {"number": "99601"}, "output": false}, {"input": {"number": "80891"}, "output": false}, {"input": {"number": "68"}, "output": false}, {"input": {"number": "66019600"}, "output": false}, {"input": {"number": "1166998668"}, "output": false}, {"input": {"number": "86"}, "output": false}, {"input": {"number": "8990189911"}, "output": false}, {"input": {"number": "8086"}, "output": false}, {"input": {"number": "6"}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BassP97/CTCI", "path": "/Med/strobogrammatic.py", "msgidx": 13742}}
{"problem_description": "Given a set of cities and the distances between them, what is the shortest possible route that visits each city exactly once and returns to the origin city? Specifically, what is the best route and the corresponding distance for the given adjacency list of cities and distances?", "io_requirements": "Input:\n  `adjacency_list` (dict): A dictionary representing the adjacency list of the graph. The keys are the names of the cities (strings), and the values are lists of tuples. Each tuple contains a city name (string) and the distance to that city (integer).\n\nOutput:\n  `return` (dict): A dictionary containing the best route and the best distance. The key `\"best_route\"` maps to a list of city names (strings) representing the best route, and the key `\"best_distance\"` maps to an integer representing the total distance of the best route.", "refcode": "# import necessary packages\nimport copy\n\n# all class and function definitions in the code file, if any\nclass TSPProblem:\n    def __init__(self, adjacency_list):\n        self.adjacencyList = adjacency_list\n\ndef permutate(values, distanceDict):\n    results = []\n    \n    if len(values) == 1:\n        results.append(tuple(values))\n        return results\n    \n    workingLists = [[values[0]]]\n    \n    for v in values[1:]:\n        tempList = []\n        for list in workingLists:\n            list.insert(0, v)\n            tempList.append(copy.deepcopy(list))\n            while list.index(v) != (len(list)-1):\n                itemLocation = list.index(v)\n                temp = list[itemLocation+1]\n                list[itemLocation+1] = v\n                list[itemLocation] = temp\n                tempList.append(copy.deepcopy(list))\n        workingLists = copy.deepcopy(tempList)\n    \n    for resultList in workingLists:\n        resultList.append(resultList[0])\n        results.append(resultList)\n    \n    bestDistance = float(\"inf\")\n    bestRoute = []\n    \n    for possibleRoute in results:\n        distance = 0\n        for i in range(len(possibleRoute)-1):\n            for toCity in distanceDict[possibleRoute[i]]:\n                if possibleRoute[i+1] == toCity[0]:\n                    distance += int(toCity[1])\n        if distance < bestDistance:\n            bestDistance = distance\n            bestRoute = possibleRoute\n    \n    return bestRoute, bestDistance\n\n# main function\ndef main_solution(adjacency_list):\n    # Convert the adjacency list to a JSON serializable format\n    json_serializable_adjacency_list = {city: [(to_city, int(distance)) for to_city, distance in city_list] for city, city_list in adjacency_list.items()}\n    \n    # Create an instance of TSPProblem\n    tsp = TSPProblem(json_serializable_adjacency_list)\n    \n    # Get the list of cities\n    cities = list(tsp.adjacencyList.keys())\n    \n    # Find the best route and distance\n    best_route, best_distance = permutate(cities, tsp.adjacencyList)\n    \n    # Return the best route and distance as JSON serializable outputs\n    return {\"best_route\": best_route, \"best_distance\": best_distance}", "funcname": "main_solution", "ios": [{"input": {"adjacency_list": {"City0": [["City2", 9]], "City1": [], "City2": [["City0", 50]]}}, "output": {"best_route": ["City2", "City1", "City0", "City2"], "best_distance": 9}}, {"input": {"adjacency_list": {"City0": [], "City1": [["City2", 91]], "City2": []}}, "output": {"best_route": ["City2", "City1", "City0", "City2"], "best_distance": 0}}, {"input": {"adjacency_list": {"City0": [["City2", 59]], "City1": [["City2", 93]], "City2": []}}, "output": {"best_route": ["City2", "City1", "City0", "City2"], "best_distance": 59}}, {"input": {"adjacency_list": {"City0": [], "City1": [["City0", 22]], "City2": [["City1", 94]]}}, "output": {"best_route": ["City1", "City2", "City0", "City1"], "best_distance": 0}}, {"input": {"adjacency_list": {"City0": [], "City1": [], "City2": []}}, "output": {"best_route": ["City2", "City1", "City0", "City2"], "best_distance": 0}}, {"input": {"adjacency_list": {"City0": [["City2", 66]], "City1": [["City2", 51]], "City2": []}}, "output": {"best_route": ["City1", "City2", "City0", "City1"], "best_distance": 51}}, {"input": {"adjacency_list": {"City0": [["City2", 13]], "City1": [], "City2": [["City0", 84]]}}, "output": {"best_route": ["City2", "City1", "City0", "City2"], "best_distance": 13}}, {"input": {"adjacency_list": {"City0": [], "City1": [["City0", 18]], "City2": [["City0", 41]]}}, "output": {"best_route": ["City2", "City1", "City0", "City2"], "best_distance": 18}}, {"input": {"adjacency_list": {"City0": [], "City1": [["City0", 96]], "City2": []}}, "output": {"best_route": ["City1", "City2", "City0", "City1"], "best_distance": 0}}, {"input": {"adjacency_list": {"City0": [], "City1": [["City2", 31]], "City2": [["City0", 28]]}}, "output": {"best_route": ["City2", "City1", "City0", "City2"], "best_distance": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "JSchooley/TravelingSalesperson", "path": "/src/TSPProblem.py", "msgidx": 13762}}
{"problem_description": "In a game of Tic-Tac-Toe, what is the outcome of the game given a specific board configuration? The board is represented by a list of 9 integers, where -1 represents 'O', 0 represents an empty square, and 1 represents 'X'. The board is evaluated to determine if 'X' wins, 'O' wins, or if the game is a draw.", "io_requirements": "Input:\n  `board` (list of integers): A list representing the Tic-Tac-Toe board. Each element in the list can be -1 (representing 'O'), 0 (representing an empty square), or 1 (representing 'X'). The list should have exactly 9 elements, corresponding to the 9 squares of the Tic-Tac-Toe board.\n\nOutput:\n  `return` (dictionary): A dictionary with a single key \"result\" whose value is an integer representing the result of the game. The possible values are:\n    - 1: Player 'X' wins.\n    - -1: Player 'O' wins.\n    - 0: The game is a draw.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef check_victory_condition(board, player):\n    board = np.array(board)\n    for i in range(3):\n        row = board[(i * 3):(i * 3 + 3)]\n        col = board[i::3]\n        if np.sum(row) == 3*player or np.sum(col) == 3*player:\n            return True\n        if np.sum(board[[0, 4, 8]]) == 3*player or np.sum(board[[2, 4, 6]]) == 3*player:\n            return True\n    return False\n\ndef judge(board):\n    # Check which is the current player\n    if np.sum(board) == 0:\n        player = 1\n    else:\n        player = -1\n    # Check endgame\n    for i in range(3):\n        row = board[(i*3):(i*3+3)]\n        col = board[i::3]\n        if np.sum(row) == 3 or np.sum(col) == 3:\n            return 1\n        if np.sum(row) == -3 or np.sum(col) == -3:\n            return -1\n    # Check diag\n    if np.sum(board[[0, 4, 8]]) == 3 or np.sum(board[[2, 4, 6]]) == 3:\n        return 1\n    if np.sum(board[[0, 4, 8]]) == -3 or np.sum(board[[2, 4, 6]]) == -3:\n        return -1\n    if 0 not in board:\n        return 0\n    # Recursive search\n    results = []\n    for i in range(len(board)):\n        if board[i] == 0:\n            next_board = np.array(board)\n            next_board[i] = player\n            result = judge(next_board)\n            if player == result:\n                return player\n            results.append(result)\n    if 0 in results:\n        return 0\n    else:\n        return -player\n\n# main function\ndef main_solution(board):\n    # Convert the input list to a numpy array\n    board_array = np.array(board)\n    # Get the result of the game\n    result = judge(board_array)\n    # Convert the result to a JSON serializable output\n    result_dict = {\"result\": result}\n    return result_dict", "funcname": "main_solution", "ios": [{"input": {"board": [0, 1, 0, 0, 0, 0, 0, 1, -1]}, "output": {"result": -1}}, {"input": {"board": [1, 0, 1, 0, -1, -1, 1, -1, 1]}, "output": {"result": -1}}, {"input": {"board": [-1, 1, 0, -1, 1, 0, -1, 1, 1]}, "output": {"result": -1}}, {"input": {"board": [-1, 1, -1, 1, 0, 1, 1, -1, -1]}, "output": {"result": 1}}, {"input": {"board": [-1, 0, -1, 1, 1, 0, 1, 0, -1]}, "output": {"result": 1}}, {"input": {"board": [0, -1, 0, 0, 0, -1, -1, 1, 1]}, "output": {"result": -1}}, {"input": {"board": [1, 1, 0, -1, 0, -1, -1, 1, -1]}, "output": {"result": -1}}, {"input": {"board": [0, 0, 1, 1, 0, -1, 1, -1, -1]}, "output": {"result": 1}}, {"input": {"board": [-1, -1, 0, 1, 0, 0, 1, 0, 1]}, "output": {"result": -1}}, {"input": {"board": [-1, 1, 1, 1, 0, -1, -1, -1, 1]}, "output": {"result": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "hephaex/deeplearning-note", "path": "/3_ETRI-lecture/tictactoe/generate_data.py", "msgidx": 13770}}
{"problem_description": "Given a sequence of 10 unique digits from '0' to '9', what is the sum of all possible pandigital numbers that exhibit the sub-string divisibility property, where each three-digit substring starting from the second digit is divisible by a specific prime number?", "io_requirements": "Input:\n  `digits` (str): A string of 10 unique digits from '0' to '9' in any order.\n\nOutput:\n  `return` (int): The sum of all 0 to 9 pandigital numbers that satisfy the sub-string divisibility property.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(digits):\n    # Convert the input string to a list of characters\n    digits_list = list(digits)\n    \n    # Generate all permutations of the digits\n    pandigitals = permutations(digits_list)\n    \n    # Function to check the sub-string divisibility property\n    def check(num):\n        primes = [2, 3, 5, 7, 11, 13, 17]\n        sub_numbers = map(int, (str(num)[i:i + 3] for i in range(1, 9)))\n        return not any(num % prime for num, prime in zip(sub_numbers, primes))\n    \n    # Filter pandigital numbers that satisfy the sub-string divisibility property\n    valid_pandigitals = filter(check, (int(''.join(p)) for p in pandigitals))\n    \n    # Sum all valid pandigital numbers\n    result = sum(valid_pandigitals)\n    \n    # Return the result as an integer\n    return result", "funcname": "main_solution", "ios": [{"input": {"digits": "0123456789"}, "output": 16695334890}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "GlenHaber/euler", "path": "/problem43.py", "msgidx": 13535}}
{"problem_description": "Given two jugs with capacities `x` and `y` liters, and an infinite water supply, can you determine if it is possible to measure exactly `z` liters using these two jugs? You are allowed to fill any of the jugs completely, empty any of the jugs, or pour water from one jug into another until the other jug is full or the first jug is empty. What is the result of this operation?", "io_requirements": "Input:\n  `x` (int): The capacity of the first jug in liters.\n  `y` (int): The capacity of the second jug in liters.\n  `z` (int): The desired amount of water in liters to be measured using the two jugs.\n\nOutput:\n  `return` (bool): `True` if it is possible to measure exactly `z` liters using the two jugs, otherwise `False`.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def canMeasureWater(self, x, y, z):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type z: int\n        :rtype: bool\n        \"\"\"\n        if z > x + y:\n            return False\n        if z == 0:\n            return True\n        if x == 0:\n            return z == y\n        if y == 0:\n            return z == x\n        return z % math.gcd(x, y) == 0\n\n# main function\ndef main_solution(x, y, z):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.canMeasureWater(x, y, z)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"x": 8, "y": 50, "z": 153}, "output": false}, {"input": {"x": 18, "y": 55, "z": 92}, "output": false}, {"input": {"x": 14, "y": 99, "z": 47}, "output": true}, {"input": {"x": 18, "y": 44, "z": 170}, "output": false}, {"input": {"x": 92, "y": 42, "z": 145}, "output": false}, {"input": {"x": 33, "y": 11, "z": 80}, "output": false}, {"input": {"x": 41, "y": 66, "z": 125}, "output": false}, {"input": {"x": 69, "y": 90, "z": 51}, "output": true}, {"input": {"x": 57, "y": 19, "z": 137}, "output": false}, {"input": {"x": 87, "y": 41, "z": 10}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lishulongVI/leetcode", "path": "/python3/365.Water and Jug Problem(\u6c34\u58f6\u95ee\u9898).py", "msgidx": 13565}}
{"problem_description": "A building has 100 floors. One of the floors is the highest floor an egg can be dropped from without breaking. Given two eggs, what is the minimum number of drops required to determine the highest floor an egg can be dropped from without breaking, with the highest floor being `egg_breaks_floor`?", "io_requirements": "Input:\n  `total_floors` (int): The total number of floors in the building.\n  `egg_breaks_floor` (int): The highest floor an egg can be dropped from without breaking.\n\nOutput:\n  `return` (int): The number of drops required to find the highest floor an egg can be dropped from without breaking.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(total_floors, egg_breaks_floor):\n    \"\"\"\n    Finds the highest floor an egg can be dropped from without breaking, using two eggs and minimizing the number of drops.\n\n    Args:\n    total_floors (int): The total number of floors in the building.\n    egg_breaks_floor (int): The highest floor an egg can be dropped from without breaking.\n\n    Returns:\n    int: The number of drops required to find the highest floor an egg can be dropped from without breaking.\n    \"\"\"\n    # Calculate the initial skip value\n    n = math.ceil((-1 + math.sqrt(1 + 8 * total_floors)) / 2)\n    \n    # Initialize variables\n    drops = 0\n    current_floor = 0\n    \n    # First egg drops\n    while current_floor < egg_breaks_floor:\n        drops += 1\n        current_floor += n\n        n -= 1\n    \n    # Second egg drops\n    current_floor -= n + 1\n    while current_floor < egg_breaks_floor:\n        drops += 1\n        current_floor += 1\n    \n    return drops", "funcname": "main_solution", "ios": [{"input": {"total_floors": 100, "egg_breaks_floor": 22}, "output": 10}, {"input": {"total_floors": 100, "egg_breaks_floor": 75}, "output": 13}, {"input": {"total_floors": 100, "egg_breaks_floor": 62}, "output": 8}, {"input": {"total_floors": 100, "egg_breaks_floor": 96}, "output": 12}, {"input": {"total_floors": 100, "egg_breaks_floor": 71}, "output": 9}, {"input": {"total_floors": 100, "egg_breaks_floor": 12}, "output": 13}, {"input": {"total_floors": 100, "egg_breaks_floor": 69}, "output": 15}, {"input": {"total_floors": 100, "egg_breaks_floor": 51}, "output": 6}, {"input": {"total_floors": 100, "egg_breaks_floor": 86}, "output": 11}, {"input": {"total_floors": 100, "egg_breaks_floor": 82}, "output": 13}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "rayt579/cake", "path": "/combinatorics_probability/two_egg_problem.py", "msgidx": 13936}}
{"problem_description": "Given a map with multiple streets, each defined by a series of vertices, determine the vertices and edges of the undirected graph that represents the intersections between these streets. What are the vertices and edges of the graph formed by the intersections of the given streets?", "io_requirements": "Input:\n- `street_info` (dict): A dictionary where each key is a street name (string) and each value is a list of coordinate strings representing the vertices of the street. Each coordinate string is in the format \"(x, y)\" where x and y are integers.\n\nOutput:\n- `return` (dict): A dictionary containing two keys:\n  - `vertices` (list of lists): A list of vertices, where each vertex is represented as a list of two integers [x, y].\n  - `edges` (list of lists): A list of edges, where each edge is represented as a list of two vertices, each vertex being a list of two integers [x, y].", "refcode": "# import necessary packages\nimport re\nimport numpy as np\n\n# This function checks whether intersection point(s) exists between two lines\ndef checks(x1, y1, x2, y2, x3, y3, x4, y4):\n    try:\n        # t and u are part of the line intersection equation\n        t_numerator = ((x1 - x3) * (y3 - y4)) - ((y1 - y3) * (x3 - x4))\n        t_denominator = ((x1 - x2) * (y3 - y4)) - ((y1 - y2) * (x3 - x4))\n\n        u_numerator = ((x1 - x2) * (y1 - y3)) - ((y1 - y2) * (x1 - x3))\n        u_denominator = ((x1 - x2) * (y3 - y4)) - ((y1 - y2) * (x3 - x4))\n\n        t = t_numerator / t_denominator\n        u = -u_numerator / u_denominator\n\n        # u and t are out of bounds --> distinct lines, not overlapping\n        if (u < 0 or u > 1 or t < 0 or t > 1):\n            return 0\n\n        # Executes if only one intersection point exists between two lines\n        if ((0 <= u <= 1) and (0 <= t <= 1)):\n            x_coord = x1 + (t * (x2 - x1))\n            y_coord = y1 + (t * (y2 - y1))\n            return [(float(\"{0:.2f}\".format(x_coord)), float(\"{0:.2f}\".format(y_coord)))]\n\n    except:\n        # These statements describe overlapping line segment scenarios for all orientations and returns both intersection points\n        if (t_numerator == 0 and t_denominator == 0 and u_numerator == 0 and u_denominator == 0):\n            if ((x3 <= x1 <= x4 and x3 <= x2 <= x4 and y3 <= y1 <= y4 and y3 <= y2 <= y4) or\n                (x4 <= x1 <= x3 and x4 <= x2 <= x3 and y4 <= y1 <= y3 and y4 <= y2 <= y3) or\n                (x3 <= x1 <= x4 and x3 <= x2 <= x4 and y3 >= y1 >= y4 and y3 >= y2 >= y4) or\n                (x4 <= x1 <= x3 and x4 <= x2 <= x3 and y4 >= y1 >= y3 and y4 >= y2 >= y3)):\n                return [(x1, y1), (x2, y2)]\n\n            if ((x2 <= x3 <= x1 and x2 <= x4 <= x1 and y2 <= y3 <= y1 and y2 <= y4 <= y1) or\n                (x1 <= x3 <= x2 and x1 <= x4 <= x2 and y1 <= y3 <= y2 and y1 <= y4 <= y2) or\n                (x2 <= x3 <= x1 and x2 <= x4 <= x1 and y2 >= y3 >= y1 and y2 >= y4 >= y1) or\n                (x1 <= x3 <= x2 and x1 <= x4 <= x2 and y1 >= y3 >= y2 and y1 >= y4 >= y2)):\n                return [(x3, y3), (x4, y4)]\n\n            if ((x1 <= x3 <= x2 <= x4 and y1 >= y3 >= y2 >= y4) or\n                (x4 <= x2 <= x3 <= x1 and y4 >= y2 >= y3 >= y1) or\n                (x1 >= x3 >= x2 >= x4 and y1 >= y3 >= y2 >= y4) or\n                (x4 >= x2 >= x3 >= x1 and y4 >= y2 >= y3 >= y1)):\n                return [(x3, y3), (x2, y2)]\n\n            if ((x1 <= x4 <= x2 <= x3 and y1 >= y4 >= y2 >= y3) or\n                (x3 <= x2 <= x4 <= x1 and y3 >= y2 >= y4 >= y1) or\n                (x1 >= x4 >= x2 >= x3 and y1 >= y4 >= y2 >= y3) or\n                (x3 >= x2 >= x4 >= x1 and y3 >= y2 >= y4 >= y1)):\n                return [(x2, y2), (x4, y4)]\n\n            if ((x2 <= x4 <= x1 <= x3 and y2 >= y4 >= y1 >= y3) or\n                (x3 <= x1 <= x4 <= x2 and y3 >= y1 >= y4 >= y2) or\n                (x2 >= x4 >= x1 >= x3 and y2 >= y4 >= y1 >= y3) or\n                (x3 >= x1 >= x4 >= x2 and y3 >= y1 >= y4 >= y2)):\n                return [(x1, y1), (x4, y4)]\n\n            if ((x4 <= x1 <= x3 <= x2 and y4 >= y1 >= y3 >= y2) or\n                (x2 <= x3 <= x1 <= x4 and y2 >= y3 >= y1 >= y4) or\n                (x4 >= x1 >= x3 >= x2 and y4 >= y1 >= y3 >= y2) or\n                (x2 >= x3 >= x1 >= x4 and y2 >= y3 >= y1 >= y4)):\n                return [(x1, y1), (x3, y3)]\n\n        # The lines are not overlapping --> parallel and not touching, no intersection\n        if (t_denominator == 0 and u_denominator == 0):\n            return 0\n\n    return 0\n\n# main function\ndef main_solution(street_info):\n    # Convert street_info to a dictionary of tuples\n    converted = {}\n    for key, value in street_info.items():\n        converted[key] = [eval(item) for item in value]\n\n    # Stores all the vertices in the street map\n    vertices = []\n\n    # Stores unsorted, redundant edge list here --> will be refined later\n    temp_edge_list = []\n\n    # This loop finds all valid intersection points in the street map and orders them with respect to distance\n    for key_temp in converted:\n        # Stores all intersection points in the street map as keys, and stores all line segment endpoints which make these intersection as values\n        ip_dict = {}\n\n        # Stores the coordinates which make up a street as an array of tuples\n        value_curr = converted[key_temp]\n\n        # This loop finds all intersection points within the street map and stores it into \"ip_dict\" dictionary\n        for i in range(0, len(value_curr) - 1):\n            # Extract coordinates for first line segment\n            x1, y1 = value_curr[i][0], value_curr[i][1]\n            x2, y2 = value_curr[i + 1][0], value_curr[i + 1][1]\n\n            for key in converted:\n                if key != key_temp:\n                    other_street_val = converted[key]\n\n                    for k in range(0, len(other_street_val) - 1):\n                        # Extract coordinates for second line segment\n                        x3, y3 = other_street_val[k][0], other_street_val[k][1]\n                        x4, y4 = other_street_val[k + 1][0], other_street_val[k + 1][1]\n\n                        # Function \"checks\" evaluates whether intersection point(s) exist between both line segments in comparison\n                        ip = checks(x1, y1, x2, y2, x3, y3, x4, y4)\n\n                        if ip != 0:\n                            for pt in ip:\n                                if pt in ip_dict:\n                                    val = ip_dict[pt]\n                                    val.append((x1, y1))\n                                    val.append((x2, y2))\n                                    val.append((x3, y3))\n                                    val.append((x4, y4))\n                                else:\n                                    ip_dict[pt] = [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]\n\n        # This loop sorts all the intersection points in order by distance - thereby producing a correct edge list for the undirected graph - and creates the edge list\n        for x in range(0, len(value_curr) - 1):\n            temp = []\n\n            p_x1, p_y1 = value_curr[x][0], value_curr[x][1]\n            p_x2, p_y2 = value_curr[x + 1][0], value_curr[x + 1][1]\n\n            for key_ip in ip_dict:\n                val = ip_dict[key_ip]\n\n                for j in range(0, len(val) - 1):\n                    p1, q1 = val[j][0], val[j][1]\n                    p2, q2 = val[j + 1][0], val[j + 1][1]\n\n                    if p_x1 == p1 and p_y1 == q1 and p_x2 == p2 and p_y2 == q2:\n                        if key_ip not in temp:\n                            temp.append(key_ip)\n                        break\n                    j = j + 1\n\n            if len(temp) > 1:\n                Ap = np.array([p_x1, p_y1])\n                B = np.asarray(temp)\n                dist = np.linalg.norm(B - Ap, ord=2, axis=1)\n                sorted_B = B[np.argsort(dist)]\n\n                temp = sorted_B.tolist()\n                temp = [tuple(y) for y in temp]\n\n            if len(temp) >= 1:\n                temp.insert(0, (p_x1, p_y1))\n                temp.append((p_x2, p_y2))\n\n            final_list = []\n            for intersection in temp:\n                if intersection not in final_list:\n                    final_list.append(intersection)\n\n            if len(final_list) >= 2:\n                for j in range(0, len(final_list) - 1):\n                    temp_edge_list.append((final_list[j], final_list[j + 1]))\n\n    redundant_edge_list = []\n    for item in temp_edge_list:\n        if item not in redundant_edge_list:\n            redundant_edge_list.append(item)\n\n    # Checks for and removes any duplicate edges from the edge list\n    final_edge_list = []\n    for y in range(0, len(redundant_edge_list)):\n        duplicate_1 = (redundant_edge_list[y][0], redundant_edge_list[y][1])\n        duplicate_2 = (redundant_edge_list[y][1], redundant_edge_list[y][0])\n        if (duplicate_1 not in final_edge_list) and (duplicate_2 not in final_edge_list):\n            final_edge_list.append(duplicate_1)\n\n    # Now that the final edge list is complete, this portion creates the vertice list from the edge list\n    for x in range(0, len(final_edge_list)):\n        if final_edge_list[x][0] not in vertices:\n            vertices.append(final_edge_list[x][0])\n\n        if final_edge_list[x][1] not in vertices:\n            vertices.append(final_edge_list[x][1])\n\n    # Convert vertices and edges to JSON serializable format\n    vertices_serializable = [list(v) for v in vertices]\n    edges_serializable = [list(e) for e in final_edge_list]\n\n    return {\"vertices\": vertices_serializable, \"edges\": edges_serializable}", "funcname": "main_solution", "ios": [{"input": {"street_info": {"Street_74": ["(-2, -5)", "(-8, -4)", "(7, 1)", "(-7, 8)", "(2, 4)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_63": ["(2, 10)", "(5, -2)", "(3, -7)", "(-8, -7)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_35": ["(8, -9)", "(10, 7)", "(9, 5)", "(-10, 1)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_30": ["(5, 8)", "(9, 3)", "(-6, 4)", "(-7, 10)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_91": ["(5, -2)", "(8, -3)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_64": ["(3, -9)", "(-9, 8)", "(-2, 10)", "(-4, -10)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_98": ["(0, -2)", "(-3, 0)", "(-7, -4)", "(-6, 4)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_46": ["(9, 7)", "(0, -4)", "(-5, 5)", "(2, -6)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_18": ["(9, -2)", "(7, -8)", "(0, 7)"]}}, "output": {"vertices": [], "edges": []}}, {"input": {"street_info": {"Street_2": ["(-8, 4)", "(4, 3)", "(5, 1)"]}}, "output": {"vertices": [], "edges": []}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "subramario/Interprocess_Communication_Driver", "path": "/undirected_graph_generator.py", "msgidx": 12330}}
{"problem_description": "Given a graph with a certain number of vertices and a set of colors, how many different ways can the vertices be colored such that no two adjacent vertices share the same color, and what is one possible valid coloring?", "io_requirements": "Input:\n  `graph` (list of lists of integers): A list where each element is a list of integers representing the vertices adjacent to the corresponding vertex.\n  `colors` (list of strings): A list of color names that can be used to color the vertices.\n\nOutput:\n  `return` (dictionary): A dictionary with the following keys:\n    - `total_combinations` (integer): The total number of valid color combinations found.\n    - `coloring` (list of strings): A list of color names representing a valid coloring of the vertices.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef gColor(graph, n, vertex, index, colors, nc):\n    global c\n    if index == n:\n        l = []\n        c += 1\n        for i in range(n):\n            l += [colors[vertex[i]]]\n        return l\n    else:\n        lc = [-1 for _ in range(nc)]\n        ls = graph[index]\n        for j in range(len(ls)):\n            if vertex[ls[j]] != -1:\n                lc[vertex[ls[j]]] = 1\n        for j in range(nc):\n            if lc[j] == -1:\n                vertex[index] = j\n                result = gColor(graph, n, vertex, index + 1, colors, nc)\n                if result:\n                    return result\n                vertex[index] = -1\n    return None\n\n# main function\ndef main_solution(graph, colors):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    n = len(graph)\n    nc = len(colors)\n    vertex = [-1 for _ in range(n)]\n    global c\n    c = 0\n    result = gColor(graph, n, vertex, 0, colors, nc)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"total_combinations\": c, \"coloring\": result}", "funcname": "main_solution", "ios": [{"input": {"graph": [[0, 2], [1, 2, 3], [3], [3, 1, 2]], "colors": ["color_0", "color_1"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_0", "color_0", "color_1"]}}, {"input": {"graph": [[0, 2], [1], [2, 1]], "colors": ["color_0", "color_1", "color_2", "color_3"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_0", "color_1"]}}, {"input": {"graph": [[0, 1], [1, 0], [2]], "colors": ["color_0", "color_1"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_1", "color_0"]}}, {"input": {"graph": [[0], [1, 2], [0]], "colors": ["color_0", "color_1", "color_2"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_0", "color_1"]}}, {"input": {"graph": [[0, 1, 3], [1], [1, 3, 2], [3, 1, 2]], "colors": ["color_0", "color_1"]}, "output": {"total_combinations": 0, "coloring": null}}, {"input": {"graph": [[1], [2, 1], [1]], "colors": ["color_0", "color_1", "color_2"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_0", "color_1"]}}, {"input": {"graph": [[1, 0], [2, 0], [0]], "colors": ["color_0", "color_1", "color_2"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_1", "color_1"]}}, {"input": {"graph": [[3, 1], [3, 1, 0], [0], [2, 1]], "colors": ["color_0", "color_1"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_1", "color_1", "color_0"]}}, {"input": {"graph": [[3, 0, 2], [1, 3, 2], [1], [3, 0]], "colors": ["color_0", "color_1"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_0", "color_1", "color_1"]}}, {"input": {"graph": [[2], [2, 1], [0, 1]], "colors": ["color_0", "color_1"]}, "output": {"total_combinations": 1, "coloring": ["color_0", "color_0", "color_1"]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mamta238/AlgoClasswork", "path": "/graphColouring.py", "msgidx": 13908}}
{"problem_description": "Given a mathematical puzzle where three numbers, Red, Blue, and Green, are concatenated to form a number, and when this number is tripled, it equals another number formed by concatenating Green three times, what are the values of Red, Blue, and Green that satisfy this condition?", "io_requirements": "Input:\n  `max_value` (int): The maximum value for x, y, and z in the range of 0 to max_value.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `x` (int): The value of x that satisfies the condition.\n    - `y` (int): The value of y that satisfies the condition.\n    - `z` (int): The value of z that satisfies the condition.\n    - `result` (int): The result of the equation `num1 * 3 == num2`. If no solution is found, all values will be `None`.", "refcode": "# import necessary packages\n\n# main function\ndef main_solution(max_value):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    for x in range(0, max_value):\n        for y in range(0, max_value):\n            for z in range(0, max_value):\n                num1 = int(f\"{x}{y}{z}\")\n                num2 = int(f\"{z}{z}{z}\")\n                if num1 * 3 == num2:\n                    return {\"x\": x, \"y\": y, \"z\": z, \"result\": num2}\n    return {\"x\": None, \"y\": None, \"z\": None, \"result\": None}", "funcname": "main_solution", "ios": [{"input": {"max_value": 691}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 194}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 946}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 388}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 202}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 617}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 480}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 645}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 181}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}, {"input": {"max_value": 840}, "output": {"x": 0, "y": 0, "z": 0, "result": 0}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "timcrone/python-training", "path": "/pre-email-1.py", "msgidx": 14349}}
{"problem_description": "Given a set of prime numbers up to a certain limit, and two specific prime numbers within this set, what is the minimum number of steps required to transform the first prime number into the second prime number by either adding or subtracting powers of 2? Each step must result in another prime number within the set.", "io_requirements": "Input:\n  `prime_limit` (int): The upper limit for finding prime numbers.\n  `start` (int): The starting prime number for the shortest path search.\n  `end` (int): The ending prime number for the shortest path search.\n\nOutput:\n  `return` (int or None): The minimum number of steps required to reach the `end` prime from the `start` prime, or `None` if no path exists.", "refcode": "# import necessary packages\nfrom math import log2\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\ndef find_primes(prime_limit):\n    primes = set()\n    numbers = list(range(0, prime_limit + 1))\n    numbers[0] = 0\n    numbers[1] = 0\n\n    for i in range(2, prime_limit + 1):\n        if numbers[i] == 0:\n            continue\n\n        primes.add(i)\n\n        for j in range(2 * i, prime_limit + 1, i):\n            numbers[j] = 0\n\n    return primes\n\ndef shortest_path(primes, start, end, max_prime):\n    q = deque([(1, start)])\n    upper_bit_limit = int(log2(max_prime)) + 1\n    primes.remove(start)\n\n    while len(q) > 0:\n        (prev_len, node) = q.popleft()\n\n        if node == end:\n            return prev_len\n\n        for i in range(upper_bit_limit):\n            diff = 1 << i\n\n            next_one = node + diff\n            if next_one in primes:\n                primes.remove(next_one)\n                q.append((prev_len + 1, next_one))\n\n            next_one = node - diff\n            if next_one in primes:\n                primes.remove(next_one)\n                q.append((prev_len + 1, next_one))\n\n    return None\n\n# main function\ndef main_solution(prime_limit, start, end):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    primes = find_primes(prime_limit)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return shortest_path(primes, start, end, prime_limit)", "funcname": "main_solution", "ios": [{"input": {"prime_limit": 332, "start": 167, "end": 139}, "output": 4}, {"input": {"prime_limit": 103, "start": 97, "end": 53}, "output": 4}, {"input": {"prime_limit": 800, "start": 683, "end": 59}, "output": 5}, {"input": {"prime_limit": 809, "start": 683, "end": 683}, "output": 1}, {"input": {"prime_limit": 124, "start": 19, "end": 3}, "output": 2}, {"input": {"prime_limit": 652, "start": 53, "end": 5}, "output": 3}, {"input": {"prime_limit": 706, "start": 61, "end": 433}, "output": 7}, {"input": {"prime_limit": 219, "start": 17, "end": 41}, "output": 5}, {"input": {"prime_limit": 343, "start": 281, "end": 257}, "output": 7}, {"input": {"prime_limit": 996, "start": 593, "end": 349}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "matthewelse/british-informatics-olympiad", "path": "/2016/q3.py", "msgidx": 13567}}
{"problem_description": "Given a list of airline tickets represented by pairs of departure and arrival airports, determine the order in which the airports are visited starting from \"ICN\". The solution should prioritize visiting airports in alphabetical order when multiple options are available. What is the sequence of airport visits?", "io_requirements": "Input:\n  `tickets` (list of lists of strings): A list of tickets where each ticket is represented as a list of two strings. The first string is the departure airport, and the second string is the arrival airport.\n\nOutput:\n  `return` (list of strings): A list of airport codes representing the order in which the airports are visited, starting from \"ICN\".", "refcode": "# import necessary packages\nfrom collections import deque\n\n# main function\ndef main_solution(tickets):\n    def go(node, new_tickets):\n        result = []\n        for i in new_tickets:\n            if i[0] == node:\n                result.append(i[1])\n        result.sort()\n        return result if result else [\"none\"]\n\n    def bfs(node, new_tickets):\n        queue = deque([node])\n        visited = []\n        while queue:\n            start = queue.popleft()\n            if start not in visited:\n                visited.append(start)\n                next_nodes = go(start, new_tickets)\n                for next_node in next_nodes:\n                    if next_node != \"none\":\n                        queue.append(next_node)\n        return visited\n\n    new_tickets = list(map(list, set(map(tuple, tickets))))\n    start_node = \"ICN\"\n    result = bfs(start_node, new_tickets)\n    return result", "funcname": "main_solution", "ios": [{"input": {"tickets": [["ATL", "CCC"], ["CCC", "ICN"], ["CCC", "ATL"], ["HND", "BBB"], ["ATL", "HND"]]}, "output": ["ICN"]}, {"input": {"tickets": [["JFK", "DDD"], ["SFO", "HND"], ["DDD", "JFK"], ["DDD", "SFO"], ["ATL", "JFK"]]}, "output": ["ICN"]}, {"input": {"tickets": [["HND", "CCC"], ["BBB", "CCC"], ["BBB", "JFK"], ["CCC", "JFK"], ["CCC", "BBB"]]}, "output": ["ICN"]}, {"input": {"tickets": [["IAD", "ATL"], ["ATL", "BBB"], ["IAD", "BBB"], ["BBB", "ATL"], ["AAA", "CCC"]]}, "output": ["ICN"]}, {"input": {"tickets": [["CCC", "DDD"], ["DDD", "SFO"], ["SFO", "CCC"], ["DDD", "JFK"], ["CCC", "ICN"]]}, "output": ["ICN"]}, {"input": {"tickets": [["ATL", "JFK"], ["SFO", "CCC"], ["SFO", "ATL"], ["JFK", "ATL"], ["SFO", "CCC"]]}, "output": ["ICN"]}, {"input": {"tickets": [["SFO", "IAD"], ["AAA", "ICN"], ["AAA", "ICN"], ["IAD", "SFO"], ["DDD", "IAD"]]}, "output": ["ICN"]}, {"input": {"tickets": [["IAD", "ATL"], ["HND", "IAD"], ["AAA", "IAD"], ["ICN", "IAD"], ["ICN", "AAA"]]}, "output": ["ICN", "AAA", "IAD", "ATL"]}, {"input": {"tickets": [["JFK", "AAA"], ["JFK", "SFO"], ["AAA", "SFO"], ["HND", "ICN"], ["AAA", "JFK"]]}, "output": ["ICN"]}, {"input": {"tickets": [["IAD", "HND"], ["ATL", "DDD"], ["ATL", "CCC"], ["ATL", "DDD"], ["CCC", "HND"]]}, "output": ["ICN"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sds1vrk/Algo_Study", "path": "/Programers_algo/DFS_BFS/pro_4_re.py", "msgidx": 13941}}
{"problem_description": "Santa's password has expired, and he needs a new one that meets specific security criteria. The new password must be an 8-character string composed of lowercase letters. It must include a sequence of three consecutive letters (e.g., \"abc\"), must not contain the letters \"i\", \"o\", or \"l\", and must have at least two different, non-overlapping pairs of letters (e.g., \"aa\" and \"bb\"). Given an initial 8-character password, what is the next valid password that meets these criteria?", "io_requirements": "Input:\n  `initial_password` (str): A string representing the initial password that needs to be incremented until it meets the specified criteria. The string should be composed of lowercase letters only and should be 8 characters long.\n\nOutput:\n  `return` (str): A string representing the next valid password that meets the criteria. The string will be composed of lowercase letters only and will be 8 characters long.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef sequence(password):\n    for i in range(0, len(password) - 2):\n        if ord(password[i]) + 2 == ord(password[i + 1]) + 1 == ord(password[i + 2]):\n            return \"true\"\n    return \"false\"\n\ndef non_confusing(password):\n    for i in range(0, len(password)):\n        if password[i] in (\"i\", \"o\", \"l\"):\n            return \"false\"\n    return \"true\"\n\ndef two_doubles(password):\n    count = 0\n    temp = [''.join(value) for key, value in itertools.groupby(password)]\n    for j in temp:\n        if len(j) > 1:\n            count += 1\n    if count > 1:\n        return \"true\"\n    else:\n        return \"false\"\n\ndef increment(password):\n    a = list(map(ord, password))\n    index = -1\n\n    while True:\n        a[index] += 1\n        if a[index] <= ord('z'):\n            break\n        else:\n            a[index] = ord('a')\n            index -= 1\n\n    return ''.join(map(chr, a))\n\ndef check_3_rules(new_password):\n    verdict = \"false\"\n    if sequence(new_password) == \"true\":\n        if non_confusing(new_password) == \"true\":\n            if two_doubles(new_password) == \"true\":\n                verdict = \"true\"\n    return verdict\n\n# main function\ndef main_solution(initial_password):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    password = initial_password\n    while True:\n        password = increment(password)\n        if check_3_rules(password) == \"true\":\n            break\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return password", "funcname": "main_solution", "ios": [{"input": {"initial_password": "xyflbgfm"}, "output": "xyfppqrr"}, {"input": {"initial_password": "ngfuhyzi"}, "output": "ngfuuvww"}, {"input": {"initial_password": "zaqetgnh"}, "output": "zaqffghh"}, {"input": {"initial_password": "zskipeii"}, "output": "zskkaabc"}, {"input": {"initial_password": "mqopsdan"}, "output": "mqpaabcc"}, {"input": {"initial_password": "myywjpku"}, "output": "myywppqr"}, {"input": {"initial_password": "vpftwwey"}, "output": "vpfuuvww"}, {"input": {"initial_password": "uwdgcbmf"}, "output": "uwdppqrr"}, {"input": {"initial_password": "sdwswewv"}, "output": "sdwttuvv"}, {"input": {"initial_password": "byetvxyw"}, "output": "byeuuvww"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "kjgross/advent_of_code", "path": "/day_11/code_advent_day11.py", "msgidx": 13343}}
{"problem_description": "In a building with five floors, five individuals\u2014Hopper, Kay, Liskov, Perlis, and Ritchie\u2014need to be assigned to these floors. However, there are specific constraints: Hopper cannot be on the top floor, Kay cannot be on the bottom floor, Liskov cannot be on the top or bottom floor, Perlis must be above Kay, Ritchie cannot be adjacent to Liskov, and Liskov cannot be adjacent to Kay. Given these constraints, what is the correct floor arrangement for these individuals?", "io_requirements": "Input:\n  `floors` (list of integers): A list of integers representing the floors, typically `[1, 2, 3, 4, 5]`.\n\nOutput:\n  `return` (list of integers or None): A list of integers representing the correct floor arrangement for Hopper, Kay, Liskov, Perlis, and Ritchie, or `None` if no valid arrangement is found.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(floors):\n    # Convert the input list to a tuple for permutation\n    floors_tuple = tuple(floors)\n    orderings = itertools.permutations(floors_tuple)\n    \n    for (Hopper, Kay, Liskov, Perlis, Ritchie) in orderings:\n        if (Hopper != floors[-1]  # Hopper is not on the top floor\n                and Kay != floors[0]  # Kay is not on the bottom floor\n                and Liskov != floors[-1]  # Liskov is not on the top floor\n                and Liskov != floors[0]  # Liskov is not on the bottom floor\n                and Perlis > Kay  # Perlis is above Kay\n                and abs(Ritchie - Liskov) > 1  # Ritchie is not adjacent to Liskov\n                and abs(Liskov - Kay) > 1):  # Liskov is not adjacent to Kay\n            return [Hopper, Kay, Liskov, Perlis, Ritchie]\n    \n    return None  # Return None if no valid solution is found", "funcname": "main_solution", "ios": [{"input": {"floors": [2, 3, 5, 4, 1]}, "output": [2, 3, 5, 4, 1]}, {"input": {"floors": [1, 2, 5, 4, 3]}, "output": [1, 2, 5, 4, 3]}, {"input": {"floors": [1, 4, 5, 3, 2]}, "output": [1, 3, 5, 4, 2]}, {"input": {"floors": [5, 3, 4, 1, 2]}, "output": [5, 1, 4, 3, 2]}, {"input": {"floors": [4, 1, 3, 2, 5]}, "output": [4, 1, 3, 2, 5]}, {"input": {"floors": [3, 1, 2, 4, 5]}, "output": [3, 1, 4, 5, 2]}, {"input": {"floors": [5, 3, 2, 1, 4]}, "output": [2, 3, 1, 5, 4]}, {"input": {"floors": [1, 5, 4, 2, 3]}, "output": [1, 2, 5, 4, 3]}, {"input": {"floors": [2, 3, 1, 5, 4]}, "output": [2, 3, 1, 5, 4]}, {"input": {"floors": [2, 1, 5, 3, 4]}, "output": [2, 1, 5, 4, 3]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "foryourselfand/udacity_cs212_design_of_computer_programs", "path": "/src/lesson_6_7_actual_2/floor_puzzle/floor_puzzle.py", "msgidx": 14012}}
{"problem_description": "In a game of chess, a knight is a piece that can move in an L-shape pattern. Given the position of a knight on a standard 8 \u00d7 8 chessboard, how many different valid moves can the knight perform? A valid move is one that keeps the knight within the boundaries of the chessboard.", "io_requirements": "Input:\n  `cell` (str): A string consisting of 2 characters representing the coordinates of the knight on an 8 \u00d7 8 chessboard in chess notation. The first character is a letter between 'a' and 'h', and the second character is a digit between '1' and '8'.\n\nOutput:\n  `return` (int): An integer representing the number of different moves the knight can perform from the given cell.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(cell):\n    # Convert cell to numeric (x, y) coordinate\n    letters = 'abcdefgh'\n    cell_to_num = {letters[idx]: idx + 1 for idx in range(len(letters))}\n    cell = np.array([cell_to_num[cell[0]], int(cell[1])])\n    \n    # Knight's potential moves will update the cell with cell[0]+=2 and cell[1]-=1 for 8 possible moves\n    potential_moves = [\n        [2, 1], [2, -1],\n        [-2, 1], [-2, -1],\n        [1, 2], [1, -2],\n        [-1, 2], [-1, -2]\n    ]\n    \n    # Record whether the knight will be on or off the board after each potential move\n    end_cells = [cell + move for move in potential_moves]\n    valid_end_cells = sum([True for position in end_cells if 1 <= position[0] <= 8 and 1 <= position[1] <= 8])\n    \n    # Return the number of valid moves\n    return valid_end_cells", "funcname": "main_solution", "ios": [{"input": {"cell": "g2"}, "output": 4}, {"input": {"cell": "b1"}, "output": 3}, {"input": {"cell": "a8"}, "output": 2}, {"input": {"cell": "h8"}, "output": 2}, {"input": {"cell": "b3"}, "output": 6}, {"input": {"cell": "c7"}, "output": 6}, {"input": {"cell": "e1"}, "output": 4}, {"input": {"cell": "c6"}, "output": 8}, {"input": {"cell": "c8"}, "output": 4}, {"input": {"cell": "e7"}, "output": 6}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "LPRowe/coding-interview-practice", "path": "/old_practice_problems/arcade/intro-problems/medium/chessKnight.py", "msgidx": 14329}}
{"problem_description": "Given a grid represented by a matrix of 0s and 1s, where 0 represents an empty space and 1 represents a wall, how many distinct paths are there to move from the top-left corner to the bottom-right corner, given that you can only move right or down? The top-left and bottom-right corners are always empty spaces.", "io_requirements": "Input:\n  `matrix_str` (str): A JSON string representing a 2D list of integers (0s and 1s). Each element in the list represents a row in the matrix.\n\nOutput:\n  `return` (int): The number of ways to move from the top-left corner to the bottom-right corner of the matrix, where only right and down movements are allowed.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\ndef waysThroughMatrix(matrix, start=(0, 0)):\n    \"\"\"Return the number of ways to move through the matrix.\"\"\"\n    if (start[0] == len(matrix)-1 and start[1] >= len(matrix[0])-2) or\\\n       (start[0] >= len(matrix)-2 and start[1] == len(matrix[0])-1):\n        return 1\n    counter = 0\n    if start[0] + 1 < len(matrix) and matrix[start[0]+1][start[1]] == 0:\n        counter += waysThroughMatrix(matrix, (start[0]+1, start[1]))\n    if start[1] + 1 < len(matrix[0]) and matrix[start[0]][start[1]+1] == 0:\n        counter += waysThroughMatrix(matrix, (start[0], start[1]+1))\n    return counter\n\n# main function\ndef main_solution(matrix_str):\n    # Convert the JSON string to a list of lists\n    matrix = json.loads(matrix_str)\n    \n    # Call the original function with the converted matrix\n    result = waysThroughMatrix(matrix)\n    \n    # Return the result as an integer\n    return result", "funcname": "main_solution", "ios": [{"input": {"matrix_str": "[[0, 0, 1], [1, 1, 1], [0, 1, 1], [1, 0, 0]]"}, "output": 0}, {"input": {"matrix_str": "[[0, 0], [1, 0]]"}, "output": 1}, {"input": {"matrix_str": "[[0, 1], [0, 0]]"}, "output": 1}, {"input": {"matrix_str": "[[0, 0, 0], [1, 0, 1], [0, 1, 0], [0, 1, 0], [0, 1, 0]]"}, "output": 0}, {"input": {"matrix_str": "[[0, 0], [1, 0], [0, 0], [0, 0], [1, 0]]"}, "output": 1}, {"input": {"matrix_str": "[[0, 1, 1, 0, 1], [0, 0, 0, 1, 0]]"}, "output": 0}, {"input": {"matrix_str": "[[0, 0, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 1, 1, 0]]"}, "output": 0}, {"input": {"matrix_str": "[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]"}, "output": 5}, {"input": {"matrix_str": "[[0, 0, 0, 1], [1, 0, 1, 1], [1, 0, 1, 1], [1, 1, 1, 0]]"}, "output": 0}, {"input": {"matrix_str": "[[0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]]"}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "BaoCaiH/Daily_Coding_Problem", "path": "/Python/2019_06_22_Problem_158_Ways_Through_Matrix.py", "msgidx": 14054}}
{"problem_description": "Given a number of pairs of parentheses, how can we generate all possible valid combinations of these parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses. It should be a positive integer.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def generateParenthesis(self, n):\n        res = []\n        cur_str = ''\n\n        def dfs(cur_str, left, right):\n            '''\n            :param cur_str: \u4ece\u6839\u7ed3\u70b9\u5230\u53f6\u5b50\u7ed3\u70b9\u7684\u8def\u5f84\u5b57\u7b26\u4e32\n            :param left: \u5de6\u62ec\u53f7\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7684\u4e2a\u6570\n            :param right: \u53f3\u62ec\u53f7\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7684\u4e2a\u6570\n            '''\n            #\u9012\u5f52\u7ec8\u6b62\u6761\u4ef6\n            if left == 0 and right == 0:\n                res.append(cur_str)\n                return\n            # \u526a\u679d\u6761\u4ef6\n            # \u82e5\u6240\u5269\u53f3\u62ec\u53f7xiao\u4e8e\u5de6\u62ec\u53f7 \u5219\u8bf4\u660e\u5148\u4f7f\u7528\u7684\u53f3 \u4e0d\u5408\u6cd5\n            if right < left:\n                return\n            # \u53ea\u6709\u8fd8\u6709\u5de6\u62ec\u53f7\u5c31\u5148\u7528\u5de6\n            if left > 0:\n                dfs(cur_str + '(', left-1, right)\n            if right > 0:\n                dfs(cur_str+')', left, right-1)\n        dfs(cur_str, n, n)\n        return res\n\n# main function\ndef main_solution(n):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  solution = Solution()\n  result = solution.generateParenthesis(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "yearing1017/Algorithm_Note", "path": "/\u7a0b\u5e8f\u5458\u4ee3\u7801\u9762\u8bd5\u6307\u5357-\u5de6\u7a0b\u4e91/\u5176\u4ed6\u9898\u76ee/khsc.py", "msgidx": 13952}}
{"problem_description": "Given a range of characters from 'a' to 'z', what are all possible password combinations in increasing order of length, up to a specified maximum length?", "io_requirements": "Input:\n  `start` (int): The ASCII value of the starting character (inclusive) for generating password combinations.\n  `end` (int): The ASCII value of the ending character (inclusive) for generating password combinations.\n  `max_length` (int): The maximum length of the password combinations to generate.\n\nOutput:\n  `return` (list of strings): A list of all possible password combinations in increasing order of length, up to the specified `max_length`.", "refcode": "# import necessary packages\nfrom time import sleep\n\n# all class and function definitions in the code file, if any\ndef initialiser(start, end):\n    list_combinations = []\n    for i in range(start, end + 1):\n        list_combinations.append(chr(i))\n    return list_combinations\n\ndef generate_combinations(list_combinations, start, end, curr_length):\n    new_combinations = []\n    for i in range(len(list_combinations)):\n        for j in range(start, end + 1):\n            new_combo = list_combinations[i] + chr(j)\n            new_combinations.append(new_combo)\n    curr_length += 1\n    return new_combinations, curr_length\n\n# main function\ndef main_solution(start, end, max_length):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    start = int(start)\n    end = int(end)\n    max_length = int(max_length)\n    \n    list_combinations = initialiser(start, end)\n    curr_length = 1\n    \n    while curr_length < max_length:\n        list_combinations, curr_length = generate_combinations(list_combinations, start, end, curr_length)\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return list_combinations", "funcname": "main_solution", "ios": [{"input": {"start": 112, "end": 112, "max_length": 4}, "output": ["pppp"]}, {"input": {"start": 112, "end": 112, "max_length": 2}, "output": ["pp"]}, {"input": {"start": 117, "end": 117, "max_length": 3}, "output": ["uuu"]}, {"input": {"start": 119, "end": 119, "max_length": 3}, "output": ["www"]}, {"input": {"start": 120, "end": 120, "max_length": 5}, "output": ["xxxxx"]}, {"input": {"start": 106, "end": 108, "max_length": 2}, "output": ["jj", "jk", "jl", "kj", "kk", "kl", "lj", "lk", "ll"]}, {"input": {"start": 98, "end": 98, "max_length": 2}, "output": ["bb"]}, {"input": {"start": 119, "end": 120, "max_length": 2}, "output": ["ww", "wx", "xw", "xx"]}, {"input": {"start": 121, "end": 121, "max_length": 4}, "output": ["yyyy"]}, {"input": {"start": 122, "end": 122, "max_length": 4}, "output": ["zzzz"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "nahimilega/Password-brute-forcing", "path": "/r+i_passwd_bruteforcee.py", "msgidx": 13730}}
{"problem_description": "You are organizing a party where attendees will be seated around a circular table. The seating arrangement must alternate between boys and girls, starting with the HOST and ending with the HOSTESS, who should be directly across from the HOST. Given the list of attendees and their genders, what is the seating plan that meets these criteria, starting with \"HOST\" and proceeding clockwise? If no valid seating plan is possible, the result should be an empty list.", "io_requirements": "Input:\n  `attendees` (list of dictionaries): A list of dictionaries where each dictionary represents an attendee. Each dictionary has two keys:\n    - `name` (string): The name of the attendee.\n    - `gender` (string): The gender of the attendee, which can be either \"boy\" or \"girl\".\n\nOutput:\n  `return` (list of strings): A list representing the seating plan around the table, starting with \"HOST\" and proceeding clockwise. Each element in the list is a string representing the name of the person seated at that position. If no valid seating plan is possible, the list will be empty.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass PartySeats(object):\n    def seating(self, attendees):\n        all_boys = [a.split(\" \")[0] for a in attendees if(\"boy\"==a[-3:])]\n        all_boys.sort()\n        all_girls = [a.split(\" \")[0] for a in attendees if(\"girl\"==a[-4:])]\n        all_girls.sort()\n        output_order = [\"HOST\"]\n\n        if(len(all_boys)!=len(all_girls)):\n            return tuple()\n\n        num_attendees = len(attendees)\n\n        last_boy = True\n        while(all_girls):\n            if(num_attendees/2!=len(output_order)-1):\n                if(last_boy):\n                    output_order.append(all_girls.pop(0))\n                    last_boy = False\n                else:\n                    output_order.append(all_boys.pop(0))\n                    last_boy = True\n            else:\n                output_order.append(\"HOSTESS\")\n                last_boy = False\n        if(all_boys or all_girls):\n            return tuple()\n\n        return tuple(output_order)\n\n# main function\ndef main_solution(attendees):\n    # Convert JSON serializable input to the original input format\n    attendees = [attendee[\"name\"] + \" \" + attendee[\"gender\"] for attendee in attendees]\n    \n    # Invoke the original function\n    party_seats = PartySeats()\n    seating_plan = party_seats.seating(attendees)\n    \n    # Convert the output to JSON serializable format\n    seating_plan = list(seating_plan)\n    \n    return seating_plan", "funcname": "main_solution", "ios": [{"input": {"attendees": [{"name": "Person1", "gender": "boy"}, {"name": "Person2", "gender": "boy"}]}, "output": []}, {"input": {"attendees": [{"name": "Person1", "gender": "girl"}, {"name": "Person2", "gender": "girl"}]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Gendo90/topCoder", "path": "/400-600 pts/topcoderPartySeats.py", "msgidx": 14066}}
{"problem_description": "Given a list of digits from 0 to 9, what is the sum of all possible pandigital numbers that can be formed using these digits, such that each number has a sub-string divisibility property where the substring formed by the 2nd to 4th, 3rd to 5th, ..., 8th to 10th digits are divisible by the prime numbers 2, 3, 5, 7, 11, 13, and 17 respectively?", "io_requirements": "Input:\n  `digits` (list of int): A list of integers representing the digits from 0 to 9.\n\nOutput:\n  `return` (int): The sum of all 0 to 9 pandigital numbers that satisfy the sub-string divisibility property.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(digits):\n    \"\"\"\n    Finds the sum of all 0 to 9 pandigital numbers that satisfy the sub-string divisibility property.\n\n    Args:\n        digits (list of int): A list of digits from 0 to 9.\n\n    Returns:\n        int: The sum of all 0 to 9 pandigital numbers with the sub-string divisibility property.\n    \"\"\"\n    def is_substring_divisible(num_str):\n        primes = [2, 3, 5, 7, 11, 13, 17]\n        for i in range(7):\n            if int(num_str[i+1:i+4]) % primes[i] != 0:\n                return False\n        return True\n\n    pandigital_numbers = [''.join(p) for p in itertools.permutations(map(str, digits))]\n    valid_pandigitals = [int(num) for num in pandigital_numbers if is_substring_divisible(num)]\n    \n    return sum(valid_pandigitals)", "funcname": "main_solution", "ios": [{"input": {"digits": [3, 7, 9, 6, 0, 4, 2, 5, 8, 1]}, "output": 16695334890}, {"input": {"digits": [0, 6, 8, 9, 4, 3, 5, 1, 2, 7]}, "output": 16695334890}, {"input": {"digits": [6, 9, 3, 5, 1, 7, 8, 0, 4, 2]}, "output": 16695334890}, {"input": {"digits": [0, 5, 3, 9, 7, 1, 4, 2, 6, 8]}, "output": 16695334890}, {"input": {"digits": [9, 4, 2, 5, 1, 7, 0, 3, 8, 6]}, "output": 16695334890}, {"input": {"digits": [4, 2, 7, 1, 3, 8, 6, 5, 0, 9]}, "output": 16695334890}, {"input": {"digits": [1, 0, 4, 8, 6, 5, 3, 2, 9, 7]}, "output": 16695334890}, {"input": {"digits": [1, 4, 7, 6, 0, 9, 8, 3, 2, 5]}, "output": 16695334890}, {"input": {"digits": [3, 4, 6, 0, 2, 7, 5, 1, 8, 9]}, "output": 16695334890}, {"input": {"digits": [5, 1, 7, 6, 9, 8, 4, 3, 2, 0]}, "output": 16695334890}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "skinnerjake/Portfolio", "path": "/Python/ProjectEuler/Problem43.py", "msgidx": 13447}}
{"problem_description": "Given a sequence of integers, determine if it represents the post-order traversal of a Binary Search Tree (BST). What is the result indicating whether the sequence is a valid post-order traversal of a BST?", "io_requirements": "Input:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string indicating whether the input sequence is a valid post-order traversal of a BST. The possible values are \"Yes\" or \"No\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if not sequence:\n            return False\n        root = sequence[-1] \n        for i in range(len(sequence)):\n            if sequence[i] > root:\n                break\n        for j in sequence[i:-1]:\n            if j < root:\n                return False\n        \n        left = True\n        right = True\n        if i > 0:\n            left = self.VerifySquenceOfBST(sequence[:i])\n        if i < len(sequence)-1:\n            right = self.VerifySquenceOfBST(sequence[i:-1])\n        return left and right\n\n# main function\ndef main_solution(sequence):\n    # Convert the input list to a JSON serializable format\n    sequence = list(sequence)\n    \n    # Create an instance of the Solution class\n    s = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = s.VerifySquenceOfBST(sequence)\n    \n    # Convert the result to a JSON serializable format\n    return \"Yes\" if result else \"No\"", "funcname": "main_solution", "ios": [{"input": {"sequence": [3, 5, 6, 7]}, "output": "Yes"}, {"input": {"sequence": [15, 13, 17, 19]}, "output": "Yes"}, {"input": {"sequence": [13, 9, 10, 12, 6, 14, 11, 15, 5]}, "output": "No"}, {"input": {"sequence": [18, 6, 11, 4]}, "output": "No"}, {"input": {"sequence": [1, 12, 18, 8, 5]}, "output": "Yes"}, {"input": {"sequence": [13, 7]}, "output": "Yes"}, {"input": {"sequence": [6, 15, 4, 5]}, "output": "No"}, {"input": {"sequence": [5, 19, 4, 12, 13, 6, 17]}, "output": "No"}, {"input": {"sequence": [12, 2, 3, 17]}, "output": "No"}, {"input": {"sequence": [17, 8]}, "output": "Yes"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "jianfengyuan/LeetCode_practice", "path": "/practice/VerifySquenceOfBST.py", "msgidx": 13992}}
{"problem_description": "Given a list of words, each word starts with a character and ends with another character. These characters can be thought of as vertices in a graph. The task is to determine if there exists a cycle in the graph formed by these words. A cycle in the graph means that starting from any vertex, one can traverse the graph and return to the starting vertex. What is the result indicating the presence of a cycle in the graph?", "io_requirements": "Input:\n  `words_list` (list of strings): A list of words where each word is a string. The first character of each word represents a vertex, and the last character of each word represents another vertex. The graph is constructed based on these words.\n\nOutput:\n  `return` (boolean): A boolean value indicating whether a cycle exists in the graph constructed from the words. `True` if a cycle exists, `False` otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass Vertex:\n    def __init__(self, value, visited):\n        self.value = value\n        self.visited = visited\n        self.adj_vertices = []\n        self.in_vertices = []\n\nclass Graph:\n    def __init__(self, g):\n        self.g = g\n\n    def create_graph(self, words_list):\n        for i in range(len(words_list)):\n            word = words_list[i]\n            start_char = word[0]\n            end_char = word[len(word) - 1]\n\n            start = self.vertex_exists(start_char)\n            if start is None:\n                start = Vertex(start_char, False)\n                self.g.append(start)\n\n            end = self.vertex_exists(end_char)\n            if end is None:\n                end = Vertex(end_char, False)\n                self.g.append(end)\n\n            self.add_edge(start, end)\n\n    def vertex_exists(self, value):\n        for i in range(len(self.g)):\n            if self.g[i].value == value:\n                return self.g[i]\n        return None\n\n    def all_visited(self):\n        for i in range(len(self.g)):\n            if self.g[i].visited is False:\n                return False\n        return True\n\n    def add_edge(self, start, end):\n        start.adj_vertices.append(end)\n        end.in_vertices.append(start)\n\n    def out_equals_in(self):\n        for i in range(len(self.g)):\n            out = len(self.g[i].adj_vertices)\n            inn = len(self.g[i].in_vertices)\n            if out != inn:\n                return False\n        return True\n\n    def check_cycle_rec(self, node, starting_node):\n        node.visited = True\n        adj = node.adj_vertices\n\n        if self.all_visited():\n            for i in range(len(adj)):\n                if adj[i] == starting_node:\n                    return True\n\n        for i in range(len(adj)):\n            if adj[i].visited is False:\n                node = adj[i]\n                if self.check_cycle_rec(node, starting_node):\n                    return True\n\n        return False\n\n    def check_cycle(self, list_size):\n        if list_size < 2:\n            return False\n        if len(self.g) > 0:\n            if self.out_equals_in():\n                return self.check_cycle_rec(self.g[0], self.g[0])\n        return False\n\n# main function\ndef main_solution(words_list):\n    # Convert JSON serializable input to original input variables\n    graph_instance = Graph([])\n    graph_instance.create_graph(words_list)\n    \n    # Perform the core logic\n    result = graph_instance.check_cycle(len(words_list))\n    \n    # Convert the result to JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"words_list": ["vavfbr", "yru", "wrf", "aobew"]}, "output": false}, {"input": {"words_list": ["saw", "jgxjbzh", "jimd", "tdrmv"]}, "output": false}, {"input": {"words_list": ["waq", "gxvck"]}, "output": false}, {"input": {"words_list": ["svmxvt", "guyq", "gqc", "rwggsc", "mubzhx", "gpqit", "gojhk", "gwmows", "wbvmkus", "dcbfbd"]}, "output": false}, {"input": {"words_list": ["qbrtg", "otown", "bes", "rnq", "ecghnsl", "tztwpe"]}, "output": false}, {"input": {"words_list": ["ymr", "jdi", "iuos", "siecnws"]}, "output": false}, {"input": {"words_list": ["vwdpa", "hmmzja", "dxxjwh", "rtaoek", "vvwroih"]}, "output": false}, {"input": {"words_list": ["pjsh", "jivhy", "tawoogm", "hyhmn"]}, "output": false}, {"input": {"words_list": ["iyjhdj", "jvad", "hjw", "aanvv", "rvzwupc"]}, "output": false}, {"input": {"words_list": ["xtc", "lckjmxf", "fgahxf", "oxhl", "alzdl"]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "tuananh8497/technical-interview-prep", "path": "/Python-Programming/Graph/Word-Chain.py", "msgidx": 13478}}
{"problem_description": "Given a number of pairs of parentheses, how can we generate all possible valid sequences where each sequence contains exactly that number of pairs of parentheses?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses to generate valid sequences for.\n\nOutput:\n  `return` (list of str): A list of strings where each string is a valid sequence of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef generateParantheses(n: int) -> list:\n  ans = []\n  def backtrack(S = '', left = 0, right = 0):\n    if len(S) == 2 * n:\n      ans.append(S)\n      return\n    if left < n:\n      backtrack(S + '(', left + 1, right)\n    if right < left:\n      backtrack(S + ')', left, right + 1)\n  if n >= 0:\n    backtrack()\n  return ans\n\n# main function\ndef main_solution(n: int):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  result = generateParantheses(n)\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return result", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 1}, "output": ["()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sashaobucina/interview_prep", "path": "/python/medium/generate_parantheses.py", "msgidx": 14636}}
{"problem_description": "Given two sets of digits, `d1_range` and `d2_range`, each containing unique digits from 1 to 9, find the sum of all unique products `p` such that:\n1. `p` is the product of two numbers formed by the digits in `d1_range` and `d2_range`.\n2. The product `p` must be a four-digit number.\n3. The digits used in forming the product `p` must be unique and not include any digits from `d1_range` or `d2_range` that have already been used.\n\nWhat is the sum of all such unique products?", "io_requirements": "Input:\n  `d1_range` (list of int): A list of integers representing the possible values for the first digit (d1) of the first factor.\n  `d2_range` (list of int): A list of integers representing the possible values for the first digit (d2) of the second factor.\n\nOutput:\n  `return` (int): The sum of all unique products that satisfy the given conditions.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(d1_range, d2_range):\n    results = []\n    for d1 in d1_range:\n        digits = list(range(1, 10))\n        digits.remove(d1)\n        for d2 in d2_range:\n            if d2 in digits:\n                digits2 = list(digits)\n                digits2.remove(d2)\n                d3 = int(str(d1 * d2)[-1])\n                if d3 in digits2:\n                    digits2.remove(d3)\n                    for d4, d5, d6, d7, d8, d9 in itertools.permutations(digits2):\n                        p = d7 * 10**3 + d8 * 10**2 + d9 * 10 + d3\n                        if p == (d4 * 10**3 + d5 * 10**2 + d6 * 10 + d1) * d2 or \\\n                           p == (d4 * 10**2 + d5 * 10 + d1) * (d6 * 10 + d2):\n                            if p not in results:\n                                results.append(p)\n    return sum(results)", "funcname": "main_solution", "ios": [{"input": {"d1_range": [2, 3, 1, 4, 6, 8, 7, 5], "d2_range": [6, 5, 2, 7, 4]}, "output": 25946}, {"input": {"d1_range": [8, 2, 6], "d2_range": [5, 4, 1, 6]}, "output": 6952}, {"input": {"d1_range": [6, 8, 7, 1, 3, 9], "d2_range": [5, 6, 8, 4, 9, 2, 7]}, "output": 45228}, {"input": {"d1_range": [6, 3, 2, 7], "d2_range": [8, 1, 6, 2]}, "output": 15538}, {"input": {"d1_range": [5, 9, 6, 3, 7, 8, 1], "d2_range": [3, 4, 5, 7, 2, 8]}, "output": 37974}, {"input": {"d1_range": [7, 9, 3, 4, 1, 6, 5, 2, 8], "d2_range": [9, 3, 4, 7, 5, 6]}, "output": 27404}, {"input": {"d1_range": [2, 6, 8, 1, 9, 5, 7], "d2_range": [9, 8, 4, 2, 3]}, "output": 37376}, {"input": {"d1_range": [7, 1, 2, 8, 4, 9], "d2_range": [5, 6, 7, 8]}, "output": 17374}, {"input": {"d1_range": [2, 6, 8, 7, 4, 1, 9, 5], "d2_range": [8, 6, 9]}, "output": 24628}, {"input": {"d1_range": [4, 1, 8, 7, 9, 5, 2, 3, 6], "d2_range": [2, 9, 1, 5, 4, 8, 6, 3, 7]}, "output": 45228}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sebdiem/euler", "path": "/32.py", "msgidx": 14267}}
{"problem_description": "Given a range of numbers and a step size, determine the largest pandigital number that can be formed by concatenating the products of each number in the range with integers from 1 to 9. A pandigital number contains each digit from 1 to 9 exactly once. What is the largest pandigital number within the specified range?", "io_requirements": "Input:\n  `start_range` (int): The starting number of the range to check for pandigital numbers.\n  `end_range` (int): The ending number of the range to check for pandigital numbers.\n  `step` (int): The step size for iterating through the range.\n\nOutput:\n  `return` (str): The largest pandigital number found within the specified range.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef Is_Pandigital(Number):\n    Numbers = \"123456789\"\n    return not Numbers[:len(str(Number))].strip(str(Number))\n\n# main function\ndef main_solution(start_range, end_range, step):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    Largest = 0\n    for i in range(start_range, end_range, step):\n        Number = \"\"\n        for j in range(1, 10):\n            Number += str(i * j)\n            if len(Number) == 9:\n                if Is_Pandigital(int(Number)):\n                    if Number > Largest:\n                        Largest = Number\n                    break\n            elif len(Number) > 9:\n                break\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return Largest", "funcname": "main_solution", "ios": [{"input": {"start_range": 6179, "end_range": 3367, "step": 1}, "output": 0}, {"input": {"start_range": 6871, "end_range": 4721, "step": 10}, "output": 0}, {"input": {"start_range": 4787, "end_range": 2309, "step": 2}, "output": 0}, {"input": {"start_range": 6131, "end_range": 639, "step": 3}, "output": 0}, {"input": {"start_range": 9648, "end_range": 5284, "step": 5}, "output": 0}, {"input": {"start_range": 1585, "end_range": 1024, "step": 3}, "output": 0}, {"input": {"start_range": 4815, "end_range": 1425, "step": 1}, "output": 0}, {"input": {"start_range": 6133, "end_range": 4322, "step": 4}, "output": 0}, {"input": {"start_range": 7409, "end_range": 5675, "step": 10}, "output": 0}, {"input": {"start_range": 4359, "end_range": 4188, "step": 7}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Harmon758/Project-Euler", "path": "/038 - Pandigital multiples/Project_Euler_038_001.py", "msgidx": 13649}}
{"problem_description": "Given a digital logic circuit, you need to determine the output of a specific logic gate for two binary inputs. What will be the output of the gate when the first input is `input1` and the second input is `input2` for the given `gate_type`?", "io_requirements": "Input:\n  `gate_type` (str): The type of logic gate to be evaluated. Possible values are \"AND\", \"NAND\", \"OR\", and \"XOR\".\n  `input1` (int): The first input value for the logic gate. It should be either 0 or 1.\n  `input2` (int): The second input value for the logic gate. It should be either 0 or 1.\n\nOutput:\n  `return` (int): The output of the specified logic gate. It will be either 0 or 1.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef AND(x1, x2):  \n    x = np.array([x1, x2])\n    w = np.array([0.5, 0.5])\n    b = -0.7\n    y = np.sum(w * x) + b \n    if y <= 0:\n        return 0\n    elif y > 0:\n        return 1\n\ndef NAND(x1, x2):  \n    x = np.array([x1, x2])\n    w = np.array([-0.5, -0.5])\n    b = 0.7\n    y = np.sum(w * x) + b \n    if y <= 0:\n        return 0\n    elif y > 0:\n        return 1\n\ndef OR(x1, x2):  \n    x = np.array([x1, x2])\n    w = np.array([0.5, 0.5])\n    b = -0.2\n    y = np.sum(w * x) + b \n    if y <= 0:\n        return 0\n    elif y > 0:\n        return 1\n\ndef XOR(x1, x2):\n    s1 = NAND(x1, x2)\n    s2 = OR(x1, x2)\n    y = AND(s1, s2)\n    return y\n\n# main function\ndef main_solution(gate_type, input1, input2):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # Convert JSON serializable inputs to the original input variables if necessary\n    if gate_type == \"AND\":\n        result = AND(input1, input2)\n    elif gate_type == \"NAND\":\n        result = NAND(input1, input2)\n    elif gate_type == \"OR\":\n        result = OR(input1, input2)\n    elif gate_type == \"XOR\":\n        result = XOR(input1, input2)\n    else:\n        raise ValueError(\"Invalid gate type\")\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"gate_type": "OR", "input1": 1, "input2": 1}, "output": 1}, {"input": {"gate_type": "OR", "input1": 0, "input2": 0}, "output": 0}, {"input": {"gate_type": "AND", "input1": 1, "input2": 0}, "output": 0}, {"input": {"gate_type": "AND", "input1": 0, "input2": 0}, "output": 0}, {"input": {"gate_type": "NAND", "input1": 1, "input2": 0}, "output": 1}, {"input": {"gate_type": "XOR", "input1": 1, "input2": 0}, "output": 1}, {"input": {"gate_type": "OR", "input1": 0, "input2": 1}, "output": 1}, {"input": {"gate_type": "NAND", "input1": 0, "input2": 1}, "output": 1}, {"input": {"gate_type": "AND", "input1": 1, "input2": 1}, "output": 1}, {"input": {"gate_type": "XOR", "input1": 0, "input2": 1}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "shoddyjing/DL", "path": "/perceptron.py", "msgidx": 14025}}
{"problem_description": "Given a chessboard of size n x n, how many distinct ways can you place n queens on the board such that no two queens threaten each other?", "io_requirements": "Input:\n  `n` (int): The number of queens and the size of the chessboard (n x n).\n\nOutput:\n  `return` (int): The number of distinct solutions to the n-queens problem.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# main function\ndef main_solution(n):\n    columns = list(range(n))\n    count = 0\n    for pos in permutations(columns):\n        if n == len(set(pos[i] - i for i in columns)) and n == len(set(pos[i] + i for i in columns)):\n            count += 1\n    return count", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": 2}, {"input": {"n": 7}, "output": 40}, {"input": {"n": 1}, "output": 1}, {"input": {"n": 3}, "output": 0}, {"input": {"n": 8}, "output": 92}, {"input": {"n": 10}, "output": 724}, {"input": {"n": 6}, "output": 4}, {"input": {"n": 5}, "output": 10}, {"input": {"n": 9}, "output": 352}, {"input": {"n": 2}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chelseavalentine/Courses", "path": "/Intro-Programming/[16]EightQueens.py", "msgidx": 14374}}
{"problem_description": "Given a number of pairs of parentheses, what are all the possible valid combinations where each combination is properly opened and closed?", "io_requirements": "Input:\n  `n` (int): The number of pairs of parentheses.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents a valid combination of `n` pairs of parentheses.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef valid_paran(leftrem, rightrem, pairs, s):\n    if leftrem == 0 and rightrem == 0:\n        pairs.append(s)\n\n    if rightrem < leftrem or leftrem < 0:\n        return\n\n    valid_paran(leftrem - 1, rightrem, pairs, s + '(')\n    valid_paran(leftrem, rightrem - 1, pairs, s + ')')\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    leftrem = n\n    rightrem = n\n    pairs = []\n    valid_paran(leftrem, rightrem, pairs, '')\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return pairs", "funcname": "main_solution", "ios": [{"input": {"n": 3}, "output": ["((()))", "(()())", "(())()", "()(())", "()()()"]}, {"input": {"n": 2}, "output": ["(())", "()()"]}, {"input": {"n": 1}, "output": ["()"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vijaygirish2001/Interview_prep_algo_ds_Python", "path": "/CTC_problems/Recursion and dynamic programming/q9.py", "msgidx": 13943}}
{"problem_description": "Given a number in a spiral sequence, what is the Manhattan distance from that number to the center of the spiral? The spiral sequence starts at 1 and grows outward in a square pattern, with each layer increasing by 2 steps in each direction. The target number is provided as input.", "io_requirements": "Input:\n  `target` (int): The target number in the spiral sequence for which the Manhattan distance needs to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the key `manhattan_distance` with the value being the Manhattan distance from the target number to the center of the spiral.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(target):\n    # Convert the target to an integer if it's not already\n    target = int(target)\n    \n    # 0. Initial state\n    step    = 1\n    value   = 0\n    offset  = -1\n    lap     = 0\n    running = True\n    right_turns        = 0\n    manhattan_distance = 0\n\n    while running:\n        for i in range(step * 2):\n            # STOP - if we have found the target\n            if value >= target:\n                running = False\n                break\n\n            value  += 1\n            offset += 1\n            offset_step = offset % step\n            mid = step // 2\n\n            # If right turn\n            if offset_step == 0: \n                right_turns += 1\n\n                # If new lap (every 4th right turn)\n                if (right_turns + 2) % 4 == 0:\n                    lap += 1\n\n            distance_mid       = abs(offset_step - mid)\n            distance_center    = lap\n            manhattan_distance = distance_mid + distance_center\n\n        step   +=  1\n        offset  = -1\n\n    # Return the manhattan distance as a dictionary\n    return {\"manhattan_distance\": manhattan_distance}", "funcname": "main_solution", "ios": [{"input": {"target": 970179}, "output": {"manhattan_distance": 938}}, {"input": {"target": 89395}, "output": {"manhattan_distance": 292}}, {"input": {"target": 142337}, "output": {"manhattan_distance": 208}}, {"input": {"target": 574264}, "output": {"manhattan_distance": 457}}, {"input": {"target": 769948}, "output": {"manhattan_distance": 819}}, {"input": {"target": 256244}, "output": {"manhattan_distance": 299}}, {"input": {"target": 681761}, "output": {"manhattan_distance": 516}}, {"input": {"target": 569676}, "output": {"manhattan_distance": 405}}, {"input": {"target": 843290}, "output": {"manhattan_distance": 565}}, {"input": {"target": 305688}, "output": {"manhattan_distance": 431}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Arxcis/adventofcode17", "path": "/day03.py", "msgidx": 14082}}
{"problem_description": "In a space station, you need to distract the bunny trainers by setting up thumb wrestling matches. Each trainer starts with a certain number of bananas, and they bet all their bananas in each round. The trainer with more bananas always loses, and the matches continue until both trainers have the same number of bananas. Your task is to pair up the trainers in such a way that the maximum number of trainers go into an infinite thumb wrestling loop. Given the list of bananas each trainer starts with, how many trainers will be left to watch the workers after the optimal pairing?", "io_requirements": "Input:\n  `banana_list` (list of integers): A list of positive integers representing the number of bananas each trainer starts with. The length of the list will be at least 1 and not more than 100. Each integer in the list will be a positive number no more than 1073741823.\n\nOutput:\n  `return` (integer): The fewest possible number of bunny trainers that will be left to watch the workers after pairing them in such a way that the maximum number of trainers go into an infinite thumb wrestling loop.", "refcode": "# import necessary packages\nfrom scipy.optimize import linear_sum_assignment\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef findLoop(n, m):\n    if (n == m or n == -1 or m == -1): return 1     # This is not allowed  \n    x = bin(n + m)[2:]\n    y = x.rstrip(\"0\")\n    k = int(len(x) - len(y))\n    N = int(y, 2)\n    if (k >= 2 and n % N == 0): return 1  # no loop = 1\n    return 0    # loop = 0\n\n# main function\ndef main_solution(banana_list):\n    # Convert input list to a JSON serializable format\n    banana_list = list(banana_list)\n    \n    # Handle odd length list by appending a placeholder\n    if (len(banana_list) % 2 == 1):\n        banana_list.append(-1)\n\n    # Create a cost matrix\n    matrix = np.empty((len(banana_list), len(banana_list)))\n    matrix.fill(0)\n\n    # Fill the cost matrix with loop/no loop values\n    for i in range(len(banana_list)):\n        for j in range(len(banana_list)):\n            matrix[i][j] = findLoop(banana_list[i], banana_list[j])\n\n    # Solve the assignment problem to find the minimum number of trainers left\n    row_ind, col_ind = linear_sum_assignment(matrix)\n    li = matrix[row_ind, col_ind]\n    \n    # Convert the result to a JSON serializable format\n    result = int(li.sum())\n    return result", "funcname": "main_solution", "ios": [{"input": {"banana_list": [254728243, 1012543257, 693995522]}, "output": 1}, {"input": {"banana_list": [880673644, 64987050, 1002397518, 376738437]}, "output": 0}, {"input": {"banana_list": [267697903, 645225862, 208608445, 148373058, 230910327, 752861773, 26967089, 473663385, 1028038719]}, "output": 1}, {"input": {"banana_list": [719050591, 127722728, 251782429, 762825397, 230117747, 572056693, 512360472, 822637649, 121457152, 266820820, 269290888]}, "output": 1}, {"input": {"banana_list": [86906706, 907845036, 356089176]}, "output": 1}, {"input": {"banana_list": [266987242, 252194552, 242187186, 918172973, 752635720, 760456364, 715121179]}, "output": 1}, {"input": {"banana_list": [1017354033]}, "output": 2}, {"input": {"banana_list": [765718901, 502294957, 967942409, 171414781, 678553706, 289161034, 573734539, 392388455, 305081944, 316969410, 542461277, 893753213, 680083661, 743749635, 869503129, 306597663]}, "output": 0}, {"input": {"banana_list": [729337496, 364013470]}, "output": 0}, {"input": {"banana_list": [834450684, 155950266, 454950116, 577752094, 314565709, 414937997, 1000202815, 1042899177, 317316446, 307954466, 851006177, 604574864, 186319693, 892864642, 329124134]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mattdasilva23/GoogleFoobar", "path": "/Level 4/lvl4_q1.py", "msgidx": 14115}}
{"problem_description": "Given a collection of sets, each containing a subset of integers, what is the minimum number of sets required to cover the entire universe of unique integers present in all sets?", "io_requirements": "Input:\n  `sets` (list of strings): Each string represents a set of integers separated by spaces. For example, `[\"1 2 3\", \"4 5\"]` represents two sets `{1, 2, 3}` and `{4, 5}`.\n\nOutput:\n  `return` (int): The minimum number of sets required to cover the entire universe. If the universe is empty, it returns `0`. If the universe can be covered with one set, it returns `1`. Otherwise, it returns the minimum number of sets needed.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\ndef gerador(sets, i):\n    return list(itertools.combinations(sets, i))\n\ndef concat(k):\n    res = []\n    for x in k:\n        res += x\n    return list(set(res))\n\ndef complete(universo, c):\n    return len(c) == len(universo)\n    \ndef valid(universo, c):\n    return sorted(c) == sorted(universo)\n    \ndef search(universo, sets):\n    c = []\n    return aux(universo, c, sets)\n\ndef aux(universo, c, sets):\n    for x in sets:\n        c = x\n        if complete(universo, c):\n            if valid(universo, c):\n                return True\n    return False\n\n# main function\ndef main_solution(sets):\n    # Convert sets to list of lists of integers\n    sets = [list(map(int, s.split())) for s in sets]\n    \n    # Calculate the universe\n    universo = []\n    for s in sets:\n        for i in s:\n            if i not in universo:\n                universo.append(i)\n    \n    # Check if the universe is empty\n    if len(universo) == 0:\n        return 0\n    \n    # Search for the solution\n    if search(sorted(universo), sets):\n        return 1\n    \n    for i in range(2, len(sets) + 1):\n        conjuntos = gerador(sets, i)\n        conjunto = []\n        for c in conjuntos:\n            conjunto.append(concat(c))\n        if sorted(universo) in conjunto:\n            return i\n    \n    return -1  # In case no solution is found, though the problem guarantees a solution", "funcname": "main_solution", "ios": [{"input": {"sets": ["3"]}, "output": 1}, {"input": {"sets": ["4 9", "10 2 1", "9 3 5"]}, "output": 3}, {"input": {"sets": ["10 9 7 3", "10 4 5 4 9"]}, "output": 2}, {"input": {"sets": ["5 1"]}, "output": 1}, {"input": {"sets": ["9 2 3 5 3", "10"]}, "output": 2}, {"input": {"sets": ["3 4", "6 10 8 4 9", "2", "5 7 3 4"]}, "output": 3}, {"input": {"sets": ["1 7 10 3", "1 1 8"]}, "output": 2}, {"input": {"sets": ["7 1", "3 3 6 3", "8 7 9 8", "1"]}, "output": 3}, {"input": {"sets": ["10 4", "1 6 6", "9 10 8", "8", "8 1 1 3"]}, "output": 4}, {"input": {"sets": ["8"]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Nelson198/LA2", "path": "/Problemas/Azul - Brute Force/X - A uni\u00e3o faz a for\u00e7a/X_v1.py", "msgidx": 14546}}
{"problem_description": "In a laboratory, there are N hourglasses, each with a unique capacity ranging from 1 to N minutes. The researchers are interested in determining how many different arrangements of these hourglasses will result in all of them emptying at the exact same time. Given the number of hourglasses N, how many such arrangements exist?", "io_requirements": "Input:\n  `N` (int): The number of hourglasses, where each hourglass has a unique capacity from 1 to N.\n\nOutput:\n  `return` (int): The number of permutations of hourglasses that will all empty at the same time.", "refcode": "# import necessary packages\nimport itertools\n\n# all class and function definitions in the code file, if any\nclass Hourglass:\n    \"\"\"\u7802\u6642\u8a08\n    \"\"\"\n    def __init__(self, minute):\n        self.capacity = self.remain = minute\n\n    def count_down(self):\n        \"\"\"1\u5206\u7d4c\u904e & \u7a7a\u306b\u306a\u3063\u305f\u3089\u901a\u77e5\n        \"\"\"\n        if self.remain > 0:\n            self.remain -= 1\n            if self.remain == 0:\n                return 1\n        return 0\n\n    def upset(self):\n        \"\"\"\u3072\u3063\u304f\u308a\u8fd4\u3059\n        \"\"\"\n        self.remain = self.capacity - self.remain\n\ndef check(pattern):\n    \"\"\"\u7802\u6642\u8a08\u304c\u540c\u6642\u306b\u843d\u3061\u308b\u304b\u30c1\u30a7\u30c3\u30af\n    \"\"\"\n    hourglasses = [Hourglass(i) for i in pattern]\n    memo = {}\n    ret = 0\n    loop = True\n    while loop:\n        # \u7802\u6642\u8a08\u3092\u4e00\u5468\u3059\u308b\n        for i in range(len(pattern)):\n            tpl = tuple([i] + [j.remain for j in hourglasses])\n            # \u78ba\u8a8d\u6e08\u307f\u306e\u72b6\u614b\u304b\n            if tpl in memo:\n                loop = False\n                break\n            else:\n                # \u4eca\u56de\u306e\u30d1\u30bf\u30fc\u30f3\u3092\u8a18\u61b6\u3059\u308b\n                memo[tpl] = True\n                # 1\u5206\u7d4c\u904e\n                cnt = sum([j.count_down() for j in hourglasses])\n                # \u3059\u3079\u3066\u306e\u7802\u304c\u540c\u6642\u306b\u843d\u3061\u305f\n                if cnt == len(hourglasses):\n                    ret = 1\n                    loop = False\n                    break\n                else:\n                    # \u3072\u3063\u304f\u308a\u8fd4\u3059\n                    for offset in range(hourglasses[i].capacity):\n                        hourglasses[(i + offset) % len(hourglasses)].upset()\n    return ret\n\n# main function\ndef main_solution(N):\n    \"\"\"\n    This function calculates the number of permutations of hourglasses that will all empty at the same time.\n    \"\"\"\n    cnt = 0\n    for ptn in itertools.permutations([i + 1 for i in range(N)]):\n        cnt += check(ptn)\n    return cnt", "funcname": "main_solution", "ios": [{"input": {"N": 4}, "output": 13}, {"input": {"N": 5}, "output": 41}, {"input": {"N": 3}, "output": 5}, {"input": {"N": 2}, "output": 2}, {"input": {"N": 6}, "output": 172}, {"input": {"N": 8}, "output": 6055}, {"input": {"N": 7}, "output": 927}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "y-tetsu/math_puzzle", "path": "/q52.py", "msgidx": 14340}}
{"problem_description": "In a game of poker, a player is dealt a hand of 5 cards. Given the hand, what is the type of the hand and the values of the cards that contribute to this type? Additionally, what are the values of the remaining cards that do not contribute to the hand type?", "io_requirements": "Input:\n  `hand_string` (str): A string representing a hand of 5 poker cards. Each card is represented by a two-character string where the first character is the card value (2-9, T, J, Q, K, A) and the second character is the suit (C, S, D, H). Cards are separated by spaces.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `hand_type` (str): The type of the hand (e.g., \"STRAIGHT_FLUSH\", \"FULL_HOUSE\", \"ONE_PAIR\").\n    - `primary_values` (list of int): A list of primary card values that contribute to the hand type.\n    - `secondary_values` (list of int): A list of secondary card values that do not contribute to the hand type.", "refcode": "# import necessary packages\nimport collections\nimport operator\nfrom enum import Enum\nfrom functools import total_ordering\n\n# all class and function definitions in the code file, if any\nclass Suit(Enum):\n  CLUBS = 1\n  SPADES = 2\n  DIAMONDS = 3\n  HEARTS = 4\n\n@total_ordering\nclass HandValue(Enum):\n  HOT_GARBAGE = 1\n  ONE_PAIR = 2\n  TWO_PAIR = 3\n  THREE_OF_A_KIND = 4\n  STRAIGHT = 5\n  FLUSH = 6\n  FULL_HOUSE = 7\n  FOUR_OF_A_KIND = 8\n  STRAIGHT_FLUSH = 9\n\n  def __eq__(self, other):\n    return self.value == other.value\n\n  def __lt__(self, other):\n    return self.value < other.value\n\nCARD_MAP = {\n  \"A\": 14,\n  \"K\": 13,\n  \"Q\": 12,\n  \"J\": 11,\n  \"T\": 10\n}\n\nSUIT_MAP = {\n  \"C\": Suit.CLUBS,\n  \"S\": Suit.SPADES,\n  \"D\": Suit.DIAMONDS,\n  \"H\": Suit.HEARTS\n}\n\n@total_ordering\nclass PokerCard(object):\n  def __init__(self, card_string):\n    self.value = CARD_MAP.get(card_string[0]) or int(card_string[0])\n    self.suit = SUIT_MAP[card_string[1]]\n\n  def __eq__(self, other):\n    return self.value == other.value\n\n  def __lt__(self, other):\n    return self.value < other.value\n\n@total_ordering\nclass PokerHand(object):\n  def __init__(self, cards):\n    self.cards = cards\n\n  def get_total_hand_value(self):\n    is_repeated_value_hand, rep = self._get_repeated_value_hand()\n    if is_repeated_value_hand:\n      return rep\n\n    max_card = max([card.value for card in self.cards])\n    min_card = min([card.value for card in self.cards])\n    is_straight = max_card - min_card == 4\n    is_flush = all(self.cards[0].suit == card.suit for card in self.cards)\n    if is_straight and is_flush:\n      return HandValue.STRAIGHT_FLUSH, (max_card,), ()\n    elif is_straight:\n      return HandValue.STRAIGHT, (max_card,), ()\n    elif is_flush:\n      return HandValue.FLUSH, tuple(sorted([card.value for card in self.cards], reverse=True)), ()\n\n    return (HandValue.HOT_GARBAGE, (), tuple(sorted([card.value for card in self.cards], reverse=True)))\n\n  def _get_repeated_value_hand(self):\n    c = collections.Counter([card.value for card in self.cards])\n    if len(c) == 5:\n      return False, ()\n    most_common = sorted(c.most_common(4), key=lambda x: (x[1], x[0]), reverse=True)\n    if len(most_common) == 2:\n      if most_common[1][1] == 2:\n        return True, (HandValue.FULL_HOUSE, (most_common[0][0], most_common[1][0]), ())\n      return True, (HandValue.FOUR_OF_A_KIND, (most_common[0][0]), (most_common[1][0],))\n\n    if len(most_common) == 3:\n      if most_common[1][1] == 1:\n        return True, (HandValue.THREE_OF_A_KIND, (most_common[0][0]), (most_common[1][0], most_common[2][0]))\n      return True, (HandValue.TWO_PAIR, (most_common[0][0], most_common[1][0]), (most_common[2][0],))\n\n    return True, (HandValue.ONE_PAIR, (most_common[0][0],), (most_common[1][0], most_common[2][0], most_common[3][0]))\n\n  def __eq__(self, other):\n    return self.get_total_hand_value() == other.get_total_hand_value()\n\n  def __lt__(self, other):\n    self_value = self.get_total_hand_value()\n    other_value = other.get_total_hand_value()\n    if self_value[0] != other_value[0]:\n      return self_value[0] < other_value[0]\n    for x, y in zip(self_value[1], other_value[1]):\n      if x != y:\n        return x < y\n    for x, y in zip(self_value[2], other_value[2]):\n      if x != y:\n        return x < y\n    return False\n\n# main function\ndef main_solution(hand_string):\n  # Convert the input string to a list of PokerCard objects\n  cards = [PokerCard(card) for card in hand_string.split()]\n  # Create a PokerHand object\n  hand = PokerHand(cards)\n  # Get the total hand value\n  hand_value = hand.get_total_hand_value()\n  # Convert the hand value to a JSON serializable format\n  return {\n    \"hand_type\": hand_value[0].name,\n    \"primary_values\": list(hand_value[1]),\n    \"secondary_values\": list(hand_value[2])\n  }", "funcname": "main_solution", "ios": [{"input": {"hand_string": "TH 2S 2C 4D 8C"}, "output": {"hand_type": "ONE_PAIR", "primary_values": [2], "secondary_values": [10, 8, 4]}}, {"input": {"hand_string": "3D 6C AH JC 7H"}, "output": {"hand_type": "HOT_GARBAGE", "primary_values": [], "secondary_values": [14, 11, 7, 6, 3]}}, {"input": {"hand_string": "AC KD 3C 7C 9S"}, "output": {"hand_type": "HOT_GARBAGE", "primary_values": [], "secondary_values": [14, 13, 9, 7, 3]}}, {"input": {"hand_string": "4H 6D 9S QH 2H"}, "output": {"hand_type": "HOT_GARBAGE", "primary_values": [], "secondary_values": [12, 9, 6, 4, 2]}}, {"input": {"hand_string": "4D JC 9H 2D 8C"}, "output": {"hand_type": "HOT_GARBAGE", "primary_values": [], "secondary_values": [11, 9, 8, 4, 2]}}, {"input": {"hand_string": "JH 6S 9C 4H KC"}, "output": {"hand_type": "HOT_GARBAGE", "primary_values": [], "secondary_values": [13, 11, 9, 6, 4]}}, {"input": {"hand_string": "JC TC JD 7C TH"}, "output": {"hand_type": "TWO_PAIR", "primary_values": [11, 10], "secondary_values": [7]}}, {"input": {"hand_string": "5D 4D JD TC JC"}, "output": {"hand_type": "ONE_PAIR", "primary_values": [11], "secondary_values": [10, 5, 4]}}, {"input": {"hand_string": "5C 7H 2D JC 7S"}, "output": {"hand_type": "ONE_PAIR", "primary_values": [7], "secondary_values": [11, 5, 2]}}, {"input": {"hand_string": "TS 8C TD AC 3C"}, "output": {"hand_type": "ONE_PAIR", "primary_values": [10], "secondary_values": [14, 8, 3]}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "admiralbolt/algorithms", "path": "/euler/utils/poker_utils.py", "msgidx": 13310}}
{"problem_description": "Given a chessboard of size `n x n`, where `n` is an integer between 1 and 9, how can you place `n` queens on the board such that no two queens can attack each other? Each solution should be represented as a configuration of the board where 'Q' indicates a queen and '.' indicates an empty space. What are all the distinct solutions for the given `n`?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be an integer between 1 and 9 inclusive.\n\nOutput:\n  `return` (List[List[str]]): A list of all distinct solutions to the n-queens puzzle. Each solution is represented as a list of strings, where each string represents a row on the chessboard. 'Q' indicates a queen and '.' indicates an empty space.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        d1 = [False] * (2 * n - 1)\n        d2 = [False] * (2 * n - 1)\n        c = [False] * n\n        res = []\n        def solve(i, tmp):\n            if i == n:\n                res.append(list(tmp))\n                return\n            st = ''\n            for j in range(n):\n                if not c[j] and not d1[i + j] and not d2[i - j]:\n                    c[j] = d1[i + j] = d2[i - j] = True\n                    st = '.' * j + 'Q' + '.' * (n - j - 1)\n                    tmp.append(st)\n                    solve(i + 1, tmp)\n                    c[j] = d1[i + j] = d2[i - j] = False\n                    tmp.pop()\n        solve(0, [])\n        return res\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 1}, "output": [["Q"]]}, {"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}, {"input": {"n": 3}, "output": []}, {"input": {"n": 2}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "way2arun/datastructures_algorithms", "path": "/src/matrix/solveNQueens.py", "msgidx": 14606}}
{"problem_description": "Commander Lambda's space station has a unique layout for its prison blocks, which are stacked in a triangular shape. Each cell in this triangular layout can be represented by coordinates (x, y), where x is the distance from the vertical wall and y is the height from the ground. Each bunny prisoner is assigned a numerical ID based on their cell's coordinates. Given the coordinates (x, y) of a bunny prisoner's cell, what is the prisoner ID of the bunny at that location?", "io_requirements": "Input:\n  `x` (int): The distance from the vertical wall (at least 1 and no greater than 100,000).\n  `y` (int): The height from the ground (at least 1 and no greater than 100,000).\n\nOutput:\n  `return` (dict): A dictionary with a single key `\"prisoner_id\"` whose value is a string representation of the prisoner ID at location (x, y).", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\n# they will be used in the main_solution function, you may need to modify them to meet the requirements of the main_solution function (optional)\n\n# main function\ndef main_solution(x, y):\n  # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n  l = [1]\n  row = (x - 1) + y\n  for i in range(y - 1):\n      l.append(l[i] + (i + 1))\n  res = []\n  column = row\n  Elem = l[-1]\n  i = 0\n  ind = (y - 1) + 2\n  res.append(Elem)\n  for i in range(x - 1):\n      Elem = Elem + ind\n      ind += 1\n\n  # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n  return {\"prisoner_id\": str(Elem)}", "funcname": "main_solution", "ios": [{"input": {"x": 28019, "y": 37726}, "output": {"prisoner_id": "2161131915"}}, {"input": {"x": 30527, "y": 85201}, "output": {"prisoner_id": "6696341928"}}, {"input": {"x": 48847, "y": 33100}, "output": {"prisoner_id": "3357581332"}}, {"input": {"x": 35677, "y": 79570}, "output": {"prisoner_id": "6640798312"}}, {"input": {"x": 85372, "y": 86576}, "output": {"prisoner_id": "14782884803"}}, {"input": {"x": 63227, "y": 57613}, "output": {"prisoner_id": "7301034768"}}, {"input": {"x": 30441, "y": 4500}, "output": {"prisoner_id": "610414771"}}, {"input": {"x": 13077, "y": 92710}, "output": {"prisoner_id": "5595299082"}}, {"input": {"x": 76985, "y": 47051}, "output": {"prisoner_id": "7692355580"}}, {"input": {"x": 90631, "y": 83576}, "output": {"prisoner_id": "15173868746"}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "poliwal/Google-Foobar", "path": "/Level 2/Bunny Prisoner Locating.py", "msgidx": 14175}}
{"problem_description": "Given a standard 8x8 chessboard, you are currently at a starting position (x y) and need to move to a target position (a b) on the board. You can only move up or to the right. How many different ways can you travel from the starting position to the target position?", "io_requirements": "Input:\n  `start_pos` (str): A string representing the starting position on the chessboard in the format \"(x y)\", where x and y are integers ranging from 1 to 8.\n  `end_pos` (str): A string representing the ending position on the chessboard in the format \"(a b)\", where a and b are integers ranging from 1 to 8 and a > x, b > y.\n\nOutput:\n  `return` (int): An integer representing the number of ways to travel from the starting position to the ending position on the chessboard by moving only up and to the right.", "refcode": "# import necessary packages\nimport math\n\n# main function\ndef main_solution(start_pos, end_pos):\n    # Convert the input strings to tuples of integers\n    x1, y1 = map(int, start_pos.strip('()').split())\n    x2, y2 = map(int, end_pos.strip('()').split())\n    \n    # Calculate the number of moves required in each direction\n    num_up = y2 - y1\n    num_right = x2 - x1\n    \n    # Calculate the number of ways to travel from (x1, y1) to (x2, y2)\n    total_moves = num_up + num_right\n    min_moves = min(num_up, num_right)\n    \n    # Use combinatorial mathematics to find the number of ways\n    ways = int(math.factorial(total_moves) / (math.factorial(min_moves) * math.factorial(total_moves - min_moves)))\n    \n    return ways", "funcname": "main_solution", "ios": [{"input": {"start_pos": "(1 6)", "end_pos": "(5 8)"}, "output": 15}, {"input": {"start_pos": "(1 4)", "end_pos": "(6 8)"}, "output": 126}, {"input": {"start_pos": "(1 4)", "end_pos": "(4 6)"}, "output": 10}, {"input": {"start_pos": "(3 4)", "end_pos": "(5 8)"}, "output": 15}, {"input": {"start_pos": "(6 7)", "end_pos": "(7 8)"}, "output": 2}, {"input": {"start_pos": "(6 4)", "end_pos": "(7 5)"}, "output": 2}, {"input": {"start_pos": "(5 3)", "end_pos": "(6 8)"}, "output": 6}, {"input": {"start_pos": "(7 4)", "end_pos": "(8 8)"}, "output": 5}, {"input": {"start_pos": "(1 3)", "end_pos": "(2 4)"}, "output": 2}, {"input": {"start_pos": "(2 2)", "end_pos": "(8 4)"}, "output": 28}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sivatoms/PyReddy", "path": "/CoderByteChessBoardTravell.py", "msgidx": 14670}}
{"problem_description": "Given the size of a chessboard, how can we determine all distinct configurations of placing n queens on an n\u00d7n chessboard such that no two queens attack each other?", "io_requirements": "Input:\n  `n` (int): The size of the chessboard and the number of queens to be placed. It should be a positive integer.\n\nOutput:\n  `return` (List[List[str]]): A list of all distinct solutions to the n-queens puzzle. Each solution is represented as a list of strings, where each string represents a row of the chessboard. 'Q' indicates a queen and '.' indicates an empty space.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        self.output = []\n        self.dfs(n, [])\n        return self.visualize_matrix(n)\n        \n    def visualize_matrix(self, n):\n        final = []\n        matrix = []\n        for i in range(n):\n            matrix.append('.' * n)\n        for x in self.output:\n            temp = matrix.copy()\n            for idx, y in enumerate(x):\n                temp[idx] = temp[idx][:y] + 'Q' + temp[idx][y + 1:]\n            final.append(temp)\n        return final\n        \n    def indiagonal(self, x, output):\n        ban = []\n        row = len(output)\n        for idx, num in enumerate(output):\n            ban.append(num + row - idx)\n            ban.append(num - row + idx)\n        if x not in ban:\n            return True\n        else:\n            return False\n        \n    def dfs(self, n, output):\n        if len(output) == n:\n            self.output.append(output.copy())\n            return\n        \n        for x in range(n):\n            if x not in output and self.indiagonal(x, output):\n                self.dfs(n, output + [x])\n                \n        return\n\n# main function\ndef main_solution(n: int) -> List[List[str]]:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.solveNQueens(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 4}, "output": [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "adwardlee/leetcode_solutions", "path": "/051_N_Queens.py", "msgidx": 14479}}
{"problem_description": "Given a number `n`, which is part of a spiral pattern where numbers are arranged in a counter-clockwise spiral starting from the origin (0, 0), what are the coordinates of `n` in the spiral and what is the Manhattan distance from `n` to the origin?", "io_requirements": "Input:\n  `n` (int): A positive integer representing the number for which the position and Manhattan distance from the origin are to be calculated.\n\nOutput:\n  `return` (dict): A dictionary containing the following keys:\n    - `position` (tuple): A tuple of two integers representing the coordinates (x, y) of the number `n` in the spiral.\n    - `distance` (int): An integer representing the Manhattan distance from the position of `n` to the origin (0, 0).", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef manhattan(pos1, pos2):\n    x1, y1 = pos1\n    x2, y2 = pos2\n    return abs(x2 - x1) + abs(y2 - y1)\n\ndef spiral(n):\n    root = math.sqrt(n)\n    if root % 1 == 0 and root % 2 != 0:\n        max_dim = math.floor(root)**2\n    elif root % 2 != 0:\n        max_dim = int((math.floor(root + math.floor(root) % 2 + 1))**2)\n\n    pos = [(1, (0, 0))]\n\n    i = 1\n\n    for x in range(2, int(math.sqrt(max_dim) + 1)):\n        if x % 2 != 0:\n            pwer = x**2\n            num = x-1\n            south = (pwer, pwer - num*1)\n            west = (pwer - num*1, pwer - num*2)\n            north = (pwer - num*2, pwer - num*3)\n            east = (pwer - num*3, pwer - (num*4 - 1))\n\n            south_row_num = [x for x in range(south[1], south[0]+1)]\n            west_row_num = [x for x in range(west[1], west[0]+1)]\n            north_row_num = [x for x in range(north[1], north[0]+1)]\n            east_row_num = [x for x in range(east[1], east[0]+1)]\n            west_row_num.reverse()\n            north_row_num.reverse()\n\n            south_row_pos = [(x, -i) for x in range(-i, i+1)]\n            west_row_pos = [(-i, y) for y in range(-i, i+1)]\n            north_row_pos = [(x, i) for x in range(-i, i+1)]\n            east_row_pos = [(i, y) for y in range(-i+1, i+1)]\n\n            pos.extend(list(zip(south_row_num, south_row_pos)))\n            pos.extend(list(zip(north_row_num, north_row_pos)))\n            pos.extend(list(zip(east_row_num, east_row_pos)))\n            pos.extend(list(zip(west_row_num, west_row_pos)))\n            i += 1\n    return dict(pos)\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    dic = spiral(n)\n    position = dic[n]\n    distance = manhattan(position, (0, 0))\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return {\"position\": position, \"distance\": distance}", "funcname": "main_solution", "ios": [{"input": {"n": 740371}, "output": {"position": [-430, -340], "distance": 770}}, {"input": {"n": 30167}, "output": {"position": [23, 87], "distance": 110}}, {"input": {"n": 575682}, "output": {"position": [-20, -379], "distance": 399}}, {"input": {"n": 730500}, "output": {"position": [-98, -427], "distance": 525}}, {"input": {"n": 997585}, "output": {"position": [83, -499], "distance": 582}}, {"input": {"n": 160171}, "output": {"position": [-200, 30], "distance": 230}}, {"input": {"n": 935869}, "output": {"position": [484, 296], "distance": 780}}, {"input": {"n": 418601}, "output": {"position": [315, -323], "distance": 638}}, {"input": {"n": 901626}, "output": {"position": [400, 475], "distance": 875}}, {"input": {"n": 883516}, "output": {"position": [-385, 470], "distance": 855}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "b-pereira/aoc2017", "path": "/day_03/day_03.py", "msgidx": 14280}}
{"problem_description": "In a crowded waiting area, the seating arrangement follows specific rules for people to sit and leave based on their neighbors. Given an initial seating layout, where each seat can be either empty (`L`), occupied (`#`), or a floor space (`.`), how many seats will be occupied in the final stable layout after no more changes occur?", "io_requirements": "Input:\n  `initial_layout` (str): A string representing the initial seating layout. Each row of seats is separated by a newline character (`\\n`), and each seat is represented by either 'L' (empty seat), '#' (occupied seat), or '.' (floor).\n\nOutput:\n  `return` (int): The number of occupied seats (`#`) in the final stable seating layout after no more changes occur.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\nclass Seating:\n    def __init__(self, as_string):\n        self.as_string = as_string.strip(\"\\n\")\n        self.as_arr = self._get_arr()\n        self.shape = self.as_arr.shape\n\n    def step(self):\n        new_layout = np.full(self.shape, \".\")\n        n, m = self.shape\n        for i in range(n):\n            for j in range(m):\n                new_layout[i, j] = self._get_new_status((i, j))\n        return new_layout\n\n    def _get_arr(self):\n        rows = self.as_string.split()\n        seats = list([list(row) for row in rows])\n        seats = np.array(seats)\n        return seats\n\n    def _get_new_status(self, coord):\n        i, j = coord\n        adjacent_steps = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n        status = self.as_arr[i, j]\n        adjacent_status = [\n            self._get_diagonal_status(\n                (coord[0] + step[0], coord[1] + step[1]), step\n            ) for step in adjacent_steps]\n\n        if status == \".\":\n            return \".\"\n        elif (status == \"L\") & (\"#\" not in adjacent_status):\n            return \"#\"\n        elif (status == \"#\") & (adjacent_status.count(\"#\") >= 5):\n            return \"L\"\n        return status\n\n    def _get_diagonal_status(self, coord, step):\n        n, m = self.shape\n        i, j = coord\n        di, dj = step\n\n        if self._is_over_edge(coord):\n            return \".\"\n\n        status = self._get_status(coord)\n        next_coord = (i + di, j + dj)\n\n        if status == \".\":\n            return self._get_diagonal_status(next_coord, step)\n        else:\n            return status\n\n    def _is_over_edge(self, coord):\n        n, m = self.shape\n        i, j = coord\n        return (i < 0) | (i >= n) | (j < 0) | (j >= m)\n\n    def _get_status(self, coord):\n        if self._is_over_edge(coord):\n            return \".\"\n        else:\n            return self.as_arr[coord]\n\n    def __str__(self):\n        rows = [\"\".join(row) for row in self.as_arr]\n        return \"\\n\".join(rows)\n\n# main function\ndef main_solution(initial_layout):\n    seat_layout = Seating(initial_layout)\n    new_layout = seat_layout.step()\n    while not np.array_equal(new_layout, seat_layout.as_arr):\n        seat_layout.as_arr = new_layout\n        seat_layout.as_string = str(seat_layout)\n        new_layout = seat_layout.step()\n\n    final_layout_str = str(seat_layout)\n    n_occupied = final_layout_str.count(\"#\")\n    return n_occupied", "funcname": "main_solution", "ios": [{"input": {"initial_layout": "###...\nL###.L\n..L#..\nL.LLL.\nL.L#L.\n#L#L#."}, "output": 10}, {"input": {"initial_layout": ".#.L#.#\n.LL#L..\n#L#.##.\n....##.\n.L#LL.L\n#..##.."}, "output": 13}, {"input": {"initial_layout": "L#L.L\n#LL.#\nL#.#.\n..LL.\nL###L"}, "output": 8}, {"input": {"initial_layout": "L..L#..#.\nL#...#L.L\n.L..#..LL\nL.##.LL..\n..##LLL.#\n.##.L.L..\nL#L.L..L#\n####.L#..\n..LLL###."}, "output": 19}, {"input": {"initial_layout": "###L#L..\nL.L.L.L.\n..#LL##.\nL..L#..#\nL#.L#L##\n.#LL#.##"}, "output": 14}, {"input": {"initial_layout": "L.#L#L.#..\nLL.L#.L#L.\nL.L.L.###L\nL#L####L..\n..##L#.L..\n##LL#.L#.#"}, "output": 19}, {"input": {"initial_layout": "L#L.##L.#L\n..#.#..L.#\n...#..##.#\n.#LL#.#LL#\n.L.L#.##L#"}, "output": 16}, {"input": {"initial_layout": "..L#.#.L\n###..#L#\n#LL#LLL#\nLLLL#L#.\n#L..#.L#\nL..#.#.#\nL#L.L#..\n#L#LL.#.\nL.L###.#\nLLL#LLL#"}, "output": 30}, {"input": {"initial_layout": "LL#.#\n##L#.\n##L.L\n.L.L#\nL...L\n#LLL."}, "output": 10}, {"input": {"initial_layout": ".L..LL\n.###.L\n....#.\n.#L###\nL##L.."}, "output": 10}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "chemron/advent_of_code_2020", "path": "/day_11/day_11_pt2.py", "msgidx": 14272}}
{"problem_description": "Imagine you are at a fast-food restaurant that sells McNuggets in packs of 6, 9, and 20. You want to know if a certain number of McNuggets can be purchased exactly using these pack sizes. Given a number of McNuggets `n`, can you determine if it is possible to buy exactly `n` McNuggets using combinations of 6, 9, and 20?", "io_requirements": "Input:\n  `n` (int): An integer representing the number of McNuggets to check if it can be formed by combinations of 6, 9, and 20.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the number of McNuggets `n` can be formed by combinations of 6, 9, and 20.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef McNuggets(n):\n    \"\"\"\n    n is an int\n    6a+9b+20c=n\n    Returns True if some integer combination of 6, 9 and 20 equals n\n    Otherwise returns False.\n    \"\"\"\n    flag = False\n    for i in range(n // 6 + 1):\n        for j in range(n // 9 + 1):\n            for k in range(n // 20 + 1):\n                if 6 * i + 9 * j + k * 20 == n:\n                    flag = True\n                    break\n    return flag\n\n# main function\ndef main_solution(n):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    result = McNuggets(n)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"n": 5}, "output": false}, {"input": {"n": 7}, "output": false}, {"input": {"n": 62}, "output": true}, {"input": {"n": 11}, "output": false}, {"input": {"n": 23}, "output": false}, {"input": {"n": 60}, "output": true}, {"input": {"n": 44}, "output": true}, {"input": {"n": 35}, "output": true}, {"input": {"n": 95}, "output": true}, {"input": {"n": 37}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Devinwon/master", "path": "/computer-science-and-python-programing-edX/mid-exam/quiz-code-graders/problem7.py", "msgidx": 14377}}
{"problem_description": "You are given a grid representing a forest where each position in the grid is either a tree (`#`) or an open space (`.`). You need to traverse the grid using different slopes (right, down) and count the number of trees encountered for each slope. What is the product of the number of trees encountered for each slope?", "io_requirements": "Input:\n  `input_lines` (list of str): A list of strings representing the grid where each string is a row in the grid. Each character in the string represents a position in the grid, with `#` indicating a tree and `.` indicating an open space.\n  `slopes` (list of tuples): A list of tuples where each tuple represents a slope (right, down). Each tuple contains two integers.\n\nOutput:\n  `return` (int): The product of the number of trees encountered for each slope.", "refcode": "# import necessary packages\nimport os\nfrom functools import reduce\n\n# main function\ndef main_solution(input_lines, slopes):\n    \"\"\"\n    Solves the problem of counting trees encountered while traversing a grid with given slopes.\n\n    Args:\n    input_lines (list of str): A list of strings representing the grid.\n    slopes (list of tuples): A list of tuples where each tuple represents a slope (right, down).\n\n    Returns:\n    int: The product of the number of trees encountered for each slope.\n    \"\"\"\n    def trees_with_slope(matrix, slope):\n        \"\"\"\n        Counts the number of trees encountered with a given slope.\n\n        Args:\n        matrix (list of str): A list of strings representing the grid.\n        slope (tuple): A tuple representing the slope (right, down).\n\n        Returns:\n        int: The number of trees encountered.\n        \"\"\"\n        pos = (0, 0)\n        trees = 0\n        while pos[1] < len(matrix):\n            line = matrix[pos[1]].strip()\n            if line[pos[0]] == \"#\":\n                trees += 1\n            pos = ((pos[0] + slope[0]) % len(line), pos[1] + slope[1])\n        return trees\n\n    return reduce((lambda x, y: x * y), [trees_with_slope(input_lines, slope) for slope in slopes])", "funcname": "main_solution", "ios": [{"input": {"input_lines": ["#...#", "..##.", "###..", "...##", "#...#"], "slopes": [[3, 2], [2, 2]]}, "output": 3}, {"input": {"input_lines": [".#.#.", "##..#", ".#..#", ".....", "...#."], "slopes": [[2, 2], [1, 2]]}, "output": 0}, {"input": {"input_lines": ["..###", "#.###", "#..##", "####.", "....."], "slopes": [[1, 1], [2, 1]]}, "output": 3}, {"input": {"input_lines": ["##.##", "..#.#", "#.#.#", ".#...", "#..#."], "slopes": [[3, 2], [2, 2]]}, "output": 2}, {"input": {"input_lines": ["##..#", "#.#.#", "..##.", "#.###", "#..##"], "slopes": [[1, 2], [2, 1]]}, "output": 3}, {"input": {"input_lines": ["###..", "#....", "....#", "#.##.", "###.#"], "slopes": [[3, 1], [3, 1]]}, "output": 4}, {"input": {"input_lines": ["..###", "#....", "..##.", "..#..", ".###."], "slopes": [[2, 2], [3, 1]]}, "output": 1}, {"input": {"input_lines": ["####.", "..#.#", "...#.", "#..##", "..##."], "slopes": [[3, 1], [1, 1]]}, "output": 6}, {"input": {"input_lines": ["##.#.", "#..##", "##.##", "#.#..", ".####"], "slopes": [[3, 2], [1, 2]]}, "output": 9}, {"input": {"input_lines": [".####", ".#..#", "..##.", "..#.#", ".##.."], "slopes": [[3, 1], [3, 1]]}, "output": 4}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "edelans/aoc2020", "path": "/day03.py", "msgidx": 14538}}
{"problem_description": "Given a set of 4-digit numbers that are polygonal (triangular, square, pentagonal, hexagonal, heptagonal, and octagonal), find a cyclic set of these numbers such that the last two digits of each number are the first two digits of the next number in the cycle. If such a cycle exists, what is the sum of the digits of the numbers in the cycle multiplied by 101? (Note: The cycle must start with the given `start_digit` and end with the given `end_digit`.)", "io_requirements": "Input:\n  `start_digit` (int): The starting digit of the first polygonal number in the cycle. Must be a 2-digit number (10-99).\n  `end_digit` (int): The ending digit of the first polygonal number in the cycle. Must be a 2-digit number (10-99).\n\nOutput:\n  `return` (tuple): A tuple containing two elements:\n    - `found_list` (list): A list of integers representing the digits of the cyclic set of polygonal numbers.\n    - `sum_product` (int): The sum of the digits in `found_list` multiplied by 101.", "refcode": "# import necessary packages\nfrom collections import defaultdict\n\n# Function to calculate the nth polygonal number\ndef polygonal(x, r):\n    if r == 3: return int(x * (x + 1) / 2)\n    if r == 4: return int(x * x)\n    if r == 5: return int(x * (3*x - 1) / 2)\n    if r == 6: return int(x * (2*x - 1))\n    if r == 7: return int(x * (5*x - 3) / 2)\n    if r == 8: return int(x * (3*x - 2))\n\n# Function to generate the list of 4-digit polygonal numbers for each type\ndef generate_polygonals():\n    polygonals = defaultdict(list)\n    for i in range(3, 9):\n        for n in range(200):\n            nth_polygonal = polygonal(n, i)\n            if 999 < nth_polygonal < 10000 and (nth_polygonal % 100) > 9 and int(nth_polygonal / 100) > 9:\n                polygonals[i].append(nth_polygonal)\n    return polygonals\n\n# Function to generate the start and end dictionaries for the polygonal numbers\ndef generate_starts_ends(polygonals):\n    starts = defaultdict(lambda: defaultdict(list))\n    ends = defaultdict(lambda: defaultdict(list))\n    for i in range(3, 9):\n        for num in polygonals[i]:\n            starts[i][int(num / 100)].append(num)\n            ends[i][num % 100].append(num)\n    return starts, ends\n\n# Main function to find the cyclic set of polygonal numbers\ndef main_solution(start_digit, end_digit):\n    polygonals = generate_polygonals()\n    starts, ends = generate_starts_ends(polygonals)\n    \n    def search(found_list, nth_list):\n        needed_start = found_list[-1]\n        for i in nth_list:\n            for num in starts[i][needed_start]:\n                nth_list.remove(i)\n                last_number = needed_start * 100 + found_list[0]\n                if nth_list:\n                    search(found_list + [num % 100], nth_list)\n                elif last_number in polygonals[i]:\n                    return found_list, sum(found_list) * 101\n                nth_list.append(i)\n        return [], 0\n    \n    list_ = list(range(3, 9))\n    for num in polygonals[3]:\n        result = search([start_digit, end_digit], list_)\n        if result[0]:\n            return result\n    return [], 0\n\n# Example usage:\n# result = main_solution(10, 20)\n# print(result)", "funcname": "main_solution", "ios": [{"input": {"start_digit": 70, "end_digit": 75}, "output": [[], 0]}, {"input": {"start_digit": 56, "end_digit": 24}, "output": [[], 0]}, {"input": {"start_digit": 43, "end_digit": 66}, "output": [[], 0]}, {"input": {"start_digit": 91, "end_digit": 11}, "output": [[], 0]}, {"input": {"start_digit": 97, "end_digit": 97}, "output": [[], 0]}, {"input": {"start_digit": 63, "end_digit": 22}, "output": [[], 0]}, {"input": {"start_digit": 89, "end_digit": 14}, "output": [[], 0]}, {"input": {"start_digit": 85, "end_digit": 38}, "output": [[], 0]}, {"input": {"start_digit": 58, "end_digit": 62}, "output": [[], 0]}, {"input": {"start_digit": 72, "end_digit": 73}, "output": [[], 0]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sabriozgur/euler-python", "path": "/euler061.py", "msgidx": 13925}}
{"problem_description": "In a seating arrangement, some seats are occupied ('L') and others are empty ('.'). The seating arrangement changes based on the following rules:\n- An empty seat ('L') becomes occupied if there are no occupied seats adjacent to it.\n- An occupied seat becomes empty if at least five adjacent seats are occupied.\n\nGiven a seating arrangement represented by a list of strings, where each string represents a row and each character represents a seat or a floor space, how many seats will be occupied when the seating arrangement stabilizes?", "io_requirements": "Input:\n  `content` (list of strings): A list where each string represents a row of a seating arrangement. Each character in the string can be either 'L' (indicating an empty seat) or '.' (indicating a floor space).\n\nOutput:\n  `return` (int): The number of occupied seats after the seating arrangement stabilizes.", "refcode": "# import necessary packages\nimport numpy as np\n\n# all class and function definitions in the code file, if any\ndef parse_input(content):\n    num_rows = len(content)\n    num_cols = len(content[0])\n    matrix = np.zeros((num_rows, num_cols))\n    for i in range(num_rows):\n        for j in range(num_cols):\n            if content[i][j] == 'L':\n                matrix[i][j] = 1\n    return matrix\n\ndef is_seat_empty(seat):\n    return seat == 1\n\ndef is_seat_occupied(seat):\n    return seat == 2\n\ndef num_adjacent_occupied(matrix, i, j):\n    x_min = max([0, j - 1])\n    x_max = min([len(matrix[0]), j + 2])\n    y_min = max([0, i - 1])\n    y_max = min([len(matrix), i + 2])\n\n    adjacents_matrix = matrix[y_min:y_max, x_min:x_max]\n    count_occupied = len(adjacents_matrix[adjacents_matrix > 1])\n\n    return count_occupied\n\ndef solve_puzzle(matrix):\n    stable = False\n    while not stable:\n        stable = True\n        old_matrix = np.copy(matrix)\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if is_seat_empty(old_matrix[i][j]) and num_adjacent_occupied(old_matrix, i, j) == 0:\n                    matrix[i][j] = 2\n                    stable = False\n                elif is_seat_occupied(old_matrix[i][j]) and num_adjacent_occupied(old_matrix, i, j) >= 5:\n                    matrix[i][j] = 1\n                    stable = False\n\n    return len(matrix[matrix == 2])\n\n# main function\ndef main_solution(content):\n    # Convert the input content to a matrix\n    matrix = parse_input(content)\n    # Solve the puzzle\n    result = solve_puzzle(matrix)\n    # Return the result as a JSON serializable output\n    return result", "funcname": "main_solution", "ios": [{"input": {"content": [".L...", "L.L..", "L...L", "LLLL.", "L.LLL", "L.L.L"]}, "output": 12}, {"input": {"content": ["LL.LLLLL", "LL.LL.L.", ".L.LL.L.", ".L..L.LL", ".LLLL.L.", "..LL.L.L", ".L..L.LL", "LLL.L...", "LL..LL.."]}, "output": 24}, {"input": {"content": ["..L.L.", "LL..L.", "L.LLLL", ".L..L.", ".L..LL", "L...L.", ".LLL.L", "..L...", ".LLLLL"]}, "output": 20}, {"input": {"content": ["L...LLL.", "LL.L.L..", "LLLL.L.L", "...LL.L.", "L..L...."]}, "output": 11}, {"input": {"content": ["LL.LL..", ".LLLL..", "LLLLLL.", "L.LL...", ".LL.LLL"]}, "output": 13}, {"input": {"content": ["LL.LL..", "L..L..L", "L..L.LL", "L.L.L.L", "..LLLL.", "..LLLL.", "LLLLL.L"]}, "output": 19}, {"input": {"content": [".....LLL", "LL.L.LL.", ".LL...LL", ".L..L...", "LLL...L.", ".LLL...L", "LL...L..", ".L.L..L.", "L...LL.L"]}, "output": 21}, {"input": {"content": ["L..LLL..L", "...L...LL", "L..LLLL.L", "L..LLLL..", "L.L.....L"]}, "output": 16}, {"input": {"content": ["..LL.", "L..L.", "..L.L", "LL...", "L..LL", ".LL..", "L.LLL", "...L."]}, "output": 13}, {"input": {"content": ["LLLLLL.L", ".....LLL", "LL.LLLLL", "L..LLLL.", "LL.LL...", "L.L...L.", ".LLLL.LL", "...LLLL."]}, "output": 24}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "joaomosm/adventofcode", "path": "/2020/11/11_part_one.py", "msgidx": 14047}}
{"problem_description": "Given a scale with a weight on the left side, how can you balance the scale using only powers of 3 on both sides? Specifically, what are the positions (left or right) of the weights required to balance the scale for a given weight on the left side?", "io_requirements": "Input:\n  `inp` (int): An integer representing the weight on the left side of the scale.\n\nOutput:\n  `return` (list of str): A list of strings where each string represents the position of a weight (either \"L\" for left, \"R\" for right, or \"-\" if no weight is used) to balance the scale.", "refcode": "import math\n\ndef balance(inp):\n    \"\"\"Balance a scale starting with inp on left side\n        using only powers of 3 on each side\"\"\"\n    max_exp = int(math.ceil(math.log(inp, 3)))\n    weights = [\"-\"] * (max_exp + 1)\n    diff = inp\n    while diff != 0:\n        this_exp = int(round(math.log(abs(diff), 3)))\n        sum_exp = sum([3**n for n in range(this_exp + 1)])\n        if abs(diff) > abs(sum_exp):\n            this_exp += 1\n        if weights[this_exp] != \"-\":\n            break\n        if diff < 0:\n            weights[this_exp] = \"L\"\n            diff += 3 ** this_exp\n        elif diff > 0:\n            weights[this_exp] = \"R\"\n            diff -= 3 ** this_exp\n    if weights[-1] == \"-\":\n        weights.pop()\n    return weights\n\ndef main_solution(inp):\n    # Convert input to integer\n    inp = int(inp)\n    # Call the balance function\n    result = balance(inp)\n    # Convert the result to a JSON serializable format\n    return result", "funcname": "main_solution", "ios": [{"input": {"inp": 704943}, "output": ["-", "-", "-", "-", "-", "-", "R", "R", "L", "-", "-", "R", "R"]}, {"input": {"inp": 640755}, "output": ["-", "-", "L", "L", "-", "-", "-", "L", "L", "-", "L", "R", "R"]}, {"input": {"inp": 741493}, "output": ["R", "-", "L", "R", "R", "-", "-", "-", "L", "L", "R", "R", "R"]}, {"input": {"inp": 75360}, "output": ["-", "R", "-", "R", "-", "R", "R", "R", "L", "R", "R"]}, {"input": {"inp": 719281}, "output": ["R", "-", "-", "-", "-", "L", "-", "L", "L", "R", "-", "R", "R"]}, {"input": {"inp": 505670}, "output": ["L", "L", "L", "-", "-", "L", "R", "-", "L", "L", "-", "-", "R"]}, {"input": {"inp": 81750}, "output": ["-", "R", "L", "R", "R", "-", "R", "R", "-", "R", "R"]}, {"input": {"inp": 354476}, "output": ["L", "R", "L", "R", "L", "R", "-", "-", "-", "-", "-", "L", "R"]}, {"input": {"inp": 619558}, "output": ["R", "L", "L", "-", "L", "-", "R", "R", "R", "R", "R", "-", "R"]}, {"input": {"inp": 319795}, "output": ["R", "L", "R", "-", "-", "L", "R", "L", "R", "R", "L", "L", "R"]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "pugswald/google-puzzles", "path": "/balance.py", "msgidx": 14688}}
{"problem_description": "Given a series of lines representing a banner format of numbers, how can we translate these lines back into their corresponding numerical digits?", "io_requirements": "Input:\n  `banner_lines` (list of strings): A list of strings where each string represents a line of the banner format. Each digit in the banner is represented by 4 lines, and each line has 27 characters.\n\nOutput:\n  `return` (string): A string representing the digits parsed from the banner format. Each character in the string corresponds to a digit from the banner.", "refcode": "# import necessary packages\nimport re\n\n# Define the mapping of each digit to its corresponding banner representation\nDIGIT_TO_BANNER = {\n    '0': [\" _ \", \"| |\", \"|_|\", \"   \"],\n    '1': [\"   \", \"  |\", \"  |\", \"   \"],\n    '2': [\" _ \", \" _|\", \"|_ \", \"   \"],\n    '3': [\" _ \", \" _|\", \" _|\", \"   \"],\n    '4': [\"   \", \"|_|\", \"  |\", \"   \"],\n    '5': [\" _ \", \"|_ \", \" _|\", \"   \"],\n    '6': [\" _ \", \"|_ \", \"|_|\", \"   \"],\n    '7': [\" _ \", \"  |\", \"  |\", \"   \"],\n    '8': [\" _ \", \"|_|\", \"|_|\", \"   \"],\n    '9': [\" _ \", \"|_|\", \" _|\", \"   \"],\n}\n\n# Function to convert a banner representation back to a digit\ndef banner_to_digit(banner):\n    for digit, banner_rep in DIGIT_TO_BANNER.items():\n        if banner_rep == banner:\n            return digit\n    return '?'\n\n# main function\ndef main_solution(banner_lines):\n    # Split the input into individual digits\n    digits = [banner_lines[i:i+4] for i in range(0, len(banner_lines), 4)]\n    \n    # Convert each digit banner to a digit\n    result = ''.join(banner_to_digit(digit) for digit in digits)\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"banner_lines": [" _  _  _ ", " _||_   |", "|_ |_|  |", "         "]}, "output": "?"}, {"input": {"banner_lines": [" _ ", "|_ ", " _|", "   "]}, "output": "5"}, {"input": {"banner_lines": [" _  _     _  _     _  _ ", "|_ | |  |  || ||_||_ | |", " _||_|  |  ||_|  ||_||_|", "                        "]}, "output": "?"}, {"input": {"banner_lines": [" _  _  _  _  _  _  _ ", "  |  | _||_  _| _| _|", "  |  | _||_| _||_  _|", "                     "]}, "output": "?"}, {"input": {"banner_lines": [" _     _  _    ", "|_   |  || ||_|", " _|  |  ||_|  |", "               "]}, "output": "?"}, {"input": {"banner_lines": [" _  _  _  _ ", " _|  | _||_ ", " _|  | _| _|", "            "]}, "output": "?"}, {"input": {"banner_lines": [" _        _  _  _  _     _ ", " _|  ||_||_   ||_ |_   || |", "|_   |  ||_|  ||_||_|  ||_|", "                           "]}, "output": "?"}, {"input": {"banner_lines": [" _  _ ", "| ||_ ", "|_||_|", "      "]}, "output": "?"}, {"input": {"banner_lines": ["    _ ", "|_||_ ", "  ||_|", "      "]}, "output": "?"}, {"input": {"banner_lines": [" _  _  _ ", "|_|  ||_|", "|_|  | _|", "         "]}, "output": "?"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "DayGitH/Python-Challenges", "path": "/DailyProgrammer/DP20150126.py", "msgidx": 13707}}
{"problem_description": "Given a sequence of digits, determine if the sequence can be divided into a series of ascending and consecutive numbers. For example, the sequence \"232425\" can be divided into consecutive numbers 23, 24, and 25. What is the result of this determination for a given sequence?", "io_requirements": "Input:\n  `input_string` (str): A string representing a sequence of numbers. The string should contain digits only and should have at least two characters.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the input string consists of ascending and consecutive numbers. Returns `True` if the numbers are ascending and consecutive, otherwise `False`.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef ascending(n):\n    length = 1\n    while length <= len(n) // 2:\n        check = 0\n        for i in range(0, len(n), length):\n            if i != 0 and int(n[i:i + length]) != int(n[i - length:i]) + 1:\n                check = 1\n                length += 1\n                break\n        if check == 0:\n            return True\n    return False\n\n# main function\ndef main_solution(input_string):\n    # input_string is a string that represents a sequence of numbers\n    result = ascending(input_string)\n    # result is a boolean indicating whether the input_string consists of ascending and consecutive numbers\n    return result", "funcname": "main_solution", "ios": [{"input": {"input_string": "280281282283284285286287"}, "output": true}, {"input": {"input_string": "873874"}, "output": true}, {"input": {"input_string": "241242243244245246247248249250"}, "output": true}, {"input": {"input_string": "914915916917918919920921"}, "output": true}, {"input": {"input_string": "885886887888889"}, "output": true}, {"input": {"input_string": "432433434435436437438439440"}, "output": true}, {"input": {"input_string": "283284285286287288289290"}, "output": true}, {"input": {"input_string": "798799800801802803"}, "output": true}, {"input": {"input_string": "488489"}, "output": true}, {"input": {"input_string": "452453454455456457"}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/9iLhKgqZn5exBrmWm_23.py", "msgidx": 13979}}
{"problem_description": "Given a permutation of 8 integers, each representing the column position of a queen on an 8x8 chessboard, determine if this arrangement is a valid solution to the 8-queens problem. The 8-queens problem requires that no two queens threaten each other, meaning no two queens share the same row, column, or diagonal. What is the validity of the given permutation as a solution to the 8-queens problem?", "io_requirements": "Input:\n  `perm` (list of integers): A list of 8 integers representing the positions of queens on an 8x8 chessboard. Each integer should be between 0 and 7.\n\nOutput:\n  `return` (boolean): A boolean value indicating whether the given permutation is a valid solution to the 8-queens problem (True if valid, False otherwise).", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef put_queen(x, y, table):\n    if table[y][x] == 0:\n        for m in range(8):\n            table[y][m] = 1\n            table[m][x] = 1\n            table[y][x] = 2\n            if y+m <= 7 and x+m <= 7:\n                table[y+m][x+m] = 1\n            if y-m >= 0 and x+m <= 7:\n                table[y-m][x+m] = 1\n            if y+m <= 7 and x-m >= 0:\n                table[y+m][x-m] = 1\n            if y-m >= 0 and x-m >= 0:\n                table[y-m][x-m] = 1\n        return True\n    else:\n        return False\n\n# main function\ndef main_solution(perm):\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    perm = tuple(perm)  # Convert list to tuple to ensure it's JSON serializable\n    table = [[0]*8 for _ in range(8)]\n    \n    # Check if the permutation is a valid solution\n    for i in range(8):\n        if not put_queen(perm[i], i, table):\n            return False\n    \n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return True", "funcname": "main_solution", "ios": [{"input": {"perm": [7, 0, 5, 3, 4, 2, 6, 1]}, "output": false}, {"input": {"perm": [3, 1, 6, 2, 5, 0, 4, 7]}, "output": false}, {"input": {"perm": [6, 7, 4, 3, 1, 0, 2, 5]}, "output": false}, {"input": {"perm": [4, 3, 0, 6, 5, 1, 7, 2]}, "output": false}, {"input": {"perm": [2, 6, 1, 3, 0, 4, 7, 5]}, "output": false}, {"input": {"perm": [4, 5, 6, 7, 2, 0, 1, 3]}, "output": false}, {"input": {"perm": [6, 0, 1, 3, 2, 7, 4, 5]}, "output": false}, {"input": {"perm": [7, 4, 1, 6, 3, 0, 2, 5]}, "output": false}, {"input": {"perm": [4, 1, 3, 2, 0, 7, 5, 6]}, "output": false}, {"input": {"perm": [5, 2, 0, 4, 1, 3, 7, 6]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Eric-J-G/Eric-J-G", "path": "/Chess Stuff.py", "msgidx": 14405}}
{"problem_description": "In a warehouse game, a storekeeper needs to push a box to a target location on a grid. The grid contains walls, floors, and the positions of the player, box, and target. Given the layout of the grid, how many pushes are required to move the box to the target position? If it is not possible to move the box to the target, what should be returned?", "io_requirements": "Input:\n  `grid` (List[List[str]]): A 2D list of strings representing the grid. Each string can be one of the following:\n    - `'#'`: Represents a wall.\n    - `'.'`: Represents a floor (empty cell).\n    - `'T'`: Represents the target position.\n    - `'B'`: Represents the box.\n    - `'S'`: Represents the player.\n\nOutput:\n  `return` (int): The minimum number of pushes required to move the box to the target position. If it is not possible to move the box to the target, returns `-1`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# main function\ndef main_solution(grid: List[List[str]]) -> int:\n    # Convert the grid to a list of lists of strings\n    grid = [list(row) for row in grid]\n\n    moves = [\n        [0, 1],\n        [1, 0],\n        [0, -1],\n        [-1, 0],\n    ]\n\n    player, box, target = None, None, None\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == 'T':\n                target = (i, j)\n                grid[i][j] = '.'\n            if grid[i][j] == 'B':\n                box = (i, j)\n                grid[i][j] = '.'\n            if grid[i][j] == 'S':\n                player = (i, j)\n                grid[i][j] = '.'\n\n    if box == target:\n        return 0\n\n    def invalidCell(pos):\n        return pos[0] < 0 or pos[1] < 0 or pos[0] >= len(grid) or pos[1] >= len(grid[pos[0]]) or grid[pos[0]][pos[1]] != '.'\n\n    def canAccess(dest, box, src):\n        q = [src]\n        visited = set()\n        while q:\n            pos = q.pop(0)\n            if invalidCell(pos):\n                continue\n            if pos in visited:\n                continue\n            if pos == box:\n                continue\n            if pos == dest:\n                return True\n            visited.add(pos)\n\n            for move in moves:\n                x = pos[0] + move[0]\n                y = pos[1] + move[1]\n                q.append((x, y))\n\n        return False\n\n    visited = set()\n    q = [(box, player, 0)]\n    while q:\n        box, player, pushes = q.pop(0)\n        if box == target:\n            return pushes\n        if (box, player) in visited:\n            continue\n        visited.add((box, player))\n\n        for move in moves:\n            newBox = (box[0] + move[0], box[1] + move[1])\n            dest = (box[0] - move[0], box[1] - move[1])\n            if invalidCell(newBox):\n                continue\n            if (newBox, box) in visited:\n                continue\n            if not canAccess(dest, box, player):\n                continue\n            q.append((newBox, box, pushes + 1))\n\n    return -1", "funcname": "main_solution", "ios": [{"input": {"grid": ["#########", "#...#...#", "##.#..#.#", "#.###.###", "##.#....#", "#..#..#B#", "#.##S.#T#", "#......##", "#########"]}, "output": 1}, {"input": {"grid": ["######", "#STB##", "##...#", "##...#", "#..#.#", "##.###", "##...#", "######"]}, "output": -1}, {"input": {"grid": ["#####", "#.#.#", "###.#", "#TS.#", "##..#", "#.#B#", "#####"]}, "output": -1}, {"input": {"grid": ["######", "#...##", "###..#", "#....#", "#.SB##", "#.#T##", "#.#..#", "######"]}, "output": 1}, {"input": {"grid": ["########", "##...#.#", "#......#", "#T#.B..#", "#.#.S..#", "########"]}, "output": -1}, {"input": {"grid": ["#######", "#...S.#", "#.#...#", "##.##.#", "#..#.T#", "##.#..#", "#.B...#", "##...##", "#######"]}, "output": -1}, {"input": {"grid": ["#####", "#...#", "#S..#", "##TB#", "#####"]}, "output": -1}, {"input": {"grid": ["######", "##..##", "####.#", "#.B.S#", "#...T#", "##..##", "######"]}, "output": -1}, {"input": {"grid": ["##########", "#B.##..###", "#.#...#.S#", "#.#...##.#", "##....T..#", "#...###.##", "#....##..#", "##########"]}, "output": -1}, {"input": {"grid": ["#####", "#S#.#", "##.T#", "#...#", "#...#", "#.B##", "#...#", "#####"]}, "output": -1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "manavdahra/interview-prep", "path": "/move_box.py", "msgidx": 14102}}
{"problem_description": "Given a list that may contain nested lists, how many elements are there in total, including all elements within the nested lists?", "io_requirements": "Input:\n  `input_list` (list): A list of elements which may contain nested lists.\n\nOutput:\n  `return` (int): The total number of elements in the list, including all elements within nested lists.", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\ndef f(a):\n    return sum(map(f, a)) + 1 if isinstance(a, list) else 1\n\n# main function\ndef main_solution(input_list):\n    # Convert the input list to a JSON serializable format\n    json_serializable_input = input_list\n    \n    # Call the original function to get the result\n    result = f(json_serializable_input) - 1\n    \n    # Convert the result to a JSON serializable format\n    json_serializable_output = result\n    \n    return json_serializable_output", "funcname": "main_solution", "ios": [{"input": {"input_list": ["x"]}, "output": 1}, {"input": {"input_list": "z"}, "output": 0}, {"input": {"input_list": [25]}, "output": 1}, {"input": {"input_list": [47, [["x"]]]}, "output": 4}, {"input": {"input_list": [26, "x"]}, "output": 2}, {"input": {"input_list": "y"}, "output": 0}, {"input": {"input_list": [["x"], [[28], "x", ["y"]], 81]}, "output": 9}, {"input": {"input_list": [["x"], [[11, "z", 17]]]}, "output": 7}, {"input": {"input_list": [["z"]]}, "output": 2}, {"input": {"input_list": ["z", "y", "x"]}, "output": 3}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "daniel-reich/turbo-robot", "path": "/nn7Na6zHLEHS9R8j2_14.py", "msgidx": 13978}}
{"problem_description": "In the classic N-Queens problem, you are tasked with placing N queens on an N\u00d7N chessboard such that no two queens threaten each other. Given a chessboard of a certain size, how many distinct solutions exist where no two queens share the same row, column, or diagonal?", "io_requirements": "Input:\n  `board_size` (int): The size of the chessboard, which is the number of rows and columns. It should be a positive integer.\n\nOutput:\n  `return` (str): A JSON string containing the size of the chessboard and the number of successful solutions found for the N-Queens problem. The JSON structure is as follows:\n  ```json\n  {\n    \"board_size\": int,\n    \"solution_count\": int\n  }\n  ```", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nBOARD_SIZE = 8\nqueens_list = [0] * BOARD_SIZE\nsuccess_count = 0\n\ndef calc_queens(row: int):\n    if row >= BOARD_SIZE:\n        global success_count\n        success_count += 1\n    else:\n        for column in range(0, BOARD_SIZE):\n            if is_valid_pos(row, column):\n                queens_list[row] = column\n                calc_queens(row + 1)\n\ndef is_valid_pos(row, column) -> bool:\n    current_row = 0\n    while current_row < row:\n        if queens_list[current_row] == column:\n            return False\n        elif row - current_row == abs(column - queens_list[current_row]):\n            return False\n        current_row += 1\n    return True\n\n# main function\ndef main_solution(board_size: int):\n    global BOARD_SIZE, queens_list, success_count\n    BOARD_SIZE = board_size\n    queens_list = [0] * BOARD_SIZE\n    success_count = 0\n    \n    calc_queens(0)\n    \n    # Convert the result to a JSON serializable format\n    result = {\n        \"board_size\": BOARD_SIZE,\n        \"solution_count\": success_count\n    }\n    return json.dumps(result)", "funcname": "main_solution", "ios": [{"input": {"board_size": 10}, "output": "{\"board_size\": 10, \"solution_count\": 724}"}, {"input": {"board_size": 4}, "output": "{\"board_size\": 4, \"solution_count\": 2}"}, {"input": {"board_size": 6}, "output": "{\"board_size\": 6, \"solution_count\": 4}"}, {"input": {"board_size": 9}, "output": "{\"board_size\": 9, \"solution_count\": 352}"}, {"input": {"board_size": 7}, "output": "{\"board_size\": 7, \"solution_count\": 40}"}, {"input": {"board_size": 8}, "output": "{\"board_size\": 8, \"solution_count\": 92}"}, {"input": {"board_size": 5}, "output": "{\"board_size\": 5, \"solution_count\": 10}"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "ykdsg/myPython", "path": "/geekbang/algo/39_back_track/eight_queens_01.py", "msgidx": 14364}}
{"problem_description": "In a mysterious castle, there are three rooms labeled I, II, and III. Each room has a sign outside, but at most one of the signs is true. The signs are:\n- ROOM I: A TIGER IS IN THIS ROOM.\n- ROOM II: A LADY IS IN THIS ROOM.\n- ROOM III: A TIGER IS IN ROOM II.\n\nOne room contains a lady, and the other two contain tigers. Which room contains the lady, given the constraints that at most one sign is true and one room must contain the lady?", "io_requirements": "Input:\n  `sign1_text` (str): The text for the first sign, e.g., \"ROOM I: A TIGER IS IN THIS ROOM.\"\n  `sign2_text` (str): The text for the second sign, e.g., \"ROOM II: A LADY IS IN THIS ROOM.\"\n  `sign3_text` (str): The text for the third sign, e.g., \"ROOM III: A TIGER IS IN ROOM II.\"\n\nOutput:\n  `return` (str): A string representation of the Z3 model that satisfies the constraints, indicating which room contains the lady. If no solution is found, it returns \"No solution found.\"", "refcode": "# import necessary packages\nfrom z3 import *\n\n# main function\ndef main_solution(sign1_text, sign2_text, sign3_text):\n    # Convert input strings to Bool variables\n    sign1 = Bool(sign1_text)\n    sign2 = Bool(sign2_text)\n    sign3 = Bool(sign3_text)\n\n    l1 = Bool('lady is in room 1.')\n    l2 = Bool('lady is in room 2.')\n    l3 = Bool('lady is in room 3.')\n\n    s = Solver()\n    \n    # Constraints\n    s.add(Or(Not(l1), Not(l2)), Or(Not(l1), Not(l3)), Or(Not(l2), Not(l3)))\n    s.add(Or(l1, l2, l3))\n    s.add(Or(Not(sign1), Not(sign2)), Or(Not(sign1), Not(sign3)), Or(Not(sign2), Not(sign3)))\n    s.add(Or(Not(sign1), Not(l1)), Or(sign1, l1))\n    s.add(Or(Not(sign2), l2), Or(Not(l2), sign2))\n    s.add(Or(Not(sign3), Not(l2)), Or(sign3, l2))\n\n    try_list = [l1, l2, l3]\n    answer = None\n    for i in range(3):\n        s.push()\n        s.add(Not(try_list[i]))\n        check = s.check()\n        if check != sat:\n            answer = try_list[i]\n        s.pop()\n\n    if answer is not None:\n        s.add(answer)\n        model = s.model()\n        return str(model)\n    else:\n        return \"No solution found.\"", "funcname": "main_solution", "ios": [{"input": {"sign1_text": "ROOM I: A TIGER IS IN THIS ROOM.", "sign2_text": "ROOM II: A LADY IS IN THIS ROOM.", "sign3_text": "ROOM III: A TIGER IS IN ROOM II."}, "output": "[]"}, {"input": {"sign1_text": "ROOM III: A TIGER IS IN ROOM II.", "sign2_text": "ROOM II: A LADY IS IN THIS ROOM.", "sign3_text": "ROOM I: A TIGER IS IN THIS ROOM."}, "output": "[]"}, {"input": {"sign1_text": "ROOM II: A LADY IS IN THIS ROOM.", "sign2_text": "ROOM I: A TIGER IS IN THIS ROOM.", "sign3_text": "ROOM III: A TIGER IS IN ROOM II."}, "output": "[]"}, {"input": {"sign1_text": "ROOM III: A TIGER IS IN ROOM II.", "sign2_text": "ROOM I: A TIGER IS IN THIS ROOM.", "sign3_text": "ROOM II: A LADY IS IN THIS ROOM."}, "output": "[]"}, {"input": {"sign1_text": "ROOM II: A LADY IS IN THIS ROOM.", "sign2_text": "ROOM III: A TIGER IS IN ROOM II.", "sign3_text": "ROOM I: A TIGER IS IN THIS ROOM."}, "output": "[]"}, {"input": {"sign1_text": "ROOM I: A TIGER IS IN THIS ROOM.", "sign2_text": "ROOM III: A TIGER IS IN ROOM II.", "sign3_text": "ROOM II: A LADY IS IN THIS ROOM."}, "output": "[]"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "EsArtic/Course_AI", "path": "/Assignment3/lady.py", "msgidx": 14692}}
{"problem_description": "Given a balance scale with two weights on its left and right sides, and a set of additional weights available for use, determine the smallest combination of up to two weights from the available set that can be used to balance the scale. What is the list of weights used to balance the scale, if any?", "io_requirements": "Input:\n  `left_weight` (int): The weight on the left side of the balance scale.\n  `right_weight` (int): The weight on the right side of the balance scale.\n  `available_weights` (list of int): A list of available weights that can be used to balance the scale.\n\nOutput:\n  `return` (list of int): A list of the weights used to balance the scale in ascending order. If it is not possible to balance the scale, the list will be empty.", "refcode": "# import necessary packages\nimport itertools\n\n# main function\ndef main_solution(left_weight, right_weight, available_weights):\n    # Convert the input to the required format for the original function\n    tplWeights = ([left_weight, right_weight], available_weights)\n    \n    # Call the original ScaleBalancing function\n    result = ScaleBalancing(tplWeights)\n    \n    # Return the result as a JSON serializable list\n    return result\n\n# Original ScaleBalancing function\ndef ScaleBalancing(tplWeights): \n    try:\n        current_weights = tplWeights[0]\n        available_weights = list(set(tplWeights[1]))\n        available_weights.sort()\n        for i in available_weights:\n            for j in available_weights:\n                if i != j:\n                    if current_weights[0] + i == current_weights[1] + j or\\\n                    current_weights[0] == current_weights[1] + i + j or\\\n                    current_weights[0] + i + j == current_weights[1]:\n                        result = [i, j]\n                        if 0 in result:\n                            result.remove(0)\n                        result.sort()\n                        return result\n        return []\n    except Exception:\n        return []", "funcname": "main_solution", "ios": [{"input": {"left_weight": 20, "right_weight": 17, "available_weights": [2, 18, 7]}, "output": []}, {"input": {"left_weight": 14, "right_weight": 16, "available_weights": [3, 15, 8, 11, 17]}, "output": [15, 17]}, {"input": {"left_weight": 7, "right_weight": 2, "available_weights": [10, 6, 7]}, "output": []}, {"input": {"left_weight": 12, "right_weight": 5, "available_weights": [4, 11, 3, 10]}, "output": [3, 4]}, {"input": {"left_weight": 2, "right_weight": 18, "available_weights": [13, 15, 4, 1, 19, 12, 5, 16, 17, 11]}, "output": [1, 15]}, {"input": {"left_weight": 19, "right_weight": 11, "available_weights": [8, 16, 1, 14, 2, 5]}, "output": [8, 16]}, {"input": {"left_weight": 10, "right_weight": 1, "available_weights": [4, 10, 15]}, "output": []}, {"input": {"left_weight": 10, "right_weight": 14, "available_weights": [16, 9, 6, 17, 14, 19, 11, 1, 15]}, "output": [11, 15]}, {"input": {"left_weight": 12, "right_weight": 18, "available_weights": [10, 2, 14]}, "output": []}, {"input": {"left_weight": 19, "right_weight": 19, "available_weights": [18, 11, 2, 4, 3, 19, 12]}, "output": []}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "vmueller71/code-challenges", "path": "/scale_balancing/solution.py", "msgidx": 14467}}
{"problem_description": "Given an array of integers, how can we construct a binary tree such that the root node is the maximum element of the array, the left subtree is constructed from the elements to the left of the maximum element, and the right subtree is constructed from the elements to the right of the maximum element? What will be the pre-order traversal of the nodes in the constructed binary tree?", "io_requirements": "Input:\n  `nums` (List[int]): A list of integers representing the array from which to construct the maximum binary tree.\n\nOutput:\n  `return` (List[int]): A list of integers representing the values of the nodes in the constructed maximum binary tree in pre-order traversal.", "refcode": "# import necessary packages\nfrom typing import List\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:\n        if nums:\n            if len(nums) == 1: # array\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\n                return TreeNode(nums[0])\n            else:\n                maximumPosition = max(enumerate(nums), key=lambda x: x[1])[0] # \u6700\u5927\u503c\u7684\u4f4d\u7f6e\n                root = TreeNode(nums[maximumPosition]) # \u6839\u8282\u70b9\u662farray\u6700\u5927\u503c\n                root.left = self.constructMaximumBinaryTree(nums[: maximumPosition]) # \u53d6\u5de6\u8fb9\u6784\u6210\u6811\n                root.right = self.constructMaximumBinaryTree(nums[maximumPosition + 1: ]) # \u53d6\u53f3\u8fb9\u6210\u6811\n                return root\n        else:\n            return None\n\n# main function\ndef main_solution(nums: List[int]) -> List[int]:\n    # Convert the input list to a JSON serializable format\n    nums = list(nums)\n    \n    # Construct the maximum binary tree\n    solution = Solution()\n    root = solution.constructMaximumBinaryTree(nums)\n    \n    # Convert the tree to a list of values in pre-order traversal\n    def pre_order_traversal(node: TreeNode) -> List[int]:\n        if not node:\n            return []\n        return [node.val] + pre_order_traversal(node.left) + pre_order_traversal(node.right)\n    \n    result = pre_order_traversal(root)\n    \n    # Return the result as a JSON serializable list\n    return result", "funcname": "main_solution", "ios": [{"input": {"nums": [14, 60, 13, 47, 74, 88, 89, 35]}, "output": [89, 88, 74, 60, 14, 47, 13, 35]}, {"input": {"nums": [51, 31, 98, 53, 37, 100, 64, 60]}, "output": [100, 98, 51, 31, 53, 37, 64, 60]}, {"input": {"nums": [30, 67, 8, 74, 51, 90, 82, 34, 75]}, "output": [90, 74, 67, 30, 8, 51, 82, 75, 34]}, {"input": {"nums": [70, 45, 0, 45, 92, 34, 77]}, "output": [92, 70, 45, 45, 0, 77, 34]}, {"input": {"nums": [61]}, "output": [61]}, {"input": {"nums": [69, 2, 78, 82, 78, 91, 71, 38, 85, 82]}, "output": [91, 82, 78, 69, 2, 78, 85, 71, 38, 82]}, {"input": {"nums": [33, 10, 60, 33]}, "output": [60, 33, 10, 33]}, {"input": {"nums": [85, 39, 7]}, "output": [85, 39, 7]}, {"input": {"nums": [22, 35, 78, 49, 5, 33]}, "output": [78, 35, 22, 49, 33, 5]}, {"input": {"nums": [28, 35, 58, 96]}, "output": [96, 58, 35, 28]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "aiifabbf/leetcode-memo", "path": "/654.py", "msgidx": 14777}}
{"problem_description": "Given a binary tree, determine whether it is a balanced binary tree. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. What is the result of the balance check for the given binary tree structure?", "io_requirements": "Input:\n  `tree_structure` (dict): A dictionary representing the structure of the binary tree. Each key-value pair represents a node in the tree. The keys are:\n    - `val` (int): The value of the node.\n    - `left` (dict or None): The left child of the node, represented as another dictionary or None if there is no left child.\n    - `right` (dict or None): The right child of the node, represented as another dictionary or None if there is no right child.\n\nOutput:\n  `return` (dict): A dictionary containing the result of the balance check. The key is:\n    - `is_balanced` (bool): True if the binary tree is balanced, False otherwise.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def __init__(self):\n        self.is_balance = True\n\n    def getDepth(self, root):\n        if root is None:\n            return 0\n        return max(self.getDepth(root.left), self.getDepth(root.right)) + 1\n\n    def isBalanced1(self, root):\n        if root is None:\n            return True\n        if abs(self.getDepth(root.left) - self.getDepth(root.right)) > 1:\n            return False\n        return self.isBalanced1(root.left) and self.isBalanced1(root.right)\n\n    def isBalanced2(self, root):\n        if root is None:\n            return True\n\n        def postOrder(root):\n            if self.is_balance is False:\n                return -1\n            if root is None:\n                return 0\n            left = postOrder(root.left)\n            right = postOrder(root.right)\n            if abs(left - right) > 1:\n                self.is_balance = False\n            return max(left, right) + 1\n\n        postOrder(root)\n        return self.is_balance\n\n# main function\ndef main_solution(tree_structure):\n    # Convert JSON serializable input to TreeNode objects\n    def build_tree(node_dict):\n        if not node_dict:\n            return None\n        root = TreeNode(node_dict['val'])\n        root.left = build_tree(node_dict['left'])\n        root.right = build_tree(node_dict['right'])\n        return root\n\n    root = build_tree(tree_structure)\n    solution = Solution()\n    is_balanced = solution.isBalanced2(root)\n    \n    # Return the result as a JSON serializable output\n    return {\"is_balanced\": is_balanced}", "funcname": "main_solution", "ios": [{"input": {"tree_structure": {"val": 35, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 93, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 59, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 10, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 88, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 70, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 60, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 42, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 15, "left": null, "right": null}}, "output": {"is_balanced": true}}, {"input": {"tree_structure": {"val": 16, "left": null, "right": null}}, "output": {"is_balanced": true}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "zhanvwei/targetoffer", "path": "/\u5e73\u8861\u4e8c\u53c9\u6811.py", "msgidx": 14711}}
{"problem_description": "Given a list of 10 integers, which number has the highest count of prime factors, and how many prime factors does it have? If there are multiple numbers with the same highest count of prime factors, return the largest of these numbers.", "io_requirements": "Input:\n  `input_list` (list of strings): A list of 10 strings, each representing an integer.\n\nOutput:\n  `return` (dict): A dictionary with the following keys:\n    - `number` (int): The number from the input list that has the maximum number of prime factors.\n    - `prime_factors_count` (int): The count of prime factors for the number with the maximum prime factors.", "refcode": "# import necessary packages\nimport math\n\n# Function to check if a number is prime\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# Function to find prime factors of a number\ndef prime_factors(num):\n    factors = []\n    for i in range(1, num + 1):\n        if num % i == 0 and is_prime(i):\n            factors.append(i)\n    return factors\n\n# main function\ndef main_solution(input_list):\n    # Convert input_list to a list of integers\n    input_list = list(map(int, input_list))\n    \n    # Find prime factors for each number in the input list\n    prime_factors_list = [prime_factors(num) for num in input_list]\n    \n    # Find the number with the maximum number of prime factors\n    max_prime_factors_count = max(len(factors) for factors in prime_factors_list)\n    candidates = [input_list[i] for i, factors in enumerate(prime_factors_list) if len(factors) == max_prime_factors_count]\n    \n    # Return the largest number among the candidates with the maximum prime factors count\n    result = max(candidates)\n    \n    # Return the result as a dictionary\n    return {\"number\": result, \"prime_factors_count\": max_prime_factors_count}", "funcname": "main_solution", "ios": [{"input": {"input_list": ["42", "12", "70", "77", "73", "47", "32", "35", "39", "73"]}, "output": {"number": 70, "prime_factors_count": 3}}, {"input": {"input_list": ["14", "38", "2", "15", "46", "43", "41", "88", "98", "30"]}, "output": {"number": 30, "prime_factors_count": 3}}, {"input": {"input_list": ["43", "74", "92", "1", "21", "28", "84", "42", "74", "65"]}, "output": {"number": 84, "prime_factors_count": 3}}, {"input": {"input_list": ["49", "81", "15", "15", "18", "14", "32", "1", "77", "37"]}, "output": {"number": 77, "prime_factors_count": 2}}, {"input": {"input_list": ["23", "80", "28", "22", "1", "31", "22", "65", "76", "80"]}, "output": {"number": 80, "prime_factors_count": 2}}, {"input": {"input_list": ["57", "12", "72", "35", "13", "74", "68", "21", "22", "78"]}, "output": {"number": 78, "prime_factors_count": 3}}, {"input": {"input_list": ["1", "70", "37", "69", "23", "32", "8", "57", "81", "25"]}, "output": {"number": 70, "prime_factors_count": 3}}, {"input": {"input_list": ["17", "77", "15", "68", "89", "76", "24", "94", "36", "31"]}, "output": {"number": 94, "prime_factors_count": 2}}, {"input": {"input_list": ["100", "31", "16", "87", "8", "22", "43", "3", "10", "94"]}, "output": {"number": 100, "prime_factors_count": 2}}, {"input": {"input_list": ["86", "30", "64", "74", "56", "68", "99", "71", "89", "93"]}, "output": {"number": 30, "prime_factors_count": 3}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "mejomba/maktabkhone", "path": "/01.py", "msgidx": 14571}}
{"problem_description": "In the game of chess, the 8 queens puzzle is a classic problem where the goal is to place 8 queens on an 8x8 chessboard such that no two queens threaten each other. This means no two queens can be in the same row, column, or diagonal. Given a partial solution that specifies the positions of queens in the first few rows, how many complete solutions can be formed by extending this partial solution to cover all 8 rows?", "io_requirements": "Input:\n  `partial_solution` (list of integers): A list of integers between 0 and 7 representing the columns where queens are placed in the first few rows of the chessboard. The length of this list should be between 0 and 7.\n\nOutput:\n  `return` (integer): The number of valid solutions to the 8 queens problem that start with the given `partial_solution`.", "refcode": "# import necessary packages\nimport functools as ft\nimport operator\n\n# all class and function definitions in the code file, if any\ndef solutions(partial_solution=()):\n    \"\"\"Solves the '8 queens problem', which is to find all the ways in which 8 queens can be\n    placed on a chessboard so that none of them threatens another.\n\n    A solution is encoded as an 8-tuple j of integers between 0 and 7, such that for every integer\n    i between 0 and 7, the unique queen on row i is at column j[i]. The function is a generator\n    which yields all the solutions.\n\n    The partial_solution argument may be any possible prefix of such a tuple; it restricts the\n    solutions yielded to those that have that prefix.\"\"\"\n\n    i = len(partial_solution)\n\n    # If the partial solution is actually a total solution, then that solution is the only one we\n    # can return.\n\n    if i == 8:\n        yield partial_solution\n        return\n\n    # Otherwise, we find all the integers j between 0 and 7 such that the partial solution remains\n    # a prefix of a solution after appending j. This gives us all the partial solutions of length\n    # i + 1, and we can recurse from there.\n\n    for j in range(8):\n        if j in partial_solution:\n            # No two queens can be in the same column.\n            continue\n\n        threatened_along_left_diagonal = False\n\n        for i_, j_ in zip(range(i - 1, -1, -1), range(j - 1, -1, -1)):\n            if partial_solution[i_] == j_:\n                threatened_along_left_diagonal = True\n                break\n\n        if threatened_along_left_diagonal:\n            continue\n\n        threatened_along_right_diagonal = False\n\n        for i_, j_ in zip(range(i - 1, -1, -1), range(j + 1, 8)):\n            if partial_solution[i_] == j_:\n                threatened_along_right_diagonal = True\n                break\n        \n        if threatened_along_right_diagonal:\n            continue\n\n        yield from solutions(partial_solution + (j,))\n\n# main function\ndef main_solution(partial_solution):\n    # Convert the input to a tuple if it's not already\n    if not isinstance(partial_solution, tuple):\n        partial_solution = tuple(partial_solution)\n    \n    # Get all solutions for the given partial solution\n    all_solutions = list(solutions(partial_solution))\n    \n    # Return the number of solutions found\n    return len(all_solutions)", "funcname": "main_solution", "ios": [{"input": {"partial_solution": [1, 6, 0, 7, 4]}, "output": 0}, {"input": {"partial_solution": [0]}, "output": 4}, {"input": {"partial_solution": [7, 6, 0, 1, 4, 3, 2]}, "output": 0}, {"input": {"partial_solution": [2]}, "output": 16}, {"input": {"partial_solution": [3, 2, 0]}, "output": 0}, {"input": {"partial_solution": [6, 0, 2, 5, 4, 7]}, "output": 1}, {"input": {"partial_solution": [2, 0, 3, 6, 5]}, "output": 1}, {"input": {"partial_solution": [2, 0, 1, 5, 6]}, "output": 0}, {"input": {"partial_solution": [6, 0, 5, 7]}, "output": 0}, {"input": {"partial_solution": [1, 7, 5]}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Andrew-Foote/8queens", "path": "/8queens2.py", "msgidx": 14566}}
{"problem_description": "Given a \"magic\" gon ring filled with numbers from 1 to 10, where each line adds up to the same total, what is the maximum 16-digit string that can be formed by concatenating the numbers in the ring, starting from the group of three with the numerically lowest external node and working clockwise? The gon ring has a specified number of sides (`gon_side`), which can be 3, 4, or 5.", "io_requirements": "Input:\n  `gon_side` (int): The number of sides in the gon ring. It should be in the range [3, 5].\n\nOutput:\n  `return` (int): The maximum 16-digit string for a \"magic\" gon_side-gon ring.", "refcode": "# import necessary packages\nfrom itertools import permutations\n\n# all class and function definitions in the code file, if any\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result\n\n\ndef is_magic_gon(numbers: list[int]) -> bool:\n    \"\"\"\n    Check if the solution set is a magic n-gon ring\n    Check that the first number is the smallest number on the outer ring\n    Take a list, and check if the sum of each 3 numbers chunk is equal to the same total\n    \"\"\"\n    if len(numbers) % 3 != 0:\n        raise ValueError(\"a gon ring should have a length that is a multiple of 3\")\n\n    if min(numbers[::3]) != numbers[0]:\n        return False\n\n    total = sum(numbers[:3])\n\n    return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))\n\n\n# main function\ndef main_solution(gon_side: int) -> int:\n    \"\"\"\n    Find the maximum number for a \"magic\" gon_side-gon ring\n    \"\"\"\n    if gon_side < 3 or gon_side > 5:\n        raise ValueError(\"gon_side must be in the range [3, 5]\")\n\n    # Since it's 16, we know 10 is on the outer ring\n    # Put the big numbers at the end so that they are never the first number\n    small_numbers = list(range(gon_side + 1, 0, -1))\n    big_numbers = list(range(gon_side + 2, gon_side * 2 + 1))\n\n    max_number = 0\n    for perm in permutations(small_numbers + big_numbers):\n        numbers = generate_gon_ring(gon_side, list(perm))\n        if is_magic_gon(numbers):\n            current_number = int(\"\".join(str(n) for n in numbers))\n            if current_number > max_number:\n                max_number = current_number\n\n    if max_number == 0:\n        raise ValueError(f\"Magic {gon_side}-gon ring is impossible\")\n\n    return max_number", "funcname": "main_solution", "ios": [{"input": {"gon_side": 4}, "output": 462723831516}, {"input": {"gon_side": 3}, "output": 432621513}, {"input": {"gon_side": 5}, "output": 28797161103104548}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "TheAlgorithms/Python", "path": "/project_euler/problem_068/sol1.py", "msgidx": 14786}}
{"problem_description": "Given a graph with a set of vertices and edges, how can we determine the minimum number of colors required to color the graph such that no two adjacent vertices share the same color? Specifically, what is the coloring of the graph when using a greedy algorithm, given the vertices and edges provided?", "io_requirements": "Input:\n  `vertices` (list of strings): A list of unique identifiers for the vertices.\n  `edges` (list of tuples): A list of tuples representing the edges between vertices.\n  `is_directed` (boolean): Whether the graph is directed (edges go in only one direction). Default is `True`.\n\nOutput:\n  `return` (dict): A dictionary where keys are vertex ids and values are the assigned colors.", "refcode": "# import necessary packages\nfrom collections import deque\n\n# all class and function definitions in the code file, if any\nclass Vertex(object):\n    \"\"\"\n    Defines a single vertex and its neighbors.\n    \"\"\"\n\n    def __init__(self, vertex_id):\n        \"\"\"\n        Initialize a vertex and its neighbors dictionary.\n        \n        Parameters:\n        vertex_id (string): A unique identifier to identify this vertex.\n        \"\"\"\n        self.__id = vertex_id\n        self.__neighbors_dict = {} # id -> object\n\n    def add_neighbor(self, vertex_obj):\n        \"\"\"\n        Add a neighbor by storing it in the neighbors dictionary.\n\n        Parameters:\n        vertex_obj (Vertex): An instance of Vertex to be stored as a neighbor.\n        \"\"\"\n        neighbor_id = vertex_obj.__id\n        self.__neighbors_dict[neighbor_id] = vertex_obj\n\n    def get_neighbors(self):\n        \"\"\"Return the neighbors of this vertex.\"\"\"\n        return list(self.__neighbors_dict.values())\n\n    def get_id(self):\n        \"\"\"Return the id of this vertex.\"\"\"\n        return self.__id\n\n\nclass Graph:\n    \"\"\" Graph Class\n    Represents a directed or undirected graph.\n    \"\"\"\n    def __init__(self, is_directed=True):\n        \"\"\"\n        Initialize a graph object with an empty vertex dictionary.\n\n        Parameters:\n        is_directed (boolean): Whether the graph is directed (edges go in only one direction).\n        \"\"\"\n        self.__vertex_dict = {} # id -> object\n        self.__is_directed = is_directed\n\n    def add_vertex(self, vertex_id):\n        \"\"\"\n        Add a new vertex object to the graph with the given key and return the vertex.\n        \n        Parameters:\n        vertex_id (string): The unique identifier for the new vertex.\n\n        Returns:\n        Vertex: The new vertex object.\n        \"\"\"\n        new_vertex = Vertex(vertex_id)\n        self.__vertex_dict[vertex_id] = new_vertex\n        return new_vertex\n\n    def get_vertex(self, vertex_id):\n        \"\"\"Return the vertex if it exists.\"\"\"\n        if vertex_id not in self.__vertex_dict:\n            return None\n\n        vertex_obj = self.__vertex_dict[vertex_id]\n        return vertex_obj\n\n    def add_edge(self, vertex_id1, vertex_id2):\n        \"\"\"\n        Add an edge from vertex with id `vertex_id1` to vertex with id `vertex_id2`.\n\n        Parameters:\n        vertex_id1 (string): The unique identifier of the first vertex.\n        vertex_id2 (string): The unique identifier of the second vertex.\n        \"\"\"\n        # store both vertex 1 and vertex 2 in a variable\n        vertex_1, vertex_2 = (\n            self.__vertex_dict[vertex_id1], \n            self.__vertex_dict[vertex_id2]\n        )\n        # make the vertex 2 a neighbor of vertex 1\n        vertex_1.add_neighbor(vertex_2)\n        # if the graph is undirected, make the edge go both ways\n        if self.__is_directed is False:\n            vertex_2.add_neighbor(vertex_1)\n\n    def greedy_coloring(self):\n        \"\"\"Return a dictionary of vertex id -> color.\"\"\"\n        vertex_id_color = {}\n        possible_colors = set(range(len(self.__vertex_dict)))\n        # visiting each vertex\n        for vertex_id in self.__vertex_dict:\n            # assign the current vertex a color if not already given\n            if vertex_id not in vertex_id_color:\n                # make sure it's not one of the neighbors' colors\n                neighbors = self.get_vertex(vertex_id).get_neighbors()\n                neighbors_colors = set()\n                for neighbor in neighbors:\n                    neighbor_id = neighbor.get_id()\n                    if neighbor_id in vertex_id_color:\n                        neighbors_colors.add(vertex_id_color[neighbor_id])\n                # choose the color not yet assigned\n                for color in possible_colors:\n                    if color not in neighbors_colors:\n                        vertex_id_color[vertex_id] = color\n        return vertex_id_color\n\n# main function\ndef main_solution(vertices, edges, is_directed=True):\n    \"\"\"\n    Given a list of vertices and edges, construct a graph and return the coloring of the graph using a greedy algorithm.\n\n    Parameters:\n    vertices (list of strings): A list of unique identifiers for the vertices.\n    edges (list of tuples): A list of tuples representing the edges between vertices.\n    is_directed (boolean): Whether the graph is directed (edges go in only one direction).\n\n    Returns:\n    dict: A dictionary where keys are vertex ids and values are the assigned colors.\n    \"\"\"\n    graph = Graph(is_directed)\n    \n    # Add vertices to the graph\n    for vertex_id in vertices:\n        graph.add_vertex(vertex_id)\n    \n    # Add edges to the graph\n    for edge in edges:\n        graph.add_edge(edge[0], edge[1])\n    \n    # Get the coloring of the graph\n    coloring = graph.greedy_coloring()\n    \n    return coloring", "funcname": "main_solution", "ios": [{"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "E"]], "is_directed": false}, "output": {"A": 4, "B": 4, "C": 4, "D": 4, "E": 3}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "B"], ["B", "D"]], "is_directed": true}, "output": {"A": 4, "B": 4, "C": 4, "D": 4, "E": 4}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "D"], ["C", "E"]], "is_directed": true}, "output": {"A": 4, "B": 4, "C": 4, "D": 4, "E": 4}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "B"], ["A", "D"]], "is_directed": true}, "output": {"A": 4, "B": 4, "C": 4, "D": 4, "E": 4}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "C"], ["A", "D"]], "is_directed": true}, "output": {"A": 4, "B": 4, "C": 4, "D": 4, "E": 4}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "D"], ["C", "D"]], "is_directed": false}, "output": {"A": 4, "B": 4, "C": 4, "D": 3, "E": 4}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "D"], ["B", "C"]], "is_directed": true}, "output": {"A": 4, "B": 4, "C": 4, "D": 4, "E": 4}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["C", "D"], ["D", "E"]], "is_directed": true}, "output": {"A": 4, "B": 4, "C": 4, "D": 4, "E": 4}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["A", "C"], ["A", "E"]], "is_directed": false}, "output": {"A": 4, "B": 4, "C": 3, "D": 4, "E": 3}}, {"input": {"vertices": ["A", "B", "C", "D", "E"], "edges": [["B", "D"]], "is_directed": false}, "output": {"A": 4, "B": 4, "C": 4, "D": 3, "E": 4}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "UPstartDeveloper/Graph-ADT", "path": "/graphs/graph.py", "msgidx": 13932}}
{"problem_description": "In a warehouse, there are several containers with different volumes. You need to determine how many combinations of these containers can be used to exactly match a specified target volume. Additionally, you may need to find the combinations that use the minimum number of containers. How many valid combinations of containers can be used to achieve the target volume, and how many of these combinations use the minimum number of containers?", "io_requirements": "Input:\n  `container_pool` (list[int]): A list of integers representing the volumes of available containers.\n  `target_volume` (int): The target volume that the combinations of containers should sum up to.\n  `minimize` (bool): A boolean flag indicating whether to count the number of combinations that use the minimum number of containers.\n\nOutput:\n  `return` (int): The number of valid container combinations that sum up to the target volume. If `minimize` is True, it returns the number of combinations using the minimum number of containers.", "refcode": "# import necessary packages\nfrom itertools import combinations\n\n# main function\ndef main_solution(container_pool: list[int], target_volume: int, minimize: bool) -> int:\n    \"\"\"\n    Calculate the number of container combinations that yield the specified total volume.\n\n    If the `minimize` flag is set, the count is instead the number of combinations of the minimum\n    possible number of containers.\n    \"\"\"\n    n_containers = len(container_pool)\n    min_containers = n_containers\n    valid_combinations = []\n    for pick_n in range(1, n_containers + 1):\n        for combo in combinations(container_pool, pick_n):\n            combo_vol = sum(combo)\n            if combo_vol == target_volume:\n                if not minimize:\n                    valid_combinations.append(combo)\n                else:\n                    if len(combo) < min_containers:\n                        valid_combinations = [combo]\n                        min_containers = len(combo)\n                    elif len(combo) == min_containers:\n                        valid_combinations.append(combo)\n\n    return len(valid_combinations)", "funcname": "main_solution", "ios": [{"input": {"container_pool": [34, 39, 46, 2, 42, 47, 37, 38, 46, 35], "target_volume": 115, "minimize": true}, "output": 4}, {"input": {"container_pool": [5, 8, 1, 47, 35], "target_volume": 114, "minimize": false}, "output": 0}, {"input": {"container_pool": [38, 10, 12, 24, 34], "target_volume": 113, "minimize": true}, "output": 0}, {"input": {"container_pool": [47, 48, 21, 49, 23, 13, 1, 33, 3], "target_volume": 189, "minimize": true}, "output": 1}, {"input": {"container_pool": [2, 22, 24, 4, 27, 41, 5, 41, 6, 10], "target_volume": 177, "minimize": false}, "output": 1}, {"input": {"container_pool": [23, 9, 31, 5, 9, 13], "target_volume": 157, "minimize": false}, "output": 0}, {"input": {"container_pool": [17, 18, 6, 50, 23], "target_volume": 191, "minimize": true}, "output": 0}, {"input": {"container_pool": [31, 33, 5, 18, 24], "target_volume": 140, "minimize": false}, "output": 0}, {"input": {"container_pool": [36, 38, 7, 39, 6, 4, 8, 4, 49], "target_volume": 153, "minimize": true}, "output": 1}, {"input": {"container_pool": [42, 8, 14, 6, 45, 7], "target_volume": 137, "minimize": true}, "output": 0}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "sco1/adventofcode", "path": "/2015/Day_17/aoc_2015_day17.py", "msgidx": 14665}}
{"problem_description": "In a game, players are represented by a sequence of digits. Each door in the game has a specific number, and only certain combinations of players can open each door. The combination of players must have a digit root equal to the door number and fall within a specified range of players per door. Given the sequence of players, the range of players per door, and the number of doors with their respective numbers, what are the valid combinations of players that can open each door?", "io_requirements": "Input:\n  `players` (str): A string representing the total players, e.g., \"123456789\".\n  `minplayers` (int): The lowest amount of players per door.\n  `maxplayers` (int): The highest amount of players per door.\n  `doortotal` (int): The total number of doors.\n  `doors` (list of tuples): A list of tuples where each tuple contains the door number (int) and an empty list for combos (list).\n\nOutput:\n  `return` (list of dict): A list of dictionaries where each dictionary contains:\n    - `num` (int): The door number.\n    - `combos` (list of str): A list of strings representing the valid player combinations for that door.", "refcode": "# import necessary packages\nfrom itertools import combinations\n\n# all class and function definitions in the code file, if any\ndef digit_root(n): \n    return (n - 1) % 9 + 1 if n else 0\n\n# main function\ndef main_solution(players, minplayers, maxplayers, doortotal, doors):\n    # Convert the doors list to a list of dictionaries with 'num' and 'combos' keys\n    doors = [{\"num\": door[0], \"combos\": door[1]} for door in doors]\n    \n    player_combinations = [''.join(l) for i in range(len(players)) for l in combinations(players, i+1)]\n    \n    for i in range(doortotal):\n        for combo in player_combinations:\n            if len(combo) >= minplayers and len(combo) <= maxplayers and digit_root(int(combo)) == doors[i][\"num\"]:\n                doors[i][\"combos\"].append(combo)\n    \n    # Convert the result to a JSON serializable format\n    result = [{'num': door['num'], 'combos': door['combos']} for door in doors]\n    \n    return result", "funcname": "main_solution", "ios": [{"input": {"players": "998779991", "minplayers": 2, "maxplayers": 4, "doortotal": 2, "doors": [[3, []], [2, []]]}, "output": [{"num": 3, "combos": []}, {"num": 2, "combos": []}]}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "Crystal2002/AO2-Scripts", "path": "/doorcombos.py", "msgidx": 14437}}
{"problem_description": "Given a list of integers representing the postorder traversal of a binary tree, determine whether this list can be the postorder traversal of a binary search tree. What is the result of this verification?", "io_requirements": "Input:\n  `postorder` (List[int]): A list of integers representing the postorder traversal of a binary tree. Each integer in the list is unique.\n\nOutput:\n  `return` (bool): A boolean value indicating whether the given list is a valid postorder traversal of a binary search tree. Returns `True` if it is valid, otherwise `False`.", "refcode": "# import necessary packages\nfrom typing import List\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def verifyPostorder(self, postorder: List[int]) -> bool:\n        \"\"\"\n        \u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5224\u65ad\u8be5\u6570\u7ec4\u662f\u4e0d\u662f\u67d0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u7ed3\u679c\u3002\u5982\u679c\u662f\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\u5047\u8bbe\u8f93\u5165\u7684\u6570\u7ec4\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u4e92\u4e0d\u76f8\u540c\u3002\n        \"\"\"\n        def helper(nums):\n            if len(nums) <= 1: return True\n            root = nums[-1]\n            for i in range(len(nums)):\n                if nums[i] > root: break\n            for j in range(i, len(nums) - 1):\n                if nums[j] < root: return False\n            return helper(nums[:i]) and helper(nums[i:-1])\n\n        if not postorder: return True\n        return helper(postorder)\n\n# main function\ndef main_solution(postorder: List[int]) -> bool:\n    # all input arguments of the main_solution function should be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    # if you need to invoke functions that require non-json serializable inputs, like those defined in the reference code file, you need to convert them (optional)\n    solution = Solution()\n    result = solution.verifyPostorder(postorder)\n    # return, the returned value must be json serializable (no self-defined objects, functions, np.array, set, tuple, etc.)\n    return result", "funcname": "main_solution", "ios": [{"input": {"postorder": [1, 15, 17, 3, 10, 11]}, "output": false}, {"input": {"postorder": [1, 2, 10, 8, 18, 6, 7, 15, 12, 9]}, "output": false}, {"input": {"postorder": [19, 13, 8, 3, 14, 15, 6, 11, 7]}, "output": false}, {"input": {"postorder": [7, 11]}, "output": true}, {"input": {"postorder": [10, 5, 16]}, "output": true}, {"input": {"postorder": [19, 7, 4, 13, 10, 12, 3]}, "output": false}, {"input": {"postorder": [6, 11]}, "output": true}, {"input": {"postorder": [19, 5, 8, 9, 7, 6, 11]}, "output": false}, {"input": {"postorder": [8, 10, 7]}, "output": true}, {"input": {"postorder": [14]}, "output": true}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "MaiziXiao/Algorithms", "path": "/\u5251\u6307offer/33-\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217.py", "msgidx": 14286}}
{"problem_description": "Alice and Bill play a game where a fair coin is flipped repeatedly, and the first player to see their special pattern (Alice's pattern is HHT, and Bill's pattern is THH) wins. Oscar claims that both players have an equal chance of winning. What is the odds ratio of Alice winning to Bill winning after a large number of trials, given a specific number of coin flips per trial?", "io_requirements": "Input:\n  `num_trials` (int): The number of trials to simulate. Each trial consists of a sequence of coin flips.\n  `num_flips` (int): The number of coin flips in each trial.\n\nOutput:\n  `return` (dict): A dictionary containing the key `odds_ratio` (float), which represents the odds ratio of Alice winning to Bill winning.", "refcode": "# import necessary packages\nimport numpy as np\n\n# main function\ndef main_solution(num_trials, num_flips):\n    # Generate the experiment data\n    experiment = np.random.randint(0, 2, (num_trials, num_flips))\n    \n    # Function to determine the winner\n    def wins(flipSequence):\n        for i in range(2, len(flipSequence)):\n            if flipSequence[i] == 1 and flipSequence[i - 1] == 0 and flipSequence[i - 2] == 0:\n                # Alice won HHT or 001\n                return 1\n            elif flipSequence[i] == 0 and flipSequence[i - 1] == 1 and flipSequence[i - 2] == 1:\n                # Bill won THH or 110\n                return -1\n        return 0\n    \n    # Apply the wins function to all trials\n    count = np.apply_along_axis(wins, 1, experiment)\n    bWins = np.sum(count == -1)\n    aWins = np.sum(count == 1)\n    \n    # Calculate the odds ratio\n    if bWins == 0:\n        odds = float('inf')\n    else:\n        odds = aWins / bWins\n    \n    # Return the odds ratio\n    return {\"odds_ratio\": odds}", "funcname": "main_solution", "ios": [{"input": {"num_trials": 6123, "num_flips": 42}, "output": {"odds_ratio": 1.004255319148936}}, {"input": {"num_trials": 6104, "num_flips": 45}, "output": {"odds_ratio": 0.9882736156351791}}, {"input": {"num_trials": 4775, "num_flips": 37}, "output": {"odds_ratio": 0.9426362896663955}}, {"input": {"num_trials": 5603, "num_flips": 38}, "output": {"odds_ratio": 1.0389374090247452}}, {"input": {"num_trials": 4846, "num_flips": 44}, "output": {"odds_ratio": 1.000825763831544}}, {"input": {"num_trials": 4393, "num_flips": 39}, "output": {"odds_ratio": 0.9620366234926306}}, {"input": {"num_trials": 5399, "num_flips": 49}, "output": {"odds_ratio": 1.0100521221146685}}, {"input": {"num_trials": 6306, "num_flips": 27}, "output": {"odds_ratio": 0.957169459962756}}, {"input": {"num_trials": 3953, "num_flips": 42}, "output": {"odds_ratio": 0.9725548902195609}}, {"input": {"num_trials": 4278, "num_flips": 22}, "output": {"odds_ratio": 1.0498322951605175}}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "dtroupe18/PenneysGame", "path": "/Penney's Game.py", "msgidx": 14936}}
{"problem_description": "Given a sequence of integers, determine whether this sequence could represent the post-order traversal of a Binary Search Tree (BST). What is the result of this verification?", "io_requirements": "Input:\n  `sequence` (list of integers): A list of integers representing the sequence to be verified as the post-order traversal of a Binary Search Tree (BST).\n\nOutput:\n  `return` (string): A string \"Yes\" if the sequence is a valid post-order traversal of a BST, otherwise \"No\".", "refcode": "# import necessary packages\n\n# all class and function definitions in the code file, if any\nclass Solution:\n    def VerifySquenceOfBST(self, sequence):\n        if len(sequence) == 0:\n            return False\n        return self.subVerifySquenceOfBST(sequence)\n\n    def subVerifySquenceOfBST(self, sequence):\n        if len(sequence) <= 2:\n            return True\n        root = sequence[-1]\n        i = 0\n        while True:\n            if root > sequence[i]:\n                i += 1\n            else:\n                break\n\n        j = i\n        while j < len(sequence) - 1:\n            if root < sequence[j]:\n                j += 1\n            else:\n                return False\n\n        return self.subVerifySquenceOfBST(sequence[:i]) and self.subVerifySquenceOfBST(sequence[i:-1])\n\n# main function\ndef main_solution(sequence):\n    # Convert input to the required format\n    sequence = list(sequence)\n    \n    # Create an instance of the Solution class\n    solution = Solution()\n    \n    # Call the VerifySquenceOfBST method\n    result = solution.VerifySquenceOfBST(sequence)\n    \n    # Convert the result to a JSON serializable output\n    return \"Yes\" if result else \"No\"", "funcname": "main_solution", "ios": [{"input": {"sequence": [87, 3, 25, 61, 93, 10, 4, 31, 83]}, "output": "No"}, {"input": {"sequence": [77]}, "output": "Yes"}, {"input": {"sequence": [57, 74, 61, 77]}, "output": "Yes"}, {"input": {"sequence": [45, 16]}, "output": "Yes"}, {"input": {"sequence": [8]}, "output": "Yes"}, {"input": {"sequence": [91, 30, 20, 72, 70, 86]}, "output": "No"}, {"input": {"sequence": [86, 41, 37]}, "output": "Yes"}, {"input": {"sequence": [46, 13, 50, 87, 8, 60, 15, 38, 2]}, "output": "No"}, {"input": {"sequence": [66, 94, 60, 3, 47, 27, 83, 82, 32, 49]}, "output": "No"}, {"input": {"sequence": [9, 84, 61]}, "output": "Yes"}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "lirixiang123/algorithm", "path": "/src/\u5251\u6307offer/22VerifySquenceOfBST.py", "msgidx": 14702}}
{"problem_description": "Given a type of prime number (circular, palindromic, or Kaprekar) and an index `n`, what is the nth number of that type?", "io_requirements": "Input:\n- `n` (int): The index of the number to find.\n- `prime_type` (str): The type of prime number to find. Can be \"circular\", \"palindromic\", or \"kaprekar\".\n\nOutput:\n- `return` (int): The nth number of the specified prime type.", "refcode": "# import necessary packages\nimport math\n\n# all class and function definitions in the code file, if any\ndef isPrime(n):\n    if n < 2:\n        return False\n    elif n < 4:\n        return True\n    else:\n        x = 2\n        while x < n:\n            if n % x == 0:\n                return False\n            x += 1\n        return True\n\ndef isCircularPrime(n):\n    x = 1\n    input_n = n\n    while n % pow(10, x) < n:\n        x += 1\n    while isPrime(n):\n        n = 10 * (n % pow(10, x - 1)) + (n // pow(10, x - 1))\n        if n == input_n:\n            return True\n    return False\n\ndef isPalindromic(n):\n    if n < 10:\n        return True\n    else:\n        x = 1\n        while n % pow(10, x) < n:\n            x += 1\n        y = 1\n        while y < x:\n            if (n % pow(10, x)) // pow(10, x - 1) != (n % pow(10, y)) // pow(10, y - 1):\n                return False\n            x -= 1\n            y += 1\n        return True\n\ndef isKaprekarNumber(n):\n    sq = n * n\n    x = 1\n    while sq % pow(10, x) < sq:\n        x += 1\n    i = 1\n    while i <= x:\n        if sq % pow(10, i) and n == sq // pow(10, i) + sq % pow(10, i):\n            return True\n        i += 1\n    return False\n\n# main function\ndef main_solution(n, prime_type):\n    \"\"\"\n    This function returns the nth number based on the specified prime type.\n\n    Parameters:\n    n (int): The index of the number to find.\n    prime_type (str): The type of prime number to find. Can be \"circular\", \"palindromic\", or \"kaprekar\".\n\n    Returns:\n    int: The nth number of the specified prime type.\n    \"\"\"\n    if prime_type == \"circular\":\n        i = 0\n        ans = 0\n        while True:\n            if isCircularPrime(ans):\n                if i == n:\n                    return ans\n                i += 1\n            ans += 1\n    elif prime_type == \"palindromic\":\n        i = 0\n        ans = 0\n        while True:\n            if isPrime(ans) and isPalindromic(ans):\n                if i == n:\n                    return ans\n                i += 1\n            ans += 1\n    elif prime_type == \"kaprekar\":\n        i = 0\n        ans = 1\n        while True:\n            if isKaprekarNumber(ans):\n                if i == n:\n                    return ans\n                i += 1\n            ans += 1\n    else:\n        raise ValueError(\"Invalid prime type. Choose from 'circular', 'palindromic', or 'kaprekar'.\")", "funcname": "main_solution", "ios": [{"input": {"n": 0, "prime_type": "palindromic"}, "output": 2}, {"input": {"n": 7, "prime_type": "palindromic"}, "output": 151}, {"input": {"n": 6, "prime_type": "kaprekar"}, "output": 703}, {"input": {"n": 4, "prime_type": "palindromic"}, "output": 11}, {"input": {"n": 0, "prime_type": "circular"}, "output": 2}, {"input": {"n": 5, "prime_type": "kaprekar"}, "output": 297}, {"input": {"n": 8, "prime_type": "circular"}, "output": 37}, {"input": {"n": 7, "prime_type": "circular"}, "output": 31}, {"input": {"n": 5, "prime_type": "circular"}, "output": 13}, {"input": {"n": 0, "prime_type": "kaprekar"}, "output": 1}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "cliu268/playground", "path": "/hw2.py", "msgidx": 14741}}
{"problem_description": "Given a binary tree represented by a list of integers and `None` values, where each integer represents a node's value and `None` represents a missing node, determine whether the binary tree is symmetric around its center. What is the result of this check?", "io_requirements": "Input:\n  `tree_structure` (list of int or None): A list representing the binary tree in level order traversal. Each element in the list represents the value of a node. If the value is `None`, it indicates that the node is missing (i.e., it is a null node).\n\nOutput:\n  `return` (bool): A boolean value indicating whether the binary tree is symmetric around its center.", "refcode": "# import necessary packages\nimport json\n\n# all class and function definitions in the code file, if any\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return self.isSymmetricCore(root, root)\n\n    def isSymmetricCore(self, root1, root2):\n        if root1 is None and root2 is None:\n            return True\n        if root1 is None or root2 is None :\n            return False\n        if root1.val != root2.val:\n            return False\n        return  self.isSymmetricCore(root1.left, root2.right) and  self.isSymmetricCore(root1.right, root2.left)\n\n# main function\ndef main_solution(tree_structure):\n  # Convert the JSON serializable input to the original input variables\n  def build_tree(nodes):\n      if not nodes:\n          return None\n      root = TreeNode(nodes[0])\n      queue = [root]\n      i = 1\n      while queue and i < len(nodes):\n          node = queue.pop(0)\n          if nodes[i] is not None:\n              node.left = TreeNode(nodes[i])\n              queue.append(node.left)\n          i += 1\n          if i < len(nodes) and nodes[i] is not None:\n              node.right = TreeNode(nodes[i])\n              queue.append(node.right)\n          i += 1\n      return root\n\n  root = build_tree(tree_structure)\n  solution = Solution()\n  result = solution.isSymmetric(root)\n  \n  # Return the result, which is JSON serializable\n  return result", "funcname": "main_solution", "ios": [{"input": {"tree_structure": [78, 17, null, 91]}, "output": false}, {"input": {"tree_structure": [64, null, 37, null, 29, 75, 89, null, 67, 62]}, "output": false}, {"input": {"tree_structure": [81]}, "output": true}, {"input": {"tree_structure": [null, 45, 53, null]}, "output": false}, {"input": {"tree_structure": [49, 38, null, null, 11, 8, 45, 2, 64]}, "output": false}, {"input": {"tree_structure": [75]}, "output": true}, {"input": {"tree_structure": [null, 98, null]}, "output": false}, {"input": {"tree_structure": [93, null]}, "output": true}, {"input": {"tree_structure": [77, 73]}, "output": false}, {"input": {"tree_structure": [null, 32, 62, 21]}, "output": false}], "source": "pyedu", "category": "Modeling of Logical Puzzles and Complex Reasoning Processes", "meta": {"repo_name": "alexkie007/offer", "path": "/LeetCode/\u6811/101. \u5bf9\u79f0\u4e8c\u53c9\u6811.py", "msgidx": 14311}}
